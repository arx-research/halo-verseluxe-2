(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
  var __require = /* @__PURE__ */ ((x4) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x4, {
    get: (a6, b7) => (typeof require !== "undefined" ? require : a6)[b7]
  }) : x4)(function(x4) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x4 + '" is not supported');
  });
  var __esm = (fn2, res) => function __init() {
    return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require2() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all3) => {
    for (var name2 in all3)
      __defProp(target, name2, { get: all3[name2], enumerable: true });
  };
  var __copyProps = (to3, from3, except, desc) => {
    if (from3 && typeof from3 === "object" || typeof from3 === "function") {
      for (let key2 of __getOwnPropNames(from3))
        if (!__hasOwnProp.call(to3, key2) && key2 !== except)
          __defProp(to3, key2, { get: () => from3[key2], enumerable: !(desc = __getOwnPropDesc(from3, key2)) || desc.enumerable });
    }
    return to3;
  };
  var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
  var __publicField = (obj, key2, value) => {
    __defNormalProp(obj, typeof key2 !== "symbol" ? key2 + "" : key2, value);
    return value;
  };

  // node_modules/react/cjs/react.development.js
  var require_react_development = __commonJS({
    "node_modules/react/cjs/react.development.js"(exports, module) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
          }
          var ReactVersion = "18.2.0";
          var REACT_ELEMENT_TYPE = Symbol.for("react.element");
          var REACT_PORTAL_TYPE = Symbol.for("react.portal");
          var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
          var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
          var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
          var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
          var REACT_CONTEXT_TYPE = Symbol.for("react.context");
          var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
          var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
          var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
          var REACT_MEMO_TYPE = Symbol.for("react.memo");
          var REACT_LAZY_TYPE = Symbol.for("react.lazy");
          var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
          var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
          var FAUX_ITERATOR_SYMBOL = "@@iterator";
          function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== "object") {
              return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === "function") {
              return maybeIterator;
            }
            return null;
          }
          var ReactCurrentDispatcher = {
            /**
             * @internal
             * @type {ReactComponent}
             */
            current: null
          };
          var ReactCurrentBatchConfig = {
            transition: null
          };
          var ReactCurrentActQueue = {
            current: null,
            // Used to reproduce behavior of `batchedUpdates` in legacy mode.
            isBatchingLegacy: false,
            didScheduleLegacyUpdate: false
          };
          var ReactCurrentOwner = {
            /**
             * @internal
             * @type {ReactComponent}
             */
            current: null
          };
          var ReactDebugCurrentFrame = {};
          var currentExtraStackFrame = null;
          function setExtraStackFrame(stack) {
            {
              currentExtraStackFrame = stack;
            }
          }
          {
            ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {
              {
                currentExtraStackFrame = stack;
              }
            };
            ReactDebugCurrentFrame.getCurrentStack = null;
            ReactDebugCurrentFrame.getStackAddendum = function() {
              var stack = "";
              if (currentExtraStackFrame) {
                stack += currentExtraStackFrame;
              }
              var impl = ReactDebugCurrentFrame.getCurrentStack;
              if (impl) {
                stack += impl() || "";
              }
              return stack;
            };
          }
          var enableScopeAPI = false;
          var enableCacheElement = false;
          var enableTransitionTracing = false;
          var enableLegacyHidden = false;
          var enableDebugTracing = false;
          var ReactSharedInternals = {
            ReactCurrentDispatcher,
            ReactCurrentBatchConfig,
            ReactCurrentOwner
          };
          {
            ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
            ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;
          }
          function warn(format2) {
            {
              {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                printWarning("warn", format2, args);
              }
            }
          }
          function error(format2) {
            {
              {
                for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                  args[_key2 - 1] = arguments[_key2];
                }
                printWarning("error", format2, args);
              }
            }
          }
          function printWarning(level, format2, args) {
            {
              var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
              var stack = ReactDebugCurrentFrame2.getStackAddendum();
              if (stack !== "") {
                format2 += "%s";
                args = args.concat([stack]);
              }
              var argsWithFormat = args.map(function(item) {
                return String(item);
              });
              argsWithFormat.unshift("Warning: " + format2);
              Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
          }
          var didWarnStateUpdateForUnmountedComponent = {};
          function warnNoop(publicInstance, callerName) {
            {
              var _constructor = publicInstance.constructor;
              var componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass";
              var warningKey = componentName + "." + callerName;
              if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
                return;
              }
              error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName);
              didWarnStateUpdateForUnmountedComponent[warningKey] = true;
            }
          }
          var ReactNoopUpdateQueue = {
            /**
             * Checks whether or not this composite component is mounted.
             * @param {ReactClass} publicInstance The instance we want to test.
             * @return {boolean} True if mounted, false otherwise.
             * @protected
             * @final
             */
            isMounted: function(publicInstance) {
              return false;
            },
            /**
             * Forces an update. This should only be invoked when it is known with
             * certainty that we are **not** in a DOM transaction.
             *
             * You may want to call this when you know that some deeper aspect of the
             * component's state has changed but `setState` was not called.
             *
             * This will not invoke `shouldComponentUpdate`, but it will invoke
             * `componentWillUpdate` and `componentDidUpdate`.
             *
             * @param {ReactClass} publicInstance The instance that should rerender.
             * @param {?function} callback Called after component is updated.
             * @param {?string} callerName name of the calling function in the public API.
             * @internal
             */
            enqueueForceUpdate: function(publicInstance, callback, callerName) {
              warnNoop(publicInstance, "forceUpdate");
            },
            /**
             * Replaces all of the state. Always use this or `setState` to mutate state.
             * You should treat `this.state` as immutable.
             *
             * There is no guarantee that `this.state` will be immediately updated, so
             * accessing `this.state` after calling this method may return the old value.
             *
             * @param {ReactClass} publicInstance The instance that should rerender.
             * @param {object} completeState Next state.
             * @param {?function} callback Called after component is updated.
             * @param {?string} callerName name of the calling function in the public API.
             * @internal
             */
            enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
              warnNoop(publicInstance, "replaceState");
            },
            /**
             * Sets a subset of the state. This only exists because _pendingState is
             * internal. This provides a merging strategy that is not available to deep
             * properties which is confusing. TODO: Expose pendingState or don't use it
             * during the merge.
             *
             * @param {ReactClass} publicInstance The instance that should rerender.
             * @param {object} partialState Next partial state to be merged with state.
             * @param {?function} callback Called after component is updated.
             * @param {?string} Name of the calling function in the public API.
             * @internal
             */
            enqueueSetState: function(publicInstance, partialState, callback, callerName) {
              warnNoop(publicInstance, "setState");
            }
          };
          var assign = Object.assign;
          var emptyObject = {};
          {
            Object.freeze(emptyObject);
          }
          function Component(props, context, updater) {
            this.props = props;
            this.context = context;
            this.refs = emptyObject;
            this.updater = updater || ReactNoopUpdateQueue;
          }
          Component.prototype.isReactComponent = {};
          Component.prototype.setState = function(partialState, callback) {
            if (typeof partialState !== "object" && typeof partialState !== "function" && partialState != null) {
              throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
            }
            this.updater.enqueueSetState(this, partialState, callback, "setState");
          };
          Component.prototype.forceUpdate = function(callback) {
            this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
          };
          {
            var deprecatedAPIs = {
              isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
              replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
            };
            var defineDeprecationWarning = function(methodName, info) {
              Object.defineProperty(Component.prototype, methodName, {
                get: function() {
                  warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
                  return void 0;
                }
              });
            };
            for (var fnName in deprecatedAPIs) {
              if (deprecatedAPIs.hasOwnProperty(fnName)) {
                defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
              }
            }
          }
          function ComponentDummy() {
          }
          ComponentDummy.prototype = Component.prototype;
          function PureComponent(props, context, updater) {
            this.props = props;
            this.context = context;
            this.refs = emptyObject;
            this.updater = updater || ReactNoopUpdateQueue;
          }
          var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
          pureComponentPrototype.constructor = PureComponent;
          assign(pureComponentPrototype, Component.prototype);
          pureComponentPrototype.isPureReactComponent = true;
          function createRef() {
            var refObject = {
              current: null
            };
            {
              Object.seal(refObject);
            }
            return refObject;
          }
          var isArrayImpl = Array.isArray;
          function isArray2(a6) {
            return isArrayImpl(a6);
          }
          function typeName(value) {
            {
              var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
              var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
              return type;
            }
          }
          function willCoercionThrow(value) {
            {
              try {
                testStringCoercion(value);
                return false;
              } catch (e9) {
                return true;
              }
            }
          }
          function testStringCoercion(value) {
            return "" + value;
          }
          function checkKeyStringCoercion(value) {
            {
              if (willCoercionThrow(value)) {
                error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          function getWrappedName(outerType, innerType, wrapperName) {
            var displayName = outerType.displayName;
            if (displayName) {
              return displayName;
            }
            var functionName = innerType.displayName || innerType.name || "";
            return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
          }
          function getContextName(type) {
            return type.displayName || "Context";
          }
          function getComponentNameFromType(type) {
            if (type == null) {
              return null;
            }
            {
              if (typeof type.tag === "number") {
                error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
              }
            }
            if (typeof type === "function") {
              return type.displayName || type.name || null;
            }
            if (typeof type === "string") {
              return type;
            }
            switch (type) {
              case REACT_FRAGMENT_TYPE:
                return "Fragment";
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_PROFILER_TYPE:
                return "Profiler";
              case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
              case REACT_SUSPENSE_TYPE:
                return "Suspense";
              case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_CONTEXT_TYPE:
                  var context = type;
                  return getContextName(context) + ".Consumer";
                case REACT_PROVIDER_TYPE:
                  var provider = type;
                  return getContextName(provider._context) + ".Provider";
                case REACT_FORWARD_REF_TYPE:
                  return getWrappedName(type, type.render, "ForwardRef");
                case REACT_MEMO_TYPE:
                  var outerName = type.displayName || null;
                  if (outerName !== null) {
                    return outerName;
                  }
                  return getComponentNameFromType(type.type) || "Memo";
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init2 = lazyComponent._init;
                  try {
                    return getComponentNameFromType(init2(payload));
                  } catch (x4) {
                    return null;
                  }
                }
              }
            }
            return null;
          }
          var hasOwnProperty2 = Object.prototype.hasOwnProperty;
          var RESERVED_PROPS = {
            key: true,
            ref: true,
            __self: true,
            __source: true
          };
          var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
          {
            didWarnAboutStringRefs = {};
          }
          function hasValidRef(config2) {
            {
              if (hasOwnProperty2.call(config2, "ref")) {
                var getter = Object.getOwnPropertyDescriptor(config2, "ref").get;
                if (getter && getter.isReactWarning) {
                  return false;
                }
              }
            }
            return config2.ref !== void 0;
          }
          function hasValidKey(config2) {
            {
              if (hasOwnProperty2.call(config2, "key")) {
                var getter = Object.getOwnPropertyDescriptor(config2, "key").get;
                if (getter && getter.isReactWarning) {
                  return false;
                }
              }
            }
            return config2.key !== void 0;
          }
          function defineKeyPropWarningGetter(props, displayName) {
            var warnAboutAccessingKey = function() {
              {
                if (!specialPropKeyWarningShown) {
                  specialPropKeyWarningShown = true;
                  error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
                }
              }
            };
            warnAboutAccessingKey.isReactWarning = true;
            Object.defineProperty(props, "key", {
              get: warnAboutAccessingKey,
              configurable: true
            });
          }
          function defineRefPropWarningGetter(props, displayName) {
            var warnAboutAccessingRef = function() {
              {
                if (!specialPropRefWarningShown) {
                  specialPropRefWarningShown = true;
                  error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
                }
              }
            };
            warnAboutAccessingRef.isReactWarning = true;
            Object.defineProperty(props, "ref", {
              get: warnAboutAccessingRef,
              configurable: true
            });
          }
          function warnIfStringRefCannotBeAutoConverted(config2) {
            {
              if (typeof config2.ref === "string" && ReactCurrentOwner.current && config2.__self && ReactCurrentOwner.current.stateNode !== config2.__self) {
                var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
                if (!didWarnAboutStringRefs[componentName]) {
                  error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, config2.ref);
                  didWarnAboutStringRefs[componentName] = true;
                }
              }
            }
          }
          var ReactElement = function(type, key2, ref, self2, source, owner, props) {
            var element = {
              // This tag allows us to uniquely identify this as a React Element
              $$typeof: REACT_ELEMENT_TYPE,
              // Built-in properties that belong on the element
              type,
              key: key2,
              ref,
              props,
              // Record the component responsible for creating this element.
              _owner: owner
            };
            {
              element._store = {};
              Object.defineProperty(element._store, "validated", {
                configurable: false,
                enumerable: false,
                writable: true,
                value: false
              });
              Object.defineProperty(element, "_self", {
                configurable: false,
                enumerable: false,
                writable: false,
                value: self2
              });
              Object.defineProperty(element, "_source", {
                configurable: false,
                enumerable: false,
                writable: false,
                value: source
              });
              if (Object.freeze) {
                Object.freeze(element.props);
                Object.freeze(element);
              }
            }
            return element;
          };
          function createElement3(type, config2, children) {
            var propName;
            var props = {};
            var key2 = null;
            var ref = null;
            var self2 = null;
            var source = null;
            if (config2 != null) {
              if (hasValidRef(config2)) {
                ref = config2.ref;
                {
                  warnIfStringRefCannotBeAutoConverted(config2);
                }
              }
              if (hasValidKey(config2)) {
                {
                  checkKeyStringCoercion(config2.key);
                }
                key2 = "" + config2.key;
              }
              self2 = config2.__self === void 0 ? null : config2.__self;
              source = config2.__source === void 0 ? null : config2.__source;
              for (propName in config2) {
                if (hasOwnProperty2.call(config2, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                  props[propName] = config2[propName];
                }
              }
            }
            var childrenLength = arguments.length - 2;
            if (childrenLength === 1) {
              props.children = children;
            } else if (childrenLength > 1) {
              var childArray = Array(childrenLength);
              for (var i7 = 0; i7 < childrenLength; i7++) {
                childArray[i7] = arguments[i7 + 2];
              }
              {
                if (Object.freeze) {
                  Object.freeze(childArray);
                }
              }
              props.children = childArray;
            }
            if (type && type.defaultProps) {
              var defaultProps = type.defaultProps;
              for (propName in defaultProps) {
                if (props[propName] === void 0) {
                  props[propName] = defaultProps[propName];
                }
              }
            }
            {
              if (key2 || ref) {
                var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
                if (key2) {
                  defineKeyPropWarningGetter(props, displayName);
                }
                if (ref) {
                  defineRefPropWarningGetter(props, displayName);
                }
              }
            }
            return ReactElement(type, key2, ref, self2, source, ReactCurrentOwner.current, props);
          }
          function cloneAndReplaceKey(oldElement, newKey) {
            var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
            return newElement;
          }
          function cloneElement(element, config2, children) {
            if (element === null || element === void 0) {
              throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
            }
            var propName;
            var props = assign({}, element.props);
            var key2 = element.key;
            var ref = element.ref;
            var self2 = element._self;
            var source = element._source;
            var owner = element._owner;
            if (config2 != null) {
              if (hasValidRef(config2)) {
                ref = config2.ref;
                owner = ReactCurrentOwner.current;
              }
              if (hasValidKey(config2)) {
                {
                  checkKeyStringCoercion(config2.key);
                }
                key2 = "" + config2.key;
              }
              var defaultProps;
              if (element.type && element.type.defaultProps) {
                defaultProps = element.type.defaultProps;
              }
              for (propName in config2) {
                if (hasOwnProperty2.call(config2, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                  if (config2[propName] === void 0 && defaultProps !== void 0) {
                    props[propName] = defaultProps[propName];
                  } else {
                    props[propName] = config2[propName];
                  }
                }
              }
            }
            var childrenLength = arguments.length - 2;
            if (childrenLength === 1) {
              props.children = children;
            } else if (childrenLength > 1) {
              var childArray = Array(childrenLength);
              for (var i7 = 0; i7 < childrenLength; i7++) {
                childArray[i7] = arguments[i7 + 2];
              }
              props.children = childArray;
            }
            return ReactElement(element.type, key2, ref, self2, source, owner, props);
          }
          function isValidElement(object) {
            return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
          }
          var SEPARATOR = ".";
          var SUBSEPARATOR = ":";
          function escape2(key2) {
            var escapeRegex = /[=:]/g;
            var escaperLookup = {
              "=": "=0",
              ":": "=2"
            };
            var escapedString = key2.replace(escapeRegex, function(match) {
              return escaperLookup[match];
            });
            return "$" + escapedString;
          }
          var didWarnAboutMaps = false;
          var userProvidedKeyEscapeRegex = /\/+/g;
          function escapeUserProvidedKey(text) {
            return text.replace(userProvidedKeyEscapeRegex, "$&/");
          }
          function getElementKey(element, index2) {
            if (typeof element === "object" && element !== null && element.key != null) {
              {
                checkKeyStringCoercion(element.key);
              }
              return escape2("" + element.key);
            }
            return index2.toString(36);
          }
          function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
            var type = typeof children;
            if (type === "undefined" || type === "boolean") {
              children = null;
            }
            var invokeCallback = false;
            if (children === null) {
              invokeCallback = true;
            } else {
              switch (type) {
                case "string":
                case "number":
                  invokeCallback = true;
                  break;
                case "object":
                  switch (children.$$typeof) {
                    case REACT_ELEMENT_TYPE:
                    case REACT_PORTAL_TYPE:
                      invokeCallback = true;
                  }
              }
            }
            if (invokeCallback) {
              var _child = children;
              var mappedChild = callback(_child);
              var childKey = nameSoFar === "" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
              if (isArray2(mappedChild)) {
                var escapedChildKey = "";
                if (childKey != null) {
                  escapedChildKey = escapeUserProvidedKey(childKey) + "/";
                }
                mapIntoArray(mappedChild, array, escapedChildKey, "", function(c9) {
                  return c9;
                });
              } else if (mappedChild != null) {
                if (isValidElement(mappedChild)) {
                  {
                    if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {
                      checkKeyStringCoercion(mappedChild.key);
                    }
                  }
                  mappedChild = cloneAndReplaceKey(
                    mappedChild,
                    // Keep both the (mapped) and old keys if they differ, just as
                    // traverseAllChildren used to do for objects as children
                    escapedPrefix + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
                    (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? (
                      // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
                      // eslint-disable-next-line react-internal/safe-string-coercion
                      escapeUserProvidedKey("" + mappedChild.key) + "/"
                    ) : "") + childKey
                  );
                }
                array.push(mappedChild);
              }
              return 1;
            }
            var child;
            var nextName;
            var subtreeCount = 0;
            var nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
            if (isArray2(children)) {
              for (var i7 = 0; i7 < children.length; i7++) {
                child = children[i7];
                nextName = nextNamePrefix + getElementKey(child, i7);
                subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
              }
            } else {
              var iteratorFn = getIteratorFn(children);
              if (typeof iteratorFn === "function") {
                var iterableChildren = children;
                {
                  if (iteratorFn === iterableChildren.entries) {
                    if (!didWarnAboutMaps) {
                      warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                    }
                    didWarnAboutMaps = true;
                  }
                }
                var iterator = iteratorFn.call(iterableChildren);
                var step;
                var ii2 = 0;
                while (!(step = iterator.next()).done) {
                  child = step.value;
                  nextName = nextNamePrefix + getElementKey(child, ii2++);
                  subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
                }
              } else if (type === "object") {
                var childrenString = String(children);
                throw new Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + "). If you meant to render a collection of children, use an array instead.");
              }
            }
            return subtreeCount;
          }
          function mapChildren(children, func, context) {
            if (children == null) {
              return children;
            }
            var result = [];
            var count = 0;
            mapIntoArray(children, result, "", "", function(child) {
              return func.call(context, child, count++);
            });
            return result;
          }
          function countChildren(children) {
            var n9 = 0;
            mapChildren(children, function() {
              n9++;
            });
            return n9;
          }
          function forEachChildren(children, forEachFunc, forEachContext) {
            mapChildren(children, function() {
              forEachFunc.apply(this, arguments);
            }, forEachContext);
          }
          function toArray2(children) {
            return mapChildren(children, function(child) {
              return child;
            }) || [];
          }
          function onlyChild(children) {
            if (!isValidElement(children)) {
              throw new Error("React.Children.only expected to receive a single React element child.");
            }
            return children;
          }
          function createContext3(defaultValue) {
            var context = {
              $$typeof: REACT_CONTEXT_TYPE,
              // As a workaround to support multiple concurrent renderers, we categorize
              // some renderers as primary and others as secondary. We only expect
              // there to be two concurrent renderers at most: React Native (primary) and
              // Fabric (secondary); React DOM (primary) and React ART (secondary).
              // Secondary renderers store their context values on separate fields.
              _currentValue: defaultValue,
              _currentValue2: defaultValue,
              // Used to track how many concurrent renderers this context currently
              // supports within in a single renderer. Such as parallel server rendering.
              _threadCount: 0,
              // These are circular
              Provider: null,
              Consumer: null,
              // Add these to use same hidden class in VM as ServerContext
              _defaultValue: null,
              _globalName: null
            };
            context.Provider = {
              $$typeof: REACT_PROVIDER_TYPE,
              _context: context
            };
            var hasWarnedAboutUsingNestedContextConsumers = false;
            var hasWarnedAboutUsingConsumerProvider = false;
            var hasWarnedAboutDisplayNameOnConsumer = false;
            {
              var Consumer = {
                $$typeof: REACT_CONTEXT_TYPE,
                _context: context
              };
              Object.defineProperties(Consumer, {
                Provider: {
                  get: function() {
                    if (!hasWarnedAboutUsingConsumerProvider) {
                      hasWarnedAboutUsingConsumerProvider = true;
                      error("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?");
                    }
                    return context.Provider;
                  },
                  set: function(_Provider) {
                    context.Provider = _Provider;
                  }
                },
                _currentValue: {
                  get: function() {
                    return context._currentValue;
                  },
                  set: function(_currentValue) {
                    context._currentValue = _currentValue;
                  }
                },
                _currentValue2: {
                  get: function() {
                    return context._currentValue2;
                  },
                  set: function(_currentValue2) {
                    context._currentValue2 = _currentValue2;
                  }
                },
                _threadCount: {
                  get: function() {
                    return context._threadCount;
                  },
                  set: function(_threadCount) {
                    context._threadCount = _threadCount;
                  }
                },
                Consumer: {
                  get: function() {
                    if (!hasWarnedAboutUsingNestedContextConsumers) {
                      hasWarnedAboutUsingNestedContextConsumers = true;
                      error("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                    }
                    return context.Consumer;
                  }
                },
                displayName: {
                  get: function() {
                    return context.displayName;
                  },
                  set: function(displayName) {
                    if (!hasWarnedAboutDisplayNameOnConsumer) {
                      warn("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", displayName);
                      hasWarnedAboutDisplayNameOnConsumer = true;
                    }
                  }
                }
              });
              context.Consumer = Consumer;
            }
            {
              context._currentRenderer = null;
              context._currentRenderer2 = null;
            }
            return context;
          }
          var Uninitialized = -1;
          var Pending = 0;
          var Resolved = 1;
          var Rejected = 2;
          function lazyInitializer(payload) {
            if (payload._status === Uninitialized) {
              var ctor = payload._result;
              var thenable = ctor();
              thenable.then(function(moduleObject2) {
                if (payload._status === Pending || payload._status === Uninitialized) {
                  var resolved = payload;
                  resolved._status = Resolved;
                  resolved._result = moduleObject2;
                }
              }, function(error2) {
                if (payload._status === Pending || payload._status === Uninitialized) {
                  var rejected = payload;
                  rejected._status = Rejected;
                  rejected._result = error2;
                }
              });
              if (payload._status === Uninitialized) {
                var pending = payload;
                pending._status = Pending;
                pending._result = thenable;
              }
            }
            if (payload._status === Resolved) {
              var moduleObject = payload._result;
              {
                if (moduleObject === void 0) {
                  error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?", moduleObject);
                }
              }
              {
                if (!("default" in moduleObject)) {
                  error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
                }
              }
              return moduleObject.default;
            } else {
              throw payload._result;
            }
          }
          function lazy(ctor) {
            var payload = {
              // We use these fields to store the result.
              _status: Uninitialized,
              _result: ctor
            };
            var lazyType = {
              $$typeof: REACT_LAZY_TYPE,
              _payload: payload,
              _init: lazyInitializer
            };
            {
              var defaultProps;
              var propTypes;
              Object.defineProperties(lazyType, {
                defaultProps: {
                  configurable: true,
                  get: function() {
                    return defaultProps;
                  },
                  set: function(newDefaultProps) {
                    error("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                    defaultProps = newDefaultProps;
                    Object.defineProperty(lazyType, "defaultProps", {
                      enumerable: true
                    });
                  }
                },
                propTypes: {
                  configurable: true,
                  get: function() {
                    return propTypes;
                  },
                  set: function(newPropTypes) {
                    error("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                    propTypes = newPropTypes;
                    Object.defineProperty(lazyType, "propTypes", {
                      enumerable: true
                    });
                  }
                }
              });
            }
            return lazyType;
          }
          function forwardRef(render) {
            {
              if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
                error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).");
              } else if (typeof render !== "function") {
                error("forwardRef requires a render function but was given %s.", render === null ? "null" : typeof render);
              } else {
                if (render.length !== 0 && render.length !== 2) {
                  error("forwardRef render functions accept exactly two parameters: props and ref. %s", render.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
                }
              }
              if (render != null) {
                if (render.defaultProps != null || render.propTypes != null) {
                  error("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
                }
              }
            }
            var elementType = {
              $$typeof: REACT_FORWARD_REF_TYPE,
              render
            };
            {
              var ownName;
              Object.defineProperty(elementType, "displayName", {
                enumerable: false,
                configurable: true,
                get: function() {
                  return ownName;
                },
                set: function(name2) {
                  ownName = name2;
                  if (!render.name && !render.displayName) {
                    render.displayName = name2;
                  }
                }
              });
            }
            return elementType;
          }
          var REACT_MODULE_REFERENCE;
          {
            REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
          }
          function isValidElementType(type) {
            if (typeof type === "string" || typeof type === "function") {
              return true;
            }
            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
              return true;
            }
            if (typeof type === "object" && type !== null) {
              if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
              // types supported by any Flight configuration anywhere since
              // we don't know which Flight build this will end up being used
              // with.
              type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
                return true;
              }
            }
            return false;
          }
          function memo(type, compare2) {
            {
              if (!isValidElementType(type)) {
                error("memo: The first argument must be a component. Instead received: %s", type === null ? "null" : typeof type);
              }
            }
            var elementType = {
              $$typeof: REACT_MEMO_TYPE,
              type,
              compare: compare2 === void 0 ? null : compare2
            };
            {
              var ownName;
              Object.defineProperty(elementType, "displayName", {
                enumerable: false,
                configurable: true,
                get: function() {
                  return ownName;
                },
                set: function(name2) {
                  ownName = name2;
                  if (!type.name && !type.displayName) {
                    type.displayName = name2;
                  }
                }
              });
            }
            return elementType;
          }
          function resolveDispatcher() {
            var dispatcher = ReactCurrentDispatcher.current;
            {
              if (dispatcher === null) {
                error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
              }
            }
            return dispatcher;
          }
          function useContext3(Context2) {
            var dispatcher = resolveDispatcher();
            {
              if (Context2._context !== void 0) {
                var realContext = Context2._context;
                if (realContext.Consumer === Context2) {
                  error("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?");
                } else if (realContext.Provider === Context2) {
                  error("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
                }
              }
            }
            return dispatcher.useContext(Context2);
          }
          function useState4(initialState) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useState(initialState);
          }
          function useReducer2(reducer, initialArg, init2) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useReducer(reducer, initialArg, init2);
          }
          function useRef4(initialValue) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useRef(initialValue);
          }
          function useEffect11(create3, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useEffect(create3, deps);
          }
          function useInsertionEffect(create3, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useInsertionEffect(create3, deps);
          }
          function useLayoutEffect(create3, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useLayoutEffect(create3, deps);
          }
          function useCallback10(callback, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useCallback(callback, deps);
          }
          function useMemo7(create3, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useMemo(create3, deps);
          }
          function useImperativeHandle(ref, create3, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useImperativeHandle(ref, create3, deps);
          }
          function useDebugValue2(value, formatterFn) {
            {
              var dispatcher = resolveDispatcher();
              return dispatcher.useDebugValue(value, formatterFn);
            }
          }
          function useTransition() {
            var dispatcher = resolveDispatcher();
            return dispatcher.useTransition();
          }
          function useDeferredValue(value) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useDeferredValue(value);
          }
          function useId() {
            var dispatcher = resolveDispatcher();
            return dispatcher.useId();
          }
          function useSyncExternalStore3(subscribe3, getSnapshot, getServerSnapshot) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useSyncExternalStore(subscribe3, getSnapshot, getServerSnapshot);
          }
          var disabledDepth = 0;
          var prevLog;
          var prevInfo;
          var prevWarn;
          var prevError;
          var prevGroup;
          var prevGroupCollapsed;
          var prevGroupEnd;
          function disabledLog() {
          }
          disabledLog.__reactDisabledLog = true;
          function disableLogs() {
            {
              if (disabledDepth === 0) {
                prevLog = console.log;
                prevInfo = console.info;
                prevWarn = console.warn;
                prevError = console.error;
                prevGroup = console.group;
                prevGroupCollapsed = console.groupCollapsed;
                prevGroupEnd = console.groupEnd;
                var props = {
                  configurable: true,
                  enumerable: true,
                  value: disabledLog,
                  writable: true
                };
                Object.defineProperties(console, {
                  info: props,
                  log: props,
                  warn: props,
                  error: props,
                  group: props,
                  groupCollapsed: props,
                  groupEnd: props
                });
              }
              disabledDepth++;
            }
          }
          function reenableLogs() {
            {
              disabledDepth--;
              if (disabledDepth === 0) {
                var props = {
                  configurable: true,
                  enumerable: true,
                  writable: true
                };
                Object.defineProperties(console, {
                  log: assign({}, props, {
                    value: prevLog
                  }),
                  info: assign({}, props, {
                    value: prevInfo
                  }),
                  warn: assign({}, props, {
                    value: prevWarn
                  }),
                  error: assign({}, props, {
                    value: prevError
                  }),
                  group: assign({}, props, {
                    value: prevGroup
                  }),
                  groupCollapsed: assign({}, props, {
                    value: prevGroupCollapsed
                  }),
                  groupEnd: assign({}, props, {
                    value: prevGroupEnd
                  })
                });
              }
              if (disabledDepth < 0) {
                error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
              }
            }
          }
          var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
          var prefix;
          function describeBuiltInComponentFrame(name2, source, ownerFn) {
            {
              if (prefix === void 0) {
                try {
                  throw Error();
                } catch (x4) {
                  var match = x4.stack.trim().match(/\n( *(at )?)/);
                  prefix = match && match[1] || "";
                }
              }
              return "\n" + prefix + name2;
            }
          }
          var reentry = false;
          var componentFrameCache;
          {
            var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
            componentFrameCache = new PossiblyWeakMap();
          }
          function describeNativeComponentFrame(fn2, construct) {
            if (!fn2 || reentry) {
              return "";
            }
            {
              var frame = componentFrameCache.get(fn2);
              if (frame !== void 0) {
                return frame;
              }
            }
            var control;
            reentry = true;
            var previousPrepareStackTrace = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            var previousDispatcher;
            {
              previousDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = null;
              disableLogs();
            }
            try {
              if (construct) {
                var Fake = function() {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                });
                if (typeof Reflect === "object" && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x4) {
                    control = x4;
                  }
                  Reflect.construct(fn2, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x4) {
                    control = x4;
                  }
                  fn2.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x4) {
                  control = x4;
                }
                fn2();
              }
            } catch (sample) {
              if (sample && control && typeof sample.stack === "string") {
                var sampleLines = sample.stack.split("\n");
                var controlLines = control.stack.split("\n");
                var s7 = sampleLines.length - 1;
                var c9 = controlLines.length - 1;
                while (s7 >= 1 && c9 >= 0 && sampleLines[s7] !== controlLines[c9]) {
                  c9--;
                }
                for (; s7 >= 1 && c9 >= 0; s7--, c9--) {
                  if (sampleLines[s7] !== controlLines[c9]) {
                    if (s7 !== 1 || c9 !== 1) {
                      do {
                        s7--;
                        c9--;
                        if (c9 < 0 || sampleLines[s7] !== controlLines[c9]) {
                          var _frame = "\n" + sampleLines[s7].replace(" at new ", " at ");
                          if (fn2.displayName && _frame.includes("<anonymous>")) {
                            _frame = _frame.replace("<anonymous>", fn2.displayName);
                          }
                          {
                            if (typeof fn2 === "function") {
                              componentFrameCache.set(fn2, _frame);
                            }
                          }
                          return _frame;
                        }
                      } while (s7 >= 1 && c9 >= 0);
                    }
                    break;
                  }
                }
              }
            } finally {
              reentry = false;
              {
                ReactCurrentDispatcher$1.current = previousDispatcher;
                reenableLogs();
              }
              Error.prepareStackTrace = previousPrepareStackTrace;
            }
            var name2 = fn2 ? fn2.displayName || fn2.name : "";
            var syntheticFrame = name2 ? describeBuiltInComponentFrame(name2) : "";
            {
              if (typeof fn2 === "function") {
                componentFrameCache.set(fn2, syntheticFrame);
              }
            }
            return syntheticFrame;
          }
          function describeFunctionComponentFrame(fn2, source, ownerFn) {
            {
              return describeNativeComponentFrame(fn2, false);
            }
          }
          function shouldConstruct(Component2) {
            var prototype3 = Component2.prototype;
            return !!(prototype3 && prototype3.isReactComponent);
          }
          function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
            if (type == null) {
              return "";
            }
            if (typeof type === "function") {
              {
                return describeNativeComponentFrame(type, shouldConstruct(type));
              }
            }
            if (typeof type === "string") {
              return describeBuiltInComponentFrame(type);
            }
            switch (type) {
              case REACT_SUSPENSE_TYPE:
                return describeBuiltInComponentFrame("Suspense");
              case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame("SuspenseList");
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_FORWARD_REF_TYPE:
                  return describeFunctionComponentFrame(type.render);
                case REACT_MEMO_TYPE:
                  return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init2 = lazyComponent._init;
                  try {
                    return describeUnknownElementTypeFrameInDEV(init2(payload), source, ownerFn);
                  } catch (x4) {
                  }
                }
              }
            }
            return "";
          }
          var loggedTypeFailures = {};
          var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
          function setCurrentlyValidatingElement(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
              } else {
                ReactDebugCurrentFrame$1.setExtraStackFrame(null);
              }
            }
          }
          function checkPropTypes(typeSpecs, values, location2, componentName, element) {
            {
              var has = Function.call.bind(hasOwnProperty2);
              for (var typeSpecName in typeSpecs) {
                if (has(typeSpecs, typeSpecName)) {
                  var error$1 = void 0;
                  try {
                    if (typeof typeSpecs[typeSpecName] !== "function") {
                      var err = Error((componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                      err.name = "Invariant Violation";
                      throw err;
                    }
                    error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location2, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                  } catch (ex) {
                    error$1 = ex;
                  }
                  if (error$1 && !(error$1 instanceof Error)) {
                    setCurrentlyValidatingElement(element);
                    error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location2, typeSpecName, typeof error$1);
                    setCurrentlyValidatingElement(null);
                  }
                  if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                    loggedTypeFailures[error$1.message] = true;
                    setCurrentlyValidatingElement(element);
                    error("Failed %s type: %s", location2, error$1.message);
                    setCurrentlyValidatingElement(null);
                  }
                }
              }
            }
          }
          function setCurrentlyValidatingElement$1(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                setExtraStackFrame(stack);
              } else {
                setExtraStackFrame(null);
              }
            }
          }
          var propTypesMisspellWarningShown;
          {
            propTypesMisspellWarningShown = false;
          }
          function getDeclarationErrorAddendum() {
            if (ReactCurrentOwner.current) {
              var name2 = getComponentNameFromType(ReactCurrentOwner.current.type);
              if (name2) {
                return "\n\nCheck the render method of `" + name2 + "`.";
              }
            }
            return "";
          }
          function getSourceInfoErrorAddendum(source) {
            if (source !== void 0) {
              var fileName = source.fileName.replace(/^.*[\\\/]/, "");
              var lineNumber = source.lineNumber;
              return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
            }
            return "";
          }
          function getSourceInfoErrorAddendumForProps(elementProps) {
            if (elementProps !== null && elementProps !== void 0) {
              return getSourceInfoErrorAddendum(elementProps.__source);
            }
            return "";
          }
          var ownerHasKeyUseWarning = {};
          function getCurrentComponentErrorInfo(parentType) {
            var info = getDeclarationErrorAddendum();
            if (!info) {
              var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
              if (parentName) {
                info = "\n\nCheck the top-level render call using <" + parentName + ">.";
              }
            }
            return info;
          }
          function validateExplicitKey(element, parentType) {
            if (!element._store || element._store.validated || element.key != null) {
              return;
            }
            element._store.validated = true;
            var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
            if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
              return;
            }
            ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
            var childOwner = "";
            if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
              childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
            }
            {
              setCurrentlyValidatingElement$1(element);
              error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
              setCurrentlyValidatingElement$1(null);
            }
          }
          function validateChildKeys(node, parentType) {
            if (typeof node !== "object") {
              return;
            }
            if (isArray2(node)) {
              for (var i7 = 0; i7 < node.length; i7++) {
                var child = node[i7];
                if (isValidElement(child)) {
                  validateExplicitKey(child, parentType);
                }
              }
            } else if (isValidElement(node)) {
              if (node._store) {
                node._store.validated = true;
              }
            } else if (node) {
              var iteratorFn = getIteratorFn(node);
              if (typeof iteratorFn === "function") {
                if (iteratorFn !== node.entries) {
                  var iterator = iteratorFn.call(node);
                  var step;
                  while (!(step = iterator.next()).done) {
                    if (isValidElement(step.value)) {
                      validateExplicitKey(step.value, parentType);
                    }
                  }
                }
              }
            }
          }
          function validatePropTypes(element) {
            {
              var type = element.type;
              if (type === null || type === void 0 || typeof type === "string") {
                return;
              }
              var propTypes;
              if (typeof type === "function") {
                propTypes = type.propTypes;
              } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.
              // Inner props are checked in the reconciler.
              type.$$typeof === REACT_MEMO_TYPE)) {
                propTypes = type.propTypes;
              } else {
                return;
              }
              if (propTypes) {
                var name2 = getComponentNameFromType(type);
                checkPropTypes(propTypes, element.props, "prop", name2, element);
              } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
                propTypesMisspellWarningShown = true;
                var _name = getComponentNameFromType(type);
                error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
              }
              if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
                error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
              }
            }
          }
          function validateFragmentProps(fragment) {
            {
              var keys2 = Object.keys(fragment.props);
              for (var i7 = 0; i7 < keys2.length; i7++) {
                var key2 = keys2[i7];
                if (key2 !== "children" && key2 !== "key") {
                  setCurrentlyValidatingElement$1(fragment);
                  error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key2);
                  setCurrentlyValidatingElement$1(null);
                  break;
                }
              }
              if (fragment.ref !== null) {
                setCurrentlyValidatingElement$1(fragment);
                error("Invalid attribute `ref` supplied to `React.Fragment`.");
                setCurrentlyValidatingElement$1(null);
              }
            }
          }
          function createElementWithValidation(type, props, children) {
            var validType = isValidElementType(type);
            if (!validType) {
              var info = "";
              if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
              }
              var sourceInfo = getSourceInfoErrorAddendumForProps(props);
              if (sourceInfo) {
                info += sourceInfo;
              } else {
                info += getDeclarationErrorAddendum();
              }
              var typeString;
              if (type === null) {
                typeString = "null";
              } else if (isArray2(type)) {
                typeString = "array";
              } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
                typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
                info = " Did you accidentally export a JSX literal instead of a component?";
              } else {
                typeString = typeof type;
              }
              {
                error("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
              }
            }
            var element = createElement3.apply(this, arguments);
            if (element == null) {
              return element;
            }
            if (validType) {
              for (var i7 = 2; i7 < arguments.length; i7++) {
                validateChildKeys(arguments[i7], type);
              }
            }
            if (type === REACT_FRAGMENT_TYPE) {
              validateFragmentProps(element);
            } else {
              validatePropTypes(element);
            }
            return element;
          }
          var didWarnAboutDeprecatedCreateFactory = false;
          function createFactoryWithValidation(type) {
            var validatedFactory = createElementWithValidation.bind(null, type);
            validatedFactory.type = type;
            {
              if (!didWarnAboutDeprecatedCreateFactory) {
                didWarnAboutDeprecatedCreateFactory = true;
                warn("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.");
              }
              Object.defineProperty(validatedFactory, "type", {
                enumerable: false,
                get: function() {
                  warn("Factory.type is deprecated. Access the class directly before passing it to createFactory.");
                  Object.defineProperty(this, "type", {
                    value: type
                  });
                  return type;
                }
              });
            }
            return validatedFactory;
          }
          function cloneElementWithValidation(element, props, children) {
            var newElement = cloneElement.apply(this, arguments);
            for (var i7 = 2; i7 < arguments.length; i7++) {
              validateChildKeys(arguments[i7], newElement.type);
            }
            validatePropTypes(newElement);
            return newElement;
          }
          function startTransition(scope, options2) {
            var prevTransition = ReactCurrentBatchConfig.transition;
            ReactCurrentBatchConfig.transition = {};
            var currentTransition = ReactCurrentBatchConfig.transition;
            {
              ReactCurrentBatchConfig.transition._updatedFibers = /* @__PURE__ */ new Set();
            }
            try {
              scope();
            } finally {
              ReactCurrentBatchConfig.transition = prevTransition;
              {
                if (prevTransition === null && currentTransition._updatedFibers) {
                  var updatedFibersCount = currentTransition._updatedFibers.size;
                  if (updatedFibersCount > 10) {
                    warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.");
                  }
                  currentTransition._updatedFibers.clear();
                }
              }
            }
          }
          var didWarnAboutMessageChannel = false;
          var enqueueTaskImpl = null;
          function enqueueTask(task) {
            if (enqueueTaskImpl === null) {
              try {
                var requireString = ("require" + Math.random()).slice(0, 7);
                var nodeRequire = module && module[requireString];
                enqueueTaskImpl = nodeRequire.call(module, "timers").setImmediate;
              } catch (_err) {
                enqueueTaskImpl = function(callback) {
                  {
                    if (didWarnAboutMessageChannel === false) {
                      didWarnAboutMessageChannel = true;
                      if (typeof MessageChannel === "undefined") {
                        error("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning.");
                      }
                    }
                  }
                  var channel = new MessageChannel();
                  channel.port1.onmessage = callback;
                  channel.port2.postMessage(void 0);
                };
              }
            }
            return enqueueTaskImpl(task);
          }
          var actScopeDepth = 0;
          var didWarnNoAwaitAct = false;
          function act(callback) {
            {
              var prevActScopeDepth = actScopeDepth;
              actScopeDepth++;
              if (ReactCurrentActQueue.current === null) {
                ReactCurrentActQueue.current = [];
              }
              var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;
              var result;
              try {
                ReactCurrentActQueue.isBatchingLegacy = true;
                result = callback();
                if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {
                  var queue = ReactCurrentActQueue.current;
                  if (queue !== null) {
                    ReactCurrentActQueue.didScheduleLegacyUpdate = false;
                    flushActQueue(queue);
                  }
                }
              } catch (error2) {
                popActScope(prevActScopeDepth);
                throw error2;
              } finally {
                ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;
              }
              if (result !== null && typeof result === "object" && typeof result.then === "function") {
                var thenableResult = result;
                var wasAwaited = false;
                var thenable = {
                  then: function(resolve, reject) {
                    wasAwaited = true;
                    thenableResult.then(function(returnValue2) {
                      popActScope(prevActScopeDepth);
                      if (actScopeDepth === 0) {
                        recursivelyFlushAsyncActWork(returnValue2, resolve, reject);
                      } else {
                        resolve(returnValue2);
                      }
                    }, function(error2) {
                      popActScope(prevActScopeDepth);
                      reject(error2);
                    });
                  }
                };
                {
                  if (!didWarnNoAwaitAct && typeof Promise !== "undefined") {
                    Promise.resolve().then(function() {
                    }).then(function() {
                      if (!wasAwaited) {
                        didWarnNoAwaitAct = true;
                        error("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);");
                      }
                    });
                  }
                }
                return thenable;
              } else {
                var returnValue = result;
                popActScope(prevActScopeDepth);
                if (actScopeDepth === 0) {
                  var _queue = ReactCurrentActQueue.current;
                  if (_queue !== null) {
                    flushActQueue(_queue);
                    ReactCurrentActQueue.current = null;
                  }
                  var _thenable = {
                    then: function(resolve, reject) {
                      if (ReactCurrentActQueue.current === null) {
                        ReactCurrentActQueue.current = [];
                        recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                      } else {
                        resolve(returnValue);
                      }
                    }
                  };
                  return _thenable;
                } else {
                  var _thenable2 = {
                    then: function(resolve, reject) {
                      resolve(returnValue);
                    }
                  };
                  return _thenable2;
                }
              }
            }
          }
          function popActScope(prevActScopeDepth) {
            {
              if (prevActScopeDepth !== actScopeDepth - 1) {
                error("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. ");
              }
              actScopeDepth = prevActScopeDepth;
            }
          }
          function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
            {
              var queue = ReactCurrentActQueue.current;
              if (queue !== null) {
                try {
                  flushActQueue(queue);
                  enqueueTask(function() {
                    if (queue.length === 0) {
                      ReactCurrentActQueue.current = null;
                      resolve(returnValue);
                    } else {
                      recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                    }
                  });
                } catch (error2) {
                  reject(error2);
                }
              } else {
                resolve(returnValue);
              }
            }
          }
          var isFlushing = false;
          function flushActQueue(queue) {
            {
              if (!isFlushing) {
                isFlushing = true;
                var i7 = 0;
                try {
                  for (; i7 < queue.length; i7++) {
                    var callback = queue[i7];
                    do {
                      callback = callback(true);
                    } while (callback !== null);
                  }
                  queue.length = 0;
                } catch (error2) {
                  queue = queue.slice(i7 + 1);
                  throw error2;
                } finally {
                  isFlushing = false;
                }
              }
            }
          }
          var createElement$1 = createElementWithValidation;
          var cloneElement$1 = cloneElementWithValidation;
          var createFactory = createFactoryWithValidation;
          var Children = {
            map: mapChildren,
            forEach: forEachChildren,
            count: countChildren,
            toArray: toArray2,
            only: onlyChild
          };
          exports.Children = Children;
          exports.Component = Component;
          exports.Fragment = REACT_FRAGMENT_TYPE;
          exports.Profiler = REACT_PROFILER_TYPE;
          exports.PureComponent = PureComponent;
          exports.StrictMode = REACT_STRICT_MODE_TYPE;
          exports.Suspense = REACT_SUSPENSE_TYPE;
          exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
          exports.cloneElement = cloneElement$1;
          exports.createContext = createContext3;
          exports.createElement = createElement$1;
          exports.createFactory = createFactory;
          exports.createRef = createRef;
          exports.forwardRef = forwardRef;
          exports.isValidElement = isValidElement;
          exports.lazy = lazy;
          exports.memo = memo;
          exports.startTransition = startTransition;
          exports.unstable_act = act;
          exports.useCallback = useCallback10;
          exports.useContext = useContext3;
          exports.useDebugValue = useDebugValue2;
          exports.useDeferredValue = useDeferredValue;
          exports.useEffect = useEffect11;
          exports.useId = useId;
          exports.useImperativeHandle = useImperativeHandle;
          exports.useInsertionEffect = useInsertionEffect;
          exports.useLayoutEffect = useLayoutEffect;
          exports.useMemo = useMemo7;
          exports.useReducer = useReducer2;
          exports.useRef = useRef4;
          exports.useState = useState4;
          exports.useSyncExternalStore = useSyncExternalStore3;
          exports.useTransition = useTransition;
          exports.version = ReactVersion;
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
          }
        })();
      }
    }
  });

  // node_modules/react/index.js
  var require_react = __commonJS({
    "node_modules/react/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_react_development();
      }
    }
  });

  // node_modules/scheduler/cjs/scheduler.development.js
  var require_scheduler_development = __commonJS({
    "node_modules/scheduler/cjs/scheduler.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
          }
          var enableSchedulerDebugging = false;
          var enableProfiling = false;
          var frameYieldMs = 5;
          function push(heap, node) {
            var index2 = heap.length;
            heap.push(node);
            siftUp(heap, node, index2);
          }
          function peek(heap) {
            return heap.length === 0 ? null : heap[0];
          }
          function pop(heap) {
            if (heap.length === 0) {
              return null;
            }
            var first = heap[0];
            var last = heap.pop();
            if (last !== first) {
              heap[0] = last;
              siftDown(heap, last, 0);
            }
            return first;
          }
          function siftUp(heap, node, i7) {
            var index2 = i7;
            while (index2 > 0) {
              var parentIndex = index2 - 1 >>> 1;
              var parent = heap[parentIndex];
              if (compare2(parent, node) > 0) {
                heap[parentIndex] = node;
                heap[index2] = parent;
                index2 = parentIndex;
              } else {
                return;
              }
            }
          }
          function siftDown(heap, node, i7) {
            var index2 = i7;
            var length2 = heap.length;
            var halfLength = length2 >>> 1;
            while (index2 < halfLength) {
              var leftIndex = (index2 + 1) * 2 - 1;
              var left = heap[leftIndex];
              var rightIndex = leftIndex + 1;
              var right = heap[rightIndex];
              if (compare2(left, node) < 0) {
                if (rightIndex < length2 && compare2(right, left) < 0) {
                  heap[index2] = right;
                  heap[rightIndex] = node;
                  index2 = rightIndex;
                } else {
                  heap[index2] = left;
                  heap[leftIndex] = node;
                  index2 = leftIndex;
                }
              } else if (rightIndex < length2 && compare2(right, node) < 0) {
                heap[index2] = right;
                heap[rightIndex] = node;
                index2 = rightIndex;
              } else {
                return;
              }
            }
          }
          function compare2(a6, b7) {
            var diff = a6.sortIndex - b7.sortIndex;
            return diff !== 0 ? diff : a6.id - b7.id;
          }
          var ImmediatePriority = 1;
          var UserBlockingPriority = 2;
          var NormalPriority = 3;
          var LowPriority = 4;
          var IdlePriority = 5;
          function markTaskErrored(task, ms2) {
          }
          var hasPerformanceNow = typeof performance === "object" && typeof performance.now === "function";
          if (hasPerformanceNow) {
            var localPerformance = performance;
            exports.unstable_now = function() {
              return localPerformance.now();
            };
          } else {
            var localDate = Date;
            var initialTime = localDate.now();
            exports.unstable_now = function() {
              return localDate.now() - initialTime;
            };
          }
          var maxSigned31BitInt = 1073741823;
          var IMMEDIATE_PRIORITY_TIMEOUT = -1;
          var USER_BLOCKING_PRIORITY_TIMEOUT = 250;
          var NORMAL_PRIORITY_TIMEOUT = 5e3;
          var LOW_PRIORITY_TIMEOUT = 1e4;
          var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;
          var taskQueue = [];
          var timerQueue = [];
          var taskIdCounter = 1;
          var currentTask = null;
          var currentPriorityLevel = NormalPriority;
          var isPerformingWork = false;
          var isHostCallbackScheduled = false;
          var isHostTimeoutScheduled = false;
          var localSetTimeout = typeof setTimeout === "function" ? setTimeout : null;
          var localClearTimeout = typeof clearTimeout === "function" ? clearTimeout : null;
          var localSetImmediate = typeof setImmediate !== "undefined" ? setImmediate : null;
          var isInputPending = typeof navigator !== "undefined" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;
          function advanceTimers(currentTime) {
            var timer2 = peek(timerQueue);
            while (timer2 !== null) {
              if (timer2.callback === null) {
                pop(timerQueue);
              } else if (timer2.startTime <= currentTime) {
                pop(timerQueue);
                timer2.sortIndex = timer2.expirationTime;
                push(taskQueue, timer2);
              } else {
                return;
              }
              timer2 = peek(timerQueue);
            }
          }
          function handleTimeout(currentTime) {
            isHostTimeoutScheduled = false;
            advanceTimers(currentTime);
            if (!isHostCallbackScheduled) {
              if (peek(taskQueue) !== null) {
                isHostCallbackScheduled = true;
                requestHostCallback(flushWork);
              } else {
                var firstTimer = peek(timerQueue);
                if (firstTimer !== null) {
                  requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
                }
              }
            }
          }
          function flushWork(hasTimeRemaining, initialTime2) {
            isHostCallbackScheduled = false;
            if (isHostTimeoutScheduled) {
              isHostTimeoutScheduled = false;
              cancelHostTimeout();
            }
            isPerformingWork = true;
            var previousPriorityLevel = currentPriorityLevel;
            try {
              if (enableProfiling) {
                try {
                  return workLoop(hasTimeRemaining, initialTime2);
                } catch (error) {
                  if (currentTask !== null) {
                    var currentTime = exports.unstable_now();
                    markTaskErrored(currentTask, currentTime);
                    currentTask.isQueued = false;
                  }
                  throw error;
                }
              } else {
                return workLoop(hasTimeRemaining, initialTime2);
              }
            } finally {
              currentTask = null;
              currentPriorityLevel = previousPriorityLevel;
              isPerformingWork = false;
            }
          }
          function workLoop(hasTimeRemaining, initialTime2) {
            var currentTime = initialTime2;
            advanceTimers(currentTime);
            currentTask = peek(taskQueue);
            while (currentTask !== null && !enableSchedulerDebugging) {
              if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {
                break;
              }
              var callback = currentTask.callback;
              if (typeof callback === "function") {
                currentTask.callback = null;
                currentPriorityLevel = currentTask.priorityLevel;
                var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
                var continuationCallback = callback(didUserCallbackTimeout);
                currentTime = exports.unstable_now();
                if (typeof continuationCallback === "function") {
                  currentTask.callback = continuationCallback;
                } else {
                  if (currentTask === peek(taskQueue)) {
                    pop(taskQueue);
                  }
                }
                advanceTimers(currentTime);
              } else {
                pop(taskQueue);
              }
              currentTask = peek(taskQueue);
            }
            if (currentTask !== null) {
              return true;
            } else {
              var firstTimer = peek(timerQueue);
              if (firstTimer !== null) {
                requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
              }
              return false;
            }
          }
          function unstable_runWithPriority(priorityLevel, eventHandler) {
            switch (priorityLevel) {
              case ImmediatePriority:
              case UserBlockingPriority:
              case NormalPriority:
              case LowPriority:
              case IdlePriority:
                break;
              default:
                priorityLevel = NormalPriority;
            }
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = priorityLevel;
            try {
              return eventHandler();
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          }
          function unstable_next(eventHandler) {
            var priorityLevel;
            switch (currentPriorityLevel) {
              case ImmediatePriority:
              case UserBlockingPriority:
              case NormalPriority:
                priorityLevel = NormalPriority;
                break;
              default:
                priorityLevel = currentPriorityLevel;
                break;
            }
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = priorityLevel;
            try {
              return eventHandler();
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          }
          function unstable_wrapCallback(callback) {
            var parentPriorityLevel = currentPriorityLevel;
            return function() {
              var previousPriorityLevel = currentPriorityLevel;
              currentPriorityLevel = parentPriorityLevel;
              try {
                return callback.apply(this, arguments);
              } finally {
                currentPriorityLevel = previousPriorityLevel;
              }
            };
          }
          function unstable_scheduleCallback(priorityLevel, callback, options2) {
            var currentTime = exports.unstable_now();
            var startTime2;
            if (typeof options2 === "object" && options2 !== null) {
              var delay = options2.delay;
              if (typeof delay === "number" && delay > 0) {
                startTime2 = currentTime + delay;
              } else {
                startTime2 = currentTime;
              }
            } else {
              startTime2 = currentTime;
            }
            var timeout;
            switch (priorityLevel) {
              case ImmediatePriority:
                timeout = IMMEDIATE_PRIORITY_TIMEOUT;
                break;
              case UserBlockingPriority:
                timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
                break;
              case IdlePriority:
                timeout = IDLE_PRIORITY_TIMEOUT;
                break;
              case LowPriority:
                timeout = LOW_PRIORITY_TIMEOUT;
                break;
              case NormalPriority:
              default:
                timeout = NORMAL_PRIORITY_TIMEOUT;
                break;
            }
            var expirationTime = startTime2 + timeout;
            var newTask = {
              id: taskIdCounter++,
              callback,
              priorityLevel,
              startTime: startTime2,
              expirationTime,
              sortIndex: -1
            };
            if (startTime2 > currentTime) {
              newTask.sortIndex = startTime2;
              push(timerQueue, newTask);
              if (peek(taskQueue) === null && newTask === peek(timerQueue)) {
                if (isHostTimeoutScheduled) {
                  cancelHostTimeout();
                } else {
                  isHostTimeoutScheduled = true;
                }
                requestHostTimeout(handleTimeout, startTime2 - currentTime);
              }
            } else {
              newTask.sortIndex = expirationTime;
              push(taskQueue, newTask);
              if (!isHostCallbackScheduled && !isPerformingWork) {
                isHostCallbackScheduled = true;
                requestHostCallback(flushWork);
              }
            }
            return newTask;
          }
          function unstable_pauseExecution() {
          }
          function unstable_continueExecution() {
            if (!isHostCallbackScheduled && !isPerformingWork) {
              isHostCallbackScheduled = true;
              requestHostCallback(flushWork);
            }
          }
          function unstable_getFirstCallbackNode() {
            return peek(taskQueue);
          }
          function unstable_cancelCallback(task) {
            task.callback = null;
          }
          function unstable_getCurrentPriorityLevel() {
            return currentPriorityLevel;
          }
          var isMessageLoopRunning = false;
          var scheduledHostCallback = null;
          var taskTimeoutID = -1;
          var frameInterval = frameYieldMs;
          var startTime = -1;
          function shouldYieldToHost() {
            var timeElapsed = exports.unstable_now() - startTime;
            if (timeElapsed < frameInterval) {
              return false;
            }
            return true;
          }
          function requestPaint() {
          }
          function forceFrameRate(fps) {
            if (fps < 0 || fps > 125) {
              console["error"]("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
              return;
            }
            if (fps > 0) {
              frameInterval = Math.floor(1e3 / fps);
            } else {
              frameInterval = frameYieldMs;
            }
          }
          var performWorkUntilDeadline = function() {
            if (scheduledHostCallback !== null) {
              var currentTime = exports.unstable_now();
              startTime = currentTime;
              var hasTimeRemaining = true;
              var hasMoreWork = true;
              try {
                hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);
              } finally {
                if (hasMoreWork) {
                  schedulePerformWorkUntilDeadline();
                } else {
                  isMessageLoopRunning = false;
                  scheduledHostCallback = null;
                }
              }
            } else {
              isMessageLoopRunning = false;
            }
          };
          var schedulePerformWorkUntilDeadline;
          if (typeof localSetImmediate === "function") {
            schedulePerformWorkUntilDeadline = function() {
              localSetImmediate(performWorkUntilDeadline);
            };
          } else if (typeof MessageChannel !== "undefined") {
            var channel = new MessageChannel();
            var port = channel.port2;
            channel.port1.onmessage = performWorkUntilDeadline;
            schedulePerformWorkUntilDeadline = function() {
              port.postMessage(null);
            };
          } else {
            schedulePerformWorkUntilDeadline = function() {
              localSetTimeout(performWorkUntilDeadline, 0);
            };
          }
          function requestHostCallback(callback) {
            scheduledHostCallback = callback;
            if (!isMessageLoopRunning) {
              isMessageLoopRunning = true;
              schedulePerformWorkUntilDeadline();
            }
          }
          function requestHostTimeout(callback, ms2) {
            taskTimeoutID = localSetTimeout(function() {
              callback(exports.unstable_now());
            }, ms2);
          }
          function cancelHostTimeout() {
            localClearTimeout(taskTimeoutID);
            taskTimeoutID = -1;
          }
          var unstable_requestPaint = requestPaint;
          var unstable_Profiling = null;
          exports.unstable_IdlePriority = IdlePriority;
          exports.unstable_ImmediatePriority = ImmediatePriority;
          exports.unstable_LowPriority = LowPriority;
          exports.unstable_NormalPriority = NormalPriority;
          exports.unstable_Profiling = unstable_Profiling;
          exports.unstable_UserBlockingPriority = UserBlockingPriority;
          exports.unstable_cancelCallback = unstable_cancelCallback;
          exports.unstable_continueExecution = unstable_continueExecution;
          exports.unstable_forceFrameRate = forceFrameRate;
          exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;
          exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;
          exports.unstable_next = unstable_next;
          exports.unstable_pauseExecution = unstable_pauseExecution;
          exports.unstable_requestPaint = unstable_requestPaint;
          exports.unstable_runWithPriority = unstable_runWithPriority;
          exports.unstable_scheduleCallback = unstable_scheduleCallback;
          exports.unstable_shouldYield = shouldYieldToHost;
          exports.unstable_wrapCallback = unstable_wrapCallback;
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
          }
        })();
      }
    }
  });

  // node_modules/scheduler/index.js
  var require_scheduler = __commonJS({
    "node_modules/scheduler/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_scheduler_development();
      }
    }
  });

  // node_modules/react-dom/cjs/react-dom.development.js
  var require_react_dom_development = __commonJS({
    "node_modules/react-dom/cjs/react-dom.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
          }
          var React43 = require_react();
          var Scheduler = require_scheduler();
          var ReactSharedInternals = React43.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
          var suppressWarning = false;
          function setSuppressWarning(newSuppressWarning) {
            {
              suppressWarning = newSuppressWarning;
            }
          }
          function warn(format2) {
            {
              if (!suppressWarning) {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                printWarning("warn", format2, args);
              }
            }
          }
          function error(format2) {
            {
              if (!suppressWarning) {
                for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                  args[_key2 - 1] = arguments[_key2];
                }
                printWarning("error", format2, args);
              }
            }
          }
          function printWarning(level, format2, args) {
            {
              var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
              var stack = ReactDebugCurrentFrame2.getStackAddendum();
              if (stack !== "") {
                format2 += "%s";
                args = args.concat([stack]);
              }
              var argsWithFormat = args.map(function(item) {
                return String(item);
              });
              argsWithFormat.unshift("Warning: " + format2);
              Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
          }
          var FunctionComponent = 0;
          var ClassComponent = 1;
          var IndeterminateComponent = 2;
          var HostRoot = 3;
          var HostPortal = 4;
          var HostComponent = 5;
          var HostText = 6;
          var Fragment2 = 7;
          var Mode = 8;
          var ContextConsumer = 9;
          var ContextProvider = 10;
          var ForwardRef = 11;
          var Profiler = 12;
          var SuspenseComponent = 13;
          var MemoComponent = 14;
          var SimpleMemoComponent = 15;
          var LazyComponent = 16;
          var IncompleteClassComponent = 17;
          var DehydratedFragment = 18;
          var SuspenseListComponent = 19;
          var ScopeComponent = 21;
          var OffscreenComponent = 22;
          var LegacyHiddenComponent = 23;
          var CacheComponent = 24;
          var TracingMarkerComponent = 25;
          var enableClientRenderFallbackOnTextMismatch = true;
          var enableNewReconciler = false;
          var enableLazyContextPropagation = false;
          var enableLegacyHidden = false;
          var enableSuspenseAvoidThisFallback = false;
          var disableCommentsAsDOMContainers = true;
          var enableCustomElementPropertySupport = false;
          var warnAboutStringRefs = false;
          var enableSchedulingProfiler = true;
          var enableProfilerTimer = true;
          var enableProfilerCommitHooks = true;
          var allNativeEvents = /* @__PURE__ */ new Set();
          var registrationNameDependencies = {};
          var possibleRegistrationNames = {};
          function registerTwoPhaseEvent(registrationName, dependencies) {
            registerDirectEvent(registrationName, dependencies);
            registerDirectEvent(registrationName + "Capture", dependencies);
          }
          function registerDirectEvent(registrationName, dependencies) {
            {
              if (registrationNameDependencies[registrationName]) {
                error("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", registrationName);
              }
            }
            registrationNameDependencies[registrationName] = dependencies;
            {
              var lowerCasedName = registrationName.toLowerCase();
              possibleRegistrationNames[lowerCasedName] = registrationName;
              if (registrationName === "onDoubleClick") {
                possibleRegistrationNames.ondblclick = registrationName;
              }
            }
            for (var i7 = 0; i7 < dependencies.length; i7++) {
              allNativeEvents.add(dependencies[i7]);
            }
          }
          var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
          var hasOwnProperty2 = Object.prototype.hasOwnProperty;
          function typeName(value) {
            {
              var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
              var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
              return type;
            }
          }
          function willCoercionThrow(value) {
            {
              try {
                testStringCoercion(value);
                return false;
              } catch (e9) {
                return true;
              }
            }
          }
          function testStringCoercion(value) {
            return "" + value;
          }
          function checkAttributeStringCoercion(value, attributeName) {
            {
              if (willCoercionThrow(value)) {
                error("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", attributeName, typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          function checkKeyStringCoercion(value) {
            {
              if (willCoercionThrow(value)) {
                error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          function checkPropStringCoercion(value, propName) {
            {
              if (willCoercionThrow(value)) {
                error("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          function checkCSSPropertyStringCoercion(value, propName) {
            {
              if (willCoercionThrow(value)) {
                error("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          function checkHtmlStringCoercion(value) {
            {
              if (willCoercionThrow(value)) {
                error("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          function checkFormFieldValueStringCoercion(value) {
            {
              if (willCoercionThrow(value)) {
                error("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.", typeName(value));
                return testStringCoercion(value);
              }
            }
          }
          var RESERVED = 0;
          var STRING = 1;
          var BOOLEANISH_STRING = 2;
          var BOOLEAN = 3;
          var OVERLOADED_BOOLEAN = 4;
          var NUMERIC = 5;
          var POSITIVE_NUMERIC = 6;
          var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
          var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
          var VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
          var illegalAttributeNameCache = {};
          var validatedAttributeNameCache = {};
          function isAttributeNameSafe(attributeName) {
            if (hasOwnProperty2.call(validatedAttributeNameCache, attributeName)) {
              return true;
            }
            if (hasOwnProperty2.call(illegalAttributeNameCache, attributeName)) {
              return false;
            }
            if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
              validatedAttributeNameCache[attributeName] = true;
              return true;
            }
            illegalAttributeNameCache[attributeName] = true;
            {
              error("Invalid attribute name: `%s`", attributeName);
            }
            return false;
          }
          function shouldIgnoreAttribute(name2, propertyInfo, isCustomComponentTag) {
            if (propertyInfo !== null) {
              return propertyInfo.type === RESERVED;
            }
            if (isCustomComponentTag) {
              return false;
            }
            if (name2.length > 2 && (name2[0] === "o" || name2[0] === "O") && (name2[1] === "n" || name2[1] === "N")) {
              return true;
            }
            return false;
          }
          function shouldRemoveAttributeWithWarning(name2, value, propertyInfo, isCustomComponentTag) {
            if (propertyInfo !== null && propertyInfo.type === RESERVED) {
              return false;
            }
            switch (typeof value) {
              case "function":
              case "symbol":
                return true;
              case "boolean": {
                if (isCustomComponentTag) {
                  return false;
                }
                if (propertyInfo !== null) {
                  return !propertyInfo.acceptsBooleans;
                } else {
                  var prefix2 = name2.toLowerCase().slice(0, 5);
                  return prefix2 !== "data-" && prefix2 !== "aria-";
                }
              }
              default:
                return false;
            }
          }
          function shouldRemoveAttribute(name2, value, propertyInfo, isCustomComponentTag) {
            if (value === null || typeof value === "undefined") {
              return true;
            }
            if (shouldRemoveAttributeWithWarning(name2, value, propertyInfo, isCustomComponentTag)) {
              return true;
            }
            if (isCustomComponentTag) {
              return false;
            }
            if (propertyInfo !== null) {
              switch (propertyInfo.type) {
                case BOOLEAN:
                  return !value;
                case OVERLOADED_BOOLEAN:
                  return value === false;
                case NUMERIC:
                  return isNaN(value);
                case POSITIVE_NUMERIC:
                  return isNaN(value) || value < 1;
              }
            }
            return false;
          }
          function getPropertyInfo(name2) {
            return properties.hasOwnProperty(name2) ? properties[name2] : null;
          }
          function PropertyInfoRecord(name2, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
            this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
            this.attributeName = attributeName;
            this.attributeNamespace = attributeNamespace;
            this.mustUseProperty = mustUseProperty;
            this.propertyName = name2;
            this.type = type;
            this.sanitizeURL = sanitizeURL2;
            this.removeEmptyString = removeEmptyString;
          }
          var properties = {};
          var reservedProps = [
            "children",
            "dangerouslySetInnerHTML",
            // TODO: This prevents the assignment of defaultValue to regular
            // elements (not just inputs). Now that ReactDOMInput assigns to the
            // defaultValue property -- do we need this?
            "defaultValue",
            "defaultChecked",
            "innerHTML",
            "suppressContentEditableWarning",
            "suppressHydrationWarning",
            "style"
          ];
          reservedProps.forEach(function(name2) {
            properties[name2] = new PropertyInfoRecord(
              name2,
              RESERVED,
              false,
              // mustUseProperty
              name2,
              // attributeName
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
            var name2 = _ref[0], attributeName = _ref[1];
            properties[name2] = new PropertyInfoRecord(
              name2,
              STRING,
              false,
              // mustUseProperty
              attributeName,
              // attributeName
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name2) {
            properties[name2] = new PropertyInfoRecord(
              name2,
              BOOLEANISH_STRING,
              false,
              // mustUseProperty
              name2.toLowerCase(),
              // attributeName
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name2) {
            properties[name2] = new PropertyInfoRecord(
              name2,
              BOOLEANISH_STRING,
              false,
              // mustUseProperty
              name2,
              // attributeName
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          [
            "allowFullScreen",
            "async",
            // Note: there is a special case that prevents it from being written to the DOM
            // on the client side because the browsers are inconsistent. Instead we call focus().
            "autoFocus",
            "autoPlay",
            "controls",
            "default",
            "defer",
            "disabled",
            "disablePictureInPicture",
            "disableRemotePlayback",
            "formNoValidate",
            "hidden",
            "loop",
            "noModule",
            "noValidate",
            "open",
            "playsInline",
            "readOnly",
            "required",
            "reversed",
            "scoped",
            "seamless",
            // Microdata
            "itemScope"
          ].forEach(function(name2) {
            properties[name2] = new PropertyInfoRecord(
              name2,
              BOOLEAN,
              false,
              // mustUseProperty
              name2.toLowerCase(),
              // attributeName
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          [
            "checked",
            // Note: `option.selected` is not updated if `select.multiple` is
            // disabled with `removeAttribute`. We have special logic for handling this.
            "multiple",
            "muted",
            "selected"
            // NOTE: if you add a camelCased prop to this list,
            // you'll need to set attributeName to name.toLowerCase()
            // instead in the assignment below.
          ].forEach(function(name2) {
            properties[name2] = new PropertyInfoRecord(
              name2,
              BOOLEAN,
              true,
              // mustUseProperty
              name2,
              // attributeName
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          [
            "capture",
            "download"
            // NOTE: if you add a camelCased prop to this list,
            // you'll need to set attributeName to name.toLowerCase()
            // instead in the assignment below.
          ].forEach(function(name2) {
            properties[name2] = new PropertyInfoRecord(
              name2,
              OVERLOADED_BOOLEAN,
              false,
              // mustUseProperty
              name2,
              // attributeName
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          [
            "cols",
            "rows",
            "size",
            "span"
            // NOTE: if you add a camelCased prop to this list,
            // you'll need to set attributeName to name.toLowerCase()
            // instead in the assignment below.
          ].forEach(function(name2) {
            properties[name2] = new PropertyInfoRecord(
              name2,
              POSITIVE_NUMERIC,
              false,
              // mustUseProperty
              name2,
              // attributeName
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          ["rowSpan", "start"].forEach(function(name2) {
            properties[name2] = new PropertyInfoRecord(
              name2,
              NUMERIC,
              false,
              // mustUseProperty
              name2.toLowerCase(),
              // attributeName
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          var CAMELIZE = /[\-\:]([a-z])/g;
          var capitalize = function(token) {
            return token[1].toUpperCase();
          };
          [
            "accent-height",
            "alignment-baseline",
            "arabic-form",
            "baseline-shift",
            "cap-height",
            "clip-path",
            "clip-rule",
            "color-interpolation",
            "color-interpolation-filters",
            "color-profile",
            "color-rendering",
            "dominant-baseline",
            "enable-background",
            "fill-opacity",
            "fill-rule",
            "flood-color",
            "flood-opacity",
            "font-family",
            "font-size",
            "font-size-adjust",
            "font-stretch",
            "font-style",
            "font-variant",
            "font-weight",
            "glyph-name",
            "glyph-orientation-horizontal",
            "glyph-orientation-vertical",
            "horiz-adv-x",
            "horiz-origin-x",
            "image-rendering",
            "letter-spacing",
            "lighting-color",
            "marker-end",
            "marker-mid",
            "marker-start",
            "overline-position",
            "overline-thickness",
            "paint-order",
            "panose-1",
            "pointer-events",
            "rendering-intent",
            "shape-rendering",
            "stop-color",
            "stop-opacity",
            "strikethrough-position",
            "strikethrough-thickness",
            "stroke-dasharray",
            "stroke-dashoffset",
            "stroke-linecap",
            "stroke-linejoin",
            "stroke-miterlimit",
            "stroke-opacity",
            "stroke-width",
            "text-anchor",
            "text-decoration",
            "text-rendering",
            "underline-position",
            "underline-thickness",
            "unicode-bidi",
            "unicode-range",
            "units-per-em",
            "v-alphabetic",
            "v-hanging",
            "v-ideographic",
            "v-mathematical",
            "vector-effect",
            "vert-adv-y",
            "vert-origin-x",
            "vert-origin-y",
            "word-spacing",
            "writing-mode",
            "xmlns:xlink",
            "x-height"
            // NOTE: if you add a camelCased prop to this list,
            // you'll need to set attributeName to name.toLowerCase()
            // instead in the assignment below.
          ].forEach(function(attributeName) {
            var name2 = attributeName.replace(CAMELIZE, capitalize);
            properties[name2] = new PropertyInfoRecord(
              name2,
              STRING,
              false,
              // mustUseProperty
              attributeName,
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          [
            "xlink:actuate",
            "xlink:arcrole",
            "xlink:role",
            "xlink:show",
            "xlink:title",
            "xlink:type"
            // NOTE: if you add a camelCased prop to this list,
            // you'll need to set attributeName to name.toLowerCase()
            // instead in the assignment below.
          ].forEach(function(attributeName) {
            var name2 = attributeName.replace(CAMELIZE, capitalize);
            properties[name2] = new PropertyInfoRecord(
              name2,
              STRING,
              false,
              // mustUseProperty
              attributeName,
              "http://www.w3.org/1999/xlink",
              false,
              // sanitizeURL
              false
            );
          });
          [
            "xml:base",
            "xml:lang",
            "xml:space"
            // NOTE: if you add a camelCased prop to this list,
            // you'll need to set attributeName to name.toLowerCase()
            // instead in the assignment below.
          ].forEach(function(attributeName) {
            var name2 = attributeName.replace(CAMELIZE, capitalize);
            properties[name2] = new PropertyInfoRecord(
              name2,
              STRING,
              false,
              // mustUseProperty
              attributeName,
              "http://www.w3.org/XML/1998/namespace",
              false,
              // sanitizeURL
              false
            );
          });
          ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
            properties[attributeName] = new PropertyInfoRecord(
              attributeName,
              STRING,
              false,
              // mustUseProperty
              attributeName.toLowerCase(),
              // attributeName
              null,
              // attributeNamespace
              false,
              // sanitizeURL
              false
            );
          });
          var xlinkHref = "xlinkHref";
          properties[xlinkHref] = new PropertyInfoRecord(
            "xlinkHref",
            STRING,
            false,
            // mustUseProperty
            "xlink:href",
            "http://www.w3.org/1999/xlink",
            true,
            // sanitizeURL
            false
          );
          ["src", "href", "action", "formAction"].forEach(function(attributeName) {
            properties[attributeName] = new PropertyInfoRecord(
              attributeName,
              STRING,
              false,
              // mustUseProperty
              attributeName.toLowerCase(),
              // attributeName
              null,
              // attributeNamespace
              true,
              // sanitizeURL
              true
            );
          });
          var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
          var didWarn = false;
          function sanitizeURL(url) {
            {
              if (!didWarn && isJavaScriptProtocol.test(url)) {
                didWarn = true;
                error("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url));
              }
            }
          }
          function getValueForProperty(node, name2, expected, propertyInfo) {
            {
              if (propertyInfo.mustUseProperty) {
                var propertyName = propertyInfo.propertyName;
                return node[propertyName];
              } else {
                {
                  checkAttributeStringCoercion(expected, name2);
                }
                if (propertyInfo.sanitizeURL) {
                  sanitizeURL("" + expected);
                }
                var attributeName = propertyInfo.attributeName;
                var stringValue = null;
                if (propertyInfo.type === OVERLOADED_BOOLEAN) {
                  if (node.hasAttribute(attributeName)) {
                    var value = node.getAttribute(attributeName);
                    if (value === "") {
                      return true;
                    }
                    if (shouldRemoveAttribute(name2, expected, propertyInfo, false)) {
                      return value;
                    }
                    if (value === "" + expected) {
                      return expected;
                    }
                    return value;
                  }
                } else if (node.hasAttribute(attributeName)) {
                  if (shouldRemoveAttribute(name2, expected, propertyInfo, false)) {
                    return node.getAttribute(attributeName);
                  }
                  if (propertyInfo.type === BOOLEAN) {
                    return expected;
                  }
                  stringValue = node.getAttribute(attributeName);
                }
                if (shouldRemoveAttribute(name2, expected, propertyInfo, false)) {
                  return stringValue === null ? expected : stringValue;
                } else if (stringValue === "" + expected) {
                  return expected;
                } else {
                  return stringValue;
                }
              }
            }
          }
          function getValueForAttribute(node, name2, expected, isCustomComponentTag) {
            {
              if (!isAttributeNameSafe(name2)) {
                return;
              }
              if (!node.hasAttribute(name2)) {
                return expected === void 0 ? void 0 : null;
              }
              var value = node.getAttribute(name2);
              {
                checkAttributeStringCoercion(expected, name2);
              }
              if (value === "" + expected) {
                return expected;
              }
              return value;
            }
          }
          function setValueForProperty(node, name2, value, isCustomComponentTag) {
            var propertyInfo = getPropertyInfo(name2);
            if (shouldIgnoreAttribute(name2, propertyInfo, isCustomComponentTag)) {
              return;
            }
            if (shouldRemoveAttribute(name2, value, propertyInfo, isCustomComponentTag)) {
              value = null;
            }
            if (isCustomComponentTag || propertyInfo === null) {
              if (isAttributeNameSafe(name2)) {
                var _attributeName = name2;
                if (value === null) {
                  node.removeAttribute(_attributeName);
                } else {
                  {
                    checkAttributeStringCoercion(value, name2);
                  }
                  node.setAttribute(_attributeName, "" + value);
                }
              }
              return;
            }
            var mustUseProperty = propertyInfo.mustUseProperty;
            if (mustUseProperty) {
              var propertyName = propertyInfo.propertyName;
              if (value === null) {
                var type = propertyInfo.type;
                node[propertyName] = type === BOOLEAN ? false : "";
              } else {
                node[propertyName] = value;
              }
              return;
            }
            var attributeName = propertyInfo.attributeName, attributeNamespace = propertyInfo.attributeNamespace;
            if (value === null) {
              node.removeAttribute(attributeName);
            } else {
              var _type = propertyInfo.type;
              var attributeValue;
              if (_type === BOOLEAN || _type === OVERLOADED_BOOLEAN && value === true) {
                attributeValue = "";
              } else {
                {
                  {
                    checkAttributeStringCoercion(value, attributeName);
                  }
                  attributeValue = "" + value;
                }
                if (propertyInfo.sanitizeURL) {
                  sanitizeURL(attributeValue.toString());
                }
              }
              if (attributeNamespace) {
                node.setAttributeNS(attributeNamespace, attributeName, attributeValue);
              } else {
                node.setAttribute(attributeName, attributeValue);
              }
            }
          }
          var REACT_ELEMENT_TYPE = Symbol.for("react.element");
          var REACT_PORTAL_TYPE = Symbol.for("react.portal");
          var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
          var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
          var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
          var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
          var REACT_CONTEXT_TYPE = Symbol.for("react.context");
          var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
          var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
          var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
          var REACT_MEMO_TYPE = Symbol.for("react.memo");
          var REACT_LAZY_TYPE = Symbol.for("react.lazy");
          var REACT_SCOPE_TYPE = Symbol.for("react.scope");
          var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for("react.debug_trace_mode");
          var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
          var REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
          var REACT_CACHE_TYPE = Symbol.for("react.cache");
          var REACT_TRACING_MARKER_TYPE = Symbol.for("react.tracing_marker");
          var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
          var FAUX_ITERATOR_SYMBOL = "@@iterator";
          function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== "object") {
              return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === "function") {
              return maybeIterator;
            }
            return null;
          }
          var assign = Object.assign;
          var disabledDepth = 0;
          var prevLog;
          var prevInfo;
          var prevWarn;
          var prevError;
          var prevGroup;
          var prevGroupCollapsed;
          var prevGroupEnd;
          function disabledLog() {
          }
          disabledLog.__reactDisabledLog = true;
          function disableLogs() {
            {
              if (disabledDepth === 0) {
                prevLog = console.log;
                prevInfo = console.info;
                prevWarn = console.warn;
                prevError = console.error;
                prevGroup = console.group;
                prevGroupCollapsed = console.groupCollapsed;
                prevGroupEnd = console.groupEnd;
                var props = {
                  configurable: true,
                  enumerable: true,
                  value: disabledLog,
                  writable: true
                };
                Object.defineProperties(console, {
                  info: props,
                  log: props,
                  warn: props,
                  error: props,
                  group: props,
                  groupCollapsed: props,
                  groupEnd: props
                });
              }
              disabledDepth++;
            }
          }
          function reenableLogs() {
            {
              disabledDepth--;
              if (disabledDepth === 0) {
                var props = {
                  configurable: true,
                  enumerable: true,
                  writable: true
                };
                Object.defineProperties(console, {
                  log: assign({}, props, {
                    value: prevLog
                  }),
                  info: assign({}, props, {
                    value: prevInfo
                  }),
                  warn: assign({}, props, {
                    value: prevWarn
                  }),
                  error: assign({}, props, {
                    value: prevError
                  }),
                  group: assign({}, props, {
                    value: prevGroup
                  }),
                  groupCollapsed: assign({}, props, {
                    value: prevGroupCollapsed
                  }),
                  groupEnd: assign({}, props, {
                    value: prevGroupEnd
                  })
                });
              }
              if (disabledDepth < 0) {
                error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
              }
            }
          }
          var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
          var prefix;
          function describeBuiltInComponentFrame(name2, source, ownerFn) {
            {
              if (prefix === void 0) {
                try {
                  throw Error();
                } catch (x4) {
                  var match = x4.stack.trim().match(/\n( *(at )?)/);
                  prefix = match && match[1] || "";
                }
              }
              return "\n" + prefix + name2;
            }
          }
          var reentry = false;
          var componentFrameCache;
          {
            var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
            componentFrameCache = new PossiblyWeakMap();
          }
          function describeNativeComponentFrame(fn2, construct) {
            if (!fn2 || reentry) {
              return "";
            }
            {
              var frame = componentFrameCache.get(fn2);
              if (frame !== void 0) {
                return frame;
              }
            }
            var control;
            reentry = true;
            var previousPrepareStackTrace = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            var previousDispatcher;
            {
              previousDispatcher = ReactCurrentDispatcher.current;
              ReactCurrentDispatcher.current = null;
              disableLogs();
            }
            try {
              if (construct) {
                var Fake = function() {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                });
                if (typeof Reflect === "object" && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x4) {
                    control = x4;
                  }
                  Reflect.construct(fn2, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x4) {
                    control = x4;
                  }
                  fn2.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x4) {
                  control = x4;
                }
                fn2();
              }
            } catch (sample) {
              if (sample && control && typeof sample.stack === "string") {
                var sampleLines = sample.stack.split("\n");
                var controlLines = control.stack.split("\n");
                var s7 = sampleLines.length - 1;
                var c9 = controlLines.length - 1;
                while (s7 >= 1 && c9 >= 0 && sampleLines[s7] !== controlLines[c9]) {
                  c9--;
                }
                for (; s7 >= 1 && c9 >= 0; s7--, c9--) {
                  if (sampleLines[s7] !== controlLines[c9]) {
                    if (s7 !== 1 || c9 !== 1) {
                      do {
                        s7--;
                        c9--;
                        if (c9 < 0 || sampleLines[s7] !== controlLines[c9]) {
                          var _frame = "\n" + sampleLines[s7].replace(" at new ", " at ");
                          if (fn2.displayName && _frame.includes("<anonymous>")) {
                            _frame = _frame.replace("<anonymous>", fn2.displayName);
                          }
                          {
                            if (typeof fn2 === "function") {
                              componentFrameCache.set(fn2, _frame);
                            }
                          }
                          return _frame;
                        }
                      } while (s7 >= 1 && c9 >= 0);
                    }
                    break;
                  }
                }
              }
            } finally {
              reentry = false;
              {
                ReactCurrentDispatcher.current = previousDispatcher;
                reenableLogs();
              }
              Error.prepareStackTrace = previousPrepareStackTrace;
            }
            var name2 = fn2 ? fn2.displayName || fn2.name : "";
            var syntheticFrame = name2 ? describeBuiltInComponentFrame(name2) : "";
            {
              if (typeof fn2 === "function") {
                componentFrameCache.set(fn2, syntheticFrame);
              }
            }
            return syntheticFrame;
          }
          function describeClassComponentFrame(ctor, source, ownerFn) {
            {
              return describeNativeComponentFrame(ctor, true);
            }
          }
          function describeFunctionComponentFrame(fn2, source, ownerFn) {
            {
              return describeNativeComponentFrame(fn2, false);
            }
          }
          function shouldConstruct(Component) {
            var prototype3 = Component.prototype;
            return !!(prototype3 && prototype3.isReactComponent);
          }
          function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
            if (type == null) {
              return "";
            }
            if (typeof type === "function") {
              {
                return describeNativeComponentFrame(type, shouldConstruct(type));
              }
            }
            if (typeof type === "string") {
              return describeBuiltInComponentFrame(type);
            }
            switch (type) {
              case REACT_SUSPENSE_TYPE:
                return describeBuiltInComponentFrame("Suspense");
              case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame("SuspenseList");
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_FORWARD_REF_TYPE:
                  return describeFunctionComponentFrame(type.render);
                case REACT_MEMO_TYPE:
                  return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init2 = lazyComponent._init;
                  try {
                    return describeUnknownElementTypeFrameInDEV(init2(payload), source, ownerFn);
                  } catch (x4) {
                  }
                }
              }
            }
            return "";
          }
          function describeFiber(fiber) {
            var owner = fiber._debugOwner ? fiber._debugOwner.type : null;
            var source = fiber._debugSource;
            switch (fiber.tag) {
              case HostComponent:
                return describeBuiltInComponentFrame(fiber.type);
              case LazyComponent:
                return describeBuiltInComponentFrame("Lazy");
              case SuspenseComponent:
                return describeBuiltInComponentFrame("Suspense");
              case SuspenseListComponent:
                return describeBuiltInComponentFrame("SuspenseList");
              case FunctionComponent:
              case IndeterminateComponent:
              case SimpleMemoComponent:
                return describeFunctionComponentFrame(fiber.type);
              case ForwardRef:
                return describeFunctionComponentFrame(fiber.type.render);
              case ClassComponent:
                return describeClassComponentFrame(fiber.type);
              default:
                return "";
            }
          }
          function getStackByFiberInDevAndProd(workInProgress2) {
            try {
              var info = "";
              var node = workInProgress2;
              do {
                info += describeFiber(node);
                node = node.return;
              } while (node);
              return info;
            } catch (x4) {
              return "\nError generating stack: " + x4.message + "\n" + x4.stack;
            }
          }
          function getWrappedName(outerType, innerType, wrapperName) {
            var displayName = outerType.displayName;
            if (displayName) {
              return displayName;
            }
            var functionName = innerType.displayName || innerType.name || "";
            return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
          }
          function getContextName(type) {
            return type.displayName || "Context";
          }
          function getComponentNameFromType(type) {
            if (type == null) {
              return null;
            }
            {
              if (typeof type.tag === "number") {
                error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
              }
            }
            if (typeof type === "function") {
              return type.displayName || type.name || null;
            }
            if (typeof type === "string") {
              return type;
            }
            switch (type) {
              case REACT_FRAGMENT_TYPE:
                return "Fragment";
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_PROFILER_TYPE:
                return "Profiler";
              case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
              case REACT_SUSPENSE_TYPE:
                return "Suspense";
              case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_CONTEXT_TYPE:
                  var context = type;
                  return getContextName(context) + ".Consumer";
                case REACT_PROVIDER_TYPE:
                  var provider = type;
                  return getContextName(provider._context) + ".Provider";
                case REACT_FORWARD_REF_TYPE:
                  return getWrappedName(type, type.render, "ForwardRef");
                case REACT_MEMO_TYPE:
                  var outerName = type.displayName || null;
                  if (outerName !== null) {
                    return outerName;
                  }
                  return getComponentNameFromType(type.type) || "Memo";
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init2 = lazyComponent._init;
                  try {
                    return getComponentNameFromType(init2(payload));
                  } catch (x4) {
                    return null;
                  }
                }
              }
            }
            return null;
          }
          function getWrappedName$1(outerType, innerType, wrapperName) {
            var functionName = innerType.displayName || innerType.name || "";
            return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
          }
          function getContextName$1(type) {
            return type.displayName || "Context";
          }
          function getComponentNameFromFiber(fiber) {
            var tag = fiber.tag, type = fiber.type;
            switch (tag) {
              case CacheComponent:
                return "Cache";
              case ContextConsumer:
                var context = type;
                return getContextName$1(context) + ".Consumer";
              case ContextProvider:
                var provider = type;
                return getContextName$1(provider._context) + ".Provider";
              case DehydratedFragment:
                return "DehydratedFragment";
              case ForwardRef:
                return getWrappedName$1(type, type.render, "ForwardRef");
              case Fragment2:
                return "Fragment";
              case HostComponent:
                return type;
              case HostPortal:
                return "Portal";
              case HostRoot:
                return "Root";
              case HostText:
                return "Text";
              case LazyComponent:
                return getComponentNameFromType(type);
              case Mode:
                if (type === REACT_STRICT_MODE_TYPE) {
                  return "StrictMode";
                }
                return "Mode";
              case OffscreenComponent:
                return "Offscreen";
              case Profiler:
                return "Profiler";
              case ScopeComponent:
                return "Scope";
              case SuspenseComponent:
                return "Suspense";
              case SuspenseListComponent:
                return "SuspenseList";
              case TracingMarkerComponent:
                return "TracingMarker";
              case ClassComponent:
              case FunctionComponent:
              case IncompleteClassComponent:
              case IndeterminateComponent:
              case MemoComponent:
              case SimpleMemoComponent:
                if (typeof type === "function") {
                  return type.displayName || type.name || null;
                }
                if (typeof type === "string") {
                  return type;
                }
                break;
            }
            return null;
          }
          var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
          var current = null;
          var isRendering = false;
          function getCurrentFiberOwnerNameInDevOrNull() {
            {
              if (current === null) {
                return null;
              }
              var owner = current._debugOwner;
              if (owner !== null && typeof owner !== "undefined") {
                return getComponentNameFromFiber(owner);
              }
            }
            return null;
          }
          function getCurrentFiberStackInDev() {
            {
              if (current === null) {
                return "";
              }
              return getStackByFiberInDevAndProd(current);
            }
          }
          function resetCurrentFiber() {
            {
              ReactDebugCurrentFrame.getCurrentStack = null;
              current = null;
              isRendering = false;
            }
          }
          function setCurrentFiber(fiber) {
            {
              ReactDebugCurrentFrame.getCurrentStack = fiber === null ? null : getCurrentFiberStackInDev;
              current = fiber;
              isRendering = false;
            }
          }
          function getCurrentFiber() {
            {
              return current;
            }
          }
          function setIsRendering(rendering) {
            {
              isRendering = rendering;
            }
          }
          function toString5(value) {
            return "" + value;
          }
          function getToStringValue(value) {
            switch (typeof value) {
              case "boolean":
              case "number":
              case "string":
              case "undefined":
                return value;
              case "object":
                {
                  checkFormFieldValueStringCoercion(value);
                }
                return value;
              default:
                return "";
            }
          }
          var hasReadOnlyValue = {
            button: true,
            checkbox: true,
            image: true,
            hidden: true,
            radio: true,
            reset: true,
            submit: true
          };
          function checkControlledValueProps(tagName, props) {
            {
              if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
                error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.");
              }
              if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
                error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
              }
            }
          }
          function isCheckable(elem) {
            var type = elem.type;
            var nodeName = elem.nodeName;
            return nodeName && nodeName.toLowerCase() === "input" && (type === "checkbox" || type === "radio");
          }
          function getTracker(node) {
            return node._valueTracker;
          }
          function detachTracker(node) {
            node._valueTracker = null;
          }
          function getValueFromNode(node) {
            var value = "";
            if (!node) {
              return value;
            }
            if (isCheckable(node)) {
              value = node.checked ? "true" : "false";
            } else {
              value = node.value;
            }
            return value;
          }
          function trackValueOnNode(node) {
            var valueField = isCheckable(node) ? "checked" : "value";
            var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);
            {
              checkFormFieldValueStringCoercion(node[valueField]);
            }
            var currentValue = "" + node[valueField];
            if (node.hasOwnProperty(valueField) || typeof descriptor === "undefined" || typeof descriptor.get !== "function" || typeof descriptor.set !== "function") {
              return;
            }
            var get3 = descriptor.get, set3 = descriptor.set;
            Object.defineProperty(node, valueField, {
              configurable: true,
              get: function() {
                return get3.call(this);
              },
              set: function(value) {
                {
                  checkFormFieldValueStringCoercion(value);
                }
                currentValue = "" + value;
                set3.call(this, value);
              }
            });
            Object.defineProperty(node, valueField, {
              enumerable: descriptor.enumerable
            });
            var tracker = {
              getValue: function() {
                return currentValue;
              },
              setValue: function(value) {
                {
                  checkFormFieldValueStringCoercion(value);
                }
                currentValue = "" + value;
              },
              stopTracking: function() {
                detachTracker(node);
                delete node[valueField];
              }
            };
            return tracker;
          }
          function track(node) {
            if (getTracker(node)) {
              return;
            }
            node._valueTracker = trackValueOnNode(node);
          }
          function updateValueIfChanged(node) {
            if (!node) {
              return false;
            }
            var tracker = getTracker(node);
            if (!tracker) {
              return true;
            }
            var lastValue = tracker.getValue();
            var nextValue = getValueFromNode(node);
            if (nextValue !== lastValue) {
              tracker.setValue(nextValue);
              return true;
            }
            return false;
          }
          function getActiveElement(doc) {
            doc = doc || (typeof document !== "undefined" ? document : void 0);
            if (typeof doc === "undefined") {
              return null;
            }
            try {
              return doc.activeElement || doc.body;
            } catch (e9) {
              return doc.body;
            }
          }
          var didWarnValueDefaultValue = false;
          var didWarnCheckedDefaultChecked = false;
          var didWarnControlledToUncontrolled = false;
          var didWarnUncontrolledToControlled = false;
          function isControlled(props) {
            var usesChecked = props.type === "checkbox" || props.type === "radio";
            return usesChecked ? props.checked != null : props.value != null;
          }
          function getHostProps(element, props) {
            var node = element;
            var checked = props.checked;
            var hostProps = assign({}, props, {
              defaultChecked: void 0,
              defaultValue: void 0,
              value: void 0,
              checked: checked != null ? checked : node._wrapperState.initialChecked
            });
            return hostProps;
          }
          function initWrapperState(element, props) {
            {
              checkControlledValueProps("input", props);
              if (props.checked !== void 0 && props.defaultChecked !== void 0 && !didWarnCheckedDefaultChecked) {
                error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type);
                didWarnCheckedDefaultChecked = true;
              }
              if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValueDefaultValue) {
                error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type);
                didWarnValueDefaultValue = true;
              }
            }
            var node = element;
            var defaultValue = props.defaultValue == null ? "" : props.defaultValue;
            node._wrapperState = {
              initialChecked: props.checked != null ? props.checked : props.defaultChecked,
              initialValue: getToStringValue(props.value != null ? props.value : defaultValue),
              controlled: isControlled(props)
            };
          }
          function updateChecked(element, props) {
            var node = element;
            var checked = props.checked;
            if (checked != null) {
              setValueForProperty(node, "checked", checked, false);
            }
          }
          function updateWrapper(element, props) {
            var node = element;
            {
              var controlled = isControlled(props);
              if (!node._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
                error("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components");
                didWarnUncontrolledToControlled = true;
              }
              if (node._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
                error("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components");
                didWarnControlledToUncontrolled = true;
              }
            }
            updateChecked(element, props);
            var value = getToStringValue(props.value);
            var type = props.type;
            if (value != null) {
              if (type === "number") {
                if (value === 0 && node.value === "" || // We explicitly want to coerce to number here if possible.
                // eslint-disable-next-line
                node.value != value) {
                  node.value = toString5(value);
                }
              } else if (node.value !== toString5(value)) {
                node.value = toString5(value);
              }
            } else if (type === "submit" || type === "reset") {
              node.removeAttribute("value");
              return;
            }
            {
              if (props.hasOwnProperty("value")) {
                setDefaultValue(node, props.type, value);
              } else if (props.hasOwnProperty("defaultValue")) {
                setDefaultValue(node, props.type, getToStringValue(props.defaultValue));
              }
            }
            {
              if (props.checked == null && props.defaultChecked != null) {
                node.defaultChecked = !!props.defaultChecked;
              }
            }
          }
          function postMountWrapper(element, props, isHydrating2) {
            var node = element;
            if (props.hasOwnProperty("value") || props.hasOwnProperty("defaultValue")) {
              var type = props.type;
              var isButton = type === "submit" || type === "reset";
              if (isButton && (props.value === void 0 || props.value === null)) {
                return;
              }
              var initialValue = toString5(node._wrapperState.initialValue);
              if (!isHydrating2) {
                {
                  if (initialValue !== node.value) {
                    node.value = initialValue;
                  }
                }
              }
              {
                node.defaultValue = initialValue;
              }
            }
            var name2 = node.name;
            if (name2 !== "") {
              node.name = "";
            }
            {
              node.defaultChecked = !node.defaultChecked;
              node.defaultChecked = !!node._wrapperState.initialChecked;
            }
            if (name2 !== "") {
              node.name = name2;
            }
          }
          function restoreControlledState(element, props) {
            var node = element;
            updateWrapper(node, props);
            updateNamedCousins(node, props);
          }
          function updateNamedCousins(rootNode, props) {
            var name2 = props.name;
            if (props.type === "radio" && name2 != null) {
              var queryRoot = rootNode;
              while (queryRoot.parentNode) {
                queryRoot = queryRoot.parentNode;
              }
              {
                checkAttributeStringCoercion(name2, "name");
              }
              var group = queryRoot.querySelectorAll("input[name=" + JSON.stringify("" + name2) + '][type="radio"]');
              for (var i7 = 0; i7 < group.length; i7++) {
                var otherNode = group[i7];
                if (otherNode === rootNode || otherNode.form !== rootNode.form) {
                  continue;
                }
                var otherProps = getFiberCurrentPropsFromNode(otherNode);
                if (!otherProps) {
                  throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
                }
                updateValueIfChanged(otherNode);
                updateWrapper(otherNode, otherProps);
              }
            }
          }
          function setDefaultValue(node, type, value) {
            if (
              // Focused number inputs synchronize on blur. See ChangeEventPlugin.js
              type !== "number" || getActiveElement(node.ownerDocument) !== node
            ) {
              if (value == null) {
                node.defaultValue = toString5(node._wrapperState.initialValue);
              } else if (node.defaultValue !== toString5(value)) {
                node.defaultValue = toString5(value);
              }
            }
          }
          var didWarnSelectedSetOnOption = false;
          var didWarnInvalidChild = false;
          var didWarnInvalidInnerHTML = false;
          function validateProps(element, props) {
            {
              if (props.value == null) {
                if (typeof props.children === "object" && props.children !== null) {
                  React43.Children.forEach(props.children, function(child) {
                    if (child == null) {
                      return;
                    }
                    if (typeof child === "string" || typeof child === "number") {
                      return;
                    }
                    if (!didWarnInvalidChild) {
                      didWarnInvalidChild = true;
                      error("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.");
                    }
                  });
                } else if (props.dangerouslySetInnerHTML != null) {
                  if (!didWarnInvalidInnerHTML) {
                    didWarnInvalidInnerHTML = true;
                    error("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.");
                  }
                }
              }
              if (props.selected != null && !didWarnSelectedSetOnOption) {
                error("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.");
                didWarnSelectedSetOnOption = true;
              }
            }
          }
          function postMountWrapper$1(element, props) {
            if (props.value != null) {
              element.setAttribute("value", toString5(getToStringValue(props.value)));
            }
          }
          var isArrayImpl = Array.isArray;
          function isArray2(a6) {
            return isArrayImpl(a6);
          }
          var didWarnValueDefaultValue$1;
          {
            didWarnValueDefaultValue$1 = false;
          }
          function getDeclarationErrorAddendum() {
            var ownerName = getCurrentFiberOwnerNameInDevOrNull();
            if (ownerName) {
              return "\n\nCheck the render method of `" + ownerName + "`.";
            }
            return "";
          }
          var valuePropNames = ["value", "defaultValue"];
          function checkSelectPropTypes(props) {
            {
              checkControlledValueProps("select", props);
              for (var i7 = 0; i7 < valuePropNames.length; i7++) {
                var propName = valuePropNames[i7];
                if (props[propName] == null) {
                  continue;
                }
                var propNameIsArray = isArray2(props[propName]);
                if (props.multiple && !propNameIsArray) {
                  error("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", propName, getDeclarationErrorAddendum());
                } else if (!props.multiple && propNameIsArray) {
                  error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", propName, getDeclarationErrorAddendum());
                }
              }
            }
          }
          function updateOptions(node, multiple, propValue, setDefaultSelected) {
            var options3 = node.options;
            if (multiple) {
              var selectedValues = propValue;
              var selectedValue = {};
              for (var i7 = 0; i7 < selectedValues.length; i7++) {
                selectedValue["$" + selectedValues[i7]] = true;
              }
              for (var _i = 0; _i < options3.length; _i++) {
                var selected = selectedValue.hasOwnProperty("$" + options3[_i].value);
                if (options3[_i].selected !== selected) {
                  options3[_i].selected = selected;
                }
                if (selected && setDefaultSelected) {
                  options3[_i].defaultSelected = true;
                }
              }
            } else {
              var _selectedValue = toString5(getToStringValue(propValue));
              var defaultSelected = null;
              for (var _i2 = 0; _i2 < options3.length; _i2++) {
                if (options3[_i2].value === _selectedValue) {
                  options3[_i2].selected = true;
                  if (setDefaultSelected) {
                    options3[_i2].defaultSelected = true;
                  }
                  return;
                }
                if (defaultSelected === null && !options3[_i2].disabled) {
                  defaultSelected = options3[_i2];
                }
              }
              if (defaultSelected !== null) {
                defaultSelected.selected = true;
              }
            }
          }
          function getHostProps$1(element, props) {
            return assign({}, props, {
              value: void 0
            });
          }
          function initWrapperState$1(element, props) {
            var node = element;
            {
              checkSelectPropTypes(props);
            }
            node._wrapperState = {
              wasMultiple: !!props.multiple
            };
            {
              if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValueDefaultValue$1) {
                error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components");
                didWarnValueDefaultValue$1 = true;
              }
            }
          }
          function postMountWrapper$2(element, props) {
            var node = element;
            node.multiple = !!props.multiple;
            var value = props.value;
            if (value != null) {
              updateOptions(node, !!props.multiple, value, false);
            } else if (props.defaultValue != null) {
              updateOptions(node, !!props.multiple, props.defaultValue, true);
            }
          }
          function postUpdateWrapper(element, props) {
            var node = element;
            var wasMultiple = node._wrapperState.wasMultiple;
            node._wrapperState.wasMultiple = !!props.multiple;
            var value = props.value;
            if (value != null) {
              updateOptions(node, !!props.multiple, value, false);
            } else if (wasMultiple !== !!props.multiple) {
              if (props.defaultValue != null) {
                updateOptions(node, !!props.multiple, props.defaultValue, true);
              } else {
                updateOptions(node, !!props.multiple, props.multiple ? [] : "", false);
              }
            }
          }
          function restoreControlledState$1(element, props) {
            var node = element;
            var value = props.value;
            if (value != null) {
              updateOptions(node, !!props.multiple, value, false);
            }
          }
          var didWarnValDefaultVal = false;
          function getHostProps$2(element, props) {
            var node = element;
            if (props.dangerouslySetInnerHTML != null) {
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
            }
            var hostProps = assign({}, props, {
              value: void 0,
              defaultValue: void 0,
              children: toString5(node._wrapperState.initialValue)
            });
            return hostProps;
          }
          function initWrapperState$2(element, props) {
            var node = element;
            {
              checkControlledValueProps("textarea", props);
              if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValDefaultVal) {
                error("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component");
                didWarnValDefaultVal = true;
              }
            }
            var initialValue = props.value;
            if (initialValue == null) {
              var children = props.children, defaultValue = props.defaultValue;
              if (children != null) {
                {
                  error("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
                }
                {
                  if (defaultValue != null) {
                    throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
                  }
                  if (isArray2(children)) {
                    if (children.length > 1) {
                      throw new Error("<textarea> can only have at most one child.");
                    }
                    children = children[0];
                  }
                  defaultValue = children;
                }
              }
              if (defaultValue == null) {
                defaultValue = "";
              }
              initialValue = defaultValue;
            }
            node._wrapperState = {
              initialValue: getToStringValue(initialValue)
            };
          }
          function updateWrapper$1(element, props) {
            var node = element;
            var value = getToStringValue(props.value);
            var defaultValue = getToStringValue(props.defaultValue);
            if (value != null) {
              var newValue = toString5(value);
              if (newValue !== node.value) {
                node.value = newValue;
              }
              if (props.defaultValue == null && node.defaultValue !== newValue) {
                node.defaultValue = newValue;
              }
            }
            if (defaultValue != null) {
              node.defaultValue = toString5(defaultValue);
            }
          }
          function postMountWrapper$3(element, props) {
            var node = element;
            var textContent = node.textContent;
            if (textContent === node._wrapperState.initialValue) {
              if (textContent !== "" && textContent !== null) {
                node.value = textContent;
              }
            }
          }
          function restoreControlledState$2(element, props) {
            updateWrapper$1(element, props);
          }
          var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
          var MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
          var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
          function getIntrinsicNamespace(type) {
            switch (type) {
              case "svg":
                return SVG_NAMESPACE;
              case "math":
                return MATH_NAMESPACE;
              default:
                return HTML_NAMESPACE;
            }
          }
          function getChildNamespace(parentNamespace, type) {
            if (parentNamespace == null || parentNamespace === HTML_NAMESPACE) {
              return getIntrinsicNamespace(type);
            }
            if (parentNamespace === SVG_NAMESPACE && type === "foreignObject") {
              return HTML_NAMESPACE;
            }
            return parentNamespace;
          }
          var createMicrosoftUnsafeLocalFunction = function(func) {
            if (typeof MSApp !== "undefined" && MSApp.execUnsafeLocalFunction) {
              return function(arg0, arg1, arg2, arg3) {
                MSApp.execUnsafeLocalFunction(function() {
                  return func(arg0, arg1, arg2, arg3);
                });
              };
            } else {
              return func;
            }
          };
          var reusableSVGContainer;
          var setInnerHTML = createMicrosoftUnsafeLocalFunction(function(node, html) {
            if (node.namespaceURI === SVG_NAMESPACE) {
              if (!("innerHTML" in node)) {
                reusableSVGContainer = reusableSVGContainer || document.createElement("div");
                reusableSVGContainer.innerHTML = "<svg>" + html.valueOf().toString() + "</svg>";
                var svgNode = reusableSVGContainer.firstChild;
                while (node.firstChild) {
                  node.removeChild(node.firstChild);
                }
                while (svgNode.firstChild) {
                  node.appendChild(svgNode.firstChild);
                }
                return;
              }
            }
            node.innerHTML = html;
          });
          var ELEMENT_NODE = 1;
          var TEXT_NODE = 3;
          var COMMENT_NODE = 8;
          var DOCUMENT_NODE = 9;
          var DOCUMENT_FRAGMENT_NODE = 11;
          var setTextContent = function(node, text) {
            if (text) {
              var firstChild = node.firstChild;
              if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {
                firstChild.nodeValue = text;
                return;
              }
            }
            node.textContent = text;
          };
          var shorthandToLonghand = {
            animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
            background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
            backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
            border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
            borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
            borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
            borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
            borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
            borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
            borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
            borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
            borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
            borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
            borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
            borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
            borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
            borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
            columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
            columns: ["columnCount", "columnWidth"],
            flex: ["flexBasis", "flexGrow", "flexShrink"],
            flexFlow: ["flexDirection", "flexWrap"],
            font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
            fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
            gap: ["columnGap", "rowGap"],
            grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
            gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
            gridColumn: ["gridColumnEnd", "gridColumnStart"],
            gridColumnGap: ["columnGap"],
            gridGap: ["columnGap", "rowGap"],
            gridRow: ["gridRowEnd", "gridRowStart"],
            gridRowGap: ["rowGap"],
            gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
            listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
            margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
            marker: ["markerEnd", "markerMid", "markerStart"],
            mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
            maskPosition: ["maskPositionX", "maskPositionY"],
            outline: ["outlineColor", "outlineStyle", "outlineWidth"],
            overflow: ["overflowX", "overflowY"],
            padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
            placeContent: ["alignContent", "justifyContent"],
            placeItems: ["alignItems", "justifyItems"],
            placeSelf: ["alignSelf", "justifySelf"],
            textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
            textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
            transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
            wordWrap: ["overflowWrap"]
          };
          var isUnitlessNumber = {
            animationIterationCount: true,
            aspectRatio: true,
            borderImageOutset: true,
            borderImageSlice: true,
            borderImageWidth: true,
            boxFlex: true,
            boxFlexGroup: true,
            boxOrdinalGroup: true,
            columnCount: true,
            columns: true,
            flex: true,
            flexGrow: true,
            flexPositive: true,
            flexShrink: true,
            flexNegative: true,
            flexOrder: true,
            gridArea: true,
            gridRow: true,
            gridRowEnd: true,
            gridRowSpan: true,
            gridRowStart: true,
            gridColumn: true,
            gridColumnEnd: true,
            gridColumnSpan: true,
            gridColumnStart: true,
            fontWeight: true,
            lineClamp: true,
            lineHeight: true,
            opacity: true,
            order: true,
            orphans: true,
            tabSize: true,
            widows: true,
            zIndex: true,
            zoom: true,
            // SVG-related properties
            fillOpacity: true,
            floodOpacity: true,
            stopOpacity: true,
            strokeDasharray: true,
            strokeDashoffset: true,
            strokeMiterlimit: true,
            strokeOpacity: true,
            strokeWidth: true
          };
          function prefixKey(prefix2, key2) {
            return prefix2 + key2.charAt(0).toUpperCase() + key2.substring(1);
          }
          var prefixes = ["Webkit", "ms", "Moz", "O"];
          Object.keys(isUnitlessNumber).forEach(function(prop) {
            prefixes.forEach(function(prefix2) {
              isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop];
            });
          });
          function dangerousStyleValue(name2, value, isCustomProperty) {
            var isEmpty = value == null || typeof value === "boolean" || value === "";
            if (isEmpty) {
              return "";
            }
            if (!isCustomProperty && typeof value === "number" && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name2) && isUnitlessNumber[name2])) {
              return value + "px";
            }
            {
              checkCSSPropertyStringCoercion(value, name2);
            }
            return ("" + value).trim();
          }
          var uppercasePattern = /([A-Z])/g;
          var msPattern = /^ms-/;
          function hyphenateStyleName(name2) {
            return name2.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern, "-ms-");
          }
          var warnValidStyle = function() {
          };
          {
            var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
            var msPattern$1 = /^-ms-/;
            var hyphenPattern = /-(.)/g;
            var badStyleValueWithSemicolonPattern = /;\s*$/;
            var warnedStyleNames = {};
            var warnedStyleValues = {};
            var warnedForNaNValue = false;
            var warnedForInfinityValue = false;
            var camelize = function(string2) {
              return string2.replace(hyphenPattern, function(_8, character) {
                return character.toUpperCase();
              });
            };
            var warnHyphenatedStyleName = function(name2) {
              if (warnedStyleNames.hasOwnProperty(name2) && warnedStyleNames[name2]) {
                return;
              }
              warnedStyleNames[name2] = true;
              error(
                "Unsupported style property %s. Did you mean %s?",
                name2,
                // As Andi Smith suggests
                // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
                // is converted to lowercase `ms`.
                camelize(name2.replace(msPattern$1, "ms-"))
              );
            };
            var warnBadVendoredStyleName = function(name2) {
              if (warnedStyleNames.hasOwnProperty(name2) && warnedStyleNames[name2]) {
                return;
              }
              warnedStyleNames[name2] = true;
              error("Unsupported vendor-prefixed style property %s. Did you mean %s?", name2, name2.charAt(0).toUpperCase() + name2.slice(1));
            };
            var warnStyleValueWithSemicolon = function(name2, value) {
              if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
                return;
              }
              warnedStyleValues[value] = true;
              error(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name2, value.replace(badStyleValueWithSemicolonPattern, ""));
            };
            var warnStyleValueIsNaN = function(name2, value) {
              if (warnedForNaNValue) {
                return;
              }
              warnedForNaNValue = true;
              error("`NaN` is an invalid value for the `%s` css style property.", name2);
            };
            var warnStyleValueIsInfinity = function(name2, value) {
              if (warnedForInfinityValue) {
                return;
              }
              warnedForInfinityValue = true;
              error("`Infinity` is an invalid value for the `%s` css style property.", name2);
            };
            warnValidStyle = function(name2, value) {
              if (name2.indexOf("-") > -1) {
                warnHyphenatedStyleName(name2);
              } else if (badVendoredStyleNamePattern.test(name2)) {
                warnBadVendoredStyleName(name2);
              } else if (badStyleValueWithSemicolonPattern.test(value)) {
                warnStyleValueWithSemicolon(name2, value);
              }
              if (typeof value === "number") {
                if (isNaN(value)) {
                  warnStyleValueIsNaN(name2, value);
                } else if (!isFinite(value)) {
                  warnStyleValueIsInfinity(name2, value);
                }
              }
            };
          }
          var warnValidStyle$1 = warnValidStyle;
          function createDangerousStringForStyles(styles) {
            {
              var serialized = "";
              var delimiter = "";
              for (var styleName in styles) {
                if (!styles.hasOwnProperty(styleName)) {
                  continue;
                }
                var styleValue = styles[styleName];
                if (styleValue != null) {
                  var isCustomProperty = styleName.indexOf("--") === 0;
                  serialized += delimiter + (isCustomProperty ? styleName : hyphenateStyleName(styleName)) + ":";
                  serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);
                  delimiter = ";";
                }
              }
              return serialized || null;
            }
          }
          function setValueForStyles(node, styles) {
            var style3 = node.style;
            for (var styleName in styles) {
              if (!styles.hasOwnProperty(styleName)) {
                continue;
              }
              var isCustomProperty = styleName.indexOf("--") === 0;
              {
                if (!isCustomProperty) {
                  warnValidStyle$1(styleName, styles[styleName]);
                }
              }
              var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);
              if (styleName === "float") {
                styleName = "cssFloat";
              }
              if (isCustomProperty) {
                style3.setProperty(styleName, styleValue);
              } else {
                style3[styleName] = styleValue;
              }
            }
          }
          function isValueEmpty(value) {
            return value == null || typeof value === "boolean" || value === "";
          }
          function expandShorthandMap(styles) {
            var expanded = {};
            for (var key2 in styles) {
              var longhands = shorthandToLonghand[key2] || [key2];
              for (var i7 = 0; i7 < longhands.length; i7++) {
                expanded[longhands[i7]] = key2;
              }
            }
            return expanded;
          }
          function validateShorthandPropertyCollisionInDev(styleUpdates, nextStyles) {
            {
              if (!nextStyles) {
                return;
              }
              var expandedUpdates = expandShorthandMap(styleUpdates);
              var expandedStyles = expandShorthandMap(nextStyles);
              var warnedAbout = {};
              for (var key2 in expandedUpdates) {
                var originalKey = expandedUpdates[key2];
                var correctOriginalKey = expandedStyles[key2];
                if (correctOriginalKey && originalKey !== correctOriginalKey) {
                  var warningKey = originalKey + "," + correctOriginalKey;
                  if (warnedAbout[warningKey]) {
                    continue;
                  }
                  warnedAbout[warningKey] = true;
                  error("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", isValueEmpty(styleUpdates[originalKey]) ? "Removing" : "Updating", originalKey, correctOriginalKey);
                }
              }
            }
          }
          var omittedCloseTags = {
            area: true,
            base: true,
            br: true,
            col: true,
            embed: true,
            hr: true,
            img: true,
            input: true,
            keygen: true,
            link: true,
            meta: true,
            param: true,
            source: true,
            track: true,
            wbr: true
            // NOTE: menuitem's close tag should be omitted, but that causes problems.
          };
          var voidElementTags = assign({
            menuitem: true
          }, omittedCloseTags);
          var HTML = "__html";
          function assertValidProps(tag, props) {
            if (!props) {
              return;
            }
            if (voidElementTags[tag]) {
              if (props.children != null || props.dangerouslySetInnerHTML != null) {
                throw new Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
              }
            }
            if (props.dangerouslySetInnerHTML != null) {
              if (props.children != null) {
                throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
              }
              if (typeof props.dangerouslySetInnerHTML !== "object" || !(HTML in props.dangerouslySetInnerHTML)) {
                throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
              }
            }
            {
              if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
                error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
              }
            }
            if (props.style != null && typeof props.style !== "object") {
              throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
            }
          }
          function isCustomComponent(tagName, props) {
            if (tagName.indexOf("-") === -1) {
              return typeof props.is === "string";
            }
            switch (tagName) {
              case "annotation-xml":
              case "color-profile":
              case "font-face":
              case "font-face-src":
              case "font-face-uri":
              case "font-face-format":
              case "font-face-name":
              case "missing-glyph":
                return false;
              default:
                return true;
            }
          }
          var possibleStandardNames = {
            // HTML
            accept: "accept",
            acceptcharset: "acceptCharset",
            "accept-charset": "acceptCharset",
            accesskey: "accessKey",
            action: "action",
            allowfullscreen: "allowFullScreen",
            alt: "alt",
            as: "as",
            async: "async",
            autocapitalize: "autoCapitalize",
            autocomplete: "autoComplete",
            autocorrect: "autoCorrect",
            autofocus: "autoFocus",
            autoplay: "autoPlay",
            autosave: "autoSave",
            capture: "capture",
            cellpadding: "cellPadding",
            cellspacing: "cellSpacing",
            challenge: "challenge",
            charset: "charSet",
            checked: "checked",
            children: "children",
            cite: "cite",
            class: "className",
            classid: "classID",
            classname: "className",
            cols: "cols",
            colspan: "colSpan",
            content: "content",
            contenteditable: "contentEditable",
            contextmenu: "contextMenu",
            controls: "controls",
            controlslist: "controlsList",
            coords: "coords",
            crossorigin: "crossOrigin",
            dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
            data: "data",
            datetime: "dateTime",
            default: "default",
            defaultchecked: "defaultChecked",
            defaultvalue: "defaultValue",
            defer: "defer",
            dir: "dir",
            disabled: "disabled",
            disablepictureinpicture: "disablePictureInPicture",
            disableremoteplayback: "disableRemotePlayback",
            download: "download",
            draggable: "draggable",
            enctype: "encType",
            enterkeyhint: "enterKeyHint",
            for: "htmlFor",
            form: "form",
            formmethod: "formMethod",
            formaction: "formAction",
            formenctype: "formEncType",
            formnovalidate: "formNoValidate",
            formtarget: "formTarget",
            frameborder: "frameBorder",
            headers: "headers",
            height: "height",
            hidden: "hidden",
            high: "high",
            href: "href",
            hreflang: "hrefLang",
            htmlfor: "htmlFor",
            httpequiv: "httpEquiv",
            "http-equiv": "httpEquiv",
            icon: "icon",
            id: "id",
            imagesizes: "imageSizes",
            imagesrcset: "imageSrcSet",
            innerhtml: "innerHTML",
            inputmode: "inputMode",
            integrity: "integrity",
            is: "is",
            itemid: "itemID",
            itemprop: "itemProp",
            itemref: "itemRef",
            itemscope: "itemScope",
            itemtype: "itemType",
            keyparams: "keyParams",
            keytype: "keyType",
            kind: "kind",
            label: "label",
            lang: "lang",
            list: "list",
            loop: "loop",
            low: "low",
            manifest: "manifest",
            marginwidth: "marginWidth",
            marginheight: "marginHeight",
            max: "max",
            maxlength: "maxLength",
            media: "media",
            mediagroup: "mediaGroup",
            method: "method",
            min: "min",
            minlength: "minLength",
            multiple: "multiple",
            muted: "muted",
            name: "name",
            nomodule: "noModule",
            nonce: "nonce",
            novalidate: "noValidate",
            open: "open",
            optimum: "optimum",
            pattern: "pattern",
            placeholder: "placeholder",
            playsinline: "playsInline",
            poster: "poster",
            preload: "preload",
            profile: "profile",
            radiogroup: "radioGroup",
            readonly: "readOnly",
            referrerpolicy: "referrerPolicy",
            rel: "rel",
            required: "required",
            reversed: "reversed",
            role: "role",
            rows: "rows",
            rowspan: "rowSpan",
            sandbox: "sandbox",
            scope: "scope",
            scoped: "scoped",
            scrolling: "scrolling",
            seamless: "seamless",
            selected: "selected",
            shape: "shape",
            size: "size",
            sizes: "sizes",
            span: "span",
            spellcheck: "spellCheck",
            src: "src",
            srcdoc: "srcDoc",
            srclang: "srcLang",
            srcset: "srcSet",
            start: "start",
            step: "step",
            style: "style",
            summary: "summary",
            tabindex: "tabIndex",
            target: "target",
            title: "title",
            type: "type",
            usemap: "useMap",
            value: "value",
            width: "width",
            wmode: "wmode",
            wrap: "wrap",
            // SVG
            about: "about",
            accentheight: "accentHeight",
            "accent-height": "accentHeight",
            accumulate: "accumulate",
            additive: "additive",
            alignmentbaseline: "alignmentBaseline",
            "alignment-baseline": "alignmentBaseline",
            allowreorder: "allowReorder",
            alphabetic: "alphabetic",
            amplitude: "amplitude",
            arabicform: "arabicForm",
            "arabic-form": "arabicForm",
            ascent: "ascent",
            attributename: "attributeName",
            attributetype: "attributeType",
            autoreverse: "autoReverse",
            azimuth: "azimuth",
            basefrequency: "baseFrequency",
            baselineshift: "baselineShift",
            "baseline-shift": "baselineShift",
            baseprofile: "baseProfile",
            bbox: "bbox",
            begin: "begin",
            bias: "bias",
            by: "by",
            calcmode: "calcMode",
            capheight: "capHeight",
            "cap-height": "capHeight",
            clip: "clip",
            clippath: "clipPath",
            "clip-path": "clipPath",
            clippathunits: "clipPathUnits",
            cliprule: "clipRule",
            "clip-rule": "clipRule",
            color: "color",
            colorinterpolation: "colorInterpolation",
            "color-interpolation": "colorInterpolation",
            colorinterpolationfilters: "colorInterpolationFilters",
            "color-interpolation-filters": "colorInterpolationFilters",
            colorprofile: "colorProfile",
            "color-profile": "colorProfile",
            colorrendering: "colorRendering",
            "color-rendering": "colorRendering",
            contentscripttype: "contentScriptType",
            contentstyletype: "contentStyleType",
            cursor: "cursor",
            cx: "cx",
            cy: "cy",
            d: "d",
            datatype: "datatype",
            decelerate: "decelerate",
            descent: "descent",
            diffuseconstant: "diffuseConstant",
            direction: "direction",
            display: "display",
            divisor: "divisor",
            dominantbaseline: "dominantBaseline",
            "dominant-baseline": "dominantBaseline",
            dur: "dur",
            dx: "dx",
            dy: "dy",
            edgemode: "edgeMode",
            elevation: "elevation",
            enablebackground: "enableBackground",
            "enable-background": "enableBackground",
            end: "end",
            exponent: "exponent",
            externalresourcesrequired: "externalResourcesRequired",
            fill: "fill",
            fillopacity: "fillOpacity",
            "fill-opacity": "fillOpacity",
            fillrule: "fillRule",
            "fill-rule": "fillRule",
            filter: "filter",
            filterres: "filterRes",
            filterunits: "filterUnits",
            floodopacity: "floodOpacity",
            "flood-opacity": "floodOpacity",
            floodcolor: "floodColor",
            "flood-color": "floodColor",
            focusable: "focusable",
            fontfamily: "fontFamily",
            "font-family": "fontFamily",
            fontsize: "fontSize",
            "font-size": "fontSize",
            fontsizeadjust: "fontSizeAdjust",
            "font-size-adjust": "fontSizeAdjust",
            fontstretch: "fontStretch",
            "font-stretch": "fontStretch",
            fontstyle: "fontStyle",
            "font-style": "fontStyle",
            fontvariant: "fontVariant",
            "font-variant": "fontVariant",
            fontweight: "fontWeight",
            "font-weight": "fontWeight",
            format: "format",
            from: "from",
            fx: "fx",
            fy: "fy",
            g1: "g1",
            g2: "g2",
            glyphname: "glyphName",
            "glyph-name": "glyphName",
            glyphorientationhorizontal: "glyphOrientationHorizontal",
            "glyph-orientation-horizontal": "glyphOrientationHorizontal",
            glyphorientationvertical: "glyphOrientationVertical",
            "glyph-orientation-vertical": "glyphOrientationVertical",
            glyphref: "glyphRef",
            gradienttransform: "gradientTransform",
            gradientunits: "gradientUnits",
            hanging: "hanging",
            horizadvx: "horizAdvX",
            "horiz-adv-x": "horizAdvX",
            horizoriginx: "horizOriginX",
            "horiz-origin-x": "horizOriginX",
            ideographic: "ideographic",
            imagerendering: "imageRendering",
            "image-rendering": "imageRendering",
            in2: "in2",
            in: "in",
            inlist: "inlist",
            intercept: "intercept",
            k1: "k1",
            k2: "k2",
            k3: "k3",
            k4: "k4",
            k: "k",
            kernelmatrix: "kernelMatrix",
            kernelunitlength: "kernelUnitLength",
            kerning: "kerning",
            keypoints: "keyPoints",
            keysplines: "keySplines",
            keytimes: "keyTimes",
            lengthadjust: "lengthAdjust",
            letterspacing: "letterSpacing",
            "letter-spacing": "letterSpacing",
            lightingcolor: "lightingColor",
            "lighting-color": "lightingColor",
            limitingconeangle: "limitingConeAngle",
            local: "local",
            markerend: "markerEnd",
            "marker-end": "markerEnd",
            markerheight: "markerHeight",
            markermid: "markerMid",
            "marker-mid": "markerMid",
            markerstart: "markerStart",
            "marker-start": "markerStart",
            markerunits: "markerUnits",
            markerwidth: "markerWidth",
            mask: "mask",
            maskcontentunits: "maskContentUnits",
            maskunits: "maskUnits",
            mathematical: "mathematical",
            mode: "mode",
            numoctaves: "numOctaves",
            offset: "offset",
            opacity: "opacity",
            operator: "operator",
            order: "order",
            orient: "orient",
            orientation: "orientation",
            origin: "origin",
            overflow: "overflow",
            overlineposition: "overlinePosition",
            "overline-position": "overlinePosition",
            overlinethickness: "overlineThickness",
            "overline-thickness": "overlineThickness",
            paintorder: "paintOrder",
            "paint-order": "paintOrder",
            panose1: "panose1",
            "panose-1": "panose1",
            pathlength: "pathLength",
            patterncontentunits: "patternContentUnits",
            patterntransform: "patternTransform",
            patternunits: "patternUnits",
            pointerevents: "pointerEvents",
            "pointer-events": "pointerEvents",
            points: "points",
            pointsatx: "pointsAtX",
            pointsaty: "pointsAtY",
            pointsatz: "pointsAtZ",
            prefix: "prefix",
            preservealpha: "preserveAlpha",
            preserveaspectratio: "preserveAspectRatio",
            primitiveunits: "primitiveUnits",
            property: "property",
            r: "r",
            radius: "radius",
            refx: "refX",
            refy: "refY",
            renderingintent: "renderingIntent",
            "rendering-intent": "renderingIntent",
            repeatcount: "repeatCount",
            repeatdur: "repeatDur",
            requiredextensions: "requiredExtensions",
            requiredfeatures: "requiredFeatures",
            resource: "resource",
            restart: "restart",
            result: "result",
            results: "results",
            rotate: "rotate",
            rx: "rx",
            ry: "ry",
            scale: "scale",
            security: "security",
            seed: "seed",
            shaperendering: "shapeRendering",
            "shape-rendering": "shapeRendering",
            slope: "slope",
            spacing: "spacing",
            specularconstant: "specularConstant",
            specularexponent: "specularExponent",
            speed: "speed",
            spreadmethod: "spreadMethod",
            startoffset: "startOffset",
            stddeviation: "stdDeviation",
            stemh: "stemh",
            stemv: "stemv",
            stitchtiles: "stitchTiles",
            stopcolor: "stopColor",
            "stop-color": "stopColor",
            stopopacity: "stopOpacity",
            "stop-opacity": "stopOpacity",
            strikethroughposition: "strikethroughPosition",
            "strikethrough-position": "strikethroughPosition",
            strikethroughthickness: "strikethroughThickness",
            "strikethrough-thickness": "strikethroughThickness",
            string: "string",
            stroke: "stroke",
            strokedasharray: "strokeDasharray",
            "stroke-dasharray": "strokeDasharray",
            strokedashoffset: "strokeDashoffset",
            "stroke-dashoffset": "strokeDashoffset",
            strokelinecap: "strokeLinecap",
            "stroke-linecap": "strokeLinecap",
            strokelinejoin: "strokeLinejoin",
            "stroke-linejoin": "strokeLinejoin",
            strokemiterlimit: "strokeMiterlimit",
            "stroke-miterlimit": "strokeMiterlimit",
            strokewidth: "strokeWidth",
            "stroke-width": "strokeWidth",
            strokeopacity: "strokeOpacity",
            "stroke-opacity": "strokeOpacity",
            suppresscontenteditablewarning: "suppressContentEditableWarning",
            suppresshydrationwarning: "suppressHydrationWarning",
            surfacescale: "surfaceScale",
            systemlanguage: "systemLanguage",
            tablevalues: "tableValues",
            targetx: "targetX",
            targety: "targetY",
            textanchor: "textAnchor",
            "text-anchor": "textAnchor",
            textdecoration: "textDecoration",
            "text-decoration": "textDecoration",
            textlength: "textLength",
            textrendering: "textRendering",
            "text-rendering": "textRendering",
            to: "to",
            transform: "transform",
            typeof: "typeof",
            u1: "u1",
            u2: "u2",
            underlineposition: "underlinePosition",
            "underline-position": "underlinePosition",
            underlinethickness: "underlineThickness",
            "underline-thickness": "underlineThickness",
            unicode: "unicode",
            unicodebidi: "unicodeBidi",
            "unicode-bidi": "unicodeBidi",
            unicoderange: "unicodeRange",
            "unicode-range": "unicodeRange",
            unitsperem: "unitsPerEm",
            "units-per-em": "unitsPerEm",
            unselectable: "unselectable",
            valphabetic: "vAlphabetic",
            "v-alphabetic": "vAlphabetic",
            values: "values",
            vectoreffect: "vectorEffect",
            "vector-effect": "vectorEffect",
            version: "version",
            vertadvy: "vertAdvY",
            "vert-adv-y": "vertAdvY",
            vertoriginx: "vertOriginX",
            "vert-origin-x": "vertOriginX",
            vertoriginy: "vertOriginY",
            "vert-origin-y": "vertOriginY",
            vhanging: "vHanging",
            "v-hanging": "vHanging",
            videographic: "vIdeographic",
            "v-ideographic": "vIdeographic",
            viewbox: "viewBox",
            viewtarget: "viewTarget",
            visibility: "visibility",
            vmathematical: "vMathematical",
            "v-mathematical": "vMathematical",
            vocab: "vocab",
            widths: "widths",
            wordspacing: "wordSpacing",
            "word-spacing": "wordSpacing",
            writingmode: "writingMode",
            "writing-mode": "writingMode",
            x1: "x1",
            x2: "x2",
            x: "x",
            xchannelselector: "xChannelSelector",
            xheight: "xHeight",
            "x-height": "xHeight",
            xlinkactuate: "xlinkActuate",
            "xlink:actuate": "xlinkActuate",
            xlinkarcrole: "xlinkArcrole",
            "xlink:arcrole": "xlinkArcrole",
            xlinkhref: "xlinkHref",
            "xlink:href": "xlinkHref",
            xlinkrole: "xlinkRole",
            "xlink:role": "xlinkRole",
            xlinkshow: "xlinkShow",
            "xlink:show": "xlinkShow",
            xlinktitle: "xlinkTitle",
            "xlink:title": "xlinkTitle",
            xlinktype: "xlinkType",
            "xlink:type": "xlinkType",
            xmlbase: "xmlBase",
            "xml:base": "xmlBase",
            xmllang: "xmlLang",
            "xml:lang": "xmlLang",
            xmlns: "xmlns",
            "xml:space": "xmlSpace",
            xmlnsxlink: "xmlnsXlink",
            "xmlns:xlink": "xmlnsXlink",
            xmlspace: "xmlSpace",
            y1: "y1",
            y2: "y2",
            y: "y",
            ychannelselector: "yChannelSelector",
            z: "z",
            zoomandpan: "zoomAndPan"
          };
          var ariaProperties = {
            "aria-current": 0,
            // state
            "aria-description": 0,
            "aria-details": 0,
            "aria-disabled": 0,
            // state
            "aria-hidden": 0,
            // state
            "aria-invalid": 0,
            // state
            "aria-keyshortcuts": 0,
            "aria-label": 0,
            "aria-roledescription": 0,
            // Widget Attributes
            "aria-autocomplete": 0,
            "aria-checked": 0,
            "aria-expanded": 0,
            "aria-haspopup": 0,
            "aria-level": 0,
            "aria-modal": 0,
            "aria-multiline": 0,
            "aria-multiselectable": 0,
            "aria-orientation": 0,
            "aria-placeholder": 0,
            "aria-pressed": 0,
            "aria-readonly": 0,
            "aria-required": 0,
            "aria-selected": 0,
            "aria-sort": 0,
            "aria-valuemax": 0,
            "aria-valuemin": 0,
            "aria-valuenow": 0,
            "aria-valuetext": 0,
            // Live Region Attributes
            "aria-atomic": 0,
            "aria-busy": 0,
            "aria-live": 0,
            "aria-relevant": 0,
            // Drag-and-Drop Attributes
            "aria-dropeffect": 0,
            "aria-grabbed": 0,
            // Relationship Attributes
            "aria-activedescendant": 0,
            "aria-colcount": 0,
            "aria-colindex": 0,
            "aria-colspan": 0,
            "aria-controls": 0,
            "aria-describedby": 0,
            "aria-errormessage": 0,
            "aria-flowto": 0,
            "aria-labelledby": 0,
            "aria-owns": 0,
            "aria-posinset": 0,
            "aria-rowcount": 0,
            "aria-rowindex": 0,
            "aria-rowspan": 0,
            "aria-setsize": 0
          };
          var warnedProperties = {};
          var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
          var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
          function validateProperty(tagName, name2) {
            {
              if (hasOwnProperty2.call(warnedProperties, name2) && warnedProperties[name2]) {
                return true;
              }
              if (rARIACamel.test(name2)) {
                var ariaName = "aria-" + name2.slice(4).toLowerCase();
                var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
                if (correctName == null) {
                  error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name2);
                  warnedProperties[name2] = true;
                  return true;
                }
                if (name2 !== correctName) {
                  error("Invalid ARIA attribute `%s`. Did you mean `%s`?", name2, correctName);
                  warnedProperties[name2] = true;
                  return true;
                }
              }
              if (rARIA.test(name2)) {
                var lowerCasedName = name2.toLowerCase();
                var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
                if (standardName == null) {
                  warnedProperties[name2] = true;
                  return false;
                }
                if (name2 !== standardName) {
                  error("Unknown ARIA attribute `%s`. Did you mean `%s`?", name2, standardName);
                  warnedProperties[name2] = true;
                  return true;
                }
              }
            }
            return true;
          }
          function warnInvalidARIAProps(type, props) {
            {
              var invalidProps = [];
              for (var key2 in props) {
                var isValid = validateProperty(type, key2);
                if (!isValid) {
                  invalidProps.push(key2);
                }
              }
              var unknownPropString = invalidProps.map(function(prop) {
                return "`" + prop + "`";
              }).join(", ");
              if (invalidProps.length === 1) {
                error("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
              } else if (invalidProps.length > 1) {
                error("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
              }
            }
          }
          function validateProperties(type, props) {
            if (isCustomComponent(type, props)) {
              return;
            }
            warnInvalidARIAProps(type, props);
          }
          var didWarnValueNull = false;
          function validateProperties$1(type, props) {
            {
              if (type !== "input" && type !== "textarea" && type !== "select") {
                return;
              }
              if (props != null && props.value === null && !didWarnValueNull) {
                didWarnValueNull = true;
                if (type === "select" && props.multiple) {
                  error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type);
                } else {
                  error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type);
                }
              }
            }
          }
          var validateProperty$1 = function() {
          };
          {
            var warnedProperties$1 = {};
            var EVENT_NAME_REGEX = /^on./;
            var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
            var rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
            var rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
            validateProperty$1 = function(tagName, name2, value, eventRegistry) {
              if (hasOwnProperty2.call(warnedProperties$1, name2) && warnedProperties$1[name2]) {
                return true;
              }
              var lowerCasedName = name2.toLowerCase();
              if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout") {
                error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.");
                warnedProperties$1[name2] = true;
                return true;
              }
              if (eventRegistry != null) {
                var registrationNameDependencies2 = eventRegistry.registrationNameDependencies, possibleRegistrationNames2 = eventRegistry.possibleRegistrationNames;
                if (registrationNameDependencies2.hasOwnProperty(name2)) {
                  return true;
                }
                var registrationName = possibleRegistrationNames2.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames2[lowerCasedName] : null;
                if (registrationName != null) {
                  error("Invalid event handler property `%s`. Did you mean `%s`?", name2, registrationName);
                  warnedProperties$1[name2] = true;
                  return true;
                }
                if (EVENT_NAME_REGEX.test(name2)) {
                  error("Unknown event handler property `%s`. It will be ignored.", name2);
                  warnedProperties$1[name2] = true;
                  return true;
                }
              } else if (EVENT_NAME_REGEX.test(name2)) {
                if (INVALID_EVENT_NAME_REGEX.test(name2)) {
                  error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name2);
                }
                warnedProperties$1[name2] = true;
                return true;
              }
              if (rARIA$1.test(name2) || rARIACamel$1.test(name2)) {
                return true;
              }
              if (lowerCasedName === "innerhtml") {
                error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.");
                warnedProperties$1[name2] = true;
                return true;
              }
              if (lowerCasedName === "aria") {
                error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.");
                warnedProperties$1[name2] = true;
                return true;
              }
              if (lowerCasedName === "is" && value !== null && value !== void 0 && typeof value !== "string") {
                error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value);
                warnedProperties$1[name2] = true;
                return true;
              }
              if (typeof value === "number" && isNaN(value)) {
                error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name2);
                warnedProperties$1[name2] = true;
                return true;
              }
              var propertyInfo = getPropertyInfo(name2);
              var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
              if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
                var standardName = possibleStandardNames[lowerCasedName];
                if (standardName !== name2) {
                  error("Invalid DOM property `%s`. Did you mean `%s`?", name2, standardName);
                  warnedProperties$1[name2] = true;
                  return true;
                }
              } else if (!isReserved && name2 !== lowerCasedName) {
                error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name2, lowerCasedName);
                warnedProperties$1[name2] = true;
                return true;
              }
              if (typeof value === "boolean" && shouldRemoveAttributeWithWarning(name2, value, propertyInfo, false)) {
                if (value) {
                  error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name2, name2, value, name2);
                } else {
                  error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name2, name2, value, name2, name2, name2);
                }
                warnedProperties$1[name2] = true;
                return true;
              }
              if (isReserved) {
                return true;
              }
              if (shouldRemoveAttributeWithWarning(name2, value, propertyInfo, false)) {
                warnedProperties$1[name2] = true;
                return false;
              }
              if ((value === "false" || value === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
                error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name2, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name2, value);
                warnedProperties$1[name2] = true;
                return true;
              }
              return true;
            };
          }
          var warnUnknownProperties = function(type, props, eventRegistry) {
            {
              var unknownProps = [];
              for (var key2 in props) {
                var isValid = validateProperty$1(type, key2, props[key2], eventRegistry);
                if (!isValid) {
                  unknownProps.push(key2);
                }
              }
              var unknownPropString = unknownProps.map(function(prop) {
                return "`" + prop + "`";
              }).join(", ");
              if (unknownProps.length === 1) {
                error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
              } else if (unknownProps.length > 1) {
                error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
              }
            }
          };
          function validateProperties$2(type, props, eventRegistry) {
            if (isCustomComponent(type, props)) {
              return;
            }
            warnUnknownProperties(type, props, eventRegistry);
          }
          var IS_EVENT_HANDLE_NON_MANAGED_NODE = 1;
          var IS_NON_DELEGATED = 1 << 1;
          var IS_CAPTURE_PHASE = 1 << 2;
          var SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS = IS_EVENT_HANDLE_NON_MANAGED_NODE | IS_NON_DELEGATED | IS_CAPTURE_PHASE;
          var currentReplayingEvent = null;
          function setReplayingEvent(event) {
            {
              if (currentReplayingEvent !== null) {
                error("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            currentReplayingEvent = event;
          }
          function resetReplayingEvent() {
            {
              if (currentReplayingEvent === null) {
                error("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            currentReplayingEvent = null;
          }
          function isReplayingEvent(event) {
            return event === currentReplayingEvent;
          }
          function getEventTarget(nativeEvent) {
            var target = nativeEvent.target || nativeEvent.srcElement || window;
            if (target.correspondingUseElement) {
              target = target.correspondingUseElement;
            }
            return target.nodeType === TEXT_NODE ? target.parentNode : target;
          }
          var restoreImpl = null;
          var restoreTarget = null;
          var restoreQueue = null;
          function restoreStateOfTarget(target) {
            var internalInstance = getInstanceFromNode(target);
            if (!internalInstance) {
              return;
            }
            if (typeof restoreImpl !== "function") {
              throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
            }
            var stateNode = internalInstance.stateNode;
            if (stateNode) {
              var _props = getFiberCurrentPropsFromNode(stateNode);
              restoreImpl(internalInstance.stateNode, internalInstance.type, _props);
            }
          }
          function setRestoreImplementation(impl) {
            restoreImpl = impl;
          }
          function enqueueStateRestore(target) {
            if (restoreTarget) {
              if (restoreQueue) {
                restoreQueue.push(target);
              } else {
                restoreQueue = [target];
              }
            } else {
              restoreTarget = target;
            }
          }
          function needsStateRestore() {
            return restoreTarget !== null || restoreQueue !== null;
          }
          function restoreStateIfNeeded() {
            if (!restoreTarget) {
              return;
            }
            var target = restoreTarget;
            var queuedTargets = restoreQueue;
            restoreTarget = null;
            restoreQueue = null;
            restoreStateOfTarget(target);
            if (queuedTargets) {
              for (var i7 = 0; i7 < queuedTargets.length; i7++) {
                restoreStateOfTarget(queuedTargets[i7]);
              }
            }
          }
          var batchedUpdatesImpl = function(fn2, bookkeeping) {
            return fn2(bookkeeping);
          };
          var flushSyncImpl = function() {
          };
          var isInsideEventHandler = false;
          function finishEventHandler() {
            var controlledComponentsHavePendingUpdates = needsStateRestore();
            if (controlledComponentsHavePendingUpdates) {
              flushSyncImpl();
              restoreStateIfNeeded();
            }
          }
          function batchedUpdates(fn2, a6, b7) {
            if (isInsideEventHandler) {
              return fn2(a6, b7);
            }
            isInsideEventHandler = true;
            try {
              return batchedUpdatesImpl(fn2, a6, b7);
            } finally {
              isInsideEventHandler = false;
              finishEventHandler();
            }
          }
          function setBatchingImplementation(_batchedUpdatesImpl, _discreteUpdatesImpl, _flushSyncImpl) {
            batchedUpdatesImpl = _batchedUpdatesImpl;
            flushSyncImpl = _flushSyncImpl;
          }
          function isInteractive(tag) {
            return tag === "button" || tag === "input" || tag === "select" || tag === "textarea";
          }
          function shouldPreventMouseEvent(name2, type, props) {
            switch (name2) {
              case "onClick":
              case "onClickCapture":
              case "onDoubleClick":
              case "onDoubleClickCapture":
              case "onMouseDown":
              case "onMouseDownCapture":
              case "onMouseMove":
              case "onMouseMoveCapture":
              case "onMouseUp":
              case "onMouseUpCapture":
              case "onMouseEnter":
                return !!(props.disabled && isInteractive(type));
              default:
                return false;
            }
          }
          function getListener(inst, registrationName) {
            var stateNode = inst.stateNode;
            if (stateNode === null) {
              return null;
            }
            var props = getFiberCurrentPropsFromNode(stateNode);
            if (props === null) {
              return null;
            }
            var listener = props[registrationName];
            if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
              return null;
            }
            if (listener && typeof listener !== "function") {
              throw new Error("Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof listener + "` type.");
            }
            return listener;
          }
          var passiveBrowserEventsSupported = false;
          if (canUseDOM) {
            try {
              var options2 = {};
              Object.defineProperty(options2, "passive", {
                get: function() {
                  passiveBrowserEventsSupported = true;
                }
              });
              window.addEventListener("test", options2, options2);
              window.removeEventListener("test", options2, options2);
            } catch (e9) {
              passiveBrowserEventsSupported = false;
            }
          }
          function invokeGuardedCallbackProd(name2, func, context, a6, b7, c9, d7, e9, f7) {
            var funcArgs = Array.prototype.slice.call(arguments, 3);
            try {
              func.apply(context, funcArgs);
            } catch (error2) {
              this.onError(error2);
            }
          }
          var invokeGuardedCallbackImpl = invokeGuardedCallbackProd;
          {
            if (typeof window !== "undefined" && typeof window.dispatchEvent === "function" && typeof document !== "undefined" && typeof document.createEvent === "function") {
              var fakeNode = document.createElement("react");
              invokeGuardedCallbackImpl = function invokeGuardedCallbackDev(name2, func, context, a6, b7, c9, d7, e9, f7) {
                if (typeof document === "undefined" || document === null) {
                  throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
                }
                var evt = document.createEvent("Event");
                var didCall = false;
                var didError = true;
                var windowEvent = window.event;
                var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, "event");
                function restoreAfterDispatch() {
                  fakeNode.removeEventListener(evtType, callCallback2, false);
                  if (typeof window.event !== "undefined" && window.hasOwnProperty("event")) {
                    window.event = windowEvent;
                  }
                }
                var funcArgs = Array.prototype.slice.call(arguments, 3);
                function callCallback2() {
                  didCall = true;
                  restoreAfterDispatch();
                  func.apply(context, funcArgs);
                  didError = false;
                }
                var error2;
                var didSetError = false;
                var isCrossOriginError = false;
                function handleWindowError(event) {
                  error2 = event.error;
                  didSetError = true;
                  if (error2 === null && event.colno === 0 && event.lineno === 0) {
                    isCrossOriginError = true;
                  }
                  if (event.defaultPrevented) {
                    if (error2 != null && typeof error2 === "object") {
                      try {
                        error2._suppressLogging = true;
                      } catch (inner) {
                      }
                    }
                  }
                }
                var evtType = "react-" + (name2 ? name2 : "invokeguardedcallback");
                window.addEventListener("error", handleWindowError);
                fakeNode.addEventListener(evtType, callCallback2, false);
                evt.initEvent(evtType, false, false);
                fakeNode.dispatchEvent(evt);
                if (windowEventDescriptor) {
                  Object.defineProperty(window, "event", windowEventDescriptor);
                }
                if (didCall && didError) {
                  if (!didSetError) {
                    error2 = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`);
                  } else if (isCrossOriginError) {
                    error2 = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.");
                  }
                  this.onError(error2);
                }
                window.removeEventListener("error", handleWindowError);
                if (!didCall) {
                  restoreAfterDispatch();
                  return invokeGuardedCallbackProd.apply(this, arguments);
                }
              };
            }
          }
          var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;
          var hasError = false;
          var caughtError = null;
          var hasRethrowError = false;
          var rethrowError = null;
          var reporter = {
            onError: function(error2) {
              hasError = true;
              caughtError = error2;
            }
          };
          function invokeGuardedCallback(name2, func, context, a6, b7, c9, d7, e9, f7) {
            hasError = false;
            caughtError = null;
            invokeGuardedCallbackImpl$1.apply(reporter, arguments);
          }
          function invokeGuardedCallbackAndCatchFirstError(name2, func, context, a6, b7, c9, d7, e9, f7) {
            invokeGuardedCallback.apply(this, arguments);
            if (hasError) {
              var error2 = clearCaughtError();
              if (!hasRethrowError) {
                hasRethrowError = true;
                rethrowError = error2;
              }
            }
          }
          function rethrowCaughtError() {
            if (hasRethrowError) {
              var error2 = rethrowError;
              hasRethrowError = false;
              rethrowError = null;
              throw error2;
            }
          }
          function hasCaughtError() {
            return hasError;
          }
          function clearCaughtError() {
            if (hasError) {
              var error2 = caughtError;
              hasError = false;
              caughtError = null;
              return error2;
            } else {
              throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          function get2(key2) {
            return key2._reactInternals;
          }
          function has(key2) {
            return key2._reactInternals !== void 0;
          }
          function set2(key2, value) {
            key2._reactInternals = value;
          }
          var NoFlags = (
            /*                      */
            0
          );
          var PerformedWork = (
            /*                */
            1
          );
          var Placement = (
            /*                    */
            2
          );
          var Update = (
            /*                       */
            4
          );
          var ChildDeletion = (
            /*                */
            16
          );
          var ContentReset = (
            /*                 */
            32
          );
          var Callback = (
            /*                     */
            64
          );
          var DidCapture = (
            /*                   */
            128
          );
          var ForceClientRender = (
            /*            */
            256
          );
          var Ref = (
            /*                          */
            512
          );
          var Snapshot = (
            /*                     */
            1024
          );
          var Passive = (
            /*                      */
            2048
          );
          var Hydrating = (
            /*                    */
            4096
          );
          var Visibility = (
            /*                   */
            8192
          );
          var StoreConsistency = (
            /*             */
            16384
          );
          var LifecycleEffectMask = Passive | Update | Callback | Ref | Snapshot | StoreConsistency;
          var HostEffectMask = (
            /*               */
            32767
          );
          var Incomplete = (
            /*                   */
            32768
          );
          var ShouldCapture = (
            /*                */
            65536
          );
          var ForceUpdateForLegacySuspense = (
            /* */
            131072
          );
          var Forked = (
            /*                       */
            1048576
          );
          var RefStatic = (
            /*                    */
            2097152
          );
          var LayoutStatic = (
            /*                 */
            4194304
          );
          var PassiveStatic = (
            /*                */
            8388608
          );
          var MountLayoutDev = (
            /*               */
            16777216
          );
          var MountPassiveDev = (
            /*              */
            33554432
          );
          var BeforeMutationMask = (
            // TODO: Remove Update flag from before mutation phase by re-landing Visibility
            // flag logic (see #20043)
            Update | Snapshot | 0
          );
          var MutationMask = Placement | Update | ChildDeletion | ContentReset | Ref | Hydrating | Visibility;
          var LayoutMask = Update | Callback | Ref | Visibility;
          var PassiveMask = Passive | ChildDeletion;
          var StaticMask = LayoutStatic | PassiveStatic | RefStatic;
          var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
          function getNearestMountedFiber(fiber) {
            var node = fiber;
            var nearestMounted = fiber;
            if (!fiber.alternate) {
              var nextNode = node;
              do {
                node = nextNode;
                if ((node.flags & (Placement | Hydrating)) !== NoFlags) {
                  nearestMounted = node.return;
                }
                nextNode = node.return;
              } while (nextNode);
            } else {
              while (node.return) {
                node = node.return;
              }
            }
            if (node.tag === HostRoot) {
              return nearestMounted;
            }
            return null;
          }
          function getSuspenseInstanceFromFiber(fiber) {
            if (fiber.tag === SuspenseComponent) {
              var suspenseState = fiber.memoizedState;
              if (suspenseState === null) {
                var current2 = fiber.alternate;
                if (current2 !== null) {
                  suspenseState = current2.memoizedState;
                }
              }
              if (suspenseState !== null) {
                return suspenseState.dehydrated;
              }
            }
            return null;
          }
          function getContainerFromFiber(fiber) {
            return fiber.tag === HostRoot ? fiber.stateNode.containerInfo : null;
          }
          function isFiberMounted(fiber) {
            return getNearestMountedFiber(fiber) === fiber;
          }
          function isMounted(component) {
            {
              var owner = ReactCurrentOwner.current;
              if (owner !== null && owner.tag === ClassComponent) {
                var ownerFiber = owner;
                var instance = ownerFiber.stateNode;
                if (!instance._warnedAboutRefsInRender) {
                  error("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentNameFromFiber(ownerFiber) || "A component");
                }
                instance._warnedAboutRefsInRender = true;
              }
            }
            var fiber = get2(component);
            if (!fiber) {
              return false;
            }
            return getNearestMountedFiber(fiber) === fiber;
          }
          function assertIsMounted(fiber) {
            if (getNearestMountedFiber(fiber) !== fiber) {
              throw new Error("Unable to find node on an unmounted component.");
            }
          }
          function findCurrentFiberUsingSlowPath(fiber) {
            var alternate = fiber.alternate;
            if (!alternate) {
              var nearestMounted = getNearestMountedFiber(fiber);
              if (nearestMounted === null) {
                throw new Error("Unable to find node on an unmounted component.");
              }
              if (nearestMounted !== fiber) {
                return null;
              }
              return fiber;
            }
            var a6 = fiber;
            var b7 = alternate;
            while (true) {
              var parentA = a6.return;
              if (parentA === null) {
                break;
              }
              var parentB = parentA.alternate;
              if (parentB === null) {
                var nextParent = parentA.return;
                if (nextParent !== null) {
                  a6 = b7 = nextParent;
                  continue;
                }
                break;
              }
              if (parentA.child === parentB.child) {
                var child = parentA.child;
                while (child) {
                  if (child === a6) {
                    assertIsMounted(parentA);
                    return fiber;
                  }
                  if (child === b7) {
                    assertIsMounted(parentA);
                    return alternate;
                  }
                  child = child.sibling;
                }
                throw new Error("Unable to find node on an unmounted component.");
              }
              if (a6.return !== b7.return) {
                a6 = parentA;
                b7 = parentB;
              } else {
                var didFindChild = false;
                var _child = parentA.child;
                while (_child) {
                  if (_child === a6) {
                    didFindChild = true;
                    a6 = parentA;
                    b7 = parentB;
                    break;
                  }
                  if (_child === b7) {
                    didFindChild = true;
                    b7 = parentA;
                    a6 = parentB;
                    break;
                  }
                  _child = _child.sibling;
                }
                if (!didFindChild) {
                  _child = parentB.child;
                  while (_child) {
                    if (_child === a6) {
                      didFindChild = true;
                      a6 = parentB;
                      b7 = parentA;
                      break;
                    }
                    if (_child === b7) {
                      didFindChild = true;
                      b7 = parentB;
                      a6 = parentA;
                      break;
                    }
                    _child = _child.sibling;
                  }
                  if (!didFindChild) {
                    throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
                  }
                }
              }
              if (a6.alternate !== b7) {
                throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            if (a6.tag !== HostRoot) {
              throw new Error("Unable to find node on an unmounted component.");
            }
            if (a6.stateNode.current === a6) {
              return fiber;
            }
            return alternate;
          }
          function findCurrentHostFiber(parent) {
            var currentParent = findCurrentFiberUsingSlowPath(parent);
            return currentParent !== null ? findCurrentHostFiberImpl(currentParent) : null;
          }
          function findCurrentHostFiberImpl(node) {
            if (node.tag === HostComponent || node.tag === HostText) {
              return node;
            }
            var child = node.child;
            while (child !== null) {
              var match = findCurrentHostFiberImpl(child);
              if (match !== null) {
                return match;
              }
              child = child.sibling;
            }
            return null;
          }
          function findCurrentHostFiberWithNoPortals(parent) {
            var currentParent = findCurrentFiberUsingSlowPath(parent);
            return currentParent !== null ? findCurrentHostFiberWithNoPortalsImpl(currentParent) : null;
          }
          function findCurrentHostFiberWithNoPortalsImpl(node) {
            if (node.tag === HostComponent || node.tag === HostText) {
              return node;
            }
            var child = node.child;
            while (child !== null) {
              if (child.tag !== HostPortal) {
                var match = findCurrentHostFiberWithNoPortalsImpl(child);
                if (match !== null) {
                  return match;
                }
              }
              child = child.sibling;
            }
            return null;
          }
          var scheduleCallback = Scheduler.unstable_scheduleCallback;
          var cancelCallback = Scheduler.unstable_cancelCallback;
          var shouldYield = Scheduler.unstable_shouldYield;
          var requestPaint = Scheduler.unstable_requestPaint;
          var now2 = Scheduler.unstable_now;
          var getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel;
          var ImmediatePriority = Scheduler.unstable_ImmediatePriority;
          var UserBlockingPriority = Scheduler.unstable_UserBlockingPriority;
          var NormalPriority = Scheduler.unstable_NormalPriority;
          var LowPriority = Scheduler.unstable_LowPriority;
          var IdlePriority = Scheduler.unstable_IdlePriority;
          var unstable_yieldValue = Scheduler.unstable_yieldValue;
          var unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue;
          var rendererID = null;
          var injectedHook = null;
          var injectedProfilingHooks = null;
          var hasLoggedError = false;
          var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined";
          function injectInternals(internals) {
            if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined") {
              return false;
            }
            var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
            if (hook.isDisabled) {
              return true;
            }
            if (!hook.supportsFiber) {
              {
                error("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools");
              }
              return true;
            }
            try {
              if (enableSchedulingProfiler) {
                internals = assign({}, internals, {
                  getLaneLabelMap,
                  injectProfilingHooks
                });
              }
              rendererID = hook.inject(internals);
              injectedHook = hook;
            } catch (err) {
              {
                error("React instrumentation encountered an error: %s.", err);
              }
            }
            if (hook.checkDCE) {
              return true;
            } else {
              return false;
            }
          }
          function onScheduleRoot(root3, children) {
            {
              if (injectedHook && typeof injectedHook.onScheduleFiberRoot === "function") {
                try {
                  injectedHook.onScheduleFiberRoot(rendererID, root3, children);
                } catch (err) {
                  if (!hasLoggedError) {
                    hasLoggedError = true;
                    error("React instrumentation encountered an error: %s", err);
                  }
                }
              }
            }
          }
          function onCommitRoot(root3, eventPriority) {
            if (injectedHook && typeof injectedHook.onCommitFiberRoot === "function") {
              try {
                var didError = (root3.current.flags & DidCapture) === DidCapture;
                if (enableProfilerTimer) {
                  var schedulerPriority;
                  switch (eventPriority) {
                    case DiscreteEventPriority:
                      schedulerPriority = ImmediatePriority;
                      break;
                    case ContinuousEventPriority:
                      schedulerPriority = UserBlockingPriority;
                      break;
                    case DefaultEventPriority:
                      schedulerPriority = NormalPriority;
                      break;
                    case IdleEventPriority:
                      schedulerPriority = IdlePriority;
                      break;
                    default:
                      schedulerPriority = NormalPriority;
                      break;
                  }
                  injectedHook.onCommitFiberRoot(rendererID, root3, schedulerPriority, didError);
                } else {
                  injectedHook.onCommitFiberRoot(rendererID, root3, void 0, didError);
                }
              } catch (err) {
                {
                  if (!hasLoggedError) {
                    hasLoggedError = true;
                    error("React instrumentation encountered an error: %s", err);
                  }
                }
              }
            }
          }
          function onPostCommitRoot(root3) {
            if (injectedHook && typeof injectedHook.onPostCommitFiberRoot === "function") {
              try {
                injectedHook.onPostCommitFiberRoot(rendererID, root3);
              } catch (err) {
                {
                  if (!hasLoggedError) {
                    hasLoggedError = true;
                    error("React instrumentation encountered an error: %s", err);
                  }
                }
              }
            }
          }
          function onCommitUnmount(fiber) {
            if (injectedHook && typeof injectedHook.onCommitFiberUnmount === "function") {
              try {
                injectedHook.onCommitFiberUnmount(rendererID, fiber);
              } catch (err) {
                {
                  if (!hasLoggedError) {
                    hasLoggedError = true;
                    error("React instrumentation encountered an error: %s", err);
                  }
                }
              }
            }
          }
          function setIsStrictModeForDevtools(newIsStrictMode) {
            {
              if (typeof unstable_yieldValue === "function") {
                unstable_setDisableYieldValue(newIsStrictMode);
                setSuppressWarning(newIsStrictMode);
              }
              if (injectedHook && typeof injectedHook.setStrictMode === "function") {
                try {
                  injectedHook.setStrictMode(rendererID, newIsStrictMode);
                } catch (err) {
                  {
                    if (!hasLoggedError) {
                      hasLoggedError = true;
                      error("React instrumentation encountered an error: %s", err);
                    }
                  }
                }
              }
            }
          }
          function injectProfilingHooks(profilingHooks) {
            injectedProfilingHooks = profilingHooks;
          }
          function getLaneLabelMap() {
            {
              var map = /* @__PURE__ */ new Map();
              var lane = 1;
              for (var index3 = 0; index3 < TotalLanes; index3++) {
                var label = getLabelForLane(lane);
                map.set(lane, label);
                lane *= 2;
              }
              return map;
            }
          }
          function markCommitStarted(lanes) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStarted === "function") {
                injectedProfilingHooks.markCommitStarted(lanes);
              }
            }
          }
          function markCommitStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStopped === "function") {
                injectedProfilingHooks.markCommitStopped();
              }
            }
          }
          function markComponentRenderStarted(fiber) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStarted === "function") {
                injectedProfilingHooks.markComponentRenderStarted(fiber);
              }
            }
          }
          function markComponentRenderStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStopped === "function") {
                injectedProfilingHooks.markComponentRenderStopped();
              }
            }
          }
          function markComponentPassiveEffectMountStarted(fiber) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted === "function") {
                injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber);
              }
            }
          }
          function markComponentPassiveEffectMountStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped === "function") {
                injectedProfilingHooks.markComponentPassiveEffectMountStopped();
              }
            }
          }
          function markComponentPassiveEffectUnmountStarted(fiber) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted === "function") {
                injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber);
              }
            }
          }
          function markComponentPassiveEffectUnmountStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped === "function") {
                injectedProfilingHooks.markComponentPassiveEffectUnmountStopped();
              }
            }
          }
          function markComponentLayoutEffectMountStarted(fiber) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted === "function") {
                injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber);
              }
            }
          }
          function markComponentLayoutEffectMountStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped === "function") {
                injectedProfilingHooks.markComponentLayoutEffectMountStopped();
              }
            }
          }
          function markComponentLayoutEffectUnmountStarted(fiber) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted === "function") {
                injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber);
              }
            }
          }
          function markComponentLayoutEffectUnmountStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped === "function") {
                injectedProfilingHooks.markComponentLayoutEffectUnmountStopped();
              }
            }
          }
          function markComponentErrored(fiber, thrownValue, lanes) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentErrored === "function") {
                injectedProfilingHooks.markComponentErrored(fiber, thrownValue, lanes);
              }
            }
          }
          function markComponentSuspended(fiber, wakeable, lanes) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentSuspended === "function") {
                injectedProfilingHooks.markComponentSuspended(fiber, wakeable, lanes);
              }
            }
          }
          function markLayoutEffectsStarted(lanes) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStarted === "function") {
                injectedProfilingHooks.markLayoutEffectsStarted(lanes);
              }
            }
          }
          function markLayoutEffectsStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStopped === "function") {
                injectedProfilingHooks.markLayoutEffectsStopped();
              }
            }
          }
          function markPassiveEffectsStarted(lanes) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStarted === "function") {
                injectedProfilingHooks.markPassiveEffectsStarted(lanes);
              }
            }
          }
          function markPassiveEffectsStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStopped === "function") {
                injectedProfilingHooks.markPassiveEffectsStopped();
              }
            }
          }
          function markRenderStarted(lanes) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStarted === "function") {
                injectedProfilingHooks.markRenderStarted(lanes);
              }
            }
          }
          function markRenderYielded() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderYielded === "function") {
                injectedProfilingHooks.markRenderYielded();
              }
            }
          }
          function markRenderStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStopped === "function") {
                injectedProfilingHooks.markRenderStopped();
              }
            }
          }
          function markRenderScheduled(lane) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderScheduled === "function") {
                injectedProfilingHooks.markRenderScheduled(lane);
              }
            }
          }
          function markForceUpdateScheduled(fiber, lane) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markForceUpdateScheduled === "function") {
                injectedProfilingHooks.markForceUpdateScheduled(fiber, lane);
              }
            }
          }
          function markStateUpdateScheduled(fiber, lane) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markStateUpdateScheduled === "function") {
                injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);
              }
            }
          }
          var NoMode = (
            /*                         */
            0
          );
          var ConcurrentMode = (
            /*                 */
            1
          );
          var ProfileMode = (
            /*                    */
            2
          );
          var StrictLegacyMode = (
            /*               */
            8
          );
          var StrictEffectsMode = (
            /*              */
            16
          );
          var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
          var log = Math.log;
          var LN2 = Math.LN2;
          function clz32Fallback(x4) {
            var asUint = x4 >>> 0;
            if (asUint === 0) {
              return 32;
            }
            return 31 - (log(asUint) / LN2 | 0) | 0;
          }
          var TotalLanes = 31;
          var NoLanes = (
            /*                        */
            0
          );
          var NoLane = (
            /*                          */
            0
          );
          var SyncLane = (
            /*                        */
            1
          );
          var InputContinuousHydrationLane = (
            /*    */
            2
          );
          var InputContinuousLane = (
            /*             */
            4
          );
          var DefaultHydrationLane = (
            /*            */
            8
          );
          var DefaultLane = (
            /*                     */
            16
          );
          var TransitionHydrationLane = (
            /*                */
            32
          );
          var TransitionLanes = (
            /*                       */
            4194240
          );
          var TransitionLane1 = (
            /*                        */
            64
          );
          var TransitionLane2 = (
            /*                        */
            128
          );
          var TransitionLane3 = (
            /*                        */
            256
          );
          var TransitionLane4 = (
            /*                        */
            512
          );
          var TransitionLane5 = (
            /*                        */
            1024
          );
          var TransitionLane6 = (
            /*                        */
            2048
          );
          var TransitionLane7 = (
            /*                        */
            4096
          );
          var TransitionLane8 = (
            /*                        */
            8192
          );
          var TransitionLane9 = (
            /*                        */
            16384
          );
          var TransitionLane10 = (
            /*                       */
            32768
          );
          var TransitionLane11 = (
            /*                       */
            65536
          );
          var TransitionLane12 = (
            /*                       */
            131072
          );
          var TransitionLane13 = (
            /*                       */
            262144
          );
          var TransitionLane14 = (
            /*                       */
            524288
          );
          var TransitionLane15 = (
            /*                       */
            1048576
          );
          var TransitionLane16 = (
            /*                       */
            2097152
          );
          var RetryLanes = (
            /*                            */
            130023424
          );
          var RetryLane1 = (
            /*                             */
            4194304
          );
          var RetryLane2 = (
            /*                             */
            8388608
          );
          var RetryLane3 = (
            /*                             */
            16777216
          );
          var RetryLane4 = (
            /*                             */
            33554432
          );
          var RetryLane5 = (
            /*                             */
            67108864
          );
          var SomeRetryLane = RetryLane1;
          var SelectiveHydrationLane = (
            /*          */
            134217728
          );
          var NonIdleLanes = (
            /*                          */
            268435455
          );
          var IdleHydrationLane = (
            /*               */
            268435456
          );
          var IdleLane = (
            /*                        */
            536870912
          );
          var OffscreenLane = (
            /*                   */
            1073741824
          );
          function getLabelForLane(lane) {
            {
              if (lane & SyncLane) {
                return "Sync";
              }
              if (lane & InputContinuousHydrationLane) {
                return "InputContinuousHydration";
              }
              if (lane & InputContinuousLane) {
                return "InputContinuous";
              }
              if (lane & DefaultHydrationLane) {
                return "DefaultHydration";
              }
              if (lane & DefaultLane) {
                return "Default";
              }
              if (lane & TransitionHydrationLane) {
                return "TransitionHydration";
              }
              if (lane & TransitionLanes) {
                return "Transition";
              }
              if (lane & RetryLanes) {
                return "Retry";
              }
              if (lane & SelectiveHydrationLane) {
                return "SelectiveHydration";
              }
              if (lane & IdleHydrationLane) {
                return "IdleHydration";
              }
              if (lane & IdleLane) {
                return "Idle";
              }
              if (lane & OffscreenLane) {
                return "Offscreen";
              }
            }
          }
          var NoTimestamp = -1;
          var nextTransitionLane = TransitionLane1;
          var nextRetryLane = RetryLane1;
          function getHighestPriorityLanes(lanes) {
            switch (getHighestPriorityLane(lanes)) {
              case SyncLane:
                return SyncLane;
              case InputContinuousHydrationLane:
                return InputContinuousHydrationLane;
              case InputContinuousLane:
                return InputContinuousLane;
              case DefaultHydrationLane:
                return DefaultHydrationLane;
              case DefaultLane:
                return DefaultLane;
              case TransitionHydrationLane:
                return TransitionHydrationLane;
              case TransitionLane1:
              case TransitionLane2:
              case TransitionLane3:
              case TransitionLane4:
              case TransitionLane5:
              case TransitionLane6:
              case TransitionLane7:
              case TransitionLane8:
              case TransitionLane9:
              case TransitionLane10:
              case TransitionLane11:
              case TransitionLane12:
              case TransitionLane13:
              case TransitionLane14:
              case TransitionLane15:
              case TransitionLane16:
                return lanes & TransitionLanes;
              case RetryLane1:
              case RetryLane2:
              case RetryLane3:
              case RetryLane4:
              case RetryLane5:
                return lanes & RetryLanes;
              case SelectiveHydrationLane:
                return SelectiveHydrationLane;
              case IdleHydrationLane:
                return IdleHydrationLane;
              case IdleLane:
                return IdleLane;
              case OffscreenLane:
                return OffscreenLane;
              default:
                {
                  error("Should have found matching lanes. This is a bug in React.");
                }
                return lanes;
            }
          }
          function getNextLanes(root3, wipLanes) {
            var pendingLanes = root3.pendingLanes;
            if (pendingLanes === NoLanes) {
              return NoLanes;
            }
            var nextLanes = NoLanes;
            var suspendedLanes = root3.suspendedLanes;
            var pingedLanes = root3.pingedLanes;
            var nonIdlePendingLanes = pendingLanes & NonIdleLanes;
            if (nonIdlePendingLanes !== NoLanes) {
              var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;
              if (nonIdleUnblockedLanes !== NoLanes) {
                nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);
              } else {
                var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;
                if (nonIdlePingedLanes !== NoLanes) {
                  nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);
                }
              }
            } else {
              var unblockedLanes = pendingLanes & ~suspendedLanes;
              if (unblockedLanes !== NoLanes) {
                nextLanes = getHighestPriorityLanes(unblockedLanes);
              } else {
                if (pingedLanes !== NoLanes) {
                  nextLanes = getHighestPriorityLanes(pingedLanes);
                }
              }
            }
            if (nextLanes === NoLanes) {
              return NoLanes;
            }
            if (wipLanes !== NoLanes && wipLanes !== nextLanes && // If we already suspended with a delay, then interrupting is fine. Don't
            // bother waiting until the root is complete.
            (wipLanes & suspendedLanes) === NoLanes) {
              var nextLane = getHighestPriorityLane(nextLanes);
              var wipLane = getHighestPriorityLane(wipLanes);
              if (
                // Tests whether the next lane is equal or lower priority than the wip
                // one. This works because the bits decrease in priority as you go left.
                nextLane >= wipLane || // Default priority updates should not interrupt transition updates. The
                // only difference between default updates and transition updates is that
                // default updates do not support refresh transitions.
                nextLane === DefaultLane && (wipLane & TransitionLanes) !== NoLanes
              ) {
                return wipLanes;
              }
            }
            if ((nextLanes & InputContinuousLane) !== NoLanes) {
              nextLanes |= pendingLanes & DefaultLane;
            }
            var entangledLanes = root3.entangledLanes;
            if (entangledLanes !== NoLanes) {
              var entanglements = root3.entanglements;
              var lanes = nextLanes & entangledLanes;
              while (lanes > 0) {
                var index3 = pickArbitraryLaneIndex(lanes);
                var lane = 1 << index3;
                nextLanes |= entanglements[index3];
                lanes &= ~lane;
              }
            }
            return nextLanes;
          }
          function getMostRecentEventTime(root3, lanes) {
            var eventTimes = root3.eventTimes;
            var mostRecentEventTime = NoTimestamp;
            while (lanes > 0) {
              var index3 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index3;
              var eventTime = eventTimes[index3];
              if (eventTime > mostRecentEventTime) {
                mostRecentEventTime = eventTime;
              }
              lanes &= ~lane;
            }
            return mostRecentEventTime;
          }
          function computeExpirationTime(lane, currentTime) {
            switch (lane) {
              case SyncLane:
              case InputContinuousHydrationLane:
              case InputContinuousLane:
                return currentTime + 250;
              case DefaultHydrationLane:
              case DefaultLane:
              case TransitionHydrationLane:
              case TransitionLane1:
              case TransitionLane2:
              case TransitionLane3:
              case TransitionLane4:
              case TransitionLane5:
              case TransitionLane6:
              case TransitionLane7:
              case TransitionLane8:
              case TransitionLane9:
              case TransitionLane10:
              case TransitionLane11:
              case TransitionLane12:
              case TransitionLane13:
              case TransitionLane14:
              case TransitionLane15:
              case TransitionLane16:
                return currentTime + 5e3;
              case RetryLane1:
              case RetryLane2:
              case RetryLane3:
              case RetryLane4:
              case RetryLane5:
                return NoTimestamp;
              case SelectiveHydrationLane:
              case IdleHydrationLane:
              case IdleLane:
              case OffscreenLane:
                return NoTimestamp;
              default:
                {
                  error("Should have found matching lanes. This is a bug in React.");
                }
                return NoTimestamp;
            }
          }
          function markStarvedLanesAsExpired(root3, currentTime) {
            var pendingLanes = root3.pendingLanes;
            var suspendedLanes = root3.suspendedLanes;
            var pingedLanes = root3.pingedLanes;
            var expirationTimes = root3.expirationTimes;
            var lanes = pendingLanes;
            while (lanes > 0) {
              var index3 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index3;
              var expirationTime = expirationTimes[index3];
              if (expirationTime === NoTimestamp) {
                if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) {
                  expirationTimes[index3] = computeExpirationTime(lane, currentTime);
                }
              } else if (expirationTime <= currentTime) {
                root3.expiredLanes |= lane;
              }
              lanes &= ~lane;
            }
          }
          function getHighestPriorityPendingLanes(root3) {
            return getHighestPriorityLanes(root3.pendingLanes);
          }
          function getLanesToRetrySynchronouslyOnError(root3) {
            var everythingButOffscreen = root3.pendingLanes & ~OffscreenLane;
            if (everythingButOffscreen !== NoLanes) {
              return everythingButOffscreen;
            }
            if (everythingButOffscreen & OffscreenLane) {
              return OffscreenLane;
            }
            return NoLanes;
          }
          function includesSyncLane(lanes) {
            return (lanes & SyncLane) !== NoLanes;
          }
          function includesNonIdleWork(lanes) {
            return (lanes & NonIdleLanes) !== NoLanes;
          }
          function includesOnlyRetries(lanes) {
            return (lanes & RetryLanes) === lanes;
          }
          function includesOnlyNonUrgentLanes(lanes) {
            var UrgentLanes = SyncLane | InputContinuousLane | DefaultLane;
            return (lanes & UrgentLanes) === NoLanes;
          }
          function includesOnlyTransitions(lanes) {
            return (lanes & TransitionLanes) === lanes;
          }
          function includesBlockingLane(root3, lanes) {
            var SyncDefaultLanes = InputContinuousHydrationLane | InputContinuousLane | DefaultHydrationLane | DefaultLane;
            return (lanes & SyncDefaultLanes) !== NoLanes;
          }
          function includesExpiredLane(root3, lanes) {
            return (lanes & root3.expiredLanes) !== NoLanes;
          }
          function isTransitionLane(lane) {
            return (lane & TransitionLanes) !== NoLanes;
          }
          function claimNextTransitionLane() {
            var lane = nextTransitionLane;
            nextTransitionLane <<= 1;
            if ((nextTransitionLane & TransitionLanes) === NoLanes) {
              nextTransitionLane = TransitionLane1;
            }
            return lane;
          }
          function claimNextRetryLane() {
            var lane = nextRetryLane;
            nextRetryLane <<= 1;
            if ((nextRetryLane & RetryLanes) === NoLanes) {
              nextRetryLane = RetryLane1;
            }
            return lane;
          }
          function getHighestPriorityLane(lanes) {
            return lanes & -lanes;
          }
          function pickArbitraryLane(lanes) {
            return getHighestPriorityLane(lanes);
          }
          function pickArbitraryLaneIndex(lanes) {
            return 31 - clz32(lanes);
          }
          function laneToIndex(lane) {
            return pickArbitraryLaneIndex(lane);
          }
          function includesSomeLane(a6, b7) {
            return (a6 & b7) !== NoLanes;
          }
          function isSubsetOfLanes(set3, subset) {
            return (set3 & subset) === subset;
          }
          function mergeLanes(a6, b7) {
            return a6 | b7;
          }
          function removeLanes(set3, subset) {
            return set3 & ~subset;
          }
          function intersectLanes(a6, b7) {
            return a6 & b7;
          }
          function laneToLanes(lane) {
            return lane;
          }
          function higherPriorityLane(a6, b7) {
            return a6 !== NoLane && a6 < b7 ? a6 : b7;
          }
          function createLaneMap(initial) {
            var laneMap = [];
            for (var i7 = 0; i7 < TotalLanes; i7++) {
              laneMap.push(initial);
            }
            return laneMap;
          }
          function markRootUpdated(root3, updateLane, eventTime) {
            root3.pendingLanes |= updateLane;
            if (updateLane !== IdleLane) {
              root3.suspendedLanes = NoLanes;
              root3.pingedLanes = NoLanes;
            }
            var eventTimes = root3.eventTimes;
            var index3 = laneToIndex(updateLane);
            eventTimes[index3] = eventTime;
          }
          function markRootSuspended(root3, suspendedLanes) {
            root3.suspendedLanes |= suspendedLanes;
            root3.pingedLanes &= ~suspendedLanes;
            var expirationTimes = root3.expirationTimes;
            var lanes = suspendedLanes;
            while (lanes > 0) {
              var index3 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index3;
              expirationTimes[index3] = NoTimestamp;
              lanes &= ~lane;
            }
          }
          function markRootPinged(root3, pingedLanes, eventTime) {
            root3.pingedLanes |= root3.suspendedLanes & pingedLanes;
          }
          function markRootFinished(root3, remainingLanes) {
            var noLongerPendingLanes = root3.pendingLanes & ~remainingLanes;
            root3.pendingLanes = remainingLanes;
            root3.suspendedLanes = NoLanes;
            root3.pingedLanes = NoLanes;
            root3.expiredLanes &= remainingLanes;
            root3.mutableReadLanes &= remainingLanes;
            root3.entangledLanes &= remainingLanes;
            var entanglements = root3.entanglements;
            var eventTimes = root3.eventTimes;
            var expirationTimes = root3.expirationTimes;
            var lanes = noLongerPendingLanes;
            while (lanes > 0) {
              var index3 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index3;
              entanglements[index3] = NoLanes;
              eventTimes[index3] = NoTimestamp;
              expirationTimes[index3] = NoTimestamp;
              lanes &= ~lane;
            }
          }
          function markRootEntangled(root3, entangledLanes) {
            var rootEntangledLanes = root3.entangledLanes |= entangledLanes;
            var entanglements = root3.entanglements;
            var lanes = rootEntangledLanes;
            while (lanes) {
              var index3 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index3;
              if (
                // Is this one of the newly entangled lanes?
                lane & entangledLanes | // Is this lane transitively entangled with the newly entangled lanes?
                entanglements[index3] & entangledLanes
              ) {
                entanglements[index3] |= entangledLanes;
              }
              lanes &= ~lane;
            }
          }
          function getBumpedLaneForHydration(root3, renderLanes2) {
            var renderLane = getHighestPriorityLane(renderLanes2);
            var lane;
            switch (renderLane) {
              case InputContinuousLane:
                lane = InputContinuousHydrationLane;
                break;
              case DefaultLane:
                lane = DefaultHydrationLane;
                break;
              case TransitionLane1:
              case TransitionLane2:
              case TransitionLane3:
              case TransitionLane4:
              case TransitionLane5:
              case TransitionLane6:
              case TransitionLane7:
              case TransitionLane8:
              case TransitionLane9:
              case TransitionLane10:
              case TransitionLane11:
              case TransitionLane12:
              case TransitionLane13:
              case TransitionLane14:
              case TransitionLane15:
              case TransitionLane16:
              case RetryLane1:
              case RetryLane2:
              case RetryLane3:
              case RetryLane4:
              case RetryLane5:
                lane = TransitionHydrationLane;
                break;
              case IdleLane:
                lane = IdleHydrationLane;
                break;
              default:
                lane = NoLane;
                break;
            }
            if ((lane & (root3.suspendedLanes | renderLanes2)) !== NoLane) {
              return NoLane;
            }
            return lane;
          }
          function addFiberToLanesMap(root3, fiber, lanes) {
            if (!isDevToolsPresent) {
              return;
            }
            var pendingUpdatersLaneMap = root3.pendingUpdatersLaneMap;
            while (lanes > 0) {
              var index3 = laneToIndex(lanes);
              var lane = 1 << index3;
              var updaters = pendingUpdatersLaneMap[index3];
              updaters.add(fiber);
              lanes &= ~lane;
            }
          }
          function movePendingFibersToMemoized(root3, lanes) {
            if (!isDevToolsPresent) {
              return;
            }
            var pendingUpdatersLaneMap = root3.pendingUpdatersLaneMap;
            var memoizedUpdaters = root3.memoizedUpdaters;
            while (lanes > 0) {
              var index3 = laneToIndex(lanes);
              var lane = 1 << index3;
              var updaters = pendingUpdatersLaneMap[index3];
              if (updaters.size > 0) {
                updaters.forEach(function(fiber) {
                  var alternate = fiber.alternate;
                  if (alternate === null || !memoizedUpdaters.has(alternate)) {
                    memoizedUpdaters.add(fiber);
                  }
                });
                updaters.clear();
              }
              lanes &= ~lane;
            }
          }
          function getTransitionsForLanes(root3, lanes) {
            {
              return null;
            }
          }
          var DiscreteEventPriority = SyncLane;
          var ContinuousEventPriority = InputContinuousLane;
          var DefaultEventPriority = DefaultLane;
          var IdleEventPriority = IdleLane;
          var currentUpdatePriority = NoLane;
          function getCurrentUpdatePriority() {
            return currentUpdatePriority;
          }
          function setCurrentUpdatePriority(newPriority) {
            currentUpdatePriority = newPriority;
          }
          function runWithPriority(priority, fn2) {
            var previousPriority = currentUpdatePriority;
            try {
              currentUpdatePriority = priority;
              return fn2();
            } finally {
              currentUpdatePriority = previousPriority;
            }
          }
          function higherEventPriority(a6, b7) {
            return a6 !== 0 && a6 < b7 ? a6 : b7;
          }
          function lowerEventPriority(a6, b7) {
            return a6 === 0 || a6 > b7 ? a6 : b7;
          }
          function isHigherEventPriority(a6, b7) {
            return a6 !== 0 && a6 < b7;
          }
          function lanesToEventPriority(lanes) {
            var lane = getHighestPriorityLane(lanes);
            if (!isHigherEventPriority(DiscreteEventPriority, lane)) {
              return DiscreteEventPriority;
            }
            if (!isHigherEventPriority(ContinuousEventPriority, lane)) {
              return ContinuousEventPriority;
            }
            if (includesNonIdleWork(lane)) {
              return DefaultEventPriority;
            }
            return IdleEventPriority;
          }
          function isRootDehydrated(root3) {
            var currentState = root3.current.memoizedState;
            return currentState.isDehydrated;
          }
          var _attemptSynchronousHydration;
          function setAttemptSynchronousHydration(fn2) {
            _attemptSynchronousHydration = fn2;
          }
          function attemptSynchronousHydration(fiber) {
            _attemptSynchronousHydration(fiber);
          }
          var attemptContinuousHydration;
          function setAttemptContinuousHydration(fn2) {
            attemptContinuousHydration = fn2;
          }
          var attemptHydrationAtCurrentPriority;
          function setAttemptHydrationAtCurrentPriority(fn2) {
            attemptHydrationAtCurrentPriority = fn2;
          }
          var getCurrentUpdatePriority$1;
          function setGetCurrentUpdatePriority(fn2) {
            getCurrentUpdatePriority$1 = fn2;
          }
          var attemptHydrationAtPriority;
          function setAttemptHydrationAtPriority(fn2) {
            attemptHydrationAtPriority = fn2;
          }
          var hasScheduledReplayAttempt = false;
          var queuedDiscreteEvents = [];
          var queuedFocus = null;
          var queuedDrag = null;
          var queuedMouse = null;
          var queuedPointers = /* @__PURE__ */ new Map();
          var queuedPointerCaptures = /* @__PURE__ */ new Map();
          var queuedExplicitHydrationTargets = [];
          var discreteReplayableEvents = [
            "mousedown",
            "mouseup",
            "touchcancel",
            "touchend",
            "touchstart",
            "auxclick",
            "dblclick",
            "pointercancel",
            "pointerdown",
            "pointerup",
            "dragend",
            "dragstart",
            "drop",
            "compositionend",
            "compositionstart",
            "keydown",
            "keypress",
            "keyup",
            "input",
            "textInput",
            // Intentionally camelCase
            "copy",
            "cut",
            "paste",
            "click",
            "change",
            "contextmenu",
            "reset",
            "submit"
          ];
          function isDiscreteEventThatRequiresHydration(eventType) {
            return discreteReplayableEvents.indexOf(eventType) > -1;
          }
          function createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            return {
              blockedOn,
              domEventName,
              eventSystemFlags,
              nativeEvent,
              targetContainers: [targetContainer]
            };
          }
          function clearIfContinuousEvent(domEventName, nativeEvent) {
            switch (domEventName) {
              case "focusin":
              case "focusout":
                queuedFocus = null;
                break;
              case "dragenter":
              case "dragleave":
                queuedDrag = null;
                break;
              case "mouseover":
              case "mouseout":
                queuedMouse = null;
                break;
              case "pointerover":
              case "pointerout": {
                var pointerId = nativeEvent.pointerId;
                queuedPointers.delete(pointerId);
                break;
              }
              case "gotpointercapture":
              case "lostpointercapture": {
                var _pointerId = nativeEvent.pointerId;
                queuedPointerCaptures.delete(_pointerId);
                break;
              }
            }
          }
          function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            if (existingQueuedEvent === null || existingQueuedEvent.nativeEvent !== nativeEvent) {
              var queuedEvent = createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);
              if (blockedOn !== null) {
                var _fiber2 = getInstanceFromNode(blockedOn);
                if (_fiber2 !== null) {
                  attemptContinuousHydration(_fiber2);
                }
              }
              return queuedEvent;
            }
            existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
            var targetContainers = existingQueuedEvent.targetContainers;
            if (targetContainer !== null && targetContainers.indexOf(targetContainer) === -1) {
              targetContainers.push(targetContainer);
            }
            return existingQueuedEvent;
          }
          function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            switch (domEventName) {
              case "focusin": {
                var focusEvent = nativeEvent;
                queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, domEventName, eventSystemFlags, targetContainer, focusEvent);
                return true;
              }
              case "dragenter": {
                var dragEvent = nativeEvent;
                queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, domEventName, eventSystemFlags, targetContainer, dragEvent);
                return true;
              }
              case "mouseover": {
                var mouseEvent = nativeEvent;
                queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, domEventName, eventSystemFlags, targetContainer, mouseEvent);
                return true;
              }
              case "pointerover": {
                var pointerEvent = nativeEvent;
                var pointerId = pointerEvent.pointerId;
                queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, pointerEvent));
                return true;
              }
              case "gotpointercapture": {
                var _pointerEvent = nativeEvent;
                var _pointerId2 = _pointerEvent.pointerId;
                queuedPointerCaptures.set(_pointerId2, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(_pointerId2) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, _pointerEvent));
                return true;
              }
            }
            return false;
          }
          function attemptExplicitHydrationTarget(queuedTarget) {
            var targetInst = getClosestInstanceFromNode(queuedTarget.target);
            if (targetInst !== null) {
              var nearestMounted = getNearestMountedFiber(targetInst);
              if (nearestMounted !== null) {
                var tag = nearestMounted.tag;
                if (tag === SuspenseComponent) {
                  var instance = getSuspenseInstanceFromFiber(nearestMounted);
                  if (instance !== null) {
                    queuedTarget.blockedOn = instance;
                    attemptHydrationAtPriority(queuedTarget.priority, function() {
                      attemptHydrationAtCurrentPriority(nearestMounted);
                    });
                    return;
                  }
                } else if (tag === HostRoot) {
                  var root3 = nearestMounted.stateNode;
                  if (isRootDehydrated(root3)) {
                    queuedTarget.blockedOn = getContainerFromFiber(nearestMounted);
                    return;
                  }
                }
              }
            }
            queuedTarget.blockedOn = null;
          }
          function queueExplicitHydrationTarget(target) {
            var updatePriority = getCurrentUpdatePriority$1();
            var queuedTarget = {
              blockedOn: null,
              target,
              priority: updatePriority
            };
            var i7 = 0;
            for (; i7 < queuedExplicitHydrationTargets.length; i7++) {
              if (!isHigherEventPriority(updatePriority, queuedExplicitHydrationTargets[i7].priority)) {
                break;
              }
            }
            queuedExplicitHydrationTargets.splice(i7, 0, queuedTarget);
            if (i7 === 0) {
              attemptExplicitHydrationTarget(queuedTarget);
            }
          }
          function attemptReplayContinuousQueuedEvent(queuedEvent) {
            if (queuedEvent.blockedOn !== null) {
              return false;
            }
            var targetContainers = queuedEvent.targetContainers;
            while (targetContainers.length > 0) {
              var targetContainer = targetContainers[0];
              var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.domEventName, queuedEvent.eventSystemFlags, targetContainer, queuedEvent.nativeEvent);
              if (nextBlockedOn === null) {
                {
                  var nativeEvent = queuedEvent.nativeEvent;
                  var nativeEventClone = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
                  setReplayingEvent(nativeEventClone);
                  nativeEvent.target.dispatchEvent(nativeEventClone);
                  resetReplayingEvent();
                }
              } else {
                var _fiber3 = getInstanceFromNode(nextBlockedOn);
                if (_fiber3 !== null) {
                  attemptContinuousHydration(_fiber3);
                }
                queuedEvent.blockedOn = nextBlockedOn;
                return false;
              }
              targetContainers.shift();
            }
            return true;
          }
          function attemptReplayContinuousQueuedEventInMap(queuedEvent, key2, map) {
            if (attemptReplayContinuousQueuedEvent(queuedEvent)) {
              map.delete(key2);
            }
          }
          function replayUnblockedEvents() {
            hasScheduledReplayAttempt = false;
            if (queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus)) {
              queuedFocus = null;
            }
            if (queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag)) {
              queuedDrag = null;
            }
            if (queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse)) {
              queuedMouse = null;
            }
            queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
            queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
          }
          function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
            if (queuedEvent.blockedOn === unblocked) {
              queuedEvent.blockedOn = null;
              if (!hasScheduledReplayAttempt) {
                hasScheduledReplayAttempt = true;
                Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, replayUnblockedEvents);
              }
            }
          }
          function retryIfBlockedOn(unblocked) {
            if (queuedDiscreteEvents.length > 0) {
              scheduleCallbackIfUnblocked(queuedDiscreteEvents[0], unblocked);
              for (var i7 = 1; i7 < queuedDiscreteEvents.length; i7++) {
                var queuedEvent = queuedDiscreteEvents[i7];
                if (queuedEvent.blockedOn === unblocked) {
                  queuedEvent.blockedOn = null;
                }
              }
            }
            if (queuedFocus !== null) {
              scheduleCallbackIfUnblocked(queuedFocus, unblocked);
            }
            if (queuedDrag !== null) {
              scheduleCallbackIfUnblocked(queuedDrag, unblocked);
            }
            if (queuedMouse !== null) {
              scheduleCallbackIfUnblocked(queuedMouse, unblocked);
            }
            var unblock = function(queuedEvent2) {
              return scheduleCallbackIfUnblocked(queuedEvent2, unblocked);
            };
            queuedPointers.forEach(unblock);
            queuedPointerCaptures.forEach(unblock);
            for (var _i = 0; _i < queuedExplicitHydrationTargets.length; _i++) {
              var queuedTarget = queuedExplicitHydrationTargets[_i];
              if (queuedTarget.blockedOn === unblocked) {
                queuedTarget.blockedOn = null;
              }
            }
            while (queuedExplicitHydrationTargets.length > 0) {
              var nextExplicitTarget = queuedExplicitHydrationTargets[0];
              if (nextExplicitTarget.blockedOn !== null) {
                break;
              } else {
                attemptExplicitHydrationTarget(nextExplicitTarget);
                if (nextExplicitTarget.blockedOn === null) {
                  queuedExplicitHydrationTargets.shift();
                }
              }
            }
          }
          var ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;
          var _enabled = true;
          function setEnabled(enabled) {
            _enabled = !!enabled;
          }
          function isEnabled() {
            return _enabled;
          }
          function createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags) {
            var eventPriority = getEventPriority(domEventName);
            var listenerWrapper;
            switch (eventPriority) {
              case DiscreteEventPriority:
                listenerWrapper = dispatchDiscreteEvent;
                break;
              case ContinuousEventPriority:
                listenerWrapper = dispatchContinuousEvent;
                break;
              case DefaultEventPriority:
              default:
                listenerWrapper = dispatchEvent;
                break;
            }
            return listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);
          }
          function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
            var previousPriority = getCurrentUpdatePriority();
            var prevTransition = ReactCurrentBatchConfig.transition;
            ReactCurrentBatchConfig.transition = null;
            try {
              setCurrentUpdatePriority(DiscreteEventPriority);
              dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
            } finally {
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig.transition = prevTransition;
            }
          }
          function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
            var previousPriority = getCurrentUpdatePriority();
            var prevTransition = ReactCurrentBatchConfig.transition;
            ReactCurrentBatchConfig.transition = null;
            try {
              setCurrentUpdatePriority(ContinuousEventPriority);
              dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
            } finally {
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig.transition = prevTransition;
            }
          }
          function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            if (!_enabled) {
              return;
            }
            {
              dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent);
            }
          }
          function dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            var blockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);
            if (blockedOn === null) {
              dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);
              clearIfContinuousEvent(domEventName, nativeEvent);
              return;
            }
            if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)) {
              nativeEvent.stopPropagation();
              return;
            }
            clearIfContinuousEvent(domEventName, nativeEvent);
            if (eventSystemFlags & IS_CAPTURE_PHASE && isDiscreteEventThatRequiresHydration(domEventName)) {
              while (blockedOn !== null) {
                var fiber = getInstanceFromNode(blockedOn);
                if (fiber !== null) {
                  attemptSynchronousHydration(fiber);
                }
                var nextBlockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);
                if (nextBlockedOn === null) {
                  dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);
                }
                if (nextBlockedOn === blockedOn) {
                  break;
                }
                blockedOn = nextBlockedOn;
              }
              if (blockedOn !== null) {
                nativeEvent.stopPropagation();
              }
              return;
            }
            dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);
          }
          var return_targetInst = null;
          function findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            return_targetInst = null;
            var nativeEventTarget = getEventTarget(nativeEvent);
            var targetInst = getClosestInstanceFromNode(nativeEventTarget);
            if (targetInst !== null) {
              var nearestMounted = getNearestMountedFiber(targetInst);
              if (nearestMounted === null) {
                targetInst = null;
              } else {
                var tag = nearestMounted.tag;
                if (tag === SuspenseComponent) {
                  var instance = getSuspenseInstanceFromFiber(nearestMounted);
                  if (instance !== null) {
                    return instance;
                  }
                  targetInst = null;
                } else if (tag === HostRoot) {
                  var root3 = nearestMounted.stateNode;
                  if (isRootDehydrated(root3)) {
                    return getContainerFromFiber(nearestMounted);
                  }
                  targetInst = null;
                } else if (nearestMounted !== targetInst) {
                  targetInst = null;
                }
              }
            }
            return_targetInst = targetInst;
            return null;
          }
          function getEventPriority(domEventName) {
            switch (domEventName) {
              case "cancel":
              case "click":
              case "close":
              case "contextmenu":
              case "copy":
              case "cut":
              case "auxclick":
              case "dblclick":
              case "dragend":
              case "dragstart":
              case "drop":
              case "focusin":
              case "focusout":
              case "input":
              case "invalid":
              case "keydown":
              case "keypress":
              case "keyup":
              case "mousedown":
              case "mouseup":
              case "paste":
              case "pause":
              case "play":
              case "pointercancel":
              case "pointerdown":
              case "pointerup":
              case "ratechange":
              case "reset":
              case "resize":
              case "seeked":
              case "submit":
              case "touchcancel":
              case "touchend":
              case "touchstart":
              case "volumechange":
              case "change":
              case "selectionchange":
              case "textInput":
              case "compositionstart":
              case "compositionend":
              case "compositionupdate":
              case "beforeblur":
              case "afterblur":
              case "beforeinput":
              case "blur":
              case "fullscreenchange":
              case "focus":
              case "hashchange":
              case "popstate":
              case "select":
              case "selectstart":
                return DiscreteEventPriority;
              case "drag":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "mousemove":
              case "mouseout":
              case "mouseover":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "scroll":
              case "toggle":
              case "touchmove":
              case "wheel":
              case "mouseenter":
              case "mouseleave":
              case "pointerenter":
              case "pointerleave":
                return ContinuousEventPriority;
              case "message": {
                var schedulerPriority = getCurrentPriorityLevel();
                switch (schedulerPriority) {
                  case ImmediatePriority:
                    return DiscreteEventPriority;
                  case UserBlockingPriority:
                    return ContinuousEventPriority;
                  case NormalPriority:
                  case LowPriority:
                    return DefaultEventPriority;
                  case IdlePriority:
                    return IdleEventPriority;
                  default:
                    return DefaultEventPriority;
                }
              }
              default:
                return DefaultEventPriority;
            }
          }
          function addEventBubbleListener(target, eventType, listener) {
            target.addEventListener(eventType, listener, false);
            return listener;
          }
          function addEventCaptureListener(target, eventType, listener) {
            target.addEventListener(eventType, listener, true);
            return listener;
          }
          function addEventCaptureListenerWithPassiveFlag(target, eventType, listener, passive) {
            target.addEventListener(eventType, listener, {
              capture: true,
              passive
            });
            return listener;
          }
          function addEventBubbleListenerWithPassiveFlag(target, eventType, listener, passive) {
            target.addEventListener(eventType, listener, {
              passive
            });
            return listener;
          }
          var root2 = null;
          var startText = null;
          var fallbackText = null;
          function initialize(nativeEventTarget) {
            root2 = nativeEventTarget;
            startText = getText();
            return true;
          }
          function reset2() {
            root2 = null;
            startText = null;
            fallbackText = null;
          }
          function getData2() {
            if (fallbackText) {
              return fallbackText;
            }
            var start;
            var startValue = startText;
            var startLength = startValue.length;
            var end;
            var endValue = getText();
            var endLength = endValue.length;
            for (start = 0; start < startLength; start++) {
              if (startValue[start] !== endValue[start]) {
                break;
              }
            }
            var minEnd = startLength - start;
            for (end = 1; end <= minEnd; end++) {
              if (startValue[startLength - end] !== endValue[endLength - end]) {
                break;
              }
            }
            var sliceTail = end > 1 ? 1 - end : void 0;
            fallbackText = endValue.slice(start, sliceTail);
            return fallbackText;
          }
          function getText() {
            if ("value" in root2) {
              return root2.value;
            }
            return root2.textContent;
          }
          function getEventCharCode(nativeEvent) {
            var charCode;
            var keyCode = nativeEvent.keyCode;
            if ("charCode" in nativeEvent) {
              charCode = nativeEvent.charCode;
              if (charCode === 0 && keyCode === 13) {
                charCode = 13;
              }
            } else {
              charCode = keyCode;
            }
            if (charCode === 10) {
              charCode = 13;
            }
            if (charCode >= 32 || charCode === 13) {
              return charCode;
            }
            return 0;
          }
          function functionThatReturnsTrue() {
            return true;
          }
          function functionThatReturnsFalse() {
            return false;
          }
          function createSyntheticEvent(Interface2) {
            function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
              this._reactName = reactName;
              this._targetInst = targetInst;
              this.type = reactEventType;
              this.nativeEvent = nativeEvent;
              this.target = nativeEventTarget;
              this.currentTarget = null;
              for (var _propName in Interface2) {
                if (!Interface2.hasOwnProperty(_propName)) {
                  continue;
                }
                var normalize3 = Interface2[_propName];
                if (normalize3) {
                  this[_propName] = normalize3(nativeEvent);
                } else {
                  this[_propName] = nativeEvent[_propName];
                }
              }
              var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
              if (defaultPrevented) {
                this.isDefaultPrevented = functionThatReturnsTrue;
              } else {
                this.isDefaultPrevented = functionThatReturnsFalse;
              }
              this.isPropagationStopped = functionThatReturnsFalse;
              return this;
            }
            assign(SyntheticBaseEvent.prototype, {
              preventDefault: function() {
                this.defaultPrevented = true;
                var event = this.nativeEvent;
                if (!event) {
                  return;
                }
                if (event.preventDefault) {
                  event.preventDefault();
                } else if (typeof event.returnValue !== "unknown") {
                  event.returnValue = false;
                }
                this.isDefaultPrevented = functionThatReturnsTrue;
              },
              stopPropagation: function() {
                var event = this.nativeEvent;
                if (!event) {
                  return;
                }
                if (event.stopPropagation) {
                  event.stopPropagation();
                } else if (typeof event.cancelBubble !== "unknown") {
                  event.cancelBubble = true;
                }
                this.isPropagationStopped = functionThatReturnsTrue;
              },
              /**
               * We release all dispatched `SyntheticEvent`s after each event loop, adding
               * them back into the pool. This allows a way to hold onto a reference that
               * won't be added back into the pool.
               */
              persist: function() {
              },
              /**
               * Checks if this event should be released back into the pool.
               *
               * @return {boolean} True if this should not be released, false otherwise.
               */
              isPersistent: functionThatReturnsTrue
            });
            return SyntheticBaseEvent;
          }
          var EventInterface = {
            eventPhase: 0,
            bubbles: 0,
            cancelable: 0,
            timeStamp: function(event) {
              return event.timeStamp || Date.now();
            },
            defaultPrevented: 0,
            isTrusted: 0
          };
          var SyntheticEvent = createSyntheticEvent(EventInterface);
          var UIEventInterface = assign({}, EventInterface, {
            view: 0,
            detail: 0
          });
          var SyntheticUIEvent = createSyntheticEvent(UIEventInterface);
          var lastMovementX;
          var lastMovementY;
          var lastMouseEvent;
          function updateMouseMovementPolyfillState(event) {
            if (event !== lastMouseEvent) {
              if (lastMouseEvent && event.type === "mousemove") {
                lastMovementX = event.screenX - lastMouseEvent.screenX;
                lastMovementY = event.screenY - lastMouseEvent.screenY;
              } else {
                lastMovementX = 0;
                lastMovementY = 0;
              }
              lastMouseEvent = event;
            }
          }
          var MouseEventInterface = assign({}, UIEventInterface, {
            screenX: 0,
            screenY: 0,
            clientX: 0,
            clientY: 0,
            pageX: 0,
            pageY: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            getModifierState: getEventModifierState,
            button: 0,
            buttons: 0,
            relatedTarget: function(event) {
              if (event.relatedTarget === void 0)
                return event.fromElement === event.srcElement ? event.toElement : event.fromElement;
              return event.relatedTarget;
            },
            movementX: function(event) {
              if ("movementX" in event) {
                return event.movementX;
              }
              updateMouseMovementPolyfillState(event);
              return lastMovementX;
            },
            movementY: function(event) {
              if ("movementY" in event) {
                return event.movementY;
              }
              return lastMovementY;
            }
          });
          var SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface);
          var DragEventInterface = assign({}, MouseEventInterface, {
            dataTransfer: 0
          });
          var SyntheticDragEvent = createSyntheticEvent(DragEventInterface);
          var FocusEventInterface = assign({}, UIEventInterface, {
            relatedTarget: 0
          });
          var SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface);
          var AnimationEventInterface = assign({}, EventInterface, {
            animationName: 0,
            elapsedTime: 0,
            pseudoElement: 0
          });
          var SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface);
          var ClipboardEventInterface = assign({}, EventInterface, {
            clipboardData: function(event) {
              return "clipboardData" in event ? event.clipboardData : window.clipboardData;
            }
          });
          var SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface);
          var CompositionEventInterface = assign({}, EventInterface, {
            data: 0
          });
          var SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface);
          var SyntheticInputEvent = SyntheticCompositionEvent;
          var normalizeKey2 = {
            Esc: "Escape",
            Spacebar: " ",
            Left: "ArrowLeft",
            Up: "ArrowUp",
            Right: "ArrowRight",
            Down: "ArrowDown",
            Del: "Delete",
            Win: "OS",
            Menu: "ContextMenu",
            Apps: "ContextMenu",
            Scroll: "ScrollLock",
            MozPrintableKey: "Unidentified"
          };
          var translateToKey = {
            "8": "Backspace",
            "9": "Tab",
            "12": "Clear",
            "13": "Enter",
            "16": "Shift",
            "17": "Control",
            "18": "Alt",
            "19": "Pause",
            "20": "CapsLock",
            "27": "Escape",
            "32": " ",
            "33": "PageUp",
            "34": "PageDown",
            "35": "End",
            "36": "Home",
            "37": "ArrowLeft",
            "38": "ArrowUp",
            "39": "ArrowRight",
            "40": "ArrowDown",
            "45": "Insert",
            "46": "Delete",
            "112": "F1",
            "113": "F2",
            "114": "F3",
            "115": "F4",
            "116": "F5",
            "117": "F6",
            "118": "F7",
            "119": "F8",
            "120": "F9",
            "121": "F10",
            "122": "F11",
            "123": "F12",
            "144": "NumLock",
            "145": "ScrollLock",
            "224": "Meta"
          };
          function getEventKey(nativeEvent) {
            if (nativeEvent.key) {
              var key2 = normalizeKey2[nativeEvent.key] || nativeEvent.key;
              if (key2 !== "Unidentified") {
                return key2;
              }
            }
            if (nativeEvent.type === "keypress") {
              var charCode = getEventCharCode(nativeEvent);
              return charCode === 13 ? "Enter" : String.fromCharCode(charCode);
            }
            if (nativeEvent.type === "keydown" || nativeEvent.type === "keyup") {
              return translateToKey[nativeEvent.keyCode] || "Unidentified";
            }
            return "";
          }
          var modifierKeyToProp = {
            Alt: "altKey",
            Control: "ctrlKey",
            Meta: "metaKey",
            Shift: "shiftKey"
          };
          function modifierStateGetter(keyArg) {
            var syntheticEvent = this;
            var nativeEvent = syntheticEvent.nativeEvent;
            if (nativeEvent.getModifierState) {
              return nativeEvent.getModifierState(keyArg);
            }
            var keyProp = modifierKeyToProp[keyArg];
            return keyProp ? !!nativeEvent[keyProp] : false;
          }
          function getEventModifierState(nativeEvent) {
            return modifierStateGetter;
          }
          var KeyboardEventInterface = assign({}, UIEventInterface, {
            key: getEventKey,
            code: 0,
            location: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            repeat: 0,
            locale: 0,
            getModifierState: getEventModifierState,
            // Legacy Interface
            charCode: function(event) {
              if (event.type === "keypress") {
                return getEventCharCode(event);
              }
              return 0;
            },
            keyCode: function(event) {
              if (event.type === "keydown" || event.type === "keyup") {
                return event.keyCode;
              }
              return 0;
            },
            which: function(event) {
              if (event.type === "keypress") {
                return getEventCharCode(event);
              }
              if (event.type === "keydown" || event.type === "keyup") {
                return event.keyCode;
              }
              return 0;
            }
          });
          var SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface);
          var PointerEventInterface = assign({}, MouseEventInterface, {
            pointerId: 0,
            width: 0,
            height: 0,
            pressure: 0,
            tangentialPressure: 0,
            tiltX: 0,
            tiltY: 0,
            twist: 0,
            pointerType: 0,
            isPrimary: 0
          });
          var SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface);
          var TouchEventInterface = assign({}, UIEventInterface, {
            touches: 0,
            targetTouches: 0,
            changedTouches: 0,
            altKey: 0,
            metaKey: 0,
            ctrlKey: 0,
            shiftKey: 0,
            getModifierState: getEventModifierState
          });
          var SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface);
          var TransitionEventInterface = assign({}, EventInterface, {
            propertyName: 0,
            elapsedTime: 0,
            pseudoElement: 0
          });
          var SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface);
          var WheelEventInterface = assign({}, MouseEventInterface, {
            deltaX: function(event) {
              return "deltaX" in event ? event.deltaX : (
                // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
                "wheelDeltaX" in event ? -event.wheelDeltaX : 0
              );
            },
            deltaY: function(event) {
              return "deltaY" in event ? event.deltaY : (
                // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
                "wheelDeltaY" in event ? -event.wheelDeltaY : (
                  // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
                  "wheelDelta" in event ? -event.wheelDelta : 0
                )
              );
            },
            deltaZ: 0,
            // Browsers without "deltaMode" is reporting in raw wheel delta where one
            // notch on the scroll is always +/- 120, roughly equivalent to pixels.
            // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
            // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
            deltaMode: 0
          });
          var SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface);
          var END_KEYCODES = [9, 13, 27, 32];
          var START_KEYCODE = 229;
          var canUseCompositionEvent = canUseDOM && "CompositionEvent" in window;
          var documentMode = null;
          if (canUseDOM && "documentMode" in document) {
            documentMode = document.documentMode;
          }
          var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode;
          var useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
          var SPACEBAR_CODE = 32;
          var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
          function registerEvents() {
            registerTwoPhaseEvent("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
            registerTwoPhaseEvent("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
            registerTwoPhaseEvent("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
            registerTwoPhaseEvent("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
          }
          var hasSpaceKeypress = false;
          function isKeypressCommand(nativeEvent) {
            return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.
            !(nativeEvent.ctrlKey && nativeEvent.altKey);
          }
          function getCompositionEventType(domEventName) {
            switch (domEventName) {
              case "compositionstart":
                return "onCompositionStart";
              case "compositionend":
                return "onCompositionEnd";
              case "compositionupdate":
                return "onCompositionUpdate";
            }
          }
          function isFallbackCompositionStart(domEventName, nativeEvent) {
            return domEventName === "keydown" && nativeEvent.keyCode === START_KEYCODE;
          }
          function isFallbackCompositionEnd(domEventName, nativeEvent) {
            switch (domEventName) {
              case "keyup":
                return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
              case "keydown":
                return nativeEvent.keyCode !== START_KEYCODE;
              case "keypress":
              case "mousedown":
              case "focusout":
                return true;
              default:
                return false;
            }
          }
          function getDataFromCustomEvent(nativeEvent) {
            var detail = nativeEvent.detail;
            if (typeof detail === "object" && "data" in detail) {
              return detail.data;
            }
            return null;
          }
          function isUsingKoreanIME(nativeEvent) {
            return nativeEvent.locale === "ko";
          }
          var isComposing = false;
          function extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
            var eventType;
            var fallbackData;
            if (canUseCompositionEvent) {
              eventType = getCompositionEventType(domEventName);
            } else if (!isComposing) {
              if (isFallbackCompositionStart(domEventName, nativeEvent)) {
                eventType = "onCompositionStart";
              }
            } else if (isFallbackCompositionEnd(domEventName, nativeEvent)) {
              eventType = "onCompositionEnd";
            }
            if (!eventType) {
              return null;
            }
            if (useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)) {
              if (!isComposing && eventType === "onCompositionStart") {
                isComposing = initialize(nativeEventTarget);
              } else if (eventType === "onCompositionEnd") {
                if (isComposing) {
                  fallbackData = getData2();
                }
              }
            }
            var listeners = accumulateTwoPhaseListeners(targetInst, eventType);
            if (listeners.length > 0) {
              var event = new SyntheticCompositionEvent(eventType, domEventName, null, nativeEvent, nativeEventTarget);
              dispatchQueue.push({
                event,
                listeners
              });
              if (fallbackData) {
                event.data = fallbackData;
              } else {
                var customData = getDataFromCustomEvent(nativeEvent);
                if (customData !== null) {
                  event.data = customData;
                }
              }
            }
          }
          function getNativeBeforeInputChars(domEventName, nativeEvent) {
            switch (domEventName) {
              case "compositionend":
                return getDataFromCustomEvent(nativeEvent);
              case "keypress":
                var which = nativeEvent.which;
                if (which !== SPACEBAR_CODE) {
                  return null;
                }
                hasSpaceKeypress = true;
                return SPACEBAR_CHAR;
              case "textInput":
                var chars = nativeEvent.data;
                if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
                  return null;
                }
                return chars;
              default:
                return null;
            }
          }
          function getFallbackBeforeInputChars(domEventName, nativeEvent) {
            if (isComposing) {
              if (domEventName === "compositionend" || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent)) {
                var chars = getData2();
                reset2();
                isComposing = false;
                return chars;
              }
              return null;
            }
            switch (domEventName) {
              case "paste":
                return null;
              case "keypress":
                if (!isKeypressCommand(nativeEvent)) {
                  if (nativeEvent.char && nativeEvent.char.length > 1) {
                    return nativeEvent.char;
                  } else if (nativeEvent.which) {
                    return String.fromCharCode(nativeEvent.which);
                  }
                }
                return null;
              case "compositionend":
                return useFallbackCompositionData && !isUsingKoreanIME(nativeEvent) ? null : nativeEvent.data;
              default:
                return null;
            }
          }
          function extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
            var chars;
            if (canUseTextInputEvent) {
              chars = getNativeBeforeInputChars(domEventName, nativeEvent);
            } else {
              chars = getFallbackBeforeInputChars(domEventName, nativeEvent);
            }
            if (!chars) {
              return null;
            }
            var listeners = accumulateTwoPhaseListeners(targetInst, "onBeforeInput");
            if (listeners.length > 0) {
              var event = new SyntheticInputEvent("onBeforeInput", "beforeinput", null, nativeEvent, nativeEventTarget);
              dispatchQueue.push({
                event,
                listeners
              });
              event.data = chars;
            }
          }
          function extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
            extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
          }
          var supportedInputTypes = {
            color: true,
            date: true,
            datetime: true,
            "datetime-local": true,
            email: true,
            month: true,
            number: true,
            password: true,
            range: true,
            search: true,
            tel: true,
            text: true,
            time: true,
            url: true,
            week: true
          };
          function isTextInputElement(elem) {
            var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
            if (nodeName === "input") {
              return !!supportedInputTypes[elem.type];
            }
            if (nodeName === "textarea") {
              return true;
            }
            return false;
          }
          function isEventSupported(eventNameSuffix) {
            if (!canUseDOM) {
              return false;
            }
            var eventName = "on" + eventNameSuffix;
            var isSupported = eventName in document;
            if (!isSupported) {
              var element = document.createElement("div");
              element.setAttribute(eventName, "return;");
              isSupported = typeof element[eventName] === "function";
            }
            return isSupported;
          }
          function registerEvents$1() {
            registerTwoPhaseEvent("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
          }
          function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
            enqueueStateRestore(target);
            var listeners = accumulateTwoPhaseListeners(inst, "onChange");
            if (listeners.length > 0) {
              var event = new SyntheticEvent("onChange", "change", null, nativeEvent, target);
              dispatchQueue.push({
                event,
                listeners
              });
            }
          }
          var activeElement = null;
          var activeElementInst = null;
          function shouldUseChangeEvent(elem) {
            var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
            return nodeName === "select" || nodeName === "input" && elem.type === "file";
          }
          function manualDispatchChangeEvent(nativeEvent) {
            var dispatchQueue = [];
            createAndAccumulateChangeEvent(dispatchQueue, activeElementInst, nativeEvent, getEventTarget(nativeEvent));
            batchedUpdates(runEventInBatch, dispatchQueue);
          }
          function runEventInBatch(dispatchQueue) {
            processDispatchQueue(dispatchQueue, 0);
          }
          function getInstIfValueChanged(targetInst) {
            var targetNode = getNodeFromInstance(targetInst);
            if (updateValueIfChanged(targetNode)) {
              return targetInst;
            }
          }
          function getTargetInstForChangeEvent(domEventName, targetInst) {
            if (domEventName === "change") {
              return targetInst;
            }
          }
          var isInputEventSupported = false;
          if (canUseDOM) {
            isInputEventSupported = isEventSupported("input") && (!document.documentMode || document.documentMode > 9);
          }
          function startWatchingForValueChange(target, targetInst) {
            activeElement = target;
            activeElementInst = targetInst;
            activeElement.attachEvent("onpropertychange", handlePropertyChange);
          }
          function stopWatchingForValueChange() {
            if (!activeElement) {
              return;
            }
            activeElement.detachEvent("onpropertychange", handlePropertyChange);
            activeElement = null;
            activeElementInst = null;
          }
          function handlePropertyChange(nativeEvent) {
            if (nativeEvent.propertyName !== "value") {
              return;
            }
            if (getInstIfValueChanged(activeElementInst)) {
              manualDispatchChangeEvent(nativeEvent);
            }
          }
          function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
            if (domEventName === "focusin") {
              stopWatchingForValueChange();
              startWatchingForValueChange(target, targetInst);
            } else if (domEventName === "focusout") {
              stopWatchingForValueChange();
            }
          }
          function getTargetInstForInputEventPolyfill(domEventName, targetInst) {
            if (domEventName === "selectionchange" || domEventName === "keyup" || domEventName === "keydown") {
              return getInstIfValueChanged(activeElementInst);
            }
          }
          function shouldUseClickEvent(elem) {
            var nodeName = elem.nodeName;
            return nodeName && nodeName.toLowerCase() === "input" && (elem.type === "checkbox" || elem.type === "radio");
          }
          function getTargetInstForClickEvent(domEventName, targetInst) {
            if (domEventName === "click") {
              return getInstIfValueChanged(targetInst);
            }
          }
          function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
            if (domEventName === "input" || domEventName === "change") {
              return getInstIfValueChanged(targetInst);
            }
          }
          function handleControlledInputBlur(node) {
            var state = node._wrapperState;
            if (!state || !state.controlled || node.type !== "number") {
              return;
            }
            {
              setDefaultValue(node, "number", node.value);
            }
          }
          function extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
            var getTargetInstFunc, handleEventFunc;
            if (shouldUseChangeEvent(targetNode)) {
              getTargetInstFunc = getTargetInstForChangeEvent;
            } else if (isTextInputElement(targetNode)) {
              if (isInputEventSupported) {
                getTargetInstFunc = getTargetInstForInputOrChangeEvent;
              } else {
                getTargetInstFunc = getTargetInstForInputEventPolyfill;
                handleEventFunc = handleEventsForInputEventPolyfill;
              }
            } else if (shouldUseClickEvent(targetNode)) {
              getTargetInstFunc = getTargetInstForClickEvent;
            }
            if (getTargetInstFunc) {
              var inst = getTargetInstFunc(domEventName, targetInst);
              if (inst) {
                createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, nativeEventTarget);
                return;
              }
            }
            if (handleEventFunc) {
              handleEventFunc(domEventName, targetNode, targetInst);
            }
            if (domEventName === "focusout") {
              handleControlledInputBlur(targetNode);
            }
          }
          function registerEvents$2() {
            registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
            registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
            registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
            registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
          }
          function extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            var isOverEvent = domEventName === "mouseover" || domEventName === "pointerover";
            var isOutEvent = domEventName === "mouseout" || domEventName === "pointerout";
            if (isOverEvent && !isReplayingEvent(nativeEvent)) {
              var related = nativeEvent.relatedTarget || nativeEvent.fromElement;
              if (related) {
                if (getClosestInstanceFromNode(related) || isContainerMarkedAsRoot(related)) {
                  return;
                }
              }
            }
            if (!isOutEvent && !isOverEvent) {
              return;
            }
            var win;
            if (nativeEventTarget.window === nativeEventTarget) {
              win = nativeEventTarget;
            } else {
              var doc = nativeEventTarget.ownerDocument;
              if (doc) {
                win = doc.defaultView || doc.parentWindow;
              } else {
                win = window;
              }
            }
            var from3;
            var to3;
            if (isOutEvent) {
              var _related = nativeEvent.relatedTarget || nativeEvent.toElement;
              from3 = targetInst;
              to3 = _related ? getClosestInstanceFromNode(_related) : null;
              if (to3 !== null) {
                var nearestMounted = getNearestMountedFiber(to3);
                if (to3 !== nearestMounted || to3.tag !== HostComponent && to3.tag !== HostText) {
                  to3 = null;
                }
              }
            } else {
              from3 = null;
              to3 = targetInst;
            }
            if (from3 === to3) {
              return;
            }
            var SyntheticEventCtor = SyntheticMouseEvent;
            var leaveEventType = "onMouseLeave";
            var enterEventType = "onMouseEnter";
            var eventTypePrefix = "mouse";
            if (domEventName === "pointerout" || domEventName === "pointerover") {
              SyntheticEventCtor = SyntheticPointerEvent;
              leaveEventType = "onPointerLeave";
              enterEventType = "onPointerEnter";
              eventTypePrefix = "pointer";
            }
            var fromNode = from3 == null ? win : getNodeFromInstance(from3);
            var toNode = to3 == null ? win : getNodeFromInstance(to3);
            var leave = new SyntheticEventCtor(leaveEventType, eventTypePrefix + "leave", from3, nativeEvent, nativeEventTarget);
            leave.target = fromNode;
            leave.relatedTarget = toNode;
            var enter = null;
            var nativeTargetInst = getClosestInstanceFromNode(nativeEventTarget);
            if (nativeTargetInst === targetInst) {
              var enterEvent = new SyntheticEventCtor(enterEventType, eventTypePrefix + "enter", to3, nativeEvent, nativeEventTarget);
              enterEvent.target = toNode;
              enterEvent.relatedTarget = fromNode;
              enter = enterEvent;
            }
            accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leave, enter, from3, to3);
          }
          function is2(x4, y11) {
            return x4 === y11 && (x4 !== 0 || 1 / x4 === 1 / y11) || x4 !== x4 && y11 !== y11;
          }
          var objectIs = typeof Object.is === "function" ? Object.is : is2;
          function shallowEqual(objA, objB) {
            if (objectIs(objA, objB)) {
              return true;
            }
            if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
              return false;
            }
            var keysA = Object.keys(objA);
            var keysB = Object.keys(objB);
            if (keysA.length !== keysB.length) {
              return false;
            }
            for (var i7 = 0; i7 < keysA.length; i7++) {
              var currentKey = keysA[i7];
              if (!hasOwnProperty2.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey])) {
                return false;
              }
            }
            return true;
          }
          function getLeafNode(node) {
            while (node && node.firstChild) {
              node = node.firstChild;
            }
            return node;
          }
          function getSiblingNode(node) {
            while (node) {
              if (node.nextSibling) {
                return node.nextSibling;
              }
              node = node.parentNode;
            }
          }
          function getNodeForCharacterOffset(root3, offset) {
            var node = getLeafNode(root3);
            var nodeStart = 0;
            var nodeEnd = 0;
            while (node) {
              if (node.nodeType === TEXT_NODE) {
                nodeEnd = nodeStart + node.textContent.length;
                if (nodeStart <= offset && nodeEnd >= offset) {
                  return {
                    node,
                    offset: offset - nodeStart
                  };
                }
                nodeStart = nodeEnd;
              }
              node = getLeafNode(getSiblingNode(node));
            }
          }
          function getOffsets(outerNode) {
            var ownerDocument = outerNode.ownerDocument;
            var win = ownerDocument && ownerDocument.defaultView || window;
            var selection = win.getSelection && win.getSelection();
            if (!selection || selection.rangeCount === 0) {
              return null;
            }
            var anchorNode = selection.anchorNode, anchorOffset = selection.anchorOffset, focusNode = selection.focusNode, focusOffset = selection.focusOffset;
            try {
              anchorNode.nodeType;
              focusNode.nodeType;
            } catch (e9) {
              return null;
            }
            return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset);
          }
          function getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset) {
            var length2 = 0;
            var start = -1;
            var end = -1;
            var indexWithinAnchor = 0;
            var indexWithinFocus = 0;
            var node = outerNode;
            var parentNode = null;
            outer:
              while (true) {
                var next = null;
                while (true) {
                  if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) {
                    start = length2 + anchorOffset;
                  }
                  if (node === focusNode && (focusOffset === 0 || node.nodeType === TEXT_NODE)) {
                    end = length2 + focusOffset;
                  }
                  if (node.nodeType === TEXT_NODE) {
                    length2 += node.nodeValue.length;
                  }
                  if ((next = node.firstChild) === null) {
                    break;
                  }
                  parentNode = node;
                  node = next;
                }
                while (true) {
                  if (node === outerNode) {
                    break outer;
                  }
                  if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {
                    start = length2;
                  }
                  if (parentNode === focusNode && ++indexWithinFocus === focusOffset) {
                    end = length2;
                  }
                  if ((next = node.nextSibling) !== null) {
                    break;
                  }
                  node = parentNode;
                  parentNode = node.parentNode;
                }
                node = next;
              }
            if (start === -1 || end === -1) {
              return null;
            }
            return {
              start,
              end
            };
          }
          function setOffsets(node, offsets) {
            var doc = node.ownerDocument || document;
            var win = doc && doc.defaultView || window;
            if (!win.getSelection) {
              return;
            }
            var selection = win.getSelection();
            var length2 = node.textContent.length;
            var start = Math.min(offsets.start, length2);
            var end = offsets.end === void 0 ? start : Math.min(offsets.end, length2);
            if (!selection.extend && start > end) {
              var temp = end;
              end = start;
              start = temp;
            }
            var startMarker = getNodeForCharacterOffset(node, start);
            var endMarker = getNodeForCharacterOffset(node, end);
            if (startMarker && endMarker) {
              if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {
                return;
              }
              var range = doc.createRange();
              range.setStart(startMarker.node, startMarker.offset);
              selection.removeAllRanges();
              if (start > end) {
                selection.addRange(range);
                selection.extend(endMarker.node, endMarker.offset);
              } else {
                range.setEnd(endMarker.node, endMarker.offset);
                selection.addRange(range);
              }
            }
          }
          function isTextNode(node) {
            return node && node.nodeType === TEXT_NODE;
          }
          function containsNode(outerNode, innerNode) {
            if (!outerNode || !innerNode) {
              return false;
            } else if (outerNode === innerNode) {
              return true;
            } else if (isTextNode(outerNode)) {
              return false;
            } else if (isTextNode(innerNode)) {
              return containsNode(outerNode, innerNode.parentNode);
            } else if ("contains" in outerNode) {
              return outerNode.contains(innerNode);
            } else if (outerNode.compareDocumentPosition) {
              return !!(outerNode.compareDocumentPosition(innerNode) & 16);
            } else {
              return false;
            }
          }
          function isInDocument(node) {
            return node && node.ownerDocument && containsNode(node.ownerDocument.documentElement, node);
          }
          function isSameOriginFrame(iframe) {
            try {
              return typeof iframe.contentWindow.location.href === "string";
            } catch (err) {
              return false;
            }
          }
          function getActiveElementDeep() {
            var win = window;
            var element = getActiveElement();
            while (element instanceof win.HTMLIFrameElement) {
              if (isSameOriginFrame(element)) {
                win = element.contentWindow;
              } else {
                return element;
              }
              element = getActiveElement(win.document);
            }
            return element;
          }
          function hasSelectionCapabilities(elem) {
            var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
            return nodeName && (nodeName === "input" && (elem.type === "text" || elem.type === "search" || elem.type === "tel" || elem.type === "url" || elem.type === "password") || nodeName === "textarea" || elem.contentEditable === "true");
          }
          function getSelectionInformation() {
            var focusedElem = getActiveElementDeep();
            return {
              focusedElem,
              selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection(focusedElem) : null
            };
          }
          function restoreSelection(priorSelectionInformation) {
            var curFocusedElem = getActiveElementDeep();
            var priorFocusedElem = priorSelectionInformation.focusedElem;
            var priorSelectionRange = priorSelectionInformation.selectionRange;
            if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
              if (priorSelectionRange !== null && hasSelectionCapabilities(priorFocusedElem)) {
                setSelection(priorFocusedElem, priorSelectionRange);
              }
              var ancestors = [];
              var ancestor = priorFocusedElem;
              while (ancestor = ancestor.parentNode) {
                if (ancestor.nodeType === ELEMENT_NODE) {
                  ancestors.push({
                    element: ancestor,
                    left: ancestor.scrollLeft,
                    top: ancestor.scrollTop
                  });
                }
              }
              if (typeof priorFocusedElem.focus === "function") {
                priorFocusedElem.focus();
              }
              for (var i7 = 0; i7 < ancestors.length; i7++) {
                var info = ancestors[i7];
                info.element.scrollLeft = info.left;
                info.element.scrollTop = info.top;
              }
            }
          }
          function getSelection(input) {
            var selection;
            if ("selectionStart" in input) {
              selection = {
                start: input.selectionStart,
                end: input.selectionEnd
              };
            } else {
              selection = getOffsets(input);
            }
            return selection || {
              start: 0,
              end: 0
            };
          }
          function setSelection(input, offsets) {
            var start = offsets.start;
            var end = offsets.end;
            if (end === void 0) {
              end = start;
            }
            if ("selectionStart" in input) {
              input.selectionStart = start;
              input.selectionEnd = Math.min(end, input.value.length);
            } else {
              setOffsets(input, offsets);
            }
          }
          var skipSelectionChangeEvent = canUseDOM && "documentMode" in document && document.documentMode <= 11;
          function registerEvents$3() {
            registerTwoPhaseEvent("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
          }
          var activeElement$1 = null;
          var activeElementInst$1 = null;
          var lastSelection = null;
          var mouseDown = false;
          function getSelection$1(node) {
            if ("selectionStart" in node && hasSelectionCapabilities(node)) {
              return {
                start: node.selectionStart,
                end: node.selectionEnd
              };
            } else {
              var win = node.ownerDocument && node.ownerDocument.defaultView || window;
              var selection = win.getSelection();
              return {
                anchorNode: selection.anchorNode,
                anchorOffset: selection.anchorOffset,
                focusNode: selection.focusNode,
                focusOffset: selection.focusOffset
              };
            }
          }
          function getEventTargetDocument(eventTarget) {
            return eventTarget.window === eventTarget ? eventTarget.document : eventTarget.nodeType === DOCUMENT_NODE ? eventTarget : eventTarget.ownerDocument;
          }
          function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
            var doc = getEventTargetDocument(nativeEventTarget);
            if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement(doc)) {
              return;
            }
            var currentSelection = getSelection$1(activeElement$1);
            if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
              lastSelection = currentSelection;
              var listeners = accumulateTwoPhaseListeners(activeElementInst$1, "onSelect");
              if (listeners.length > 0) {
                var event = new SyntheticEvent("onSelect", "select", null, nativeEvent, nativeEventTarget);
                dispatchQueue.push({
                  event,
                  listeners
                });
                event.target = activeElement$1;
              }
            }
          }
          function extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
            switch (domEventName) {
              case "focusin":
                if (isTextInputElement(targetNode) || targetNode.contentEditable === "true") {
                  activeElement$1 = targetNode;
                  activeElementInst$1 = targetInst;
                  lastSelection = null;
                }
                break;
              case "focusout":
                activeElement$1 = null;
                activeElementInst$1 = null;
                lastSelection = null;
                break;
              case "mousedown":
                mouseDown = true;
                break;
              case "contextmenu":
              case "mouseup":
              case "dragend":
                mouseDown = false;
                constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
                break;
              case "selectionchange":
                if (skipSelectionChangeEvent) {
                  break;
                }
              case "keydown":
              case "keyup":
                constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
            }
          }
          function makePrefixMap(styleProp, eventName) {
            var prefixes2 = {};
            prefixes2[styleProp.toLowerCase()] = eventName.toLowerCase();
            prefixes2["Webkit" + styleProp] = "webkit" + eventName;
            prefixes2["Moz" + styleProp] = "moz" + eventName;
            return prefixes2;
          }
          var vendorPrefixes = {
            animationend: makePrefixMap("Animation", "AnimationEnd"),
            animationiteration: makePrefixMap("Animation", "AnimationIteration"),
            animationstart: makePrefixMap("Animation", "AnimationStart"),
            transitionend: makePrefixMap("Transition", "TransitionEnd")
          };
          var prefixedEventNames = {};
          var style2 = {};
          if (canUseDOM) {
            style2 = document.createElement("div").style;
            if (!("AnimationEvent" in window)) {
              delete vendorPrefixes.animationend.animation;
              delete vendorPrefixes.animationiteration.animation;
              delete vendorPrefixes.animationstart.animation;
            }
            if (!("TransitionEvent" in window)) {
              delete vendorPrefixes.transitionend.transition;
            }
          }
          function getVendorPrefixedEventName(eventName) {
            if (prefixedEventNames[eventName]) {
              return prefixedEventNames[eventName];
            } else if (!vendorPrefixes[eventName]) {
              return eventName;
            }
            var prefixMap = vendorPrefixes[eventName];
            for (var styleProp in prefixMap) {
              if (prefixMap.hasOwnProperty(styleProp) && styleProp in style2) {
                return prefixedEventNames[eventName] = prefixMap[styleProp];
              }
            }
            return eventName;
          }
          var ANIMATION_END = getVendorPrefixedEventName("animationend");
          var ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration");
          var ANIMATION_START = getVendorPrefixedEventName("animationstart");
          var TRANSITION_END = getVendorPrefixedEventName("transitionend");
          var topLevelEventsToReactNames = /* @__PURE__ */ new Map();
          var simpleEventPluginEvents = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
          function registerSimpleEvent(domEventName, reactName) {
            topLevelEventsToReactNames.set(domEventName, reactName);
            registerTwoPhaseEvent(reactName, [domEventName]);
          }
          function registerSimpleEvents() {
            for (var i7 = 0; i7 < simpleEventPluginEvents.length; i7++) {
              var eventName = simpleEventPluginEvents[i7];
              var domEventName = eventName.toLowerCase();
              var capitalizedEvent = eventName[0].toUpperCase() + eventName.slice(1);
              registerSimpleEvent(domEventName, "on" + capitalizedEvent);
            }
            registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
            registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
            registerSimpleEvent(ANIMATION_START, "onAnimationStart");
            registerSimpleEvent("dblclick", "onDoubleClick");
            registerSimpleEvent("focusin", "onFocus");
            registerSimpleEvent("focusout", "onBlur");
            registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
          }
          function extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            var reactName = topLevelEventsToReactNames.get(domEventName);
            if (reactName === void 0) {
              return;
            }
            var SyntheticEventCtor = SyntheticEvent;
            var reactEventType = domEventName;
            switch (domEventName) {
              case "keypress":
                if (getEventCharCode(nativeEvent) === 0) {
                  return;
                }
              case "keydown":
              case "keyup":
                SyntheticEventCtor = SyntheticKeyboardEvent;
                break;
              case "focusin":
                reactEventType = "focus";
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "focusout":
                reactEventType = "blur";
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "beforeblur":
              case "afterblur":
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "click":
                if (nativeEvent.button === 2) {
                  return;
                }
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                SyntheticEventCtor = SyntheticMouseEvent;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                SyntheticEventCtor = SyntheticDragEvent;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                SyntheticEventCtor = SyntheticTouchEvent;
                break;
              case ANIMATION_END:
              case ANIMATION_ITERATION:
              case ANIMATION_START:
                SyntheticEventCtor = SyntheticAnimationEvent;
                break;
              case TRANSITION_END:
                SyntheticEventCtor = SyntheticTransitionEvent;
                break;
              case "scroll":
                SyntheticEventCtor = SyntheticUIEvent;
                break;
              case "wheel":
                SyntheticEventCtor = SyntheticWheelEvent;
                break;
              case "copy":
              case "cut":
              case "paste":
                SyntheticEventCtor = SyntheticClipboardEvent;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                SyntheticEventCtor = SyntheticPointerEvent;
                break;
            }
            var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
            {
              var accumulateTargetOnly = !inCapturePhase && // TODO: ideally, we'd eventually add all events from
              // nonDelegatedEvents list in DOMPluginEventSystem.
              // Then we can remove this special list.
              // This is a breaking change that can wait until React 18.
              domEventName === "scroll";
              var _listeners = accumulateSinglePhaseListeners(targetInst, reactName, nativeEvent.type, inCapturePhase, accumulateTargetOnly);
              if (_listeners.length > 0) {
                var _event = new SyntheticEventCtor(reactName, reactEventType, null, nativeEvent, nativeEventTarget);
                dispatchQueue.push({
                  event: _event,
                  listeners: _listeners
                });
              }
            }
          }
          registerSimpleEvents();
          registerEvents$2();
          registerEvents$1();
          registerEvents$3();
          registerEvents();
          function extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
            var shouldProcessPolyfillPlugins = (eventSystemFlags & SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS) === 0;
            if (shouldProcessPolyfillPlugins) {
              extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
              extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
              extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
              extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
            }
          }
          var mediaEventTypes = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"];
          var nonDelegatedEvents = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(mediaEventTypes));
          function executeDispatch(event, listener, currentTarget) {
            var type = event.type || "unknown-event";
            event.currentTarget = currentTarget;
            invokeGuardedCallbackAndCatchFirstError(type, listener, void 0, event);
            event.currentTarget = null;
          }
          function processDispatchQueueItemsInOrder(event, dispatchListeners, inCapturePhase) {
            var previousInstance;
            if (inCapturePhase) {
              for (var i7 = dispatchListeners.length - 1; i7 >= 0; i7--) {
                var _dispatchListeners$i = dispatchListeners[i7], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget, listener = _dispatchListeners$i.listener;
                if (instance !== previousInstance && event.isPropagationStopped()) {
                  return;
                }
                executeDispatch(event, listener, currentTarget);
                previousInstance = instance;
              }
            } else {
              for (var _i = 0; _i < dispatchListeners.length; _i++) {
                var _dispatchListeners$_i = dispatchListeners[_i], _instance = _dispatchListeners$_i.instance, _currentTarget = _dispatchListeners$_i.currentTarget, _listener = _dispatchListeners$_i.listener;
                if (_instance !== previousInstance && event.isPropagationStopped()) {
                  return;
                }
                executeDispatch(event, _listener, _currentTarget);
                previousInstance = _instance;
              }
            }
          }
          function processDispatchQueue(dispatchQueue, eventSystemFlags) {
            var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
            for (var i7 = 0; i7 < dispatchQueue.length; i7++) {
              var _dispatchQueue$i = dispatchQueue[i7], event = _dispatchQueue$i.event, listeners = _dispatchQueue$i.listeners;
              processDispatchQueueItemsInOrder(event, listeners, inCapturePhase);
            }
            rethrowCaughtError();
          }
          function dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
            var nativeEventTarget = getEventTarget(nativeEvent);
            var dispatchQueue = [];
            extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
            processDispatchQueue(dispatchQueue, eventSystemFlags);
          }
          function listenToNonDelegatedEvent(domEventName, targetElement) {
            {
              if (!nonDelegatedEvents.has(domEventName)) {
                error('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', domEventName);
              }
            }
            var isCapturePhaseListener = false;
            var listenerSet = getEventListenerSet(targetElement);
            var listenerSetKey = getListenerSetKey(domEventName, isCapturePhaseListener);
            if (!listenerSet.has(listenerSetKey)) {
              addTrappedEventListener(targetElement, domEventName, IS_NON_DELEGATED, isCapturePhaseListener);
              listenerSet.add(listenerSetKey);
            }
          }
          function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
            {
              if (nonDelegatedEvents.has(domEventName) && !isCapturePhaseListener) {
                error('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', domEventName);
              }
            }
            var eventSystemFlags = 0;
            if (isCapturePhaseListener) {
              eventSystemFlags |= IS_CAPTURE_PHASE;
            }
            addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);
          }
          var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
          function listenToAllSupportedEvents(rootContainerElement) {
            if (!rootContainerElement[listeningMarker]) {
              rootContainerElement[listeningMarker] = true;
              allNativeEvents.forEach(function(domEventName) {
                if (domEventName !== "selectionchange") {
                  if (!nonDelegatedEvents.has(domEventName)) {
                    listenToNativeEvent(domEventName, false, rootContainerElement);
                  }
                  listenToNativeEvent(domEventName, true, rootContainerElement);
                }
              });
              var ownerDocument = rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
              if (ownerDocument !== null) {
                if (!ownerDocument[listeningMarker]) {
                  ownerDocument[listeningMarker] = true;
                  listenToNativeEvent("selectionchange", false, ownerDocument);
                }
              }
            }
          }
          function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener, isDeferredListenerForLegacyFBSupport) {
            var listener = createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags);
            var isPassiveListener = void 0;
            if (passiveBrowserEventsSupported) {
              if (domEventName === "touchstart" || domEventName === "touchmove" || domEventName === "wheel") {
                isPassiveListener = true;
              }
            }
            targetContainer = targetContainer;
            var unsubscribeListener;
            if (isCapturePhaseListener) {
              if (isPassiveListener !== void 0) {
                unsubscribeListener = addEventCaptureListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
              } else {
                unsubscribeListener = addEventCaptureListener(targetContainer, domEventName, listener);
              }
            } else {
              if (isPassiveListener !== void 0) {
                unsubscribeListener = addEventBubbleListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
              } else {
                unsubscribeListener = addEventBubbleListener(targetContainer, domEventName, listener);
              }
            }
          }
          function isMatchingRootContainer(grandContainer, targetContainer) {
            return grandContainer === targetContainer || grandContainer.nodeType === COMMENT_NODE && grandContainer.parentNode === targetContainer;
          }
          function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
            var ancestorInst = targetInst;
            if ((eventSystemFlags & IS_EVENT_HANDLE_NON_MANAGED_NODE) === 0 && (eventSystemFlags & IS_NON_DELEGATED) === 0) {
              var targetContainerNode = targetContainer;
              if (targetInst !== null) {
                var node = targetInst;
                mainLoop:
                  while (true) {
                    if (node === null) {
                      return;
                    }
                    var nodeTag = node.tag;
                    if (nodeTag === HostRoot || nodeTag === HostPortal) {
                      var container = node.stateNode.containerInfo;
                      if (isMatchingRootContainer(container, targetContainerNode)) {
                        break;
                      }
                      if (nodeTag === HostPortal) {
                        var grandNode = node.return;
                        while (grandNode !== null) {
                          var grandTag = grandNode.tag;
                          if (grandTag === HostRoot || grandTag === HostPortal) {
                            var grandContainer = grandNode.stateNode.containerInfo;
                            if (isMatchingRootContainer(grandContainer, targetContainerNode)) {
                              return;
                            }
                          }
                          grandNode = grandNode.return;
                        }
                      }
                      while (container !== null) {
                        var parentNode = getClosestInstanceFromNode(container);
                        if (parentNode === null) {
                          return;
                        }
                        var parentTag = parentNode.tag;
                        if (parentTag === HostComponent || parentTag === HostText) {
                          node = ancestorInst = parentNode;
                          continue mainLoop;
                        }
                        container = container.parentNode;
                      }
                    }
                    node = node.return;
                  }
              }
            }
            batchedUpdates(function() {
              return dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, ancestorInst);
            });
          }
          function createDispatchListener(instance, listener, currentTarget) {
            return {
              instance,
              listener,
              currentTarget
            };
          }
          function accumulateSinglePhaseListeners(targetFiber, reactName, nativeEventType, inCapturePhase, accumulateTargetOnly, nativeEvent) {
            var captureName = reactName !== null ? reactName + "Capture" : null;
            var reactEventName = inCapturePhase ? captureName : reactName;
            var listeners = [];
            var instance = targetFiber;
            var lastHostComponent = null;
            while (instance !== null) {
              var _instance2 = instance, stateNode = _instance2.stateNode, tag = _instance2.tag;
              if (tag === HostComponent && stateNode !== null) {
                lastHostComponent = stateNode;
                if (reactEventName !== null) {
                  var listener = getListener(instance, reactEventName);
                  if (listener != null) {
                    listeners.push(createDispatchListener(instance, listener, lastHostComponent));
                  }
                }
              }
              if (accumulateTargetOnly) {
                break;
              }
              instance = instance.return;
            }
            return listeners;
          }
          function accumulateTwoPhaseListeners(targetFiber, reactName) {
            var captureName = reactName + "Capture";
            var listeners = [];
            var instance = targetFiber;
            while (instance !== null) {
              var _instance3 = instance, stateNode = _instance3.stateNode, tag = _instance3.tag;
              if (tag === HostComponent && stateNode !== null) {
                var currentTarget = stateNode;
                var captureListener = getListener(instance, captureName);
                if (captureListener != null) {
                  listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));
                }
                var bubbleListener = getListener(instance, reactName);
                if (bubbleListener != null) {
                  listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));
                }
              }
              instance = instance.return;
            }
            return listeners;
          }
          function getParent(inst) {
            if (inst === null) {
              return null;
            }
            do {
              inst = inst.return;
            } while (inst && inst.tag !== HostComponent);
            if (inst) {
              return inst;
            }
            return null;
          }
          function getLowestCommonAncestor(instA, instB) {
            var nodeA = instA;
            var nodeB = instB;
            var depthA = 0;
            for (var tempA = nodeA; tempA; tempA = getParent(tempA)) {
              depthA++;
            }
            var depthB = 0;
            for (var tempB = nodeB; tempB; tempB = getParent(tempB)) {
              depthB++;
            }
            while (depthA - depthB > 0) {
              nodeA = getParent(nodeA);
              depthA--;
            }
            while (depthB - depthA > 0) {
              nodeB = getParent(nodeB);
              depthB--;
            }
            var depth = depthA;
            while (depth--) {
              if (nodeA === nodeB || nodeB !== null && nodeA === nodeB.alternate) {
                return nodeA;
              }
              nodeA = getParent(nodeA);
              nodeB = getParent(nodeB);
            }
            return null;
          }
          function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
            var registrationName = event._reactName;
            var listeners = [];
            var instance = target;
            while (instance !== null) {
              if (instance === common) {
                break;
              }
              var _instance4 = instance, alternate = _instance4.alternate, stateNode = _instance4.stateNode, tag = _instance4.tag;
              if (alternate !== null && alternate === common) {
                break;
              }
              if (tag === HostComponent && stateNode !== null) {
                var currentTarget = stateNode;
                if (inCapturePhase) {
                  var captureListener = getListener(instance, registrationName);
                  if (captureListener != null) {
                    listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));
                  }
                } else if (!inCapturePhase) {
                  var bubbleListener = getListener(instance, registrationName);
                  if (bubbleListener != null) {
                    listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));
                  }
                }
              }
              instance = instance.return;
            }
            if (listeners.length !== 0) {
              dispatchQueue.push({
                event,
                listeners
              });
            }
          }
          function accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leaveEvent, enterEvent, from3, to3) {
            var common = from3 && to3 ? getLowestCommonAncestor(from3, to3) : null;
            if (from3 !== null) {
              accumulateEnterLeaveListenersForEvent(dispatchQueue, leaveEvent, from3, common, false);
            }
            if (to3 !== null && enterEvent !== null) {
              accumulateEnterLeaveListenersForEvent(dispatchQueue, enterEvent, to3, common, true);
            }
          }
          function getListenerSetKey(domEventName, capture) {
            return domEventName + "__" + (capture ? "capture" : "bubble");
          }
          var didWarnInvalidHydration = false;
          var DANGEROUSLY_SET_INNER_HTML = "dangerouslySetInnerHTML";
          var SUPPRESS_CONTENT_EDITABLE_WARNING = "suppressContentEditableWarning";
          var SUPPRESS_HYDRATION_WARNING = "suppressHydrationWarning";
          var AUTOFOCUS = "autoFocus";
          var CHILDREN = "children";
          var STYLE = "style";
          var HTML$1 = "__html";
          var warnedUnknownTags;
          var validatePropertiesInDevelopment;
          var warnForPropDifference;
          var warnForExtraAttributes;
          var warnForInvalidEventListener;
          var canDiffStyleForHydrationWarning;
          var normalizeHTML;
          {
            warnedUnknownTags = {
              // There are working polyfills for <dialog>. Let people use it.
              dialog: true,
              // Electron ships a custom <webview> tag to display external web content in
              // an isolated frame and process.
              // This tag is not present in non Electron environments such as JSDom which
              // is often used for testing purposes.
              // @see https://electronjs.org/docs/api/webview-tag
              webview: true
            };
            validatePropertiesInDevelopment = function(type, props) {
              validateProperties(type, props);
              validateProperties$1(type, props);
              validateProperties$2(type, props, {
                registrationNameDependencies,
                possibleRegistrationNames
              });
            };
            canDiffStyleForHydrationWarning = canUseDOM && !document.documentMode;
            warnForPropDifference = function(propName, serverValue, clientValue) {
              if (didWarnInvalidHydration) {
                return;
              }
              var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);
              var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);
              if (normalizedServerValue === normalizedClientValue) {
                return;
              }
              didWarnInvalidHydration = true;
              error("Prop `%s` did not match. Server: %s Client: %s", propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));
            };
            warnForExtraAttributes = function(attributeNames) {
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              var names2 = [];
              attributeNames.forEach(function(name2) {
                names2.push(name2);
              });
              error("Extra attributes from the server: %s", names2);
            };
            warnForInvalidEventListener = function(registrationName, listener) {
              if (listener === false) {
                error("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", registrationName, registrationName, registrationName);
              } else {
                error("Expected `%s` listener to be a function, instead got a value of `%s` type.", registrationName, typeof listener);
              }
            };
            normalizeHTML = function(parent, html) {
              var testElement = parent.namespaceURI === HTML_NAMESPACE ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);
              testElement.innerHTML = html;
              return testElement.innerHTML;
            };
          }
          var NORMALIZE_NEWLINES_REGEX = /\r\n?/g;
          var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
          function normalizeMarkupForTextOrAttribute(markup) {
            {
              checkHtmlStringCoercion(markup);
            }
            var markupString = typeof markup === "string" ? markup : "" + markup;
            return markupString.replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
          }
          function checkForUnmatchedText(serverText, clientText, isConcurrentMode, shouldWarnDev) {
            var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);
            var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);
            if (normalizedServerText === normalizedClientText) {
              return;
            }
            if (shouldWarnDev) {
              {
                if (!didWarnInvalidHydration) {
                  didWarnInvalidHydration = true;
                  error('Text content did not match. Server: "%s" Client: "%s"', normalizedServerText, normalizedClientText);
                }
              }
            }
            if (isConcurrentMode && enableClientRenderFallbackOnTextMismatch) {
              throw new Error("Text content does not match server-rendered HTML.");
            }
          }
          function getOwnerDocumentFromRootContainer(rootContainerElement) {
            return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
          }
          function noop6() {
          }
          function trapClickOnNonInteractiveElement(node) {
            node.onclick = noop6;
          }
          function setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {
            for (var propKey in nextProps) {
              if (!nextProps.hasOwnProperty(propKey)) {
                continue;
              }
              var nextProp = nextProps[propKey];
              if (propKey === STYLE) {
                {
                  if (nextProp) {
                    Object.freeze(nextProp);
                  }
                }
                setValueForStyles(domElement, nextProp);
              } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
                if (nextHtml != null) {
                  setInnerHTML(domElement, nextHtml);
                }
              } else if (propKey === CHILDREN) {
                if (typeof nextProp === "string") {
                  var canSetTextContent = tag !== "textarea" || nextProp !== "";
                  if (canSetTextContent) {
                    setTextContent(domElement, nextProp);
                  }
                } else if (typeof nextProp === "number") {
                  setTextContent(domElement, "" + nextProp);
                }
              } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)
                ;
              else if (propKey === AUTOFOCUS)
                ;
              else if (registrationNameDependencies.hasOwnProperty(propKey)) {
                if (nextProp != null) {
                  if (typeof nextProp !== "function") {
                    warnForInvalidEventListener(propKey, nextProp);
                  }
                  if (propKey === "onScroll") {
                    listenToNonDelegatedEvent("scroll", domElement);
                  }
                }
              } else if (nextProp != null) {
                setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag);
              }
            }
          }
          function updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {
            for (var i7 = 0; i7 < updatePayload.length; i7 += 2) {
              var propKey = updatePayload[i7];
              var propValue = updatePayload[i7 + 1];
              if (propKey === STYLE) {
                setValueForStyles(domElement, propValue);
              } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                setInnerHTML(domElement, propValue);
              } else if (propKey === CHILDREN) {
                setTextContent(domElement, propValue);
              } else {
                setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);
              }
            }
          }
          function createElement3(type, props, rootContainerElement, parentNamespace) {
            var isCustomComponentTag;
            var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);
            var domElement;
            var namespaceURI = parentNamespace;
            if (namespaceURI === HTML_NAMESPACE) {
              namespaceURI = getIntrinsicNamespace(type);
            }
            if (namespaceURI === HTML_NAMESPACE) {
              {
                isCustomComponentTag = isCustomComponent(type, props);
                if (!isCustomComponentTag && type !== type.toLowerCase()) {
                  error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type);
                }
              }
              if (type === "script") {
                var div = ownerDocument.createElement("div");
                div.innerHTML = "<script><\/script>";
                var firstChild = div.firstChild;
                domElement = div.removeChild(firstChild);
              } else if (typeof props.is === "string") {
                domElement = ownerDocument.createElement(type, {
                  is: props.is
                });
              } else {
                domElement = ownerDocument.createElement(type);
                if (type === "select") {
                  var node = domElement;
                  if (props.multiple) {
                    node.multiple = true;
                  } else if (props.size) {
                    node.size = props.size;
                  }
                }
              }
            } else {
              domElement = ownerDocument.createElementNS(namespaceURI, type);
            }
            {
              if (namespaceURI === HTML_NAMESPACE) {
                if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === "[object HTMLUnknownElement]" && !hasOwnProperty2.call(warnedUnknownTags, type)) {
                  warnedUnknownTags[type] = true;
                  error("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", type);
                }
              }
            }
            return domElement;
          }
          function createTextNode(text, rootContainerElement) {
            return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);
          }
          function setInitialProperties(domElement, tag, rawProps, rootContainerElement) {
            var isCustomComponentTag = isCustomComponent(tag, rawProps);
            {
              validatePropertiesInDevelopment(tag, rawProps);
            }
            var props;
            switch (tag) {
              case "dialog":
                listenToNonDelegatedEvent("cancel", domElement);
                listenToNonDelegatedEvent("close", domElement);
                props = rawProps;
                break;
              case "iframe":
              case "object":
              case "embed":
                listenToNonDelegatedEvent("load", domElement);
                props = rawProps;
                break;
              case "video":
              case "audio":
                for (var i7 = 0; i7 < mediaEventTypes.length; i7++) {
                  listenToNonDelegatedEvent(mediaEventTypes[i7], domElement);
                }
                props = rawProps;
                break;
              case "source":
                listenToNonDelegatedEvent("error", domElement);
                props = rawProps;
                break;
              case "img":
              case "image":
              case "link":
                listenToNonDelegatedEvent("error", domElement);
                listenToNonDelegatedEvent("load", domElement);
                props = rawProps;
                break;
              case "details":
                listenToNonDelegatedEvent("toggle", domElement);
                props = rawProps;
                break;
              case "input":
                initWrapperState(domElement, rawProps);
                props = getHostProps(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
              case "option":
                validateProps(domElement, rawProps);
                props = rawProps;
                break;
              case "select":
                initWrapperState$1(domElement, rawProps);
                props = getHostProps$1(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
              case "textarea":
                initWrapperState$2(domElement, rawProps);
                props = getHostProps$2(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
              default:
                props = rawProps;
            }
            assertValidProps(tag, props);
            setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);
            switch (tag) {
              case "input":
                track(domElement);
                postMountWrapper(domElement, rawProps, false);
                break;
              case "textarea":
                track(domElement);
                postMountWrapper$3(domElement);
                break;
              case "option":
                postMountWrapper$1(domElement, rawProps);
                break;
              case "select":
                postMountWrapper$2(domElement, rawProps);
                break;
              default:
                if (typeof props.onClick === "function") {
                  trapClickOnNonInteractiveElement(domElement);
                }
                break;
            }
          }
          function diffProperties(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {
            {
              validatePropertiesInDevelopment(tag, nextRawProps);
            }
            var updatePayload = null;
            var lastProps;
            var nextProps;
            switch (tag) {
              case "input":
                lastProps = getHostProps(domElement, lastRawProps);
                nextProps = getHostProps(domElement, nextRawProps);
                updatePayload = [];
                break;
              case "select":
                lastProps = getHostProps$1(domElement, lastRawProps);
                nextProps = getHostProps$1(domElement, nextRawProps);
                updatePayload = [];
                break;
              case "textarea":
                lastProps = getHostProps$2(domElement, lastRawProps);
                nextProps = getHostProps$2(domElement, nextRawProps);
                updatePayload = [];
                break;
              default:
                lastProps = lastRawProps;
                nextProps = nextRawProps;
                if (typeof lastProps.onClick !== "function" && typeof nextProps.onClick === "function") {
                  trapClickOnNonInteractiveElement(domElement);
                }
                break;
            }
            assertValidProps(tag, nextProps);
            var propKey;
            var styleName;
            var styleUpdates = null;
            for (propKey in lastProps) {
              if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
                continue;
              }
              if (propKey === STYLE) {
                var lastStyle = lastProps[propKey];
                for (styleName in lastStyle) {
                  if (lastStyle.hasOwnProperty(styleName)) {
                    if (!styleUpdates) {
                      styleUpdates = {};
                    }
                    styleUpdates[styleName] = "";
                  }
                }
              } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN)
                ;
              else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)
                ;
              else if (propKey === AUTOFOCUS)
                ;
              else if (registrationNameDependencies.hasOwnProperty(propKey)) {
                if (!updatePayload) {
                  updatePayload = [];
                }
              } else {
                (updatePayload = updatePayload || []).push(propKey, null);
              }
            }
            for (propKey in nextProps) {
              var nextProp = nextProps[propKey];
              var lastProp = lastProps != null ? lastProps[propKey] : void 0;
              if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
                continue;
              }
              if (propKey === STYLE) {
                {
                  if (nextProp) {
                    Object.freeze(nextProp);
                  }
                }
                if (lastProp) {
                  for (styleName in lastProp) {
                    if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
                      if (!styleUpdates) {
                        styleUpdates = {};
                      }
                      styleUpdates[styleName] = "";
                    }
                  }
                  for (styleName in nextProp) {
                    if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
                      if (!styleUpdates) {
                        styleUpdates = {};
                      }
                      styleUpdates[styleName] = nextProp[styleName];
                    }
                  }
                } else {
                  if (!styleUpdates) {
                    if (!updatePayload) {
                      updatePayload = [];
                    }
                    updatePayload.push(propKey, styleUpdates);
                  }
                  styleUpdates = nextProp;
                }
              } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
                var lastHtml = lastProp ? lastProp[HTML$1] : void 0;
                if (nextHtml != null) {
                  if (lastHtml !== nextHtml) {
                    (updatePayload = updatePayload || []).push(propKey, nextHtml);
                  }
                }
              } else if (propKey === CHILDREN) {
                if (typeof nextProp === "string" || typeof nextProp === "number") {
                  (updatePayload = updatePayload || []).push(propKey, "" + nextProp);
                }
              } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)
                ;
              else if (registrationNameDependencies.hasOwnProperty(propKey)) {
                if (nextProp != null) {
                  if (typeof nextProp !== "function") {
                    warnForInvalidEventListener(propKey, nextProp);
                  }
                  if (propKey === "onScroll") {
                    listenToNonDelegatedEvent("scroll", domElement);
                  }
                }
                if (!updatePayload && lastProp !== nextProp) {
                  updatePayload = [];
                }
              } else {
                (updatePayload = updatePayload || []).push(propKey, nextProp);
              }
            }
            if (styleUpdates) {
              {
                validateShorthandPropertyCollisionInDev(styleUpdates, nextProps[STYLE]);
              }
              (updatePayload = updatePayload || []).push(STYLE, styleUpdates);
            }
            return updatePayload;
          }
          function updateProperties(domElement, updatePayload, tag, lastRawProps, nextRawProps) {
            if (tag === "input" && nextRawProps.type === "radio" && nextRawProps.name != null) {
              updateChecked(domElement, nextRawProps);
            }
            var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);
            var isCustomComponentTag = isCustomComponent(tag, nextRawProps);
            updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag);
            switch (tag) {
              case "input":
                updateWrapper(domElement, nextRawProps);
                break;
              case "textarea":
                updateWrapper$1(domElement, nextRawProps);
                break;
              case "select":
                postUpdateWrapper(domElement, nextRawProps);
                break;
            }
          }
          function getPossibleStandardName(propName) {
            {
              var lowerCasedName = propName.toLowerCase();
              if (!possibleStandardNames.hasOwnProperty(lowerCasedName)) {
                return null;
              }
              return possibleStandardNames[lowerCasedName] || null;
            }
          }
          function diffHydratedProperties(domElement, tag, rawProps, parentNamespace, rootContainerElement, isConcurrentMode, shouldWarnDev) {
            var isCustomComponentTag;
            var extraAttributeNames;
            {
              isCustomComponentTag = isCustomComponent(tag, rawProps);
              validatePropertiesInDevelopment(tag, rawProps);
            }
            switch (tag) {
              case "dialog":
                listenToNonDelegatedEvent("cancel", domElement);
                listenToNonDelegatedEvent("close", domElement);
                break;
              case "iframe":
              case "object":
              case "embed":
                listenToNonDelegatedEvent("load", domElement);
                break;
              case "video":
              case "audio":
                for (var i7 = 0; i7 < mediaEventTypes.length; i7++) {
                  listenToNonDelegatedEvent(mediaEventTypes[i7], domElement);
                }
                break;
              case "source":
                listenToNonDelegatedEvent("error", domElement);
                break;
              case "img":
              case "image":
              case "link":
                listenToNonDelegatedEvent("error", domElement);
                listenToNonDelegatedEvent("load", domElement);
                break;
              case "details":
                listenToNonDelegatedEvent("toggle", domElement);
                break;
              case "input":
                initWrapperState(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
              case "option":
                validateProps(domElement, rawProps);
                break;
              case "select":
                initWrapperState$1(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
              case "textarea":
                initWrapperState$2(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
            }
            assertValidProps(tag, rawProps);
            {
              extraAttributeNames = /* @__PURE__ */ new Set();
              var attributes = domElement.attributes;
              for (var _i = 0; _i < attributes.length; _i++) {
                var name2 = attributes[_i].name.toLowerCase();
                switch (name2) {
                  case "value":
                    break;
                  case "checked":
                    break;
                  case "selected":
                    break;
                  default:
                    extraAttributeNames.add(attributes[_i].name);
                }
              }
            }
            var updatePayload = null;
            for (var propKey in rawProps) {
              if (!rawProps.hasOwnProperty(propKey)) {
                continue;
              }
              var nextProp = rawProps[propKey];
              if (propKey === CHILDREN) {
                if (typeof nextProp === "string") {
                  if (domElement.textContent !== nextProp) {
                    if (rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {
                      checkForUnmatchedText(domElement.textContent, nextProp, isConcurrentMode, shouldWarnDev);
                    }
                    updatePayload = [CHILDREN, nextProp];
                  }
                } else if (typeof nextProp === "number") {
                  if (domElement.textContent !== "" + nextProp) {
                    if (rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {
                      checkForUnmatchedText(domElement.textContent, nextProp, isConcurrentMode, shouldWarnDev);
                    }
                    updatePayload = [CHILDREN, "" + nextProp];
                  }
                }
              } else if (registrationNameDependencies.hasOwnProperty(propKey)) {
                if (nextProp != null) {
                  if (typeof nextProp !== "function") {
                    warnForInvalidEventListener(propKey, nextProp);
                  }
                  if (propKey === "onScroll") {
                    listenToNonDelegatedEvent("scroll", domElement);
                  }
                }
              } else if (shouldWarnDev && true && // Convince Flow we've calculated it (it's DEV-only in this method.)
              typeof isCustomComponentTag === "boolean") {
                var serverValue = void 0;
                var propertyInfo = isCustomComponentTag && enableCustomElementPropertySupport ? null : getPropertyInfo(propKey);
                if (rawProps[SUPPRESS_HYDRATION_WARNING] === true)
                  ;
                else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING || // Controlled attributes are not validated
                // TODO: Only ignore them on controlled tags.
                propKey === "value" || propKey === "checked" || propKey === "selected")
                  ;
                else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                  var serverHTML = domElement.innerHTML;
                  var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
                  if (nextHtml != null) {
                    var expectedHTML = normalizeHTML(domElement, nextHtml);
                    if (expectedHTML !== serverHTML) {
                      warnForPropDifference(propKey, serverHTML, expectedHTML);
                    }
                  }
                } else if (propKey === STYLE) {
                  extraAttributeNames.delete(propKey);
                  if (canDiffStyleForHydrationWarning) {
                    var expectedStyle = createDangerousStringForStyles(nextProp);
                    serverValue = domElement.getAttribute("style");
                    if (expectedStyle !== serverValue) {
                      warnForPropDifference(propKey, serverValue, expectedStyle);
                    }
                  }
                } else if (isCustomComponentTag && !enableCustomElementPropertySupport) {
                  extraAttributeNames.delete(propKey.toLowerCase());
                  serverValue = getValueForAttribute(domElement, propKey, nextProp);
                  if (nextProp !== serverValue) {
                    warnForPropDifference(propKey, serverValue, nextProp);
                  }
                } else if (!shouldIgnoreAttribute(propKey, propertyInfo, isCustomComponentTag) && !shouldRemoveAttribute(propKey, nextProp, propertyInfo, isCustomComponentTag)) {
                  var isMismatchDueToBadCasing = false;
                  if (propertyInfo !== null) {
                    extraAttributeNames.delete(propertyInfo.attributeName);
                    serverValue = getValueForProperty(domElement, propKey, nextProp, propertyInfo);
                  } else {
                    var ownNamespace = parentNamespace;
                    if (ownNamespace === HTML_NAMESPACE) {
                      ownNamespace = getIntrinsicNamespace(tag);
                    }
                    if (ownNamespace === HTML_NAMESPACE) {
                      extraAttributeNames.delete(propKey.toLowerCase());
                    } else {
                      var standardName = getPossibleStandardName(propKey);
                      if (standardName !== null && standardName !== propKey) {
                        isMismatchDueToBadCasing = true;
                        extraAttributeNames.delete(standardName);
                      }
                      extraAttributeNames.delete(propKey);
                    }
                    serverValue = getValueForAttribute(domElement, propKey, nextProp);
                  }
                  var dontWarnCustomElement = enableCustomElementPropertySupport;
                  if (!dontWarnCustomElement && nextProp !== serverValue && !isMismatchDueToBadCasing) {
                    warnForPropDifference(propKey, serverValue, nextProp);
                  }
                }
              }
            }
            {
              if (shouldWarnDev) {
                if (
                  // $FlowFixMe - Should be inferred as not undefined.
                  extraAttributeNames.size > 0 && rawProps[SUPPRESS_HYDRATION_WARNING] !== true
                ) {
                  warnForExtraAttributes(extraAttributeNames);
                }
              }
            }
            switch (tag) {
              case "input":
                track(domElement);
                postMountWrapper(domElement, rawProps, true);
                break;
              case "textarea":
                track(domElement);
                postMountWrapper$3(domElement);
                break;
              case "select":
              case "option":
                break;
              default:
                if (typeof rawProps.onClick === "function") {
                  trapClickOnNonInteractiveElement(domElement);
                }
                break;
            }
            return updatePayload;
          }
          function diffHydratedText(textNode, text, isConcurrentMode) {
            var isDifferent = textNode.nodeValue !== text;
            return isDifferent;
          }
          function warnForDeletedHydratableElement(parentNode, child) {
            {
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              error("Did not expect server HTML to contain a <%s> in <%s>.", child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());
            }
          }
          function warnForDeletedHydratableText(parentNode, child) {
            {
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              error('Did not expect server HTML to contain the text node "%s" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());
            }
          }
          function warnForInsertedHydratedElement(parentNode, tag, props) {
            {
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              error("Expected server HTML to contain a matching <%s> in <%s>.", tag, parentNode.nodeName.toLowerCase());
            }
          }
          function warnForInsertedHydratedText(parentNode, text) {
            {
              if (text === "") {
                return;
              }
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              error('Expected server HTML to contain a matching text node for "%s" in <%s>.', text, parentNode.nodeName.toLowerCase());
            }
          }
          function restoreControlledState$3(domElement, tag, props) {
            switch (tag) {
              case "input":
                restoreControlledState(domElement, props);
                return;
              case "textarea":
                restoreControlledState$2(domElement, props);
                return;
              case "select":
                restoreControlledState$1(domElement, props);
                return;
            }
          }
          var validateDOMNesting = function() {
          };
          var updatedAncestorInfo = function() {
          };
          {
            var specialTags = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"];
            var inScopeTags = [
              "applet",
              "caption",
              "html",
              "table",
              "td",
              "th",
              "marquee",
              "object",
              "template",
              // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
              // TODO: Distinguish by namespace here -- for <title>, including it here
              // errs on the side of fewer warnings
              "foreignObject",
              "desc",
              "title"
            ];
            var buttonScopeTags = inScopeTags.concat(["button"]);
            var impliedEndTags = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"];
            var emptyAncestorInfo = {
              current: null,
              formTag: null,
              aTagInScope: null,
              buttonTagInScope: null,
              nobrTagInScope: null,
              pTagInButtonScope: null,
              listItemTagAutoclosing: null,
              dlItemTagAutoclosing: null
            };
            updatedAncestorInfo = function(oldInfo, tag) {
              var ancestorInfo = assign({}, oldInfo || emptyAncestorInfo);
              var info = {
                tag
              };
              if (inScopeTags.indexOf(tag) !== -1) {
                ancestorInfo.aTagInScope = null;
                ancestorInfo.buttonTagInScope = null;
                ancestorInfo.nobrTagInScope = null;
              }
              if (buttonScopeTags.indexOf(tag) !== -1) {
                ancestorInfo.pTagInButtonScope = null;
              }
              if (specialTags.indexOf(tag) !== -1 && tag !== "address" && tag !== "div" && tag !== "p") {
                ancestorInfo.listItemTagAutoclosing = null;
                ancestorInfo.dlItemTagAutoclosing = null;
              }
              ancestorInfo.current = info;
              if (tag === "form") {
                ancestorInfo.formTag = info;
              }
              if (tag === "a") {
                ancestorInfo.aTagInScope = info;
              }
              if (tag === "button") {
                ancestorInfo.buttonTagInScope = info;
              }
              if (tag === "nobr") {
                ancestorInfo.nobrTagInScope = info;
              }
              if (tag === "p") {
                ancestorInfo.pTagInButtonScope = info;
              }
              if (tag === "li") {
                ancestorInfo.listItemTagAutoclosing = info;
              }
              if (tag === "dd" || tag === "dt") {
                ancestorInfo.dlItemTagAutoclosing = info;
              }
              return ancestorInfo;
            };
            var isTagValidWithParent = function(tag, parentTag) {
              switch (parentTag) {
                case "select":
                  return tag === "option" || tag === "optgroup" || tag === "#text";
                case "optgroup":
                  return tag === "option" || tag === "#text";
                case "option":
                  return tag === "#text";
                case "tr":
                  return tag === "th" || tag === "td" || tag === "style" || tag === "script" || tag === "template";
                case "tbody":
                case "thead":
                case "tfoot":
                  return tag === "tr" || tag === "style" || tag === "script" || tag === "template";
                case "colgroup":
                  return tag === "col" || tag === "template";
                case "table":
                  return tag === "caption" || tag === "colgroup" || tag === "tbody" || tag === "tfoot" || tag === "thead" || tag === "style" || tag === "script" || tag === "template";
                case "head":
                  return tag === "base" || tag === "basefont" || tag === "bgsound" || tag === "link" || tag === "meta" || tag === "title" || tag === "noscript" || tag === "noframes" || tag === "style" || tag === "script" || tag === "template";
                case "html":
                  return tag === "head" || tag === "body" || tag === "frameset";
                case "frameset":
                  return tag === "frame";
                case "#document":
                  return tag === "html";
              }
              switch (tag) {
                case "h1":
                case "h2":
                case "h3":
                case "h4":
                case "h5":
                case "h6":
                  return parentTag !== "h1" && parentTag !== "h2" && parentTag !== "h3" && parentTag !== "h4" && parentTag !== "h5" && parentTag !== "h6";
                case "rp":
                case "rt":
                  return impliedEndTags.indexOf(parentTag) === -1;
                case "body":
                case "caption":
                case "col":
                case "colgroup":
                case "frameset":
                case "frame":
                case "head":
                case "html":
                case "tbody":
                case "td":
                case "tfoot":
                case "th":
                case "thead":
                case "tr":
                  return parentTag == null;
              }
              return true;
            };
            var findInvalidAncestorForTag = function(tag, ancestorInfo) {
              switch (tag) {
                case "address":
                case "article":
                case "aside":
                case "blockquote":
                case "center":
                case "details":
                case "dialog":
                case "dir":
                case "div":
                case "dl":
                case "fieldset":
                case "figcaption":
                case "figure":
                case "footer":
                case "header":
                case "hgroup":
                case "main":
                case "menu":
                case "nav":
                case "ol":
                case "p":
                case "section":
                case "summary":
                case "ul":
                case "pre":
                case "listing":
                case "table":
                case "hr":
                case "xmp":
                case "h1":
                case "h2":
                case "h3":
                case "h4":
                case "h5":
                case "h6":
                  return ancestorInfo.pTagInButtonScope;
                case "form":
                  return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
                case "li":
                  return ancestorInfo.listItemTagAutoclosing;
                case "dd":
                case "dt":
                  return ancestorInfo.dlItemTagAutoclosing;
                case "button":
                  return ancestorInfo.buttonTagInScope;
                case "a":
                  return ancestorInfo.aTagInScope;
                case "nobr":
                  return ancestorInfo.nobrTagInScope;
              }
              return null;
            };
            var didWarn$1 = {};
            validateDOMNesting = function(childTag, childText, ancestorInfo) {
              ancestorInfo = ancestorInfo || emptyAncestorInfo;
              var parentInfo = ancestorInfo.current;
              var parentTag = parentInfo && parentInfo.tag;
              if (childText != null) {
                if (childTag != null) {
                  error("validateDOMNesting: when childText is passed, childTag should be null");
                }
                childTag = "#text";
              }
              var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
              var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
              var invalidParentOrAncestor = invalidParent || invalidAncestor;
              if (!invalidParentOrAncestor) {
                return;
              }
              var ancestorTag = invalidParentOrAncestor.tag;
              var warnKey = !!invalidParent + "|" + childTag + "|" + ancestorTag;
              if (didWarn$1[warnKey]) {
                return;
              }
              didWarn$1[warnKey] = true;
              var tagDisplayName = childTag;
              var whitespaceInfo = "";
              if (childTag === "#text") {
                if (/\S/.test(childText)) {
                  tagDisplayName = "Text nodes";
                } else {
                  tagDisplayName = "Whitespace text nodes";
                  whitespaceInfo = " Make sure you don't have any extra whitespace between tags on each line of your source code.";
                }
              } else {
                tagDisplayName = "<" + childTag + ">";
              }
              if (invalidParent) {
                var info = "";
                if (ancestorTag === "table" && childTag === "tr") {
                  info += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser.";
                }
                error("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", tagDisplayName, ancestorTag, whitespaceInfo, info);
              } else {
                error("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", tagDisplayName, ancestorTag);
              }
            };
          }
          var SUPPRESS_HYDRATION_WARNING$1 = "suppressHydrationWarning";
          var SUSPENSE_START_DATA = "$";
          var SUSPENSE_END_DATA = "/$";
          var SUSPENSE_PENDING_START_DATA = "$?";
          var SUSPENSE_FALLBACK_START_DATA = "$!";
          var STYLE$1 = "style";
          var eventsEnabled = null;
          var selectionInformation = null;
          function getRootHostContext(rootContainerInstance) {
            var type;
            var namespace;
            var nodeType = rootContainerInstance.nodeType;
            switch (nodeType) {
              case DOCUMENT_NODE:
              case DOCUMENT_FRAGMENT_NODE: {
                type = nodeType === DOCUMENT_NODE ? "#document" : "#fragment";
                var root3 = rootContainerInstance.documentElement;
                namespace = root3 ? root3.namespaceURI : getChildNamespace(null, "");
                break;
              }
              default: {
                var container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;
                var ownNamespace = container.namespaceURI || null;
                type = container.tagName;
                namespace = getChildNamespace(ownNamespace, type);
                break;
              }
            }
            {
              var validatedTag = type.toLowerCase();
              var ancestorInfo = updatedAncestorInfo(null, validatedTag);
              return {
                namespace,
                ancestorInfo
              };
            }
          }
          function getChildHostContext(parentHostContext, type, rootContainerInstance) {
            {
              var parentHostContextDev = parentHostContext;
              var namespace = getChildNamespace(parentHostContextDev.namespace, type);
              var ancestorInfo = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type);
              return {
                namespace,
                ancestorInfo
              };
            }
          }
          function getPublicInstance(instance) {
            return instance;
          }
          function prepareForCommit(containerInfo) {
            eventsEnabled = isEnabled();
            selectionInformation = getSelectionInformation();
            var activeInstance = null;
            setEnabled(false);
            return activeInstance;
          }
          function resetAfterCommit(containerInfo) {
            restoreSelection(selectionInformation);
            setEnabled(eventsEnabled);
            eventsEnabled = null;
            selectionInformation = null;
          }
          function createInstance2(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
            var parentNamespace;
            {
              var hostContextDev = hostContext;
              validateDOMNesting(type, null, hostContextDev.ancestorInfo);
              if (typeof props.children === "string" || typeof props.children === "number") {
                var string2 = "" + props.children;
                var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
                validateDOMNesting(null, string2, ownAncestorInfo);
              }
              parentNamespace = hostContextDev.namespace;
            }
            var domElement = createElement3(type, props, rootContainerInstance, parentNamespace);
            precacheFiberNode(internalInstanceHandle, domElement);
            updateFiberProps(domElement, props);
            return domElement;
          }
          function appendInitialChild(parentInstance, child) {
            parentInstance.appendChild(child);
          }
          function finalizeInitialChildren(domElement, type, props, rootContainerInstance, hostContext) {
            setInitialProperties(domElement, type, props, rootContainerInstance);
            switch (type) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                return !!props.autoFocus;
              case "img":
                return true;
              default:
                return false;
            }
          }
          function prepareUpdate(domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {
            {
              var hostContextDev = hostContext;
              if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === "string" || typeof newProps.children === "number")) {
                var string2 = "" + newProps.children;
                var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
                validateDOMNesting(null, string2, ownAncestorInfo);
              }
            }
            return diffProperties(domElement, type, oldProps, newProps);
          }
          function shouldSetTextContent(type, props) {
            return type === "textarea" || type === "noscript" || typeof props.children === "string" || typeof props.children === "number" || typeof props.dangerouslySetInnerHTML === "object" && props.dangerouslySetInnerHTML !== null && props.dangerouslySetInnerHTML.__html != null;
          }
          function createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {
            {
              var hostContextDev = hostContext;
              validateDOMNesting(null, text, hostContextDev.ancestorInfo);
            }
            var textNode = createTextNode(text, rootContainerInstance);
            precacheFiberNode(internalInstanceHandle, textNode);
            return textNode;
          }
          function getCurrentEventPriority() {
            var currentEvent = window.event;
            if (currentEvent === void 0) {
              return DefaultEventPriority;
            }
            return getEventPriority(currentEvent.type);
          }
          var scheduleTimeout = typeof setTimeout === "function" ? setTimeout : void 0;
          var cancelTimeout = typeof clearTimeout === "function" ? clearTimeout : void 0;
          var noTimeout = -1;
          var localPromise = typeof Promise === "function" ? Promise : void 0;
          var scheduleMicrotask2 = typeof queueMicrotask === "function" ? queueMicrotask : typeof localPromise !== "undefined" ? function(callback) {
            return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
          } : scheduleTimeout;
          function handleErrorInNextTick(error2) {
            setTimeout(function() {
              throw error2;
            });
          }
          function commitMount(domElement, type, newProps, internalInstanceHandle) {
            switch (type) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                if (newProps.autoFocus) {
                  domElement.focus();
                }
                return;
              case "img": {
                if (newProps.src) {
                  domElement.src = newProps.src;
                }
                return;
              }
            }
          }
          function commitUpdate(domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {
            updateProperties(domElement, updatePayload, type, oldProps, newProps);
            updateFiberProps(domElement, newProps);
          }
          function resetTextContent(domElement) {
            setTextContent(domElement, "");
          }
          function commitTextUpdate(textInstance, oldText, newText) {
            textInstance.nodeValue = newText;
          }
          function appendChild(parentInstance, child) {
            parentInstance.appendChild(child);
          }
          function appendChildToContainer(container, child) {
            var parentNode;
            if (container.nodeType === COMMENT_NODE) {
              parentNode = container.parentNode;
              parentNode.insertBefore(child, container);
            } else {
              parentNode = container;
              parentNode.appendChild(child);
            }
            var reactRootContainer = container._reactRootContainer;
            if ((reactRootContainer === null || reactRootContainer === void 0) && parentNode.onclick === null) {
              trapClickOnNonInteractiveElement(parentNode);
            }
          }
          function insertBefore(parentInstance, child, beforeChild) {
            parentInstance.insertBefore(child, beforeChild);
          }
          function insertInContainerBefore(container, child, beforeChild) {
            if (container.nodeType === COMMENT_NODE) {
              container.parentNode.insertBefore(child, beforeChild);
            } else {
              container.insertBefore(child, beforeChild);
            }
          }
          function removeChild(parentInstance, child) {
            parentInstance.removeChild(child);
          }
          function removeChildFromContainer(container, child) {
            if (container.nodeType === COMMENT_NODE) {
              container.parentNode.removeChild(child);
            } else {
              container.removeChild(child);
            }
          }
          function clearSuspenseBoundary(parentInstance, suspenseInstance) {
            var node = suspenseInstance;
            var depth = 0;
            do {
              var nextNode = node.nextSibling;
              parentInstance.removeChild(node);
              if (nextNode && nextNode.nodeType === COMMENT_NODE) {
                var data2 = nextNode.data;
                if (data2 === SUSPENSE_END_DATA) {
                  if (depth === 0) {
                    parentInstance.removeChild(nextNode);
                    retryIfBlockedOn(suspenseInstance);
                    return;
                  } else {
                    depth--;
                  }
                } else if (data2 === SUSPENSE_START_DATA || data2 === SUSPENSE_PENDING_START_DATA || data2 === SUSPENSE_FALLBACK_START_DATA) {
                  depth++;
                }
              }
              node = nextNode;
            } while (node);
            retryIfBlockedOn(suspenseInstance);
          }
          function clearSuspenseBoundaryFromContainer(container, suspenseInstance) {
            if (container.nodeType === COMMENT_NODE) {
              clearSuspenseBoundary(container.parentNode, suspenseInstance);
            } else if (container.nodeType === ELEMENT_NODE) {
              clearSuspenseBoundary(container, suspenseInstance);
            }
            retryIfBlockedOn(container);
          }
          function hideInstance(instance) {
            instance = instance;
            var style3 = instance.style;
            if (typeof style3.setProperty === "function") {
              style3.setProperty("display", "none", "important");
            } else {
              style3.display = "none";
            }
          }
          function hideTextInstance(textInstance) {
            textInstance.nodeValue = "";
          }
          function unhideInstance(instance, props) {
            instance = instance;
            var styleProp = props[STYLE$1];
            var display = styleProp !== void 0 && styleProp !== null && styleProp.hasOwnProperty("display") ? styleProp.display : null;
            instance.style.display = dangerousStyleValue("display", display);
          }
          function unhideTextInstance(textInstance, text) {
            textInstance.nodeValue = text;
          }
          function clearContainer(container) {
            if (container.nodeType === ELEMENT_NODE) {
              container.textContent = "";
            } else if (container.nodeType === DOCUMENT_NODE) {
              if (container.documentElement) {
                container.removeChild(container.documentElement);
              }
            }
          }
          function canHydrateInstance(instance, type, props) {
            if (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {
              return null;
            }
            return instance;
          }
          function canHydrateTextInstance(instance, text) {
            if (text === "" || instance.nodeType !== TEXT_NODE) {
              return null;
            }
            return instance;
          }
          function canHydrateSuspenseInstance(instance) {
            if (instance.nodeType !== COMMENT_NODE) {
              return null;
            }
            return instance;
          }
          function isSuspenseInstancePending(instance) {
            return instance.data === SUSPENSE_PENDING_START_DATA;
          }
          function isSuspenseInstanceFallback(instance) {
            return instance.data === SUSPENSE_FALLBACK_START_DATA;
          }
          function getSuspenseInstanceFallbackErrorDetails(instance) {
            var dataset = instance.nextSibling && instance.nextSibling.dataset;
            var digest2, message, stack;
            if (dataset) {
              digest2 = dataset.dgst;
              {
                message = dataset.msg;
                stack = dataset.stck;
              }
            }
            {
              return {
                message,
                digest: digest2,
                stack
              };
            }
          }
          function registerSuspenseInstanceRetry(instance, callback) {
            instance._reactRetry = callback;
          }
          function getNextHydratable(node) {
            for (; node != null; node = node.nextSibling) {
              var nodeType = node.nodeType;
              if (nodeType === ELEMENT_NODE || nodeType === TEXT_NODE) {
                break;
              }
              if (nodeType === COMMENT_NODE) {
                var nodeData = node.data;
                if (nodeData === SUSPENSE_START_DATA || nodeData === SUSPENSE_FALLBACK_START_DATA || nodeData === SUSPENSE_PENDING_START_DATA) {
                  break;
                }
                if (nodeData === SUSPENSE_END_DATA) {
                  return null;
                }
              }
            }
            return node;
          }
          function getNextHydratableSibling(instance) {
            return getNextHydratable(instance.nextSibling);
          }
          function getFirstHydratableChild(parentInstance) {
            return getNextHydratable(parentInstance.firstChild);
          }
          function getFirstHydratableChildWithinContainer(parentContainer) {
            return getNextHydratable(parentContainer.firstChild);
          }
          function getFirstHydratableChildWithinSuspenseInstance(parentInstance) {
            return getNextHydratable(parentInstance.nextSibling);
          }
          function hydrateInstance(instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle, shouldWarnDev) {
            precacheFiberNode(internalInstanceHandle, instance);
            updateFiberProps(instance, props);
            var parentNamespace;
            {
              var hostContextDev = hostContext;
              parentNamespace = hostContextDev.namespace;
            }
            var isConcurrentMode = (internalInstanceHandle.mode & ConcurrentMode) !== NoMode;
            return diffHydratedProperties(instance, type, props, parentNamespace, rootContainerInstance, isConcurrentMode, shouldWarnDev);
          }
          function hydrateTextInstance(textInstance, text, internalInstanceHandle, shouldWarnDev) {
            precacheFiberNode(internalInstanceHandle, textInstance);
            var isConcurrentMode = (internalInstanceHandle.mode & ConcurrentMode) !== NoMode;
            return diffHydratedText(textInstance, text);
          }
          function hydrateSuspenseInstance(suspenseInstance, internalInstanceHandle) {
            precacheFiberNode(internalInstanceHandle, suspenseInstance);
          }
          function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {
            var node = suspenseInstance.nextSibling;
            var depth = 0;
            while (node) {
              if (node.nodeType === COMMENT_NODE) {
                var data2 = node.data;
                if (data2 === SUSPENSE_END_DATA) {
                  if (depth === 0) {
                    return getNextHydratableSibling(node);
                  } else {
                    depth--;
                  }
                } else if (data2 === SUSPENSE_START_DATA || data2 === SUSPENSE_FALLBACK_START_DATA || data2 === SUSPENSE_PENDING_START_DATA) {
                  depth++;
                }
              }
              node = node.nextSibling;
            }
            return null;
          }
          function getParentSuspenseInstance(targetInstance) {
            var node = targetInstance.previousSibling;
            var depth = 0;
            while (node) {
              if (node.nodeType === COMMENT_NODE) {
                var data2 = node.data;
                if (data2 === SUSPENSE_START_DATA || data2 === SUSPENSE_FALLBACK_START_DATA || data2 === SUSPENSE_PENDING_START_DATA) {
                  if (depth === 0) {
                    return node;
                  } else {
                    depth--;
                  }
                } else if (data2 === SUSPENSE_END_DATA) {
                  depth++;
                }
              }
              node = node.previousSibling;
            }
            return null;
          }
          function commitHydratedContainer(container) {
            retryIfBlockedOn(container);
          }
          function commitHydratedSuspenseInstance(suspenseInstance) {
            retryIfBlockedOn(suspenseInstance);
          }
          function shouldDeleteUnhydratedTailInstances(parentType) {
            return parentType !== "head" && parentType !== "body";
          }
          function didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, text, isConcurrentMode) {
            var shouldWarnDev = true;
            checkForUnmatchedText(textInstance.nodeValue, text, isConcurrentMode, shouldWarnDev);
          }
          function didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, text, isConcurrentMode) {
            if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
              var shouldWarnDev = true;
              checkForUnmatchedText(textInstance.nodeValue, text, isConcurrentMode, shouldWarnDev);
            }
          }
          function didNotHydrateInstanceWithinContainer(parentContainer, instance) {
            {
              if (instance.nodeType === ELEMENT_NODE) {
                warnForDeletedHydratableElement(parentContainer, instance);
              } else if (instance.nodeType === COMMENT_NODE)
                ;
              else {
                warnForDeletedHydratableText(parentContainer, instance);
              }
            }
          }
          function didNotHydrateInstanceWithinSuspenseInstance(parentInstance, instance) {
            {
              var parentNode = parentInstance.parentNode;
              if (parentNode !== null) {
                if (instance.nodeType === ELEMENT_NODE) {
                  warnForDeletedHydratableElement(parentNode, instance);
                } else if (instance.nodeType === COMMENT_NODE)
                  ;
                else {
                  warnForDeletedHydratableText(parentNode, instance);
                }
              }
            }
          }
          function didNotHydrateInstance(parentType, parentProps, parentInstance, instance, isConcurrentMode) {
            {
              if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
                if (instance.nodeType === ELEMENT_NODE) {
                  warnForDeletedHydratableElement(parentInstance, instance);
                } else if (instance.nodeType === COMMENT_NODE)
                  ;
                else {
                  warnForDeletedHydratableText(parentInstance, instance);
                }
              }
            }
          }
          function didNotFindHydratableInstanceWithinContainer(parentContainer, type, props) {
            {
              warnForInsertedHydratedElement(parentContainer, type);
            }
          }
          function didNotFindHydratableTextInstanceWithinContainer(parentContainer, text) {
            {
              warnForInsertedHydratedText(parentContainer, text);
            }
          }
          function didNotFindHydratableInstanceWithinSuspenseInstance(parentInstance, type, props) {
            {
              var parentNode = parentInstance.parentNode;
              if (parentNode !== null)
                warnForInsertedHydratedElement(parentNode, type);
            }
          }
          function didNotFindHydratableTextInstanceWithinSuspenseInstance(parentInstance, text) {
            {
              var parentNode = parentInstance.parentNode;
              if (parentNode !== null)
                warnForInsertedHydratedText(parentNode, text);
            }
          }
          function didNotFindHydratableInstance(parentType, parentProps, parentInstance, type, props, isConcurrentMode) {
            {
              if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
                warnForInsertedHydratedElement(parentInstance, type);
              }
            }
          }
          function didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text, isConcurrentMode) {
            {
              if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
                warnForInsertedHydratedText(parentInstance, text);
              }
            }
          }
          function errorHydratingContainer(parentContainer) {
            {
              error("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", parentContainer.nodeName.toLowerCase());
            }
          }
          function preparePortalMount(portalInstance) {
            listenToAllSupportedEvents(portalInstance);
          }
          var randomKey = Math.random().toString(36).slice(2);
          var internalInstanceKey = "__reactFiber$" + randomKey;
          var internalPropsKey = "__reactProps$" + randomKey;
          var internalContainerInstanceKey = "__reactContainer$" + randomKey;
          var internalEventHandlersKey = "__reactEvents$" + randomKey;
          var internalEventHandlerListenersKey = "__reactListeners$" + randomKey;
          var internalEventHandlesSetKey = "__reactHandles$" + randomKey;
          function detachDeletedInstance(node) {
            delete node[internalInstanceKey];
            delete node[internalPropsKey];
            delete node[internalEventHandlersKey];
            delete node[internalEventHandlerListenersKey];
            delete node[internalEventHandlesSetKey];
          }
          function precacheFiberNode(hostInst, node) {
            node[internalInstanceKey] = hostInst;
          }
          function markContainerAsRoot(hostRoot, node) {
            node[internalContainerInstanceKey] = hostRoot;
          }
          function unmarkContainerAsRoot(node) {
            node[internalContainerInstanceKey] = null;
          }
          function isContainerMarkedAsRoot(node) {
            return !!node[internalContainerInstanceKey];
          }
          function getClosestInstanceFromNode(targetNode) {
            var targetInst = targetNode[internalInstanceKey];
            if (targetInst) {
              return targetInst;
            }
            var parentNode = targetNode.parentNode;
            while (parentNode) {
              targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey];
              if (targetInst) {
                var alternate = targetInst.alternate;
                if (targetInst.child !== null || alternate !== null && alternate.child !== null) {
                  var suspenseInstance = getParentSuspenseInstance(targetNode);
                  while (suspenseInstance !== null) {
                    var targetSuspenseInst = suspenseInstance[internalInstanceKey];
                    if (targetSuspenseInst) {
                      return targetSuspenseInst;
                    }
                    suspenseInstance = getParentSuspenseInstance(suspenseInstance);
                  }
                }
                return targetInst;
              }
              targetNode = parentNode;
              parentNode = targetNode.parentNode;
            }
            return null;
          }
          function getInstanceFromNode(node) {
            var inst = node[internalInstanceKey] || node[internalContainerInstanceKey];
            if (inst) {
              if (inst.tag === HostComponent || inst.tag === HostText || inst.tag === SuspenseComponent || inst.tag === HostRoot) {
                return inst;
              } else {
                return null;
              }
            }
            return null;
          }
          function getNodeFromInstance(inst) {
            if (inst.tag === HostComponent || inst.tag === HostText) {
              return inst.stateNode;
            }
            throw new Error("getNodeFromInstance: Invalid argument.");
          }
          function getFiberCurrentPropsFromNode(node) {
            return node[internalPropsKey] || null;
          }
          function updateFiberProps(node, props) {
            node[internalPropsKey] = props;
          }
          function getEventListenerSet(node) {
            var elementListenerSet = node[internalEventHandlersKey];
            if (elementListenerSet === void 0) {
              elementListenerSet = node[internalEventHandlersKey] = /* @__PURE__ */ new Set();
            }
            return elementListenerSet;
          }
          var loggedTypeFailures = {};
          var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
          function setCurrentlyValidatingElement(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
              } else {
                ReactDebugCurrentFrame$1.setExtraStackFrame(null);
              }
            }
          }
          function checkPropTypes(typeSpecs, values, location2, componentName, element) {
            {
              var has2 = Function.call.bind(hasOwnProperty2);
              for (var typeSpecName in typeSpecs) {
                if (has2(typeSpecs, typeSpecName)) {
                  var error$1 = void 0;
                  try {
                    if (typeof typeSpecs[typeSpecName] !== "function") {
                      var err = Error((componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                      err.name = "Invariant Violation";
                      throw err;
                    }
                    error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location2, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                  } catch (ex) {
                    error$1 = ex;
                  }
                  if (error$1 && !(error$1 instanceof Error)) {
                    setCurrentlyValidatingElement(element);
                    error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location2, typeSpecName, typeof error$1);
                    setCurrentlyValidatingElement(null);
                  }
                  if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                    loggedTypeFailures[error$1.message] = true;
                    setCurrentlyValidatingElement(element);
                    error("Failed %s type: %s", location2, error$1.message);
                    setCurrentlyValidatingElement(null);
                  }
                }
              }
            }
          }
          var valueStack = [];
          var fiberStack;
          {
            fiberStack = [];
          }
          var index2 = -1;
          function createCursor(defaultValue) {
            return {
              current: defaultValue
            };
          }
          function pop(cursor, fiber) {
            if (index2 < 0) {
              {
                error("Unexpected pop.");
              }
              return;
            }
            {
              if (fiber !== fiberStack[index2]) {
                error("Unexpected Fiber popped.");
              }
            }
            cursor.current = valueStack[index2];
            valueStack[index2] = null;
            {
              fiberStack[index2] = null;
            }
            index2--;
          }
          function push(cursor, value, fiber) {
            index2++;
            valueStack[index2] = cursor.current;
            {
              fiberStack[index2] = fiber;
            }
            cursor.current = value;
          }
          var warnedAboutMissingGetChildContext;
          {
            warnedAboutMissingGetChildContext = {};
          }
          var emptyContextObject = {};
          {
            Object.freeze(emptyContextObject);
          }
          var contextStackCursor = createCursor(emptyContextObject);
          var didPerformWorkStackCursor = createCursor(false);
          var previousContext = emptyContextObject;
          function getUnmaskedContext(workInProgress2, Component, didPushOwnContextIfProvider) {
            {
              if (didPushOwnContextIfProvider && isContextProvider(Component)) {
                return previousContext;
              }
              return contextStackCursor.current;
            }
          }
          function cacheContext(workInProgress2, unmaskedContext, maskedContext) {
            {
              var instance = workInProgress2.stateNode;
              instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
              instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
            }
          }
          function getMaskedContext(workInProgress2, unmaskedContext) {
            {
              var type = workInProgress2.type;
              var contextTypes = type.contextTypes;
              if (!contextTypes) {
                return emptyContextObject;
              }
              var instance = workInProgress2.stateNode;
              if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {
                return instance.__reactInternalMemoizedMaskedChildContext;
              }
              var context = {};
              for (var key2 in contextTypes) {
                context[key2] = unmaskedContext[key2];
              }
              {
                var name2 = getComponentNameFromFiber(workInProgress2) || "Unknown";
                checkPropTypes(contextTypes, context, "context", name2);
              }
              if (instance) {
                cacheContext(workInProgress2, unmaskedContext, context);
              }
              return context;
            }
          }
          function hasContextChanged() {
            {
              return didPerformWorkStackCursor.current;
            }
          }
          function isContextProvider(type) {
            {
              var childContextTypes = type.childContextTypes;
              return childContextTypes !== null && childContextTypes !== void 0;
            }
          }
          function popContext(fiber) {
            {
              pop(didPerformWorkStackCursor, fiber);
              pop(contextStackCursor, fiber);
            }
          }
          function popTopLevelContextObject(fiber) {
            {
              pop(didPerformWorkStackCursor, fiber);
              pop(contextStackCursor, fiber);
            }
          }
          function pushTopLevelContextObject(fiber, context, didChange) {
            {
              if (contextStackCursor.current !== emptyContextObject) {
                throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
              }
              push(contextStackCursor, context, fiber);
              push(didPerformWorkStackCursor, didChange, fiber);
            }
          }
          function processChildContext(fiber, type, parentContext) {
            {
              var instance = fiber.stateNode;
              var childContextTypes = type.childContextTypes;
              if (typeof instance.getChildContext !== "function") {
                {
                  var componentName = getComponentNameFromFiber(fiber) || "Unknown";
                  if (!warnedAboutMissingGetChildContext[componentName]) {
                    warnedAboutMissingGetChildContext[componentName] = true;
                    error("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName);
                  }
                }
                return parentContext;
              }
              var childContext = instance.getChildContext();
              for (var contextKey in childContext) {
                if (!(contextKey in childContextTypes)) {
                  throw new Error((getComponentNameFromFiber(fiber) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
                }
              }
              {
                var name2 = getComponentNameFromFiber(fiber) || "Unknown";
                checkPropTypes(childContextTypes, childContext, "child context", name2);
              }
              return assign({}, parentContext, childContext);
            }
          }
          function pushContextProvider(workInProgress2) {
            {
              var instance = workInProgress2.stateNode;
              var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject;
              previousContext = contextStackCursor.current;
              push(contextStackCursor, memoizedMergedChildContext, workInProgress2);
              push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress2);
              return true;
            }
          }
          function invalidateContextProvider(workInProgress2, type, didChange) {
            {
              var instance = workInProgress2.stateNode;
              if (!instance) {
                throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
              }
              if (didChange) {
                var mergedContext = processChildContext(workInProgress2, type, previousContext);
                instance.__reactInternalMemoizedMergedChildContext = mergedContext;
                pop(didPerformWorkStackCursor, workInProgress2);
                pop(contextStackCursor, workInProgress2);
                push(contextStackCursor, mergedContext, workInProgress2);
                push(didPerformWorkStackCursor, didChange, workInProgress2);
              } else {
                pop(didPerformWorkStackCursor, workInProgress2);
                push(didPerformWorkStackCursor, didChange, workInProgress2);
              }
            }
          }
          function findCurrentUnmaskedContext(fiber) {
            {
              if (!isFiberMounted(fiber) || fiber.tag !== ClassComponent) {
                throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
              }
              var node = fiber;
              do {
                switch (node.tag) {
                  case HostRoot:
                    return node.stateNode.context;
                  case ClassComponent: {
                    var Component = node.type;
                    if (isContextProvider(Component)) {
                      return node.stateNode.__reactInternalMemoizedMergedChildContext;
                    }
                    break;
                  }
                }
                node = node.return;
              } while (node !== null);
              throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          var LegacyRoot = 0;
          var ConcurrentRoot = 1;
          var syncQueue = null;
          var includesLegacySyncCallbacks = false;
          var isFlushingSyncQueue = false;
          function scheduleSyncCallback(callback) {
            if (syncQueue === null) {
              syncQueue = [callback];
            } else {
              syncQueue.push(callback);
            }
          }
          function scheduleLegacySyncCallback(callback) {
            includesLegacySyncCallbacks = true;
            scheduleSyncCallback(callback);
          }
          function flushSyncCallbacksOnlyInLegacyMode() {
            if (includesLegacySyncCallbacks) {
              flushSyncCallbacks();
            }
          }
          function flushSyncCallbacks() {
            if (!isFlushingSyncQueue && syncQueue !== null) {
              isFlushingSyncQueue = true;
              var i7 = 0;
              var previousUpdatePriority = getCurrentUpdatePriority();
              try {
                var isSync = true;
                var queue = syncQueue;
                setCurrentUpdatePriority(DiscreteEventPriority);
                for (; i7 < queue.length; i7++) {
                  var callback = queue[i7];
                  do {
                    callback = callback(isSync);
                  } while (callback !== null);
                }
                syncQueue = null;
                includesLegacySyncCallbacks = false;
              } catch (error2) {
                if (syncQueue !== null) {
                  syncQueue = syncQueue.slice(i7 + 1);
                }
                scheduleCallback(ImmediatePriority, flushSyncCallbacks);
                throw error2;
              } finally {
                setCurrentUpdatePriority(previousUpdatePriority);
                isFlushingSyncQueue = false;
              }
            }
            return null;
          }
          var forkStack = [];
          var forkStackIndex = 0;
          var treeForkProvider = null;
          var treeForkCount = 0;
          var idStack = [];
          var idStackIndex = 0;
          var treeContextProvider = null;
          var treeContextId = 1;
          var treeContextOverflow = "";
          function isForkedChild(workInProgress2) {
            warnIfNotHydrating();
            return (workInProgress2.flags & Forked) !== NoFlags;
          }
          function getForksAtLevel(workInProgress2) {
            warnIfNotHydrating();
            return treeForkCount;
          }
          function getTreeId() {
            var overflow = treeContextOverflow;
            var idWithLeadingBit = treeContextId;
            var id3 = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
            return id3.toString(32) + overflow;
          }
          function pushTreeFork(workInProgress2, totalChildren) {
            warnIfNotHydrating();
            forkStack[forkStackIndex++] = treeForkCount;
            forkStack[forkStackIndex++] = treeForkProvider;
            treeForkProvider = workInProgress2;
            treeForkCount = totalChildren;
          }
          function pushTreeId(workInProgress2, totalChildren, index3) {
            warnIfNotHydrating();
            idStack[idStackIndex++] = treeContextId;
            idStack[idStackIndex++] = treeContextOverflow;
            idStack[idStackIndex++] = treeContextProvider;
            treeContextProvider = workInProgress2;
            var baseIdWithLeadingBit = treeContextId;
            var baseOverflow = treeContextOverflow;
            var baseLength = getBitLength(baseIdWithLeadingBit) - 1;
            var baseId = baseIdWithLeadingBit & ~(1 << baseLength);
            var slot = index3 + 1;
            var length2 = getBitLength(totalChildren) + baseLength;
            if (length2 > 30) {
              var numberOfOverflowBits = baseLength - baseLength % 5;
              var newOverflowBits = (1 << numberOfOverflowBits) - 1;
              var newOverflow = (baseId & newOverflowBits).toString(32);
              var restOfBaseId = baseId >> numberOfOverflowBits;
              var restOfBaseLength = baseLength - numberOfOverflowBits;
              var restOfLength = getBitLength(totalChildren) + restOfBaseLength;
              var restOfNewBits = slot << restOfBaseLength;
              var id3 = restOfNewBits | restOfBaseId;
              var overflow = newOverflow + baseOverflow;
              treeContextId = 1 << restOfLength | id3;
              treeContextOverflow = overflow;
            } else {
              var newBits = slot << baseLength;
              var _id = newBits | baseId;
              var _overflow = baseOverflow;
              treeContextId = 1 << length2 | _id;
              treeContextOverflow = _overflow;
            }
          }
          function pushMaterializedTreeId(workInProgress2) {
            warnIfNotHydrating();
            var returnFiber = workInProgress2.return;
            if (returnFiber !== null) {
              var numberOfForks = 1;
              var slotIndex = 0;
              pushTreeFork(workInProgress2, numberOfForks);
              pushTreeId(workInProgress2, numberOfForks, slotIndex);
            }
          }
          function getBitLength(number2) {
            return 32 - clz32(number2);
          }
          function getLeadingBit(id3) {
            return 1 << getBitLength(id3) - 1;
          }
          function popTreeContext(workInProgress2) {
            while (workInProgress2 === treeForkProvider) {
              treeForkProvider = forkStack[--forkStackIndex];
              forkStack[forkStackIndex] = null;
              treeForkCount = forkStack[--forkStackIndex];
              forkStack[forkStackIndex] = null;
            }
            while (workInProgress2 === treeContextProvider) {
              treeContextProvider = idStack[--idStackIndex];
              idStack[idStackIndex] = null;
              treeContextOverflow = idStack[--idStackIndex];
              idStack[idStackIndex] = null;
              treeContextId = idStack[--idStackIndex];
              idStack[idStackIndex] = null;
            }
          }
          function getSuspendedTreeContext() {
            warnIfNotHydrating();
            if (treeContextProvider !== null) {
              return {
                id: treeContextId,
                overflow: treeContextOverflow
              };
            } else {
              return null;
            }
          }
          function restoreSuspendedTreeContext(workInProgress2, suspendedContext) {
            warnIfNotHydrating();
            idStack[idStackIndex++] = treeContextId;
            idStack[idStackIndex++] = treeContextOverflow;
            idStack[idStackIndex++] = treeContextProvider;
            treeContextId = suspendedContext.id;
            treeContextOverflow = suspendedContext.overflow;
            treeContextProvider = workInProgress2;
          }
          function warnIfNotHydrating() {
            {
              if (!getIsHydrating()) {
                error("Expected to be hydrating. This is a bug in React. Please file an issue.");
              }
            }
          }
          var hydrationParentFiber = null;
          var nextHydratableInstance = null;
          var isHydrating = false;
          var didSuspendOrErrorDEV = false;
          var hydrationErrors = null;
          function warnIfHydrating() {
            {
              if (isHydrating) {
                error("We should not be hydrating here. This is a bug in React. Please file a bug.");
              }
            }
          }
          function markDidThrowWhileHydratingDEV() {
            {
              didSuspendOrErrorDEV = true;
            }
          }
          function didSuspendOrErrorWhileHydratingDEV() {
            {
              return didSuspendOrErrorDEV;
            }
          }
          function enterHydrationState(fiber) {
            var parentInstance = fiber.stateNode.containerInfo;
            nextHydratableInstance = getFirstHydratableChildWithinContainer(parentInstance);
            hydrationParentFiber = fiber;
            isHydrating = true;
            hydrationErrors = null;
            didSuspendOrErrorDEV = false;
            return true;
          }
          function reenterHydrationStateFromDehydratedSuspenseInstance(fiber, suspenseInstance, treeContext) {
            nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);
            hydrationParentFiber = fiber;
            isHydrating = true;
            hydrationErrors = null;
            didSuspendOrErrorDEV = false;
            if (treeContext !== null) {
              restoreSuspendedTreeContext(fiber, treeContext);
            }
            return true;
          }
          function warnUnhydratedInstance(returnFiber, instance) {
            {
              switch (returnFiber.tag) {
                case HostRoot: {
                  didNotHydrateInstanceWithinContainer(returnFiber.stateNode.containerInfo, instance);
                  break;
                }
                case HostComponent: {
                  var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                  didNotHydrateInstance(
                    returnFiber.type,
                    returnFiber.memoizedProps,
                    returnFiber.stateNode,
                    instance,
                    // TODO: Delete this argument when we remove the legacy root API.
                    isConcurrentMode
                  );
                  break;
                }
                case SuspenseComponent: {
                  var suspenseState = returnFiber.memoizedState;
                  if (suspenseState.dehydrated !== null)
                    didNotHydrateInstanceWithinSuspenseInstance(suspenseState.dehydrated, instance);
                  break;
                }
              }
            }
          }
          function deleteHydratableInstance(returnFiber, instance) {
            warnUnhydratedInstance(returnFiber, instance);
            var childToDelete = createFiberFromHostInstanceForDeletion();
            childToDelete.stateNode = instance;
            childToDelete.return = returnFiber;
            var deletions = returnFiber.deletions;
            if (deletions === null) {
              returnFiber.deletions = [childToDelete];
              returnFiber.flags |= ChildDeletion;
            } else {
              deletions.push(childToDelete);
            }
          }
          function warnNonhydratedInstance(returnFiber, fiber) {
            {
              if (didSuspendOrErrorDEV) {
                return;
              }
              switch (returnFiber.tag) {
                case HostRoot: {
                  var parentContainer = returnFiber.stateNode.containerInfo;
                  switch (fiber.tag) {
                    case HostComponent:
                      var type = fiber.type;
                      var props = fiber.pendingProps;
                      didNotFindHydratableInstanceWithinContainer(parentContainer, type);
                      break;
                    case HostText:
                      var text = fiber.pendingProps;
                      didNotFindHydratableTextInstanceWithinContainer(parentContainer, text);
                      break;
                  }
                  break;
                }
                case HostComponent: {
                  var parentType = returnFiber.type;
                  var parentProps = returnFiber.memoizedProps;
                  var parentInstance = returnFiber.stateNode;
                  switch (fiber.tag) {
                    case HostComponent: {
                      var _type = fiber.type;
                      var _props = fiber.pendingProps;
                      var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                      didNotFindHydratableInstance(
                        parentType,
                        parentProps,
                        parentInstance,
                        _type,
                        _props,
                        // TODO: Delete this argument when we remove the legacy root API.
                        isConcurrentMode
                      );
                      break;
                    }
                    case HostText: {
                      var _text = fiber.pendingProps;
                      var _isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                      didNotFindHydratableTextInstance(
                        parentType,
                        parentProps,
                        parentInstance,
                        _text,
                        // TODO: Delete this argument when we remove the legacy root API.
                        _isConcurrentMode
                      );
                      break;
                    }
                  }
                  break;
                }
                case SuspenseComponent: {
                  var suspenseState = returnFiber.memoizedState;
                  var _parentInstance = suspenseState.dehydrated;
                  if (_parentInstance !== null)
                    switch (fiber.tag) {
                      case HostComponent:
                        var _type2 = fiber.type;
                        var _props2 = fiber.pendingProps;
                        didNotFindHydratableInstanceWithinSuspenseInstance(_parentInstance, _type2);
                        break;
                      case HostText:
                        var _text2 = fiber.pendingProps;
                        didNotFindHydratableTextInstanceWithinSuspenseInstance(_parentInstance, _text2);
                        break;
                    }
                  break;
                }
                default:
                  return;
              }
            }
          }
          function insertNonHydratedInstance(returnFiber, fiber) {
            fiber.flags = fiber.flags & ~Hydrating | Placement;
            warnNonhydratedInstance(returnFiber, fiber);
          }
          function tryHydrate(fiber, nextInstance) {
            switch (fiber.tag) {
              case HostComponent: {
                var type = fiber.type;
                var props = fiber.pendingProps;
                var instance = canHydrateInstance(nextInstance, type);
                if (instance !== null) {
                  fiber.stateNode = instance;
                  hydrationParentFiber = fiber;
                  nextHydratableInstance = getFirstHydratableChild(instance);
                  return true;
                }
                return false;
              }
              case HostText: {
                var text = fiber.pendingProps;
                var textInstance = canHydrateTextInstance(nextInstance, text);
                if (textInstance !== null) {
                  fiber.stateNode = textInstance;
                  hydrationParentFiber = fiber;
                  nextHydratableInstance = null;
                  return true;
                }
                return false;
              }
              case SuspenseComponent: {
                var suspenseInstance = canHydrateSuspenseInstance(nextInstance);
                if (suspenseInstance !== null) {
                  var suspenseState = {
                    dehydrated: suspenseInstance,
                    treeContext: getSuspendedTreeContext(),
                    retryLane: OffscreenLane
                  };
                  fiber.memoizedState = suspenseState;
                  var dehydratedFragment = createFiberFromDehydratedFragment(suspenseInstance);
                  dehydratedFragment.return = fiber;
                  fiber.child = dehydratedFragment;
                  hydrationParentFiber = fiber;
                  nextHydratableInstance = null;
                  return true;
                }
                return false;
              }
              default:
                return false;
            }
          }
          function shouldClientRenderOnMismatch(fiber) {
            return (fiber.mode & ConcurrentMode) !== NoMode && (fiber.flags & DidCapture) === NoFlags;
          }
          function throwOnHydrationMismatch(fiber) {
            throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
          }
          function tryToClaimNextHydratableInstance(fiber) {
            if (!isHydrating) {
              return;
            }
            var nextInstance = nextHydratableInstance;
            if (!nextInstance) {
              if (shouldClientRenderOnMismatch(fiber)) {
                warnNonhydratedInstance(hydrationParentFiber, fiber);
                throwOnHydrationMismatch();
              }
              insertNonHydratedInstance(hydrationParentFiber, fiber);
              isHydrating = false;
              hydrationParentFiber = fiber;
              return;
            }
            var firstAttemptedInstance = nextInstance;
            if (!tryHydrate(fiber, nextInstance)) {
              if (shouldClientRenderOnMismatch(fiber)) {
                warnNonhydratedInstance(hydrationParentFiber, fiber);
                throwOnHydrationMismatch();
              }
              nextInstance = getNextHydratableSibling(firstAttemptedInstance);
              var prevHydrationParentFiber = hydrationParentFiber;
              if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
                insertNonHydratedInstance(hydrationParentFiber, fiber);
                isHydrating = false;
                hydrationParentFiber = fiber;
                return;
              }
              deleteHydratableInstance(prevHydrationParentFiber, firstAttemptedInstance);
            }
          }
          function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {
            var instance = fiber.stateNode;
            var shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;
            var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber, shouldWarnIfMismatchDev);
            fiber.updateQueue = updatePayload;
            if (updatePayload !== null) {
              return true;
            }
            return false;
          }
          function prepareToHydrateHostTextInstance(fiber) {
            var textInstance = fiber.stateNode;
            var textContent = fiber.memoizedProps;
            var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);
            if (shouldUpdate) {
              var returnFiber = hydrationParentFiber;
              if (returnFiber !== null) {
                switch (returnFiber.tag) {
                  case HostRoot: {
                    var parentContainer = returnFiber.stateNode.containerInfo;
                    var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                    didNotMatchHydratedContainerTextInstance(
                      parentContainer,
                      textInstance,
                      textContent,
                      // TODO: Delete this argument when we remove the legacy root API.
                      isConcurrentMode
                    );
                    break;
                  }
                  case HostComponent: {
                    var parentType = returnFiber.type;
                    var parentProps = returnFiber.memoizedProps;
                    var parentInstance = returnFiber.stateNode;
                    var _isConcurrentMode2 = (returnFiber.mode & ConcurrentMode) !== NoMode;
                    didNotMatchHydratedTextInstance(
                      parentType,
                      parentProps,
                      parentInstance,
                      textInstance,
                      textContent,
                      // TODO: Delete this argument when we remove the legacy root API.
                      _isConcurrentMode2
                    );
                    break;
                  }
                }
              }
            }
            return shouldUpdate;
          }
          function prepareToHydrateHostSuspenseInstance(fiber) {
            var suspenseState = fiber.memoizedState;
            var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
            if (!suspenseInstance) {
              throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
            }
            hydrateSuspenseInstance(suspenseInstance, fiber);
          }
          function skipPastDehydratedSuspenseInstance(fiber) {
            var suspenseState = fiber.memoizedState;
            var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
            if (!suspenseInstance) {
              throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
            }
            return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);
          }
          function popToNextHostParent(fiber) {
            var parent = fiber.return;
            while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot && parent.tag !== SuspenseComponent) {
              parent = parent.return;
            }
            hydrationParentFiber = parent;
          }
          function popHydrationState(fiber) {
            if (fiber !== hydrationParentFiber) {
              return false;
            }
            if (!isHydrating) {
              popToNextHostParent(fiber);
              isHydrating = true;
              return false;
            }
            if (fiber.tag !== HostRoot && (fiber.tag !== HostComponent || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps))) {
              var nextInstance = nextHydratableInstance;
              if (nextInstance) {
                if (shouldClientRenderOnMismatch(fiber)) {
                  warnIfUnhydratedTailNodes(fiber);
                  throwOnHydrationMismatch();
                } else {
                  while (nextInstance) {
                    deleteHydratableInstance(fiber, nextInstance);
                    nextInstance = getNextHydratableSibling(nextInstance);
                  }
                }
              }
            }
            popToNextHostParent(fiber);
            if (fiber.tag === SuspenseComponent) {
              nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);
            } else {
              nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
            }
            return true;
          }
          function hasUnhydratedTailNodes() {
            return isHydrating && nextHydratableInstance !== null;
          }
          function warnIfUnhydratedTailNodes(fiber) {
            var nextInstance = nextHydratableInstance;
            while (nextInstance) {
              warnUnhydratedInstance(fiber, nextInstance);
              nextInstance = getNextHydratableSibling(nextInstance);
            }
          }
          function resetHydrationState() {
            hydrationParentFiber = null;
            nextHydratableInstance = null;
            isHydrating = false;
            didSuspendOrErrorDEV = false;
          }
          function upgradeHydrationErrorsToRecoverable() {
            if (hydrationErrors !== null) {
              queueRecoverableErrors(hydrationErrors);
              hydrationErrors = null;
            }
          }
          function getIsHydrating() {
            return isHydrating;
          }
          function queueHydrationError(error2) {
            if (hydrationErrors === null) {
              hydrationErrors = [error2];
            } else {
              hydrationErrors.push(error2);
            }
          }
          var ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;
          var NoTransition = null;
          function requestCurrentTransition() {
            return ReactCurrentBatchConfig$1.transition;
          }
          var ReactStrictModeWarnings = {
            recordUnsafeLifecycleWarnings: function(fiber, instance) {
            },
            flushPendingUnsafeLifecycleWarnings: function() {
            },
            recordLegacyContextWarning: function(fiber, instance) {
            },
            flushLegacyContextWarning: function() {
            },
            discardPendingWarnings: function() {
            }
          };
          {
            var findStrictRoot = function(fiber) {
              var maybeStrictRoot = null;
              var node = fiber;
              while (node !== null) {
                if (node.mode & StrictLegacyMode) {
                  maybeStrictRoot = node;
                }
                node = node.return;
              }
              return maybeStrictRoot;
            };
            var setToSortedString = function(set3) {
              var array = [];
              set3.forEach(function(value) {
                array.push(value);
              });
              return array.sort().join(", ");
            };
            var pendingComponentWillMountWarnings = [];
            var pendingUNSAFE_ComponentWillMountWarnings = [];
            var pendingComponentWillReceivePropsWarnings = [];
            var pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
            var pendingComponentWillUpdateWarnings = [];
            var pendingUNSAFE_ComponentWillUpdateWarnings = [];
            var didWarnAboutUnsafeLifecycles = /* @__PURE__ */ new Set();
            ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {
              if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {
                return;
              }
              if (typeof instance.componentWillMount === "function" && // Don't warn about react-lifecycles-compat polyfilled components.
              instance.componentWillMount.__suppressDeprecationWarning !== true) {
                pendingComponentWillMountWarnings.push(fiber);
              }
              if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillMount === "function") {
                pendingUNSAFE_ComponentWillMountWarnings.push(fiber);
              }
              if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
                pendingComponentWillReceivePropsWarnings.push(fiber);
              }
              if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillReceiveProps === "function") {
                pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);
              }
              if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
                pendingComponentWillUpdateWarnings.push(fiber);
              }
              if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillUpdate === "function") {
                pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);
              }
            };
            ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
              var componentWillMountUniqueNames = /* @__PURE__ */ new Set();
              if (pendingComponentWillMountWarnings.length > 0) {
                pendingComponentWillMountWarnings.forEach(function(fiber) {
                  componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingComponentWillMountWarnings = [];
              }
              var UNSAFE_componentWillMountUniqueNames = /* @__PURE__ */ new Set();
              if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {
                pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
                  UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingUNSAFE_ComponentWillMountWarnings = [];
              }
              var componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
              if (pendingComponentWillReceivePropsWarnings.length > 0) {
                pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {
                  componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingComponentWillReceivePropsWarnings = [];
              }
              var UNSAFE_componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
              if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {
                pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {
                  UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
              }
              var componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
              if (pendingComponentWillUpdateWarnings.length > 0) {
                pendingComponentWillUpdateWarnings.forEach(function(fiber) {
                  componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingComponentWillUpdateWarnings = [];
              }
              var UNSAFE_componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
              if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {
                pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
                  UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingUNSAFE_ComponentWillUpdateWarnings = [];
              }
              if (UNSAFE_componentWillMountUniqueNames.size > 0) {
                var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);
                error("Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s", sortedNames);
              }
              if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {
                var _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);
                error("Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n\nPlease update the following components: %s", _sortedNames);
              }
              if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {
                var _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);
                error("Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s", _sortedNames2);
              }
              if (componentWillMountUniqueNames.size > 0) {
                var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);
                warn("componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames3);
              }
              if (componentWillReceivePropsUniqueNames.size > 0) {
                var _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);
                warn("componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames4);
              }
              if (componentWillUpdateUniqueNames.size > 0) {
                var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);
                warn("componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames5);
              }
            };
            var pendingLegacyContextWarning = /* @__PURE__ */ new Map();
            var didWarnAboutLegacyContext = /* @__PURE__ */ new Set();
            ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {
              var strictRoot = findStrictRoot(fiber);
              if (strictRoot === null) {
                error("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
                return;
              }
              if (didWarnAboutLegacyContext.has(fiber.type)) {
                return;
              }
              var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);
              if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === "function") {
                if (warningsForRoot === void 0) {
                  warningsForRoot = [];
                  pendingLegacyContextWarning.set(strictRoot, warningsForRoot);
                }
                warningsForRoot.push(fiber);
              }
            };
            ReactStrictModeWarnings.flushLegacyContextWarning = function() {
              pendingLegacyContextWarning.forEach(function(fiberArray, strictRoot) {
                if (fiberArray.length === 0) {
                  return;
                }
                var firstFiber = fiberArray[0];
                var uniqueNames = /* @__PURE__ */ new Set();
                fiberArray.forEach(function(fiber) {
                  uniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutLegacyContext.add(fiber.type);
                });
                var sortedNames = setToSortedString(uniqueNames);
                try {
                  setCurrentFiber(firstFiber);
                  error("Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://reactjs.org/link/legacy-context", sortedNames);
                } finally {
                  resetCurrentFiber();
                }
              });
            };
            ReactStrictModeWarnings.discardPendingWarnings = function() {
              pendingComponentWillMountWarnings = [];
              pendingUNSAFE_ComponentWillMountWarnings = [];
              pendingComponentWillReceivePropsWarnings = [];
              pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
              pendingComponentWillUpdateWarnings = [];
              pendingUNSAFE_ComponentWillUpdateWarnings = [];
              pendingLegacyContextWarning = /* @__PURE__ */ new Map();
            };
          }
          function resolveDefaultProps(Component, baseProps) {
            if (Component && Component.defaultProps) {
              var props = assign({}, baseProps);
              var defaultProps = Component.defaultProps;
              for (var propName in defaultProps) {
                if (props[propName] === void 0) {
                  props[propName] = defaultProps[propName];
                }
              }
              return props;
            }
            return baseProps;
          }
          var valueCursor = createCursor(null);
          var rendererSigil;
          {
            rendererSigil = {};
          }
          var currentlyRenderingFiber = null;
          var lastContextDependency = null;
          var lastFullyObservedContext = null;
          var isDisallowedContextReadInDEV = false;
          function resetContextDependencies() {
            currentlyRenderingFiber = null;
            lastContextDependency = null;
            lastFullyObservedContext = null;
            {
              isDisallowedContextReadInDEV = false;
            }
          }
          function enterDisallowedContextReadInDEV() {
            {
              isDisallowedContextReadInDEV = true;
            }
          }
          function exitDisallowedContextReadInDEV() {
            {
              isDisallowedContextReadInDEV = false;
            }
          }
          function pushProvider(providerFiber, context, nextValue) {
            {
              push(valueCursor, context._currentValue, providerFiber);
              context._currentValue = nextValue;
              {
                if (context._currentRenderer !== void 0 && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {
                  error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
                }
                context._currentRenderer = rendererSigil;
              }
            }
          }
          function popProvider(context, providerFiber) {
            var currentValue = valueCursor.current;
            pop(valueCursor, providerFiber);
            {
              {
                context._currentValue = currentValue;
              }
            }
          }
          function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
            var node = parent;
            while (node !== null) {
              var alternate = node.alternate;
              if (!isSubsetOfLanes(node.childLanes, renderLanes2)) {
                node.childLanes = mergeLanes(node.childLanes, renderLanes2);
                if (alternate !== null) {
                  alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);
                }
              } else if (alternate !== null && !isSubsetOfLanes(alternate.childLanes, renderLanes2)) {
                alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);
              }
              if (node === propagationRoot) {
                break;
              }
              node = node.return;
            }
            {
              if (node !== propagationRoot) {
                error("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
          }
          function propagateContextChange(workInProgress2, context, renderLanes2) {
            {
              propagateContextChange_eager(workInProgress2, context, renderLanes2);
            }
          }
          function propagateContextChange_eager(workInProgress2, context, renderLanes2) {
            var fiber = workInProgress2.child;
            if (fiber !== null) {
              fiber.return = workInProgress2;
            }
            while (fiber !== null) {
              var nextFiber = void 0;
              var list = fiber.dependencies;
              if (list !== null) {
                nextFiber = fiber.child;
                var dependency = list.firstContext;
                while (dependency !== null) {
                  if (dependency.context === context) {
                    if (fiber.tag === ClassComponent) {
                      var lane = pickArbitraryLane(renderLanes2);
                      var update2 = createUpdate(NoTimestamp, lane);
                      update2.tag = ForceUpdate;
                      var updateQueue = fiber.updateQueue;
                      if (updateQueue === null)
                        ;
                      else {
                        var sharedQueue = updateQueue.shared;
                        var pending = sharedQueue.pending;
                        if (pending === null) {
                          update2.next = update2;
                        } else {
                          update2.next = pending.next;
                          pending.next = update2;
                        }
                        sharedQueue.pending = update2;
                      }
                    }
                    fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
                    var alternate = fiber.alternate;
                    if (alternate !== null) {
                      alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);
                    }
                    scheduleContextWorkOnParentPath(fiber.return, renderLanes2, workInProgress2);
                    list.lanes = mergeLanes(list.lanes, renderLanes2);
                    break;
                  }
                  dependency = dependency.next;
                }
              } else if (fiber.tag === ContextProvider) {
                nextFiber = fiber.type === workInProgress2.type ? null : fiber.child;
              } else if (fiber.tag === DehydratedFragment) {
                var parentSuspense = fiber.return;
                if (parentSuspense === null) {
                  throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
                }
                parentSuspense.lanes = mergeLanes(parentSuspense.lanes, renderLanes2);
                var _alternate = parentSuspense.alternate;
                if (_alternate !== null) {
                  _alternate.lanes = mergeLanes(_alternate.lanes, renderLanes2);
                }
                scheduleContextWorkOnParentPath(parentSuspense, renderLanes2, workInProgress2);
                nextFiber = fiber.sibling;
              } else {
                nextFiber = fiber.child;
              }
              if (nextFiber !== null) {
                nextFiber.return = fiber;
              } else {
                nextFiber = fiber;
                while (nextFiber !== null) {
                  if (nextFiber === workInProgress2) {
                    nextFiber = null;
                    break;
                  }
                  var sibling = nextFiber.sibling;
                  if (sibling !== null) {
                    sibling.return = nextFiber.return;
                    nextFiber = sibling;
                    break;
                  }
                  nextFiber = nextFiber.return;
                }
              }
              fiber = nextFiber;
            }
          }
          function prepareToReadContext(workInProgress2, renderLanes2) {
            currentlyRenderingFiber = workInProgress2;
            lastContextDependency = null;
            lastFullyObservedContext = null;
            var dependencies = workInProgress2.dependencies;
            if (dependencies !== null) {
              {
                var firstContext = dependencies.firstContext;
                if (firstContext !== null) {
                  if (includesSomeLane(dependencies.lanes, renderLanes2)) {
                    markWorkInProgressReceivedUpdate();
                  }
                  dependencies.firstContext = null;
                }
              }
            }
          }
          function readContext(context) {
            {
              if (isDisallowedContextReadInDEV) {
                error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
              }
            }
            var value = context._currentValue;
            if (lastFullyObservedContext === context)
              ;
            else {
              var contextItem = {
                context,
                memoizedValue: value,
                next: null
              };
              if (lastContextDependency === null) {
                if (currentlyRenderingFiber === null) {
                  throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
                }
                lastContextDependency = contextItem;
                currentlyRenderingFiber.dependencies = {
                  lanes: NoLanes,
                  firstContext: contextItem
                };
              } else {
                lastContextDependency = lastContextDependency.next = contextItem;
              }
            }
            return value;
          }
          var concurrentQueues = null;
          function pushConcurrentUpdateQueue(queue) {
            if (concurrentQueues === null) {
              concurrentQueues = [queue];
            } else {
              concurrentQueues.push(queue);
            }
          }
          function finishQueueingConcurrentUpdates() {
            if (concurrentQueues !== null) {
              for (var i7 = 0; i7 < concurrentQueues.length; i7++) {
                var queue = concurrentQueues[i7];
                var lastInterleavedUpdate = queue.interleaved;
                if (lastInterleavedUpdate !== null) {
                  queue.interleaved = null;
                  var firstInterleavedUpdate = lastInterleavedUpdate.next;
                  var lastPendingUpdate = queue.pending;
                  if (lastPendingUpdate !== null) {
                    var firstPendingUpdate = lastPendingUpdate.next;
                    lastPendingUpdate.next = firstInterleavedUpdate;
                    lastInterleavedUpdate.next = firstPendingUpdate;
                  }
                  queue.pending = lastInterleavedUpdate;
                }
              }
              concurrentQueues = null;
            }
          }
          function enqueueConcurrentHookUpdate(fiber, queue, update2, lane) {
            var interleaved = queue.interleaved;
            if (interleaved === null) {
              update2.next = update2;
              pushConcurrentUpdateQueue(queue);
            } else {
              update2.next = interleaved.next;
              interleaved.next = update2;
            }
            queue.interleaved = update2;
            return markUpdateLaneFromFiberToRoot(fiber, lane);
          }
          function enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update2, lane) {
            var interleaved = queue.interleaved;
            if (interleaved === null) {
              update2.next = update2;
              pushConcurrentUpdateQueue(queue);
            } else {
              update2.next = interleaved.next;
              interleaved.next = update2;
            }
            queue.interleaved = update2;
          }
          function enqueueConcurrentClassUpdate(fiber, queue, update2, lane) {
            var interleaved = queue.interleaved;
            if (interleaved === null) {
              update2.next = update2;
              pushConcurrentUpdateQueue(queue);
            } else {
              update2.next = interleaved.next;
              interleaved.next = update2;
            }
            queue.interleaved = update2;
            return markUpdateLaneFromFiberToRoot(fiber, lane);
          }
          function enqueueConcurrentRenderForLane(fiber, lane) {
            return markUpdateLaneFromFiberToRoot(fiber, lane);
          }
          var unsafe_markUpdateLaneFromFiberToRoot = markUpdateLaneFromFiberToRoot;
          function markUpdateLaneFromFiberToRoot(sourceFiber, lane) {
            sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);
            var alternate = sourceFiber.alternate;
            if (alternate !== null) {
              alternate.lanes = mergeLanes(alternate.lanes, lane);
            }
            {
              if (alternate === null && (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags) {
                warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
              }
            }
            var node = sourceFiber;
            var parent = sourceFiber.return;
            while (parent !== null) {
              parent.childLanes = mergeLanes(parent.childLanes, lane);
              alternate = parent.alternate;
              if (alternate !== null) {
                alternate.childLanes = mergeLanes(alternate.childLanes, lane);
              } else {
                {
                  if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {
                    warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
                  }
                }
              }
              node = parent;
              parent = parent.return;
            }
            if (node.tag === HostRoot) {
              var root3 = node.stateNode;
              return root3;
            } else {
              return null;
            }
          }
          var UpdateState = 0;
          var ReplaceState = 1;
          var ForceUpdate = 2;
          var CaptureUpdate = 3;
          var hasForceUpdate = false;
          var didWarnUpdateInsideUpdate;
          var currentlyProcessingQueue;
          {
            didWarnUpdateInsideUpdate = false;
            currentlyProcessingQueue = null;
          }
          function initializeUpdateQueue(fiber) {
            var queue = {
              baseState: fiber.memoizedState,
              firstBaseUpdate: null,
              lastBaseUpdate: null,
              shared: {
                pending: null,
                interleaved: null,
                lanes: NoLanes
              },
              effects: null
            };
            fiber.updateQueue = queue;
          }
          function cloneUpdateQueue(current2, workInProgress2) {
            var queue = workInProgress2.updateQueue;
            var currentQueue = current2.updateQueue;
            if (queue === currentQueue) {
              var clone = {
                baseState: currentQueue.baseState,
                firstBaseUpdate: currentQueue.firstBaseUpdate,
                lastBaseUpdate: currentQueue.lastBaseUpdate,
                shared: currentQueue.shared,
                effects: currentQueue.effects
              };
              workInProgress2.updateQueue = clone;
            }
          }
          function createUpdate(eventTime, lane) {
            var update2 = {
              eventTime,
              lane,
              tag: UpdateState,
              payload: null,
              callback: null,
              next: null
            };
            return update2;
          }
          function enqueueUpdate(fiber, update2, lane) {
            var updateQueue = fiber.updateQueue;
            if (updateQueue === null) {
              return null;
            }
            var sharedQueue = updateQueue.shared;
            {
              if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {
                error("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.");
                didWarnUpdateInsideUpdate = true;
              }
            }
            if (isUnsafeClassRenderPhaseUpdate()) {
              var pending = sharedQueue.pending;
              if (pending === null) {
                update2.next = update2;
              } else {
                update2.next = pending.next;
                pending.next = update2;
              }
              sharedQueue.pending = update2;
              return unsafe_markUpdateLaneFromFiberToRoot(fiber, lane);
            } else {
              return enqueueConcurrentClassUpdate(fiber, sharedQueue, update2, lane);
            }
          }
          function entangleTransitions(root3, fiber, lane) {
            var updateQueue = fiber.updateQueue;
            if (updateQueue === null) {
              return;
            }
            var sharedQueue = updateQueue.shared;
            if (isTransitionLane(lane)) {
              var queueLanes = sharedQueue.lanes;
              queueLanes = intersectLanes(queueLanes, root3.pendingLanes);
              var newQueueLanes = mergeLanes(queueLanes, lane);
              sharedQueue.lanes = newQueueLanes;
              markRootEntangled(root3, newQueueLanes);
            }
          }
          function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
            var queue = workInProgress2.updateQueue;
            var current2 = workInProgress2.alternate;
            if (current2 !== null) {
              var currentQueue = current2.updateQueue;
              if (queue === currentQueue) {
                var newFirst = null;
                var newLast = null;
                var firstBaseUpdate = queue.firstBaseUpdate;
                if (firstBaseUpdate !== null) {
                  var update2 = firstBaseUpdate;
                  do {
                    var clone = {
                      eventTime: update2.eventTime,
                      lane: update2.lane,
                      tag: update2.tag,
                      payload: update2.payload,
                      callback: update2.callback,
                      next: null
                    };
                    if (newLast === null) {
                      newFirst = newLast = clone;
                    } else {
                      newLast.next = clone;
                      newLast = clone;
                    }
                    update2 = update2.next;
                  } while (update2 !== null);
                  if (newLast === null) {
                    newFirst = newLast = capturedUpdate;
                  } else {
                    newLast.next = capturedUpdate;
                    newLast = capturedUpdate;
                  }
                } else {
                  newFirst = newLast = capturedUpdate;
                }
                queue = {
                  baseState: currentQueue.baseState,
                  firstBaseUpdate: newFirst,
                  lastBaseUpdate: newLast,
                  shared: currentQueue.shared,
                  effects: currentQueue.effects
                };
                workInProgress2.updateQueue = queue;
                return;
              }
            }
            var lastBaseUpdate = queue.lastBaseUpdate;
            if (lastBaseUpdate === null) {
              queue.firstBaseUpdate = capturedUpdate;
            } else {
              lastBaseUpdate.next = capturedUpdate;
            }
            queue.lastBaseUpdate = capturedUpdate;
          }
          function getStateFromUpdate(workInProgress2, queue, update2, prevState, nextProps, instance) {
            switch (update2.tag) {
              case ReplaceState: {
                var payload = update2.payload;
                if (typeof payload === "function") {
                  {
                    enterDisallowedContextReadInDEV();
                  }
                  var nextState = payload.call(instance, prevState, nextProps);
                  {
                    if (workInProgress2.mode & StrictLegacyMode) {
                      setIsStrictModeForDevtools(true);
                      try {
                        payload.call(instance, prevState, nextProps);
                      } finally {
                        setIsStrictModeForDevtools(false);
                      }
                    }
                    exitDisallowedContextReadInDEV();
                  }
                  return nextState;
                }
                return payload;
              }
              case CaptureUpdate: {
                workInProgress2.flags = workInProgress2.flags & ~ShouldCapture | DidCapture;
              }
              case UpdateState: {
                var _payload = update2.payload;
                var partialState;
                if (typeof _payload === "function") {
                  {
                    enterDisallowedContextReadInDEV();
                  }
                  partialState = _payload.call(instance, prevState, nextProps);
                  {
                    if (workInProgress2.mode & StrictLegacyMode) {
                      setIsStrictModeForDevtools(true);
                      try {
                        _payload.call(instance, prevState, nextProps);
                      } finally {
                        setIsStrictModeForDevtools(false);
                      }
                    }
                    exitDisallowedContextReadInDEV();
                  }
                } else {
                  partialState = _payload;
                }
                if (partialState === null || partialState === void 0) {
                  return prevState;
                }
                return assign({}, prevState, partialState);
              }
              case ForceUpdate: {
                hasForceUpdate = true;
                return prevState;
              }
            }
            return prevState;
          }
          function processUpdateQueue(workInProgress2, props, instance, renderLanes2) {
            var queue = workInProgress2.updateQueue;
            hasForceUpdate = false;
            {
              currentlyProcessingQueue = queue.shared;
            }
            var firstBaseUpdate = queue.firstBaseUpdate;
            var lastBaseUpdate = queue.lastBaseUpdate;
            var pendingQueue = queue.shared.pending;
            if (pendingQueue !== null) {
              queue.shared.pending = null;
              var lastPendingUpdate = pendingQueue;
              var firstPendingUpdate = lastPendingUpdate.next;
              lastPendingUpdate.next = null;
              if (lastBaseUpdate === null) {
                firstBaseUpdate = firstPendingUpdate;
              } else {
                lastBaseUpdate.next = firstPendingUpdate;
              }
              lastBaseUpdate = lastPendingUpdate;
              var current2 = workInProgress2.alternate;
              if (current2 !== null) {
                var currentQueue = current2.updateQueue;
                var currentLastBaseUpdate = currentQueue.lastBaseUpdate;
                if (currentLastBaseUpdate !== lastBaseUpdate) {
                  if (currentLastBaseUpdate === null) {
                    currentQueue.firstBaseUpdate = firstPendingUpdate;
                  } else {
                    currentLastBaseUpdate.next = firstPendingUpdate;
                  }
                  currentQueue.lastBaseUpdate = lastPendingUpdate;
                }
              }
            }
            if (firstBaseUpdate !== null) {
              var newState = queue.baseState;
              var newLanes = NoLanes;
              var newBaseState = null;
              var newFirstBaseUpdate = null;
              var newLastBaseUpdate = null;
              var update2 = firstBaseUpdate;
              do {
                var updateLane = update2.lane;
                var updateEventTime = update2.eventTime;
                if (!isSubsetOfLanes(renderLanes2, updateLane)) {
                  var clone = {
                    eventTime: updateEventTime,
                    lane: updateLane,
                    tag: update2.tag,
                    payload: update2.payload,
                    callback: update2.callback,
                    next: null
                  };
                  if (newLastBaseUpdate === null) {
                    newFirstBaseUpdate = newLastBaseUpdate = clone;
                    newBaseState = newState;
                  } else {
                    newLastBaseUpdate = newLastBaseUpdate.next = clone;
                  }
                  newLanes = mergeLanes(newLanes, updateLane);
                } else {
                  if (newLastBaseUpdate !== null) {
                    var _clone = {
                      eventTime: updateEventTime,
                      // This update is going to be committed so we never want uncommit
                      // it. Using NoLane works because 0 is a subset of all bitmasks, so
                      // this will never be skipped by the check above.
                      lane: NoLane,
                      tag: update2.tag,
                      payload: update2.payload,
                      callback: update2.callback,
                      next: null
                    };
                    newLastBaseUpdate = newLastBaseUpdate.next = _clone;
                  }
                  newState = getStateFromUpdate(workInProgress2, queue, update2, newState, props, instance);
                  var callback = update2.callback;
                  if (callback !== null && // If the update was already committed, we should not queue its
                  // callback again.
                  update2.lane !== NoLane) {
                    workInProgress2.flags |= Callback;
                    var effects = queue.effects;
                    if (effects === null) {
                      queue.effects = [update2];
                    } else {
                      effects.push(update2);
                    }
                  }
                }
                update2 = update2.next;
                if (update2 === null) {
                  pendingQueue = queue.shared.pending;
                  if (pendingQueue === null) {
                    break;
                  } else {
                    var _lastPendingUpdate = pendingQueue;
                    var _firstPendingUpdate = _lastPendingUpdate.next;
                    _lastPendingUpdate.next = null;
                    update2 = _firstPendingUpdate;
                    queue.lastBaseUpdate = _lastPendingUpdate;
                    queue.shared.pending = null;
                  }
                }
              } while (true);
              if (newLastBaseUpdate === null) {
                newBaseState = newState;
              }
              queue.baseState = newBaseState;
              queue.firstBaseUpdate = newFirstBaseUpdate;
              queue.lastBaseUpdate = newLastBaseUpdate;
              var lastInterleaved = queue.shared.interleaved;
              if (lastInterleaved !== null) {
                var interleaved = lastInterleaved;
                do {
                  newLanes = mergeLanes(newLanes, interleaved.lane);
                  interleaved = interleaved.next;
                } while (interleaved !== lastInterleaved);
              } else if (firstBaseUpdate === null) {
                queue.shared.lanes = NoLanes;
              }
              markSkippedUpdateLanes(newLanes);
              workInProgress2.lanes = newLanes;
              workInProgress2.memoizedState = newState;
            }
            {
              currentlyProcessingQueue = null;
            }
          }
          function callCallback(callback, context) {
            if (typeof callback !== "function") {
              throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + callback));
            }
            callback.call(context);
          }
          function resetHasForceUpdateBeforeProcessing() {
            hasForceUpdate = false;
          }
          function checkHasForceUpdateAfterProcessing() {
            return hasForceUpdate;
          }
          function commitUpdateQueue(finishedWork, finishedQueue, instance) {
            var effects = finishedQueue.effects;
            finishedQueue.effects = null;
            if (effects !== null) {
              for (var i7 = 0; i7 < effects.length; i7++) {
                var effect = effects[i7];
                var callback = effect.callback;
                if (callback !== null) {
                  effect.callback = null;
                  callCallback(callback, instance);
                }
              }
            }
          }
          var fakeInternalInstance = {};
          var emptyRefsObject = new React43.Component().refs;
          var didWarnAboutStateAssignmentForComponent;
          var didWarnAboutUninitializedState;
          var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
          var didWarnAboutLegacyLifecyclesAndDerivedState;
          var didWarnAboutUndefinedDerivedState;
          var warnOnUndefinedDerivedState;
          var warnOnInvalidCallback;
          var didWarnAboutDirectlyAssigningPropsToState;
          var didWarnAboutContextTypeAndContextTypes;
          var didWarnAboutInvalidateContextType;
          {
            didWarnAboutStateAssignmentForComponent = /* @__PURE__ */ new Set();
            didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
            didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
            didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
            didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
            didWarnAboutContextTypeAndContextTypes = /* @__PURE__ */ new Set();
            didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
            var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
            warnOnInvalidCallback = function(callback, callerName) {
              if (callback === null || typeof callback === "function") {
                return;
              }
              var key2 = callerName + "_" + callback;
              if (!didWarnOnInvalidCallback.has(key2)) {
                didWarnOnInvalidCallback.add(key2);
                error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
              }
            };
            warnOnUndefinedDerivedState = function(type, partialState) {
              if (partialState === void 0) {
                var componentName = getComponentNameFromType(type) || "Component";
                if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
                  didWarnAboutUndefinedDerivedState.add(componentName);
                  error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName);
                }
              }
            };
            Object.defineProperty(fakeInternalInstance, "_processChildContext", {
              enumerable: false,
              value: function() {
                throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
              }
            });
            Object.freeze(fakeInternalInstance);
          }
          function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
            var prevState = workInProgress2.memoizedState;
            var partialState = getDerivedStateFromProps(nextProps, prevState);
            {
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  partialState = getDerivedStateFromProps(nextProps, prevState);
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
              warnOnUndefinedDerivedState(ctor, partialState);
            }
            var memoizedState = partialState === null || partialState === void 0 ? prevState : assign({}, prevState, partialState);
            workInProgress2.memoizedState = memoizedState;
            if (workInProgress2.lanes === NoLanes) {
              var updateQueue = workInProgress2.updateQueue;
              updateQueue.baseState = memoizedState;
            }
          }
          var classComponentUpdater = {
            isMounted,
            enqueueSetState: function(inst, payload, callback) {
              var fiber = get2(inst);
              var eventTime = requestEventTime();
              var lane = requestUpdateLane(fiber);
              var update2 = createUpdate(eventTime, lane);
              update2.payload = payload;
              if (callback !== void 0 && callback !== null) {
                {
                  warnOnInvalidCallback(callback, "setState");
                }
                update2.callback = callback;
              }
              var root3 = enqueueUpdate(fiber, update2, lane);
              if (root3 !== null) {
                scheduleUpdateOnFiber(root3, fiber, lane, eventTime);
                entangleTransitions(root3, fiber, lane);
              }
              {
                markStateUpdateScheduled(fiber, lane);
              }
            },
            enqueueReplaceState: function(inst, payload, callback) {
              var fiber = get2(inst);
              var eventTime = requestEventTime();
              var lane = requestUpdateLane(fiber);
              var update2 = createUpdate(eventTime, lane);
              update2.tag = ReplaceState;
              update2.payload = payload;
              if (callback !== void 0 && callback !== null) {
                {
                  warnOnInvalidCallback(callback, "replaceState");
                }
                update2.callback = callback;
              }
              var root3 = enqueueUpdate(fiber, update2, lane);
              if (root3 !== null) {
                scheduleUpdateOnFiber(root3, fiber, lane, eventTime);
                entangleTransitions(root3, fiber, lane);
              }
              {
                markStateUpdateScheduled(fiber, lane);
              }
            },
            enqueueForceUpdate: function(inst, callback) {
              var fiber = get2(inst);
              var eventTime = requestEventTime();
              var lane = requestUpdateLane(fiber);
              var update2 = createUpdate(eventTime, lane);
              update2.tag = ForceUpdate;
              if (callback !== void 0 && callback !== null) {
                {
                  warnOnInvalidCallback(callback, "forceUpdate");
                }
                update2.callback = callback;
              }
              var root3 = enqueueUpdate(fiber, update2, lane);
              if (root3 !== null) {
                scheduleUpdateOnFiber(root3, fiber, lane, eventTime);
                entangleTransitions(root3, fiber, lane);
              }
              {
                markForceUpdateScheduled(fiber, lane);
              }
            }
          };
          function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
            var instance = workInProgress2.stateNode;
            if (typeof instance.shouldComponentUpdate === "function") {
              var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
              {
                if (workInProgress2.mode & StrictLegacyMode) {
                  setIsStrictModeForDevtools(true);
                  try {
                    shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
                  } finally {
                    setIsStrictModeForDevtools(false);
                  }
                }
                if (shouldUpdate === void 0) {
                  error("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", getComponentNameFromType(ctor) || "Component");
                }
              }
              return shouldUpdate;
            }
            if (ctor.prototype && ctor.prototype.isPureReactComponent) {
              return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);
            }
            return true;
          }
          function checkClassInstance(workInProgress2, ctor, newProps) {
            var instance = workInProgress2.stateNode;
            {
              var name2 = getComponentNameFromType(ctor) || "Component";
              var renderPresent = instance.render;
              if (!renderPresent) {
                if (ctor.prototype && typeof ctor.prototype.render === "function") {
                  error("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name2);
                } else {
                  error("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name2);
                }
              }
              if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {
                error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name2);
              }
              if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {
                error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name2);
              }
              if (instance.propTypes) {
                error("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name2);
              }
              if (instance.contextType) {
                error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name2);
              }
              {
                if (instance.contextTypes) {
                  error("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name2);
                }
                if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
                  didWarnAboutContextTypeAndContextTypes.add(ctor);
                  error("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name2);
                }
              }
              if (typeof instance.componentShouldUpdate === "function") {
                error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name2);
              }
              if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined") {
                error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(ctor) || "A pure component");
              }
              if (typeof instance.componentDidUnmount === "function") {
                error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name2);
              }
              if (typeof instance.componentDidReceiveProps === "function") {
                error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name2);
              }
              if (typeof instance.componentWillRecieveProps === "function") {
                error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name2);
              }
              if (typeof instance.UNSAFE_componentWillRecieveProps === "function") {
                error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name2);
              }
              var hasMutatedProps = instance.props !== newProps;
              if (instance.props !== void 0 && hasMutatedProps) {
                error("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name2, name2);
              }
              if (instance.defaultProps) {
                error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name2, name2);
              }
              if (typeof instance.getSnapshotBeforeUpdate === "function" && typeof instance.componentDidUpdate !== "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
                didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
                error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(ctor));
              }
              if (typeof instance.getDerivedStateFromProps === "function") {
                error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name2);
              }
              if (typeof instance.getDerivedStateFromError === "function") {
                error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name2);
              }
              if (typeof ctor.getSnapshotBeforeUpdate === "function") {
                error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name2);
              }
              var _state = instance.state;
              if (_state && (typeof _state !== "object" || isArray2(_state))) {
                error("%s.state: must be set to an object or null", name2);
              }
              if (typeof instance.getChildContext === "function" && typeof ctor.childContextTypes !== "object") {
                error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name2);
              }
            }
          }
          function adoptClassInstance(workInProgress2, instance) {
            instance.updater = classComponentUpdater;
            workInProgress2.stateNode = instance;
            set2(instance, workInProgress2);
            {
              instance._reactInternalInstance = fakeInternalInstance;
            }
          }
          function constructClassInstance(workInProgress2, ctor, props) {
            var isLegacyContextConsumer = false;
            var unmaskedContext = emptyContextObject;
            var context = emptyContextObject;
            var contextType = ctor.contextType;
            {
              if ("contextType" in ctor) {
                var isValid = (
                  // Allow null for conditional declaration
                  contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0
                );
                if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
                  didWarnAboutInvalidateContextType.add(ctor);
                  var addendum = "";
                  if (contextType === void 0) {
                    addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
                  } else if (typeof contextType !== "object") {
                    addendum = " However, it is set to a " + typeof contextType + ".";
                  } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                    addendum = " Did you accidentally pass the Context.Provider instead?";
                  } else if (contextType._context !== void 0) {
                    addendum = " Did you accidentally pass the Context.Consumer instead?";
                  } else {
                    addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
                  }
                  error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(ctor) || "Component", addendum);
                }
              }
            }
            if (typeof contextType === "object" && contextType !== null) {
              context = readContext(contextType);
            } else {
              unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
              var contextTypes = ctor.contextTypes;
              isLegacyContextConsumer = contextTypes !== null && contextTypes !== void 0;
              context = isLegacyContextConsumer ? getMaskedContext(workInProgress2, unmaskedContext) : emptyContextObject;
            }
            var instance = new ctor(props, context);
            {
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  instance = new ctor(props, context);
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
            }
            var state = workInProgress2.memoizedState = instance.state !== null && instance.state !== void 0 ? instance.state : null;
            adoptClassInstance(workInProgress2, instance);
            {
              if (typeof ctor.getDerivedStateFromProps === "function" && state === null) {
                var componentName = getComponentNameFromType(ctor) || "Component";
                if (!didWarnAboutUninitializedState.has(componentName)) {
                  didWarnAboutUninitializedState.add(componentName);
                  error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName);
                }
              }
              if (typeof ctor.getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function") {
                var foundWillMountName = null;
                var foundWillReceivePropsName = null;
                var foundWillUpdateName = null;
                if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
                  foundWillMountName = "componentWillMount";
                } else if (typeof instance.UNSAFE_componentWillMount === "function") {
                  foundWillMountName = "UNSAFE_componentWillMount";
                }
                if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
                  foundWillReceivePropsName = "componentWillReceiveProps";
                } else if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
                  foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
                }
                if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
                  foundWillUpdateName = "componentWillUpdate";
                } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
                  foundWillUpdateName = "UNSAFE_componentWillUpdate";
                }
                if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
                  var _componentName = getComponentNameFromType(ctor) || "Component";
                  var newApiName = typeof ctor.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                  if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                    didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                    error("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://reactjs.org/link/unsafe-component-lifecycles", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : "", foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "", foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "");
                  }
                }
              }
            }
            if (isLegacyContextConsumer) {
              cacheContext(workInProgress2, unmaskedContext, context);
            }
            return instance;
          }
          function callComponentWillMount(workInProgress2, instance) {
            var oldState = instance.state;
            if (typeof instance.componentWillMount === "function") {
              instance.componentWillMount();
            }
            if (typeof instance.UNSAFE_componentWillMount === "function") {
              instance.UNSAFE_componentWillMount();
            }
            if (oldState !== instance.state) {
              {
                error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromFiber(workInProgress2) || "Component");
              }
              classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
            }
          }
          function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
            var oldState = instance.state;
            if (typeof instance.componentWillReceiveProps === "function") {
              instance.componentWillReceiveProps(newProps, nextContext);
            }
            if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
              instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
            }
            if (instance.state !== oldState) {
              {
                var componentName = getComponentNameFromFiber(workInProgress2) || "Component";
                if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {
                  didWarnAboutStateAssignmentForComponent.add(componentName);
                  error("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", componentName);
                }
              }
              classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
            }
          }
          function mountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
            {
              checkClassInstance(workInProgress2, ctor, newProps);
            }
            var instance = workInProgress2.stateNode;
            instance.props = newProps;
            instance.state = workInProgress2.memoizedState;
            instance.refs = emptyRefsObject;
            initializeUpdateQueue(workInProgress2);
            var contextType = ctor.contextType;
            if (typeof contextType === "object" && contextType !== null) {
              instance.context = readContext(contextType);
            } else {
              var unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
              instance.context = getMaskedContext(workInProgress2, unmaskedContext);
            }
            {
              if (instance.state === newProps) {
                var componentName = getComponentNameFromType(ctor) || "Component";
                if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
                  didWarnAboutDirectlyAssigningPropsToState.add(componentName);
                  error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName);
                }
              }
              if (workInProgress2.mode & StrictLegacyMode) {
                ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, instance);
              }
              {
                ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress2, instance);
              }
            }
            instance.state = workInProgress2.memoizedState;
            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
            if (typeof getDerivedStateFromProps === "function") {
              applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
              instance.state = workInProgress2.memoizedState;
            }
            if (typeof ctor.getDerivedStateFromProps !== "function" && typeof instance.getSnapshotBeforeUpdate !== "function" && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
              callComponentWillMount(workInProgress2, instance);
              processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
              instance.state = workInProgress2.memoizedState;
            }
            if (typeof instance.componentDidMount === "function") {
              var fiberFlags = Update;
              {
                fiberFlags |= LayoutStatic;
              }
              if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                fiberFlags |= MountLayoutDev;
              }
              workInProgress2.flags |= fiberFlags;
            }
          }
          function resumeMountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
            var instance = workInProgress2.stateNode;
            var oldProps = workInProgress2.memoizedProps;
            instance.props = oldProps;
            var oldContext = instance.context;
            var contextType = ctor.contextType;
            var nextContext = emptyContextObject;
            if (typeof contextType === "object" && contextType !== null) {
              nextContext = readContext(contextType);
            } else {
              var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
              nextContext = getMaskedContext(workInProgress2, nextLegacyUnmaskedContext);
            }
            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
            var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";
            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
              if (oldProps !== newProps || oldContext !== nextContext) {
                callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext);
              }
            }
            resetHasForceUpdateBeforeProcessing();
            var oldState = workInProgress2.memoizedState;
            var newState = instance.state = oldState;
            processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
            newState = workInProgress2.memoizedState;
            if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
              if (typeof instance.componentDidMount === "function") {
                var fiberFlags = Update;
                {
                  fiberFlags |= LayoutStatic;
                }
                if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                  fiberFlags |= MountLayoutDev;
                }
                workInProgress2.flags |= fiberFlags;
              }
              return false;
            }
            if (typeof getDerivedStateFromProps === "function") {
              applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
              newState = workInProgress2.memoizedState;
            }
            var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext);
            if (shouldUpdate) {
              if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
                if (typeof instance.componentWillMount === "function") {
                  instance.componentWillMount();
                }
                if (typeof instance.UNSAFE_componentWillMount === "function") {
                  instance.UNSAFE_componentWillMount();
                }
              }
              if (typeof instance.componentDidMount === "function") {
                var _fiberFlags = Update;
                {
                  _fiberFlags |= LayoutStatic;
                }
                if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                  _fiberFlags |= MountLayoutDev;
                }
                workInProgress2.flags |= _fiberFlags;
              }
            } else {
              if (typeof instance.componentDidMount === "function") {
                var _fiberFlags2 = Update;
                {
                  _fiberFlags2 |= LayoutStatic;
                }
                if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                  _fiberFlags2 |= MountLayoutDev;
                }
                workInProgress2.flags |= _fiberFlags2;
              }
              workInProgress2.memoizedProps = newProps;
              workInProgress2.memoizedState = newState;
            }
            instance.props = newProps;
            instance.state = newState;
            instance.context = nextContext;
            return shouldUpdate;
          }
          function updateClassInstance(current2, workInProgress2, ctor, newProps, renderLanes2) {
            var instance = workInProgress2.stateNode;
            cloneUpdateQueue(current2, workInProgress2);
            var unresolvedOldProps = workInProgress2.memoizedProps;
            var oldProps = workInProgress2.type === workInProgress2.elementType ? unresolvedOldProps : resolveDefaultProps(workInProgress2.type, unresolvedOldProps);
            instance.props = oldProps;
            var unresolvedNewProps = workInProgress2.pendingProps;
            var oldContext = instance.context;
            var contextType = ctor.contextType;
            var nextContext = emptyContextObject;
            if (typeof contextType === "object" && contextType !== null) {
              nextContext = readContext(contextType);
            } else {
              var nextUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
              nextContext = getMaskedContext(workInProgress2, nextUnmaskedContext);
            }
            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
            var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";
            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
              if (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) {
                callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext);
              }
            }
            resetHasForceUpdateBeforeProcessing();
            var oldState = workInProgress2.memoizedState;
            var newState = instance.state = oldState;
            processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
            newState = workInProgress2.memoizedState;
            if (unresolvedOldProps === unresolvedNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing() && !enableLazyContextPropagation) {
              if (typeof instance.componentDidUpdate === "function") {
                if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                  workInProgress2.flags |= Update;
                }
              }
              if (typeof instance.getSnapshotBeforeUpdate === "function") {
                if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                  workInProgress2.flags |= Snapshot;
                }
              }
              return false;
            }
            if (typeof getDerivedStateFromProps === "function") {
              applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
              newState = workInProgress2.memoizedState;
            }
            var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) || // TODO: In some cases, we'll end up checking if context has changed twice,
            // both before and after `shouldComponentUpdate` has been called. Not ideal,
            // but I'm loath to refactor this function. This only happens for memoized
            // components so it's not that common.
            enableLazyContextPropagation;
            if (shouldUpdate) {
              if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === "function" || typeof instance.componentWillUpdate === "function")) {
                if (typeof instance.componentWillUpdate === "function") {
                  instance.componentWillUpdate(newProps, newState, nextContext);
                }
                if (typeof instance.UNSAFE_componentWillUpdate === "function") {
                  instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);
                }
              }
              if (typeof instance.componentDidUpdate === "function") {
                workInProgress2.flags |= Update;
              }
              if (typeof instance.getSnapshotBeforeUpdate === "function") {
                workInProgress2.flags |= Snapshot;
              }
            } else {
              if (typeof instance.componentDidUpdate === "function") {
                if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                  workInProgress2.flags |= Update;
                }
              }
              if (typeof instance.getSnapshotBeforeUpdate === "function") {
                if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                  workInProgress2.flags |= Snapshot;
                }
              }
              workInProgress2.memoizedProps = newProps;
              workInProgress2.memoizedState = newState;
            }
            instance.props = newProps;
            instance.state = newState;
            instance.context = nextContext;
            return shouldUpdate;
          }
          var didWarnAboutMaps;
          var didWarnAboutGenerators;
          var didWarnAboutStringRefs;
          var ownerHasKeyUseWarning;
          var ownerHasFunctionTypeWarning;
          var warnForMissingKey = function(child, returnFiber) {
          };
          {
            didWarnAboutMaps = false;
            didWarnAboutGenerators = false;
            didWarnAboutStringRefs = {};
            ownerHasKeyUseWarning = {};
            ownerHasFunctionTypeWarning = {};
            warnForMissingKey = function(child, returnFiber) {
              if (child === null || typeof child !== "object") {
                return;
              }
              if (!child._store || child._store.validated || child.key != null) {
                return;
              }
              if (typeof child._store !== "object") {
                throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
              }
              child._store.validated = true;
              var componentName = getComponentNameFromFiber(returnFiber) || "Component";
              if (ownerHasKeyUseWarning[componentName]) {
                return;
              }
              ownerHasKeyUseWarning[componentName] = true;
              error('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.');
            };
          }
          function coerceRef(returnFiber, current2, element) {
            var mixedRef = element.ref;
            if (mixedRef !== null && typeof mixedRef !== "function" && typeof mixedRef !== "object") {
              {
                if ((returnFiber.mode & StrictLegacyMode || warnAboutStringRefs) && // We warn in ReactElement.js if owner and self are equal for string refs
                // because these cannot be automatically converted to an arrow function
                // using a codemod. Therefore, we don't have to warn about string refs again.
                !(element._owner && element._self && element._owner.stateNode !== element._self)) {
                  var componentName = getComponentNameFromFiber(returnFiber) || "Component";
                  if (!didWarnAboutStringRefs[componentName]) {
                    {
                      error('A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', mixedRef);
                    }
                    didWarnAboutStringRefs[componentName] = true;
                  }
                }
              }
              if (element._owner) {
                var owner = element._owner;
                var inst;
                if (owner) {
                  var ownerFiber = owner;
                  if (ownerFiber.tag !== ClassComponent) {
                    throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
                  }
                  inst = ownerFiber.stateNode;
                }
                if (!inst) {
                  throw new Error("Missing owner for string ref " + mixedRef + ". This error is likely caused by a bug in React. Please file an issue.");
                }
                var resolvedInst = inst;
                {
                  checkPropStringCoercion(mixedRef, "ref");
                }
                var stringRef = "" + mixedRef;
                if (current2 !== null && current2.ref !== null && typeof current2.ref === "function" && current2.ref._stringRef === stringRef) {
                  return current2.ref;
                }
                var ref = function(value) {
                  var refs = resolvedInst.refs;
                  if (refs === emptyRefsObject) {
                    refs = resolvedInst.refs = {};
                  }
                  if (value === null) {
                    delete refs[stringRef];
                  } else {
                    refs[stringRef] = value;
                  }
                };
                ref._stringRef = stringRef;
                return ref;
              } else {
                if (typeof mixedRef !== "string") {
                  throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
                }
                if (!element._owner) {
                  throw new Error("Element ref was specified as a string (" + mixedRef + ") but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component's render method\n3. You have multiple copies of React loaded\nSee https://reactjs.org/link/refs-must-have-owner for more information.");
                }
              }
            }
            return mixedRef;
          }
          function throwOnInvalidObjectType(returnFiber, newChild) {
            var childString = Object.prototype.toString.call(newChild);
            throw new Error("Objects are not valid as a React child (found: " + (childString === "[object Object]" ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : childString) + "). If you meant to render a collection of children, use an array instead.");
          }
          function warnOnFunctionType(returnFiber) {
            {
              var componentName = getComponentNameFromFiber(returnFiber) || "Component";
              if (ownerHasFunctionTypeWarning[componentName]) {
                return;
              }
              ownerHasFunctionTypeWarning[componentName] = true;
              error("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
            }
          }
          function resolveLazy(lazyType) {
            var payload = lazyType._payload;
            var init2 = lazyType._init;
            return init2(payload);
          }
          function ChildReconciler(shouldTrackSideEffects) {
            function deleteChild(returnFiber, childToDelete) {
              if (!shouldTrackSideEffects) {
                return;
              }
              var deletions = returnFiber.deletions;
              if (deletions === null) {
                returnFiber.deletions = [childToDelete];
                returnFiber.flags |= ChildDeletion;
              } else {
                deletions.push(childToDelete);
              }
            }
            function deleteRemainingChildren(returnFiber, currentFirstChild) {
              if (!shouldTrackSideEffects) {
                return null;
              }
              var childToDelete = currentFirstChild;
              while (childToDelete !== null) {
                deleteChild(returnFiber, childToDelete);
                childToDelete = childToDelete.sibling;
              }
              return null;
            }
            function mapRemainingChildren(returnFiber, currentFirstChild) {
              var existingChildren = /* @__PURE__ */ new Map();
              var existingChild = currentFirstChild;
              while (existingChild !== null) {
                if (existingChild.key !== null) {
                  existingChildren.set(existingChild.key, existingChild);
                } else {
                  existingChildren.set(existingChild.index, existingChild);
                }
                existingChild = existingChild.sibling;
              }
              return existingChildren;
            }
            function useFiber(fiber, pendingProps) {
              var clone = createWorkInProgress(fiber, pendingProps);
              clone.index = 0;
              clone.sibling = null;
              return clone;
            }
            function placeChild(newFiber, lastPlacedIndex, newIndex) {
              newFiber.index = newIndex;
              if (!shouldTrackSideEffects) {
                newFiber.flags |= Forked;
                return lastPlacedIndex;
              }
              var current2 = newFiber.alternate;
              if (current2 !== null) {
                var oldIndex = current2.index;
                if (oldIndex < lastPlacedIndex) {
                  newFiber.flags |= Placement;
                  return lastPlacedIndex;
                } else {
                  return oldIndex;
                }
              } else {
                newFiber.flags |= Placement;
                return lastPlacedIndex;
              }
            }
            function placeSingleChild(newFiber) {
              if (shouldTrackSideEffects && newFiber.alternate === null) {
                newFiber.flags |= Placement;
              }
              return newFiber;
            }
            function updateTextNode(returnFiber, current2, textContent, lanes) {
              if (current2 === null || current2.tag !== HostText) {
                var created = createFiberFromText(textContent, returnFiber.mode, lanes);
                created.return = returnFiber;
                return created;
              } else {
                var existing = useFiber(current2, textContent);
                existing.return = returnFiber;
                return existing;
              }
            }
            function updateElement(returnFiber, current2, element, lanes) {
              var elementType = element.type;
              if (elementType === REACT_FRAGMENT_TYPE) {
                return updateFragment2(returnFiber, current2, element.props.children, lanes, element.key);
              }
              if (current2 !== null) {
                if (current2.elementType === elementType || // Keep this check inline so it only runs on the false path:
                isCompatibleFamilyForHotReloading(current2, element) || // Lazy types should reconcile their resolved type.
                // We need to do this after the Hot Reloading check above,
                // because hot reloading has different semantics than prod because
                // it doesn't resuspend. So we can't let the call below suspend.
                typeof elementType === "object" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current2.type) {
                  var existing = useFiber(current2, element.props);
                  existing.ref = coerceRef(returnFiber, current2, element);
                  existing.return = returnFiber;
                  {
                    existing._debugSource = element._source;
                    existing._debugOwner = element._owner;
                  }
                  return existing;
                }
              }
              var created = createFiberFromElement(element, returnFiber.mode, lanes);
              created.ref = coerceRef(returnFiber, current2, element);
              created.return = returnFiber;
              return created;
            }
            function updatePortal(returnFiber, current2, portal, lanes) {
              if (current2 === null || current2.tag !== HostPortal || current2.stateNode.containerInfo !== portal.containerInfo || current2.stateNode.implementation !== portal.implementation) {
                var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
                created.return = returnFiber;
                return created;
              } else {
                var existing = useFiber(current2, portal.children || []);
                existing.return = returnFiber;
                return existing;
              }
            }
            function updateFragment2(returnFiber, current2, fragment, lanes, key2) {
              if (current2 === null || current2.tag !== Fragment2) {
                var created = createFiberFromFragment(fragment, returnFiber.mode, lanes, key2);
                created.return = returnFiber;
                return created;
              } else {
                var existing = useFiber(current2, fragment);
                existing.return = returnFiber;
                return existing;
              }
            }
            function createChild(returnFiber, newChild, lanes) {
              if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
                var created = createFiberFromText("" + newChild, returnFiber.mode, lanes);
                created.return = returnFiber;
                return created;
              }
              if (typeof newChild === "object" && newChild !== null) {
                switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE: {
                    var _created = createFiberFromElement(newChild, returnFiber.mode, lanes);
                    _created.ref = coerceRef(returnFiber, null, newChild);
                    _created.return = returnFiber;
                    return _created;
                  }
                  case REACT_PORTAL_TYPE: {
                    var _created2 = createFiberFromPortal(newChild, returnFiber.mode, lanes);
                    _created2.return = returnFiber;
                    return _created2;
                  }
                  case REACT_LAZY_TYPE: {
                    var payload = newChild._payload;
                    var init2 = newChild._init;
                    return createChild(returnFiber, init2(payload), lanes);
                  }
                }
                if (isArray2(newChild) || getIteratorFn(newChild)) {
                  var _created3 = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);
                  _created3.return = returnFiber;
                  return _created3;
                }
                throwOnInvalidObjectType(returnFiber, newChild);
              }
              {
                if (typeof newChild === "function") {
                  warnOnFunctionType(returnFiber);
                }
              }
              return null;
            }
            function updateSlot(returnFiber, oldFiber, newChild, lanes) {
              var key2 = oldFiber !== null ? oldFiber.key : null;
              if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
                if (key2 !== null) {
                  return null;
                }
                return updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
              }
              if (typeof newChild === "object" && newChild !== null) {
                switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE: {
                    if (newChild.key === key2) {
                      return updateElement(returnFiber, oldFiber, newChild, lanes);
                    } else {
                      return null;
                    }
                  }
                  case REACT_PORTAL_TYPE: {
                    if (newChild.key === key2) {
                      return updatePortal(returnFiber, oldFiber, newChild, lanes);
                    } else {
                      return null;
                    }
                  }
                  case REACT_LAZY_TYPE: {
                    var payload = newChild._payload;
                    var init2 = newChild._init;
                    return updateSlot(returnFiber, oldFiber, init2(payload), lanes);
                  }
                }
                if (isArray2(newChild) || getIteratorFn(newChild)) {
                  if (key2 !== null) {
                    return null;
                  }
                  return updateFragment2(returnFiber, oldFiber, newChild, lanes, null);
                }
                throwOnInvalidObjectType(returnFiber, newChild);
              }
              {
                if (typeof newChild === "function") {
                  warnOnFunctionType(returnFiber);
                }
              }
              return null;
            }
            function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
              if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
                var matchedFiber = existingChildren.get(newIdx) || null;
                return updateTextNode(returnFiber, matchedFiber, "" + newChild, lanes);
              }
              if (typeof newChild === "object" && newChild !== null) {
                switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE: {
                    var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                    return updateElement(returnFiber, _matchedFiber, newChild, lanes);
                  }
                  case REACT_PORTAL_TYPE: {
                    var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                    return updatePortal(returnFiber, _matchedFiber2, newChild, lanes);
                  }
                  case REACT_LAZY_TYPE:
                    var payload = newChild._payload;
                    var init2 = newChild._init;
                    return updateFromMap(existingChildren, returnFiber, newIdx, init2(payload), lanes);
                }
                if (isArray2(newChild) || getIteratorFn(newChild)) {
                  var _matchedFiber3 = existingChildren.get(newIdx) || null;
                  return updateFragment2(returnFiber, _matchedFiber3, newChild, lanes, null);
                }
                throwOnInvalidObjectType(returnFiber, newChild);
              }
              {
                if (typeof newChild === "function") {
                  warnOnFunctionType(returnFiber);
                }
              }
              return null;
            }
            function warnOnInvalidKey(child, knownKeys, returnFiber) {
              {
                if (typeof child !== "object" || child === null) {
                  return knownKeys;
                }
                switch (child.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                  case REACT_PORTAL_TYPE:
                    warnForMissingKey(child, returnFiber);
                    var key2 = child.key;
                    if (typeof key2 !== "string") {
                      break;
                    }
                    if (knownKeys === null) {
                      knownKeys = /* @__PURE__ */ new Set();
                      knownKeys.add(key2);
                      break;
                    }
                    if (!knownKeys.has(key2)) {
                      knownKeys.add(key2);
                      break;
                    }
                    error("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \u2014 the behavior is unsupported and could change in a future version.", key2);
                    break;
                  case REACT_LAZY_TYPE:
                    var payload = child._payload;
                    var init2 = child._init;
                    warnOnInvalidKey(init2(payload), knownKeys, returnFiber);
                    break;
                }
              }
              return knownKeys;
            }
            function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
              {
                var knownKeys = null;
                for (var i7 = 0; i7 < newChildren.length; i7++) {
                  var child = newChildren[i7];
                  knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
                }
              }
              var resultingFirstChild = null;
              var previousNewFiber = null;
              var oldFiber = currentFirstChild;
              var lastPlacedIndex = 0;
              var newIdx = 0;
              var nextOldFiber = null;
              for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
                if (oldFiber.index > newIdx) {
                  nextOldFiber = oldFiber;
                  oldFiber = null;
                } else {
                  nextOldFiber = oldFiber.sibling;
                }
                var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);
                if (newFiber === null) {
                  if (oldFiber === null) {
                    oldFiber = nextOldFiber;
                  }
                  break;
                }
                if (shouldTrackSideEffects) {
                  if (oldFiber && newFiber.alternate === null) {
                    deleteChild(returnFiber, oldFiber);
                  }
                }
                lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = newFiber;
                } else {
                  previousNewFiber.sibling = newFiber;
                }
                previousNewFiber = newFiber;
                oldFiber = nextOldFiber;
              }
              if (newIdx === newChildren.length) {
                deleteRemainingChildren(returnFiber, oldFiber);
                if (getIsHydrating()) {
                  var numberOfForks = newIdx;
                  pushTreeFork(returnFiber, numberOfForks);
                }
                return resultingFirstChild;
              }
              if (oldFiber === null) {
                for (; newIdx < newChildren.length; newIdx++) {
                  var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes);
                  if (_newFiber === null) {
                    continue;
                  }
                  lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);
                  if (previousNewFiber === null) {
                    resultingFirstChild = _newFiber;
                  } else {
                    previousNewFiber.sibling = _newFiber;
                  }
                  previousNewFiber = _newFiber;
                }
                if (getIsHydrating()) {
                  var _numberOfForks = newIdx;
                  pushTreeFork(returnFiber, _numberOfForks);
                }
                return resultingFirstChild;
              }
              var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
              for (; newIdx < newChildren.length; newIdx++) {
                var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);
                if (_newFiber2 !== null) {
                  if (shouldTrackSideEffects) {
                    if (_newFiber2.alternate !== null) {
                      existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);
                    }
                  }
                  lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);
                  if (previousNewFiber === null) {
                    resultingFirstChild = _newFiber2;
                  } else {
                    previousNewFiber.sibling = _newFiber2;
                  }
                  previousNewFiber = _newFiber2;
                }
              }
              if (shouldTrackSideEffects) {
                existingChildren.forEach(function(child2) {
                  return deleteChild(returnFiber, child2);
                });
              }
              if (getIsHydrating()) {
                var _numberOfForks2 = newIdx;
                pushTreeFork(returnFiber, _numberOfForks2);
              }
              return resultingFirstChild;
            }
            function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, lanes) {
              var iteratorFn = getIteratorFn(newChildrenIterable);
              if (typeof iteratorFn !== "function") {
                throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
              }
              {
                if (typeof Symbol === "function" && // $FlowFixMe Flow doesn't know about toStringTag
                newChildrenIterable[Symbol.toStringTag] === "Generator") {
                  if (!didWarnAboutGenerators) {
                    error("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.");
                  }
                  didWarnAboutGenerators = true;
                }
                if (newChildrenIterable.entries === iteratorFn) {
                  if (!didWarnAboutMaps) {
                    error("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                  }
                  didWarnAboutMaps = true;
                }
                var _newChildren = iteratorFn.call(newChildrenIterable);
                if (_newChildren) {
                  var knownKeys = null;
                  var _step = _newChildren.next();
                  for (; !_step.done; _step = _newChildren.next()) {
                    var child = _step.value;
                    knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
                  }
                }
              }
              var newChildren = iteratorFn.call(newChildrenIterable);
              if (newChildren == null) {
                throw new Error("An iterable object provided no iterator.");
              }
              var resultingFirstChild = null;
              var previousNewFiber = null;
              var oldFiber = currentFirstChild;
              var lastPlacedIndex = 0;
              var newIdx = 0;
              var nextOldFiber = null;
              var step = newChildren.next();
              for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
                if (oldFiber.index > newIdx) {
                  nextOldFiber = oldFiber;
                  oldFiber = null;
                } else {
                  nextOldFiber = oldFiber.sibling;
                }
                var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
                if (newFiber === null) {
                  if (oldFiber === null) {
                    oldFiber = nextOldFiber;
                  }
                  break;
                }
                if (shouldTrackSideEffects) {
                  if (oldFiber && newFiber.alternate === null) {
                    deleteChild(returnFiber, oldFiber);
                  }
                }
                lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = newFiber;
                } else {
                  previousNewFiber.sibling = newFiber;
                }
                previousNewFiber = newFiber;
                oldFiber = nextOldFiber;
              }
              if (step.done) {
                deleteRemainingChildren(returnFiber, oldFiber);
                if (getIsHydrating()) {
                  var numberOfForks = newIdx;
                  pushTreeFork(returnFiber, numberOfForks);
                }
                return resultingFirstChild;
              }
              if (oldFiber === null) {
                for (; !step.done; newIdx++, step = newChildren.next()) {
                  var _newFiber3 = createChild(returnFiber, step.value, lanes);
                  if (_newFiber3 === null) {
                    continue;
                  }
                  lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);
                  if (previousNewFiber === null) {
                    resultingFirstChild = _newFiber3;
                  } else {
                    previousNewFiber.sibling = _newFiber3;
                  }
                  previousNewFiber = _newFiber3;
                }
                if (getIsHydrating()) {
                  var _numberOfForks3 = newIdx;
                  pushTreeFork(returnFiber, _numberOfForks3);
                }
                return resultingFirstChild;
              }
              var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
              for (; !step.done; newIdx++, step = newChildren.next()) {
                var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes);
                if (_newFiber4 !== null) {
                  if (shouldTrackSideEffects) {
                    if (_newFiber4.alternate !== null) {
                      existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);
                    }
                  }
                  lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);
                  if (previousNewFiber === null) {
                    resultingFirstChild = _newFiber4;
                  } else {
                    previousNewFiber.sibling = _newFiber4;
                  }
                  previousNewFiber = _newFiber4;
                }
              }
              if (shouldTrackSideEffects) {
                existingChildren.forEach(function(child2) {
                  return deleteChild(returnFiber, child2);
                });
              }
              if (getIsHydrating()) {
                var _numberOfForks4 = newIdx;
                pushTreeFork(returnFiber, _numberOfForks4);
              }
              return resultingFirstChild;
            }
            function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {
              if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
                deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                var existing = useFiber(currentFirstChild, textContent);
                existing.return = returnFiber;
                return existing;
              }
              deleteRemainingChildren(returnFiber, currentFirstChild);
              var created = createFiberFromText(textContent, returnFiber.mode, lanes);
              created.return = returnFiber;
              return created;
            }
            function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) {
              var key2 = element.key;
              var child = currentFirstChild;
              while (child !== null) {
                if (child.key === key2) {
                  var elementType = element.type;
                  if (elementType === REACT_FRAGMENT_TYPE) {
                    if (child.tag === Fragment2) {
                      deleteRemainingChildren(returnFiber, child.sibling);
                      var existing = useFiber(child, element.props.children);
                      existing.return = returnFiber;
                      {
                        existing._debugSource = element._source;
                        existing._debugOwner = element._owner;
                      }
                      return existing;
                    }
                  } else {
                    if (child.elementType === elementType || // Keep this check inline so it only runs on the false path:
                    isCompatibleFamilyForHotReloading(child, element) || // Lazy types should reconcile their resolved type.
                    // We need to do this after the Hot Reloading check above,
                    // because hot reloading has different semantics than prod because
                    // it doesn't resuspend. So we can't let the call below suspend.
                    typeof elementType === "object" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === child.type) {
                      deleteRemainingChildren(returnFiber, child.sibling);
                      var _existing = useFiber(child, element.props);
                      _existing.ref = coerceRef(returnFiber, child, element);
                      _existing.return = returnFiber;
                      {
                        _existing._debugSource = element._source;
                        _existing._debugOwner = element._owner;
                      }
                      return _existing;
                    }
                  }
                  deleteRemainingChildren(returnFiber, child);
                  break;
                } else {
                  deleteChild(returnFiber, child);
                }
                child = child.sibling;
              }
              if (element.type === REACT_FRAGMENT_TYPE) {
                var created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);
                created.return = returnFiber;
                return created;
              } else {
                var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);
                _created4.ref = coerceRef(returnFiber, currentFirstChild, element);
                _created4.return = returnFiber;
                return _created4;
              }
            }
            function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes) {
              var key2 = portal.key;
              var child = currentFirstChild;
              while (child !== null) {
                if (child.key === key2) {
                  if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
                    deleteRemainingChildren(returnFiber, child.sibling);
                    var existing = useFiber(child, portal.children || []);
                    existing.return = returnFiber;
                    return existing;
                  } else {
                    deleteRemainingChildren(returnFiber, child);
                    break;
                  }
                } else {
                  deleteChild(returnFiber, child);
                }
                child = child.sibling;
              }
              var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
              created.return = returnFiber;
              return created;
            }
            function reconcileChildFibers2(returnFiber, currentFirstChild, newChild, lanes) {
              var isUnkeyedTopLevelFragment = typeof newChild === "object" && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;
              if (isUnkeyedTopLevelFragment) {
                newChild = newChild.props.children;
              }
              if (typeof newChild === "object" && newChild !== null) {
                switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                    return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));
                  case REACT_PORTAL_TYPE:
                    return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));
                  case REACT_LAZY_TYPE:
                    var payload = newChild._payload;
                    var init2 = newChild._init;
                    return reconcileChildFibers2(returnFiber, currentFirstChild, init2(payload), lanes);
                }
                if (isArray2(newChild)) {
                  return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);
                }
                if (getIteratorFn(newChild)) {
                  return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);
                }
                throwOnInvalidObjectType(returnFiber, newChild);
              }
              if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
                return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, "" + newChild, lanes));
              }
              {
                if (typeof newChild === "function") {
                  warnOnFunctionType(returnFiber);
                }
              }
              return deleteRemainingChildren(returnFiber, currentFirstChild);
            }
            return reconcileChildFibers2;
          }
          var reconcileChildFibers = ChildReconciler(true);
          var mountChildFibers = ChildReconciler(false);
          function cloneChildFibers(current2, workInProgress2) {
            if (current2 !== null && workInProgress2.child !== current2.child) {
              throw new Error("Resuming work not yet implemented.");
            }
            if (workInProgress2.child === null) {
              return;
            }
            var currentChild = workInProgress2.child;
            var newChild = createWorkInProgress(currentChild, currentChild.pendingProps);
            workInProgress2.child = newChild;
            newChild.return = workInProgress2;
            while (currentChild.sibling !== null) {
              currentChild = currentChild.sibling;
              newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);
              newChild.return = workInProgress2;
            }
            newChild.sibling = null;
          }
          function resetChildFibers(workInProgress2, lanes) {
            var child = workInProgress2.child;
            while (child !== null) {
              resetWorkInProgress(child, lanes);
              child = child.sibling;
            }
          }
          var NO_CONTEXT = {};
          var contextStackCursor$1 = createCursor(NO_CONTEXT);
          var contextFiberStackCursor = createCursor(NO_CONTEXT);
          var rootInstanceStackCursor = createCursor(NO_CONTEXT);
          function requiredContext(c9) {
            if (c9 === NO_CONTEXT) {
              throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
            }
            return c9;
          }
          function getRootHostContainer() {
            var rootInstance = requiredContext(rootInstanceStackCursor.current);
            return rootInstance;
          }
          function pushHostContainer(fiber, nextRootInstance) {
            push(rootInstanceStackCursor, nextRootInstance, fiber);
            push(contextFiberStackCursor, fiber, fiber);
            push(contextStackCursor$1, NO_CONTEXT, fiber);
            var nextRootContext = getRootHostContext(nextRootInstance);
            pop(contextStackCursor$1, fiber);
            push(contextStackCursor$1, nextRootContext, fiber);
          }
          function popHostContainer(fiber) {
            pop(contextStackCursor$1, fiber);
            pop(contextFiberStackCursor, fiber);
            pop(rootInstanceStackCursor, fiber);
          }
          function getHostContext() {
            var context = requiredContext(contextStackCursor$1.current);
            return context;
          }
          function pushHostContext(fiber) {
            var rootInstance = requiredContext(rootInstanceStackCursor.current);
            var context = requiredContext(contextStackCursor$1.current);
            var nextContext = getChildHostContext(context, fiber.type);
            if (context === nextContext) {
              return;
            }
            push(contextFiberStackCursor, fiber, fiber);
            push(contextStackCursor$1, nextContext, fiber);
          }
          function popHostContext(fiber) {
            if (contextFiberStackCursor.current !== fiber) {
              return;
            }
            pop(contextStackCursor$1, fiber);
            pop(contextFiberStackCursor, fiber);
          }
          var DefaultSuspenseContext = 0;
          var SubtreeSuspenseContextMask = 1;
          var InvisibleParentSuspenseContext = 1;
          var ForceSuspenseFallback = 2;
          var suspenseStackCursor = createCursor(DefaultSuspenseContext);
          function hasSuspenseContext(parentContext, flag) {
            return (parentContext & flag) !== 0;
          }
          function setDefaultShallowSuspenseContext(parentContext) {
            return parentContext & SubtreeSuspenseContextMask;
          }
          function setShallowSuspenseContext(parentContext, shallowContext) {
            return parentContext & SubtreeSuspenseContextMask | shallowContext;
          }
          function addSubtreeSuspenseContext(parentContext, subtreeContext) {
            return parentContext | subtreeContext;
          }
          function pushSuspenseContext(fiber, newContext) {
            push(suspenseStackCursor, newContext, fiber);
          }
          function popSuspenseContext(fiber) {
            pop(suspenseStackCursor, fiber);
          }
          function shouldCaptureSuspense(workInProgress2, hasInvisibleParent) {
            var nextState = workInProgress2.memoizedState;
            if (nextState !== null) {
              if (nextState.dehydrated !== null) {
                return true;
              }
              return false;
            }
            var props = workInProgress2.memoizedProps;
            {
              return true;
            }
          }
          function findFirstSuspended(row) {
            var node = row;
            while (node !== null) {
              if (node.tag === SuspenseComponent) {
                var state = node.memoizedState;
                if (state !== null) {
                  var dehydrated = state.dehydrated;
                  if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) {
                    return node;
                  }
                }
              } else if (node.tag === SuspenseListComponent && // revealOrder undefined can't be trusted because it don't
              // keep track of whether it suspended or not.
              node.memoizedProps.revealOrder !== void 0) {
                var didSuspend = (node.flags & DidCapture) !== NoFlags;
                if (didSuspend) {
                  return node;
                }
              } else if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === row) {
                return null;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === row) {
                  return null;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
            return null;
          }
          var NoFlags$1 = (
            /*   */
            0
          );
          var HasEffect = (
            /* */
            1
          );
          var Insertion = (
            /*  */
            2
          );
          var Layout = (
            /*    */
            4
          );
          var Passive$1 = (
            /*   */
            8
          );
          var workInProgressSources = [];
          function resetWorkInProgressVersions() {
            for (var i7 = 0; i7 < workInProgressSources.length; i7++) {
              var mutableSource = workInProgressSources[i7];
              {
                mutableSource._workInProgressVersionPrimary = null;
              }
            }
            workInProgressSources.length = 0;
          }
          function registerMutableSourceForHydration(root3, mutableSource) {
            var getVersion2 = mutableSource._getVersion;
            var version30 = getVersion2(mutableSource._source);
            if (root3.mutableSourceEagerHydrationData == null) {
              root3.mutableSourceEagerHydrationData = [mutableSource, version30];
            } else {
              root3.mutableSourceEagerHydrationData.push(mutableSource, version30);
            }
          }
          var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentBatchConfig$2 = ReactSharedInternals.ReactCurrentBatchConfig;
          var didWarnAboutMismatchedHooksForComponent;
          var didWarnUncachedGetSnapshot;
          {
            didWarnAboutMismatchedHooksForComponent = /* @__PURE__ */ new Set();
          }
          var renderLanes = NoLanes;
          var currentlyRenderingFiber$1 = null;
          var currentHook = null;
          var workInProgressHook = null;
          var didScheduleRenderPhaseUpdate = false;
          var didScheduleRenderPhaseUpdateDuringThisPass = false;
          var localIdCounter = 0;
          var globalClientIdCounter = 0;
          var RE_RENDER_LIMIT = 25;
          var currentHookNameInDev = null;
          var hookTypesDev = null;
          var hookTypesUpdateIndexDev = -1;
          var ignorePreviousDependencies = false;
          function mountHookTypesDev() {
            {
              var hookName = currentHookNameInDev;
              if (hookTypesDev === null) {
                hookTypesDev = [hookName];
              } else {
                hookTypesDev.push(hookName);
              }
            }
          }
          function updateHookTypesDev() {
            {
              var hookName = currentHookNameInDev;
              if (hookTypesDev !== null) {
                hookTypesUpdateIndexDev++;
                if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {
                  warnOnHookMismatchInDev(hookName);
                }
              }
            }
          }
          function checkDepsAreArrayDev(deps) {
            {
              if (deps !== void 0 && deps !== null && !isArray2(deps)) {
                error("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", currentHookNameInDev, typeof deps);
              }
            }
          }
          function warnOnHookMismatchInDev(currentHookName) {
            {
              var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);
              if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {
                didWarnAboutMismatchedHooksForComponent.add(componentName);
                if (hookTypesDev !== null) {
                  var table = "";
                  var secondColumnStart = 30;
                  for (var i7 = 0; i7 <= hookTypesUpdateIndexDev; i7++) {
                    var oldHookName = hookTypesDev[i7];
                    var newHookName = i7 === hookTypesUpdateIndexDev ? currentHookName : oldHookName;
                    var row = i7 + 1 + ". " + oldHookName;
                    while (row.length < secondColumnStart) {
                      row += " ";
                    }
                    row += newHookName + "\n";
                    table += row;
                  }
                  error("React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n", componentName, table);
                }
              }
            }
          }
          function throwInvalidHookError() {
            throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
          }
          function areHookInputsEqual(nextDeps, prevDeps) {
            {
              if (ignorePreviousDependencies) {
                return false;
              }
            }
            if (prevDeps === null) {
              {
                error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
              }
              return false;
            }
            {
              if (nextDeps.length !== prevDeps.length) {
                error("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + prevDeps.join(", ") + "]", "[" + nextDeps.join(", ") + "]");
              }
            }
            for (var i7 = 0; i7 < prevDeps.length && i7 < nextDeps.length; i7++) {
              if (objectIs(nextDeps[i7], prevDeps[i7])) {
                continue;
              }
              return false;
            }
            return true;
          }
          function renderWithHooks(current2, workInProgress2, Component, props, secondArg, nextRenderLanes) {
            renderLanes = nextRenderLanes;
            currentlyRenderingFiber$1 = workInProgress2;
            {
              hookTypesDev = current2 !== null ? current2._debugHookTypes : null;
              hookTypesUpdateIndexDev = -1;
              ignorePreviousDependencies = current2 !== null && current2.type !== workInProgress2.type;
            }
            workInProgress2.memoizedState = null;
            workInProgress2.updateQueue = null;
            workInProgress2.lanes = NoLanes;
            {
              if (current2 !== null && current2.memoizedState !== null) {
                ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV;
              } else if (hookTypesDev !== null) {
                ReactCurrentDispatcher$1.current = HooksDispatcherOnMountWithHookTypesInDEV;
              } else {
                ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV;
              }
            }
            var children = Component(props, secondArg);
            if (didScheduleRenderPhaseUpdateDuringThisPass) {
              var numberOfReRenders = 0;
              do {
                didScheduleRenderPhaseUpdateDuringThisPass = false;
                localIdCounter = 0;
                if (numberOfReRenders >= RE_RENDER_LIMIT) {
                  throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
                }
                numberOfReRenders += 1;
                {
                  ignorePreviousDependencies = false;
                }
                currentHook = null;
                workInProgressHook = null;
                workInProgress2.updateQueue = null;
                {
                  hookTypesUpdateIndexDev = -1;
                }
                ReactCurrentDispatcher$1.current = HooksDispatcherOnRerenderInDEV;
                children = Component(props, secondArg);
              } while (didScheduleRenderPhaseUpdateDuringThisPass);
            }
            ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
            {
              workInProgress2._debugHookTypes = hookTypesDev;
            }
            var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
            renderLanes = NoLanes;
            currentlyRenderingFiber$1 = null;
            currentHook = null;
            workInProgressHook = null;
            {
              currentHookNameInDev = null;
              hookTypesDev = null;
              hookTypesUpdateIndexDev = -1;
              if (current2 !== null && (current2.flags & StaticMask) !== (workInProgress2.flags & StaticMask) && // Disable this warning in legacy mode, because legacy Suspense is weird
              // and creates false positives. To make this work in legacy mode, we'd
              // need to mark fibers that commit in an incomplete state, somehow. For
              // now I'll disable the warning that most of the bugs that would trigger
              // it are either exclusive to concurrent mode or exist in both.
              (current2.mode & ConcurrentMode) !== NoMode) {
                error("Internal React error: Expected static flag was missing. Please notify the React team.");
              }
            }
            didScheduleRenderPhaseUpdate = false;
            if (didRenderTooFewHooks) {
              throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
            }
            return children;
          }
          function checkDidRenderIdHook() {
            var didRenderIdHook = localIdCounter !== 0;
            localIdCounter = 0;
            return didRenderIdHook;
          }
          function bailoutHooks(current2, workInProgress2, lanes) {
            workInProgress2.updateQueue = current2.updateQueue;
            if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
              workInProgress2.flags &= ~(MountPassiveDev | MountLayoutDev | Passive | Update);
            } else {
              workInProgress2.flags &= ~(Passive | Update);
            }
            current2.lanes = removeLanes(current2.lanes, lanes);
          }
          function resetHooksAfterThrow() {
            ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
            if (didScheduleRenderPhaseUpdate) {
              var hook = currentlyRenderingFiber$1.memoizedState;
              while (hook !== null) {
                var queue = hook.queue;
                if (queue !== null) {
                  queue.pending = null;
                }
                hook = hook.next;
              }
              didScheduleRenderPhaseUpdate = false;
            }
            renderLanes = NoLanes;
            currentlyRenderingFiber$1 = null;
            currentHook = null;
            workInProgressHook = null;
            {
              hookTypesDev = null;
              hookTypesUpdateIndexDev = -1;
              currentHookNameInDev = null;
              isUpdatingOpaqueValueInRenderPhase = false;
            }
            didScheduleRenderPhaseUpdateDuringThisPass = false;
            localIdCounter = 0;
          }
          function mountWorkInProgressHook() {
            var hook = {
              memoizedState: null,
              baseState: null,
              baseQueue: null,
              queue: null,
              next: null
            };
            if (workInProgressHook === null) {
              currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;
            } else {
              workInProgressHook = workInProgressHook.next = hook;
            }
            return workInProgressHook;
          }
          function updateWorkInProgressHook() {
            var nextCurrentHook;
            if (currentHook === null) {
              var current2 = currentlyRenderingFiber$1.alternate;
              if (current2 !== null) {
                nextCurrentHook = current2.memoizedState;
              } else {
                nextCurrentHook = null;
              }
            } else {
              nextCurrentHook = currentHook.next;
            }
            var nextWorkInProgressHook;
            if (workInProgressHook === null) {
              nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState;
            } else {
              nextWorkInProgressHook = workInProgressHook.next;
            }
            if (nextWorkInProgressHook !== null) {
              workInProgressHook = nextWorkInProgressHook;
              nextWorkInProgressHook = workInProgressHook.next;
              currentHook = nextCurrentHook;
            } else {
              if (nextCurrentHook === null) {
                throw new Error("Rendered more hooks than during the previous render.");
              }
              currentHook = nextCurrentHook;
              var newHook = {
                memoizedState: currentHook.memoizedState,
                baseState: currentHook.baseState,
                baseQueue: currentHook.baseQueue,
                queue: currentHook.queue,
                next: null
              };
              if (workInProgressHook === null) {
                currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook;
              } else {
                workInProgressHook = workInProgressHook.next = newHook;
              }
            }
            return workInProgressHook;
          }
          function createFunctionComponentUpdateQueue() {
            return {
              lastEffect: null,
              stores: null
            };
          }
          function basicStateReducer(state, action) {
            return typeof action === "function" ? action(state) : action;
          }
          function mountReducer(reducer, initialArg, init2) {
            var hook = mountWorkInProgressHook();
            var initialState;
            if (init2 !== void 0) {
              initialState = init2(initialArg);
            } else {
              initialState = initialArg;
            }
            hook.memoizedState = hook.baseState = initialState;
            var queue = {
              pending: null,
              interleaved: null,
              lanes: NoLanes,
              dispatch: null,
              lastRenderedReducer: reducer,
              lastRenderedState: initialState
            };
            hook.queue = queue;
            var dispatch = queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber$1, queue);
            return [hook.memoizedState, dispatch];
          }
          function updateReducer(reducer, initialArg, init2) {
            var hook = updateWorkInProgressHook();
            var queue = hook.queue;
            if (queue === null) {
              throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
            }
            queue.lastRenderedReducer = reducer;
            var current2 = currentHook;
            var baseQueue = current2.baseQueue;
            var pendingQueue = queue.pending;
            if (pendingQueue !== null) {
              if (baseQueue !== null) {
                var baseFirst = baseQueue.next;
                var pendingFirst = pendingQueue.next;
                baseQueue.next = pendingFirst;
                pendingQueue.next = baseFirst;
              }
              {
                if (current2.baseQueue !== baseQueue) {
                  error("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React.");
                }
              }
              current2.baseQueue = baseQueue = pendingQueue;
              queue.pending = null;
            }
            if (baseQueue !== null) {
              var first = baseQueue.next;
              var newState = current2.baseState;
              var newBaseState = null;
              var newBaseQueueFirst = null;
              var newBaseQueueLast = null;
              var update2 = first;
              do {
                var updateLane = update2.lane;
                if (!isSubsetOfLanes(renderLanes, updateLane)) {
                  var clone = {
                    lane: updateLane,
                    action: update2.action,
                    hasEagerState: update2.hasEagerState,
                    eagerState: update2.eagerState,
                    next: null
                  };
                  if (newBaseQueueLast === null) {
                    newBaseQueueFirst = newBaseQueueLast = clone;
                    newBaseState = newState;
                  } else {
                    newBaseQueueLast = newBaseQueueLast.next = clone;
                  }
                  currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, updateLane);
                  markSkippedUpdateLanes(updateLane);
                } else {
                  if (newBaseQueueLast !== null) {
                    var _clone = {
                      // This update is going to be committed so we never want uncommit
                      // it. Using NoLane works because 0 is a subset of all bitmasks, so
                      // this will never be skipped by the check above.
                      lane: NoLane,
                      action: update2.action,
                      hasEagerState: update2.hasEagerState,
                      eagerState: update2.eagerState,
                      next: null
                    };
                    newBaseQueueLast = newBaseQueueLast.next = _clone;
                  }
                  if (update2.hasEagerState) {
                    newState = update2.eagerState;
                  } else {
                    var action = update2.action;
                    newState = reducer(newState, action);
                  }
                }
                update2 = update2.next;
              } while (update2 !== null && update2 !== first);
              if (newBaseQueueLast === null) {
                newBaseState = newState;
              } else {
                newBaseQueueLast.next = newBaseQueueFirst;
              }
              if (!objectIs(newState, hook.memoizedState)) {
                markWorkInProgressReceivedUpdate();
              }
              hook.memoizedState = newState;
              hook.baseState = newBaseState;
              hook.baseQueue = newBaseQueueLast;
              queue.lastRenderedState = newState;
            }
            var lastInterleaved = queue.interleaved;
            if (lastInterleaved !== null) {
              var interleaved = lastInterleaved;
              do {
                var interleavedLane = interleaved.lane;
                currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, interleavedLane);
                markSkippedUpdateLanes(interleavedLane);
                interleaved = interleaved.next;
              } while (interleaved !== lastInterleaved);
            } else if (baseQueue === null) {
              queue.lanes = NoLanes;
            }
            var dispatch = queue.dispatch;
            return [hook.memoizedState, dispatch];
          }
          function rerenderReducer(reducer, initialArg, init2) {
            var hook = updateWorkInProgressHook();
            var queue = hook.queue;
            if (queue === null) {
              throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
            }
            queue.lastRenderedReducer = reducer;
            var dispatch = queue.dispatch;
            var lastRenderPhaseUpdate = queue.pending;
            var newState = hook.memoizedState;
            if (lastRenderPhaseUpdate !== null) {
              queue.pending = null;
              var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;
              var update2 = firstRenderPhaseUpdate;
              do {
                var action = update2.action;
                newState = reducer(newState, action);
                update2 = update2.next;
              } while (update2 !== firstRenderPhaseUpdate);
              if (!objectIs(newState, hook.memoizedState)) {
                markWorkInProgressReceivedUpdate();
              }
              hook.memoizedState = newState;
              if (hook.baseQueue === null) {
                hook.baseState = newState;
              }
              queue.lastRenderedState = newState;
            }
            return [newState, dispatch];
          }
          function mountMutableSource(source, getSnapshot, subscribe3) {
            {
              return void 0;
            }
          }
          function updateMutableSource(source, getSnapshot, subscribe3) {
            {
              return void 0;
            }
          }
          function mountSyncExternalStore(subscribe3, getSnapshot, getServerSnapshot) {
            var fiber = currentlyRenderingFiber$1;
            var hook = mountWorkInProgressHook();
            var nextSnapshot;
            var isHydrating2 = getIsHydrating();
            if (isHydrating2) {
              if (getServerSnapshot === void 0) {
                throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
              }
              nextSnapshot = getServerSnapshot();
              {
                if (!didWarnUncachedGetSnapshot) {
                  if (nextSnapshot !== getServerSnapshot()) {
                    error("The result of getServerSnapshot should be cached to avoid an infinite loop");
                    didWarnUncachedGetSnapshot = true;
                  }
                }
              }
            } else {
              nextSnapshot = getSnapshot();
              {
                if (!didWarnUncachedGetSnapshot) {
                  var cachedSnapshot = getSnapshot();
                  if (!objectIs(nextSnapshot, cachedSnapshot)) {
                    error("The result of getSnapshot should be cached to avoid an infinite loop");
                    didWarnUncachedGetSnapshot = true;
                  }
                }
              }
              var root3 = getWorkInProgressRoot();
              if (root3 === null) {
                throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
              }
              if (!includesBlockingLane(root3, renderLanes)) {
                pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
              }
            }
            hook.memoizedState = nextSnapshot;
            var inst = {
              value: nextSnapshot,
              getSnapshot
            };
            hook.queue = inst;
            mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe3), [subscribe3]);
            fiber.flags |= Passive;
            pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), void 0, null);
            return nextSnapshot;
          }
          function updateSyncExternalStore(subscribe3, getSnapshot, getServerSnapshot) {
            var fiber = currentlyRenderingFiber$1;
            var hook = updateWorkInProgressHook();
            var nextSnapshot = getSnapshot();
            {
              if (!didWarnUncachedGetSnapshot) {
                var cachedSnapshot = getSnapshot();
                if (!objectIs(nextSnapshot, cachedSnapshot)) {
                  error("The result of getSnapshot should be cached to avoid an infinite loop");
                  didWarnUncachedGetSnapshot = true;
                }
              }
            }
            var prevSnapshot = hook.memoizedState;
            var snapshotChanged = !objectIs(prevSnapshot, nextSnapshot);
            if (snapshotChanged) {
              hook.memoizedState = nextSnapshot;
              markWorkInProgressReceivedUpdate();
            }
            var inst = hook.queue;
            updateEffect(subscribeToStore.bind(null, fiber, inst, subscribe3), [subscribe3]);
            if (inst.getSnapshot !== getSnapshot || snapshotChanged || // Check if the susbcribe function changed. We can save some memory by
            // checking whether we scheduled a subscription effect above.
            workInProgressHook !== null && workInProgressHook.memoizedState.tag & HasEffect) {
              fiber.flags |= Passive;
              pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), void 0, null);
              var root3 = getWorkInProgressRoot();
              if (root3 === null) {
                throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
              }
              if (!includesBlockingLane(root3, renderLanes)) {
                pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
              }
            }
            return nextSnapshot;
          }
          function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
            fiber.flags |= StoreConsistency;
            var check = {
              getSnapshot,
              value: renderedSnapshot
            };
            var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
            if (componentUpdateQueue === null) {
              componentUpdateQueue = createFunctionComponentUpdateQueue();
              currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
              componentUpdateQueue.stores = [check];
            } else {
              var stores = componentUpdateQueue.stores;
              if (stores === null) {
                componentUpdateQueue.stores = [check];
              } else {
                stores.push(check);
              }
            }
          }
          function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
            inst.value = nextSnapshot;
            inst.getSnapshot = getSnapshot;
            if (checkIfSnapshotChanged(inst)) {
              forceStoreRerender(fiber);
            }
          }
          function subscribeToStore(fiber, inst, subscribe3) {
            var handleStoreChange = function() {
              if (checkIfSnapshotChanged(inst)) {
                forceStoreRerender(fiber);
              }
            };
            return subscribe3(handleStoreChange);
          }
          function checkIfSnapshotChanged(inst) {
            var latestGetSnapshot = inst.getSnapshot;
            var prevValue = inst.value;
            try {
              var nextValue = latestGetSnapshot();
              return !objectIs(prevValue, nextValue);
            } catch (error2) {
              return true;
            }
          }
          function forceStoreRerender(fiber) {
            var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (root3 !== null) {
              scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
            }
          }
          function mountState(initialState) {
            var hook = mountWorkInProgressHook();
            if (typeof initialState === "function") {
              initialState = initialState();
            }
            hook.memoizedState = hook.baseState = initialState;
            var queue = {
              pending: null,
              interleaved: null,
              lanes: NoLanes,
              dispatch: null,
              lastRenderedReducer: basicStateReducer,
              lastRenderedState: initialState
            };
            hook.queue = queue;
            var dispatch = queue.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue);
            return [hook.memoizedState, dispatch];
          }
          function updateState(initialState) {
            return updateReducer(basicStateReducer);
          }
          function rerenderState(initialState) {
            return rerenderReducer(basicStateReducer);
          }
          function pushEffect(tag, create3, destroy, deps) {
            var effect = {
              tag,
              create: create3,
              destroy,
              deps,
              // Circular
              next: null
            };
            var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
            if (componentUpdateQueue === null) {
              componentUpdateQueue = createFunctionComponentUpdateQueue();
              currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
              componentUpdateQueue.lastEffect = effect.next = effect;
            } else {
              var lastEffect = componentUpdateQueue.lastEffect;
              if (lastEffect === null) {
                componentUpdateQueue.lastEffect = effect.next = effect;
              } else {
                var firstEffect = lastEffect.next;
                lastEffect.next = effect;
                effect.next = firstEffect;
                componentUpdateQueue.lastEffect = effect;
              }
            }
            return effect;
          }
          function mountRef(initialValue) {
            var hook = mountWorkInProgressHook();
            {
              var _ref2 = {
                current: initialValue
              };
              hook.memoizedState = _ref2;
              return _ref2;
            }
          }
          function updateRef(initialValue) {
            var hook = updateWorkInProgressHook();
            return hook.memoizedState;
          }
          function mountEffectImpl(fiberFlags, hookFlags, create3, deps) {
            var hook = mountWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            currentlyRenderingFiber$1.flags |= fiberFlags;
            hook.memoizedState = pushEffect(HasEffect | hookFlags, create3, void 0, nextDeps);
          }
          function updateEffectImpl(fiberFlags, hookFlags, create3, deps) {
            var hook = updateWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            var destroy = void 0;
            if (currentHook !== null) {
              var prevEffect = currentHook.memoizedState;
              destroy = prevEffect.destroy;
              if (nextDeps !== null) {
                var prevDeps = prevEffect.deps;
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                  hook.memoizedState = pushEffect(hookFlags, create3, destroy, nextDeps);
                  return;
                }
              }
            }
            currentlyRenderingFiber$1.flags |= fiberFlags;
            hook.memoizedState = pushEffect(HasEffect | hookFlags, create3, destroy, nextDeps);
          }
          function mountEffect(create3, deps) {
            if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
              return mountEffectImpl(MountPassiveDev | Passive | PassiveStatic, Passive$1, create3, deps);
            } else {
              return mountEffectImpl(Passive | PassiveStatic, Passive$1, create3, deps);
            }
          }
          function updateEffect(create3, deps) {
            return updateEffectImpl(Passive, Passive$1, create3, deps);
          }
          function mountInsertionEffect(create3, deps) {
            return mountEffectImpl(Update, Insertion, create3, deps);
          }
          function updateInsertionEffect(create3, deps) {
            return updateEffectImpl(Update, Insertion, create3, deps);
          }
          function mountLayoutEffect(create3, deps) {
            var fiberFlags = Update;
            {
              fiberFlags |= LayoutStatic;
            }
            if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
              fiberFlags |= MountLayoutDev;
            }
            return mountEffectImpl(fiberFlags, Layout, create3, deps);
          }
          function updateLayoutEffect(create3, deps) {
            return updateEffectImpl(Update, Layout, create3, deps);
          }
          function imperativeHandleEffect(create3, ref) {
            if (typeof ref === "function") {
              var refCallback = ref;
              var _inst = create3();
              refCallback(_inst);
              return function() {
                refCallback(null);
              };
            } else if (ref !== null && ref !== void 0) {
              var refObject = ref;
              {
                if (!refObject.hasOwnProperty("current")) {
                  error("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(refObject).join(", ") + "}");
                }
              }
              var _inst2 = create3();
              refObject.current = _inst2;
              return function() {
                refObject.current = null;
              };
            }
          }
          function mountImperativeHandle(ref, create3, deps) {
            {
              if (typeof create3 !== "function") {
                error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create3 !== null ? typeof create3 : "null");
              }
            }
            var effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref]) : null;
            var fiberFlags = Update;
            {
              fiberFlags |= LayoutStatic;
            }
            if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
              fiberFlags |= MountLayoutDev;
            }
            return mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create3, ref), effectDeps);
          }
          function updateImperativeHandle(ref, create3, deps) {
            {
              if (typeof create3 !== "function") {
                error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create3 !== null ? typeof create3 : "null");
              }
            }
            var effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref]) : null;
            return updateEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create3, ref), effectDeps);
          }
          function mountDebugValue(value, formatterFn) {
          }
          var updateDebugValue = mountDebugValue;
          function mountCallback(callback, deps) {
            var hook = mountWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            hook.memoizedState = [callback, nextDeps];
            return callback;
          }
          function updateCallback(callback, deps) {
            var hook = updateWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            var prevState = hook.memoizedState;
            if (prevState !== null) {
              if (nextDeps !== null) {
                var prevDeps = prevState[1];
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                  return prevState[0];
                }
              }
            }
            hook.memoizedState = [callback, nextDeps];
            return callback;
          }
          function mountMemo(nextCreate, deps) {
            var hook = mountWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            var nextValue = nextCreate();
            hook.memoizedState = [nextValue, nextDeps];
            return nextValue;
          }
          function updateMemo(nextCreate, deps) {
            var hook = updateWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            var prevState = hook.memoizedState;
            if (prevState !== null) {
              if (nextDeps !== null) {
                var prevDeps = prevState[1];
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                  return prevState[0];
                }
              }
            }
            var nextValue = nextCreate();
            hook.memoizedState = [nextValue, nextDeps];
            return nextValue;
          }
          function mountDeferredValue(value) {
            var hook = mountWorkInProgressHook();
            hook.memoizedState = value;
            return value;
          }
          function updateDeferredValue(value) {
            var hook = updateWorkInProgressHook();
            var resolvedCurrentHook = currentHook;
            var prevValue = resolvedCurrentHook.memoizedState;
            return updateDeferredValueImpl(hook, prevValue, value);
          }
          function rerenderDeferredValue(value) {
            var hook = updateWorkInProgressHook();
            if (currentHook === null) {
              hook.memoizedState = value;
              return value;
            } else {
              var prevValue = currentHook.memoizedState;
              return updateDeferredValueImpl(hook, prevValue, value);
            }
          }
          function updateDeferredValueImpl(hook, prevValue, value) {
            var shouldDeferValue = !includesOnlyNonUrgentLanes(renderLanes);
            if (shouldDeferValue) {
              if (!objectIs(value, prevValue)) {
                var deferredLane = claimNextTransitionLane();
                currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, deferredLane);
                markSkippedUpdateLanes(deferredLane);
                hook.baseState = true;
              }
              return prevValue;
            } else {
              if (hook.baseState) {
                hook.baseState = false;
                markWorkInProgressReceivedUpdate();
              }
              hook.memoizedState = value;
              return value;
            }
          }
          function startTransition(setPending, callback, options3) {
            var previousPriority = getCurrentUpdatePriority();
            setCurrentUpdatePriority(higherEventPriority(previousPriority, ContinuousEventPriority));
            setPending(true);
            var prevTransition = ReactCurrentBatchConfig$2.transition;
            ReactCurrentBatchConfig$2.transition = {};
            var currentTransition = ReactCurrentBatchConfig$2.transition;
            {
              ReactCurrentBatchConfig$2.transition._updatedFibers = /* @__PURE__ */ new Set();
            }
            try {
              setPending(false);
              callback();
            } finally {
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig$2.transition = prevTransition;
              {
                if (prevTransition === null && currentTransition._updatedFibers) {
                  var updatedFibersCount = currentTransition._updatedFibers.size;
                  if (updatedFibersCount > 10) {
                    warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.");
                  }
                  currentTransition._updatedFibers.clear();
                }
              }
            }
          }
          function mountTransition() {
            var _mountState = mountState(false), isPending = _mountState[0], setPending = _mountState[1];
            var start = startTransition.bind(null, setPending);
            var hook = mountWorkInProgressHook();
            hook.memoizedState = start;
            return [isPending, start];
          }
          function updateTransition() {
            var _updateState = updateState(), isPending = _updateState[0];
            var hook = updateWorkInProgressHook();
            var start = hook.memoizedState;
            return [isPending, start];
          }
          function rerenderTransition() {
            var _rerenderState = rerenderState(), isPending = _rerenderState[0];
            var hook = updateWorkInProgressHook();
            var start = hook.memoizedState;
            return [isPending, start];
          }
          var isUpdatingOpaqueValueInRenderPhase = false;
          function getIsUpdatingOpaqueValueInRenderPhaseInDEV() {
            {
              return isUpdatingOpaqueValueInRenderPhase;
            }
          }
          function mountId() {
            var hook = mountWorkInProgressHook();
            var root3 = getWorkInProgressRoot();
            var identifierPrefix = root3.identifierPrefix;
            var id3;
            if (getIsHydrating()) {
              var treeId = getTreeId();
              id3 = ":" + identifierPrefix + "R" + treeId;
              var localId = localIdCounter++;
              if (localId > 0) {
                id3 += "H" + localId.toString(32);
              }
              id3 += ":";
            } else {
              var globalClientId = globalClientIdCounter++;
              id3 = ":" + identifierPrefix + "r" + globalClientId.toString(32) + ":";
            }
            hook.memoizedState = id3;
            return id3;
          }
          function updateId() {
            var hook = updateWorkInProgressHook();
            var id3 = hook.memoizedState;
            return id3;
          }
          function dispatchReducerAction(fiber, queue, action) {
            {
              if (typeof arguments[3] === "function") {
                error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
              }
            }
            var lane = requestUpdateLane(fiber);
            var update2 = {
              lane,
              action,
              hasEagerState: false,
              eagerState: null,
              next: null
            };
            if (isRenderPhaseUpdate(fiber)) {
              enqueueRenderPhaseUpdate(queue, update2);
            } else {
              var root3 = enqueueConcurrentHookUpdate(fiber, queue, update2, lane);
              if (root3 !== null) {
                var eventTime = requestEventTime();
                scheduleUpdateOnFiber(root3, fiber, lane, eventTime);
                entangleTransitionUpdate(root3, queue, lane);
              }
            }
            markUpdateInDevTools(fiber, lane);
          }
          function dispatchSetState(fiber, queue, action) {
            {
              if (typeof arguments[3] === "function") {
                error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
              }
            }
            var lane = requestUpdateLane(fiber);
            var update2 = {
              lane,
              action,
              hasEagerState: false,
              eagerState: null,
              next: null
            };
            if (isRenderPhaseUpdate(fiber)) {
              enqueueRenderPhaseUpdate(queue, update2);
            } else {
              var alternate = fiber.alternate;
              if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {
                var lastRenderedReducer = queue.lastRenderedReducer;
                if (lastRenderedReducer !== null) {
                  var prevDispatcher;
                  {
                    prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                  }
                  try {
                    var currentState = queue.lastRenderedState;
                    var eagerState = lastRenderedReducer(currentState, action);
                    update2.hasEagerState = true;
                    update2.eagerState = eagerState;
                    if (objectIs(eagerState, currentState)) {
                      enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update2, lane);
                      return;
                    }
                  } catch (error2) {
                  } finally {
                    {
                      ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                  }
                }
              }
              var root3 = enqueueConcurrentHookUpdate(fiber, queue, update2, lane);
              if (root3 !== null) {
                var eventTime = requestEventTime();
                scheduleUpdateOnFiber(root3, fiber, lane, eventTime);
                entangleTransitionUpdate(root3, queue, lane);
              }
            }
            markUpdateInDevTools(fiber, lane);
          }
          function isRenderPhaseUpdate(fiber) {
            var alternate = fiber.alternate;
            return fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1;
          }
          function enqueueRenderPhaseUpdate(queue, update2) {
            didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
            var pending = queue.pending;
            if (pending === null) {
              update2.next = update2;
            } else {
              update2.next = pending.next;
              pending.next = update2;
            }
            queue.pending = update2;
          }
          function entangleTransitionUpdate(root3, queue, lane) {
            if (isTransitionLane(lane)) {
              var queueLanes = queue.lanes;
              queueLanes = intersectLanes(queueLanes, root3.pendingLanes);
              var newQueueLanes = mergeLanes(queueLanes, lane);
              queue.lanes = newQueueLanes;
              markRootEntangled(root3, newQueueLanes);
            }
          }
          function markUpdateInDevTools(fiber, lane, action) {
            {
              markStateUpdateScheduled(fiber, lane);
            }
          }
          var ContextOnlyDispatcher = {
            readContext,
            useCallback: throwInvalidHookError,
            useContext: throwInvalidHookError,
            useEffect: throwInvalidHookError,
            useImperativeHandle: throwInvalidHookError,
            useInsertionEffect: throwInvalidHookError,
            useLayoutEffect: throwInvalidHookError,
            useMemo: throwInvalidHookError,
            useReducer: throwInvalidHookError,
            useRef: throwInvalidHookError,
            useState: throwInvalidHookError,
            useDebugValue: throwInvalidHookError,
            useDeferredValue: throwInvalidHookError,
            useTransition: throwInvalidHookError,
            useMutableSource: throwInvalidHookError,
            useSyncExternalStore: throwInvalidHookError,
            useId: throwInvalidHookError,
            unstable_isNewReconciler: enableNewReconciler
          };
          var HooksDispatcherOnMountInDEV = null;
          var HooksDispatcherOnMountWithHookTypesInDEV = null;
          var HooksDispatcherOnUpdateInDEV = null;
          var HooksDispatcherOnRerenderInDEV = null;
          var InvalidNestedHooksDispatcherOnMountInDEV = null;
          var InvalidNestedHooksDispatcherOnUpdateInDEV = null;
          var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
          {
            var warnInvalidContextAccess = function() {
              error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
            };
            var warnInvalidHookAccess = function() {
              error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
            };
            HooksDispatcherOnMountInDEV = {
              readContext: function(context) {
                return readContext(context);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountCallback(callback, deps);
              },
              useContext: function(context) {
                currentHookNameInDev = "useContext";
                mountHookTypesDev();
                return readContext(context);
              },
              useEffect: function(create3, deps) {
                currentHookNameInDev = "useEffect";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountEffect(create3, deps);
              },
              useImperativeHandle: function(ref, create3, deps) {
                currentHookNameInDev = "useImperativeHandle";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountImperativeHandle(ref, create3, deps);
              },
              useInsertionEffect: function(create3, deps) {
                currentHookNameInDev = "useInsertionEffect";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountInsertionEffect(create3, deps);
              },
              useLayoutEffect: function(create3, deps) {
                currentHookNameInDev = "useLayoutEffect";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountLayoutEffect(create3, deps);
              },
              useMemo: function(create3, deps) {
                currentHookNameInDev = "useMemo";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountMemo(create3, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init2) {
                currentHookNameInDev = "useReducer";
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountReducer(reducer, initialArg, init2);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                mountHookTypesDev();
                return mountRef(initialValue);
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                mountHookTypesDev();
                return mountDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                mountHookTypesDev();
                return mountDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                mountHookTypesDev();
                return mountTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe3) {
                currentHookNameInDev = "useMutableSource";
                mountHookTypesDev();
                return mountMutableSource();
              },
              useSyncExternalStore: function(subscribe3, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                mountHookTypesDev();
                return mountSyncExternalStore(subscribe3, getSnapshot, getServerSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                mountHookTypesDev();
                return mountId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            HooksDispatcherOnMountWithHookTypesInDEV = {
              readContext: function(context) {
                return readContext(context);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                updateHookTypesDev();
                return mountCallback(callback, deps);
              },
              useContext: function(context) {
                currentHookNameInDev = "useContext";
                updateHookTypesDev();
                return readContext(context);
              },
              useEffect: function(create3, deps) {
                currentHookNameInDev = "useEffect";
                updateHookTypesDev();
                return mountEffect(create3, deps);
              },
              useImperativeHandle: function(ref, create3, deps) {
                currentHookNameInDev = "useImperativeHandle";
                updateHookTypesDev();
                return mountImperativeHandle(ref, create3, deps);
              },
              useInsertionEffect: function(create3, deps) {
                currentHookNameInDev = "useInsertionEffect";
                updateHookTypesDev();
                return mountInsertionEffect(create3, deps);
              },
              useLayoutEffect: function(create3, deps) {
                currentHookNameInDev = "useLayoutEffect";
                updateHookTypesDev();
                return mountLayoutEffect(create3, deps);
              },
              useMemo: function(create3, deps) {
                currentHookNameInDev = "useMemo";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountMemo(create3, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init2) {
                currentHookNameInDev = "useReducer";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountReducer(reducer, initialArg, init2);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                updateHookTypesDev();
                return mountRef(initialValue);
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                updateHookTypesDev();
                return mountDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                updateHookTypesDev();
                return mountDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                updateHookTypesDev();
                return mountTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe3) {
                currentHookNameInDev = "useMutableSource";
                updateHookTypesDev();
                return mountMutableSource();
              },
              useSyncExternalStore: function(subscribe3, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                updateHookTypesDev();
                return mountSyncExternalStore(subscribe3, getSnapshot, getServerSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                updateHookTypesDev();
                return mountId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            HooksDispatcherOnUpdateInDEV = {
              readContext: function(context) {
                return readContext(context);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                updateHookTypesDev();
                return updateCallback(callback, deps);
              },
              useContext: function(context) {
                currentHookNameInDev = "useContext";
                updateHookTypesDev();
                return readContext(context);
              },
              useEffect: function(create3, deps) {
                currentHookNameInDev = "useEffect";
                updateHookTypesDev();
                return updateEffect(create3, deps);
              },
              useImperativeHandle: function(ref, create3, deps) {
                currentHookNameInDev = "useImperativeHandle";
                updateHookTypesDev();
                return updateImperativeHandle(ref, create3, deps);
              },
              useInsertionEffect: function(create3, deps) {
                currentHookNameInDev = "useInsertionEffect";
                updateHookTypesDev();
                return updateInsertionEffect(create3, deps);
              },
              useLayoutEffect: function(create3, deps) {
                currentHookNameInDev = "useLayoutEffect";
                updateHookTypesDev();
                return updateLayoutEffect(create3, deps);
              },
              useMemo: function(create3, deps) {
                currentHookNameInDev = "useMemo";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateMemo(create3, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init2) {
                currentHookNameInDev = "useReducer";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateReducer(reducer, initialArg, init2);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                updateHookTypesDev();
                return updateRef();
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                updateHookTypesDev();
                return updateDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                updateHookTypesDev();
                return updateDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                updateHookTypesDev();
                return updateTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe3) {
                currentHookNameInDev = "useMutableSource";
                updateHookTypesDev();
                return updateMutableSource();
              },
              useSyncExternalStore: function(subscribe3, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                updateHookTypesDev();
                return updateSyncExternalStore(subscribe3, getSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                updateHookTypesDev();
                return updateId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            HooksDispatcherOnRerenderInDEV = {
              readContext: function(context) {
                return readContext(context);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                updateHookTypesDev();
                return updateCallback(callback, deps);
              },
              useContext: function(context) {
                currentHookNameInDev = "useContext";
                updateHookTypesDev();
                return readContext(context);
              },
              useEffect: function(create3, deps) {
                currentHookNameInDev = "useEffect";
                updateHookTypesDev();
                return updateEffect(create3, deps);
              },
              useImperativeHandle: function(ref, create3, deps) {
                currentHookNameInDev = "useImperativeHandle";
                updateHookTypesDev();
                return updateImperativeHandle(ref, create3, deps);
              },
              useInsertionEffect: function(create3, deps) {
                currentHookNameInDev = "useInsertionEffect";
                updateHookTypesDev();
                return updateInsertionEffect(create3, deps);
              },
              useLayoutEffect: function(create3, deps) {
                currentHookNameInDev = "useLayoutEffect";
                updateHookTypesDev();
                return updateLayoutEffect(create3, deps);
              },
              useMemo: function(create3, deps) {
                currentHookNameInDev = "useMemo";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
                try {
                  return updateMemo(create3, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init2) {
                currentHookNameInDev = "useReducer";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
                try {
                  return rerenderReducer(reducer, initialArg, init2);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                updateHookTypesDev();
                return updateRef();
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
                try {
                  return rerenderState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                updateHookTypesDev();
                return updateDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                updateHookTypesDev();
                return rerenderDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                updateHookTypesDev();
                return rerenderTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe3) {
                currentHookNameInDev = "useMutableSource";
                updateHookTypesDev();
                return updateMutableSource();
              },
              useSyncExternalStore: function(subscribe3, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                updateHookTypesDev();
                return updateSyncExternalStore(subscribe3, getSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                updateHookTypesDev();
                return updateId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            InvalidNestedHooksDispatcherOnMountInDEV = {
              readContext: function(context) {
                warnInvalidContextAccess();
                return readContext(context);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountCallback(callback, deps);
              },
              useContext: function(context) {
                currentHookNameInDev = "useContext";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return readContext(context);
              },
              useEffect: function(create3, deps) {
                currentHookNameInDev = "useEffect";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountEffect(create3, deps);
              },
              useImperativeHandle: function(ref, create3, deps) {
                currentHookNameInDev = "useImperativeHandle";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountImperativeHandle(ref, create3, deps);
              },
              useInsertionEffect: function(create3, deps) {
                currentHookNameInDev = "useInsertionEffect";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountInsertionEffect(create3, deps);
              },
              useLayoutEffect: function(create3, deps) {
                currentHookNameInDev = "useLayoutEffect";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountLayoutEffect(create3, deps);
              },
              useMemo: function(create3, deps) {
                currentHookNameInDev = "useMemo";
                warnInvalidHookAccess();
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountMemo(create3, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init2) {
                currentHookNameInDev = "useReducer";
                warnInvalidHookAccess();
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountReducer(reducer, initialArg, init2);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountRef(initialValue);
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                warnInvalidHookAccess();
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe3) {
                currentHookNameInDev = "useMutableSource";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountMutableSource();
              },
              useSyncExternalStore: function(subscribe3, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountSyncExternalStore(subscribe3, getSnapshot, getServerSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            InvalidNestedHooksDispatcherOnUpdateInDEV = {
              readContext: function(context) {
                warnInvalidContextAccess();
                return readContext(context);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateCallback(callback, deps);
              },
              useContext: function(context) {
                currentHookNameInDev = "useContext";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return readContext(context);
              },
              useEffect: function(create3, deps) {
                currentHookNameInDev = "useEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateEffect(create3, deps);
              },
              useImperativeHandle: function(ref, create3, deps) {
                currentHookNameInDev = "useImperativeHandle";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateImperativeHandle(ref, create3, deps);
              },
              useInsertionEffect: function(create3, deps) {
                currentHookNameInDev = "useInsertionEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateInsertionEffect(create3, deps);
              },
              useLayoutEffect: function(create3, deps) {
                currentHookNameInDev = "useLayoutEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateLayoutEffect(create3, deps);
              },
              useMemo: function(create3, deps) {
                currentHookNameInDev = "useMemo";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateMemo(create3, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init2) {
                currentHookNameInDev = "useReducer";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateReducer(reducer, initialArg, init2);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateRef();
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe3) {
                currentHookNameInDev = "useMutableSource";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateMutableSource();
              },
              useSyncExternalStore: function(subscribe3, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateSyncExternalStore(subscribe3, getSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            InvalidNestedHooksDispatcherOnRerenderInDEV = {
              readContext: function(context) {
                warnInvalidContextAccess();
                return readContext(context);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateCallback(callback, deps);
              },
              useContext: function(context) {
                currentHookNameInDev = "useContext";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return readContext(context);
              },
              useEffect: function(create3, deps) {
                currentHookNameInDev = "useEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateEffect(create3, deps);
              },
              useImperativeHandle: function(ref, create3, deps) {
                currentHookNameInDev = "useImperativeHandle";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateImperativeHandle(ref, create3, deps);
              },
              useInsertionEffect: function(create3, deps) {
                currentHookNameInDev = "useInsertionEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateInsertionEffect(create3, deps);
              },
              useLayoutEffect: function(create3, deps) {
                currentHookNameInDev = "useLayoutEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateLayoutEffect(create3, deps);
              },
              useMemo: function(create3, deps) {
                currentHookNameInDev = "useMemo";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateMemo(create3, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init2) {
                currentHookNameInDev = "useReducer";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return rerenderReducer(reducer, initialArg, init2);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateRef();
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return rerenderState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateDebugValue();
              },
              useDeferredValue: function(value) {
                currentHookNameInDev = "useDeferredValue";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return rerenderDeferredValue(value);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return rerenderTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe3) {
                currentHookNameInDev = "useMutableSource";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateMutableSource();
              },
              useSyncExternalStore: function(subscribe3, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateSyncExternalStore(subscribe3, getSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
          }
          var now$1 = Scheduler.unstable_now;
          var commitTime = 0;
          var layoutEffectStartTime = -1;
          var profilerStartTime = -1;
          var passiveEffectStartTime = -1;
          var currentUpdateIsNested = false;
          var nestedUpdateScheduled = false;
          function isCurrentUpdateNested() {
            return currentUpdateIsNested;
          }
          function markNestedUpdateScheduled() {
            {
              nestedUpdateScheduled = true;
            }
          }
          function resetNestedUpdateFlag() {
            {
              currentUpdateIsNested = false;
              nestedUpdateScheduled = false;
            }
          }
          function syncNestedUpdateFlag() {
            {
              currentUpdateIsNested = nestedUpdateScheduled;
              nestedUpdateScheduled = false;
            }
          }
          function getCommitTime() {
            return commitTime;
          }
          function recordCommitTime() {
            commitTime = now$1();
          }
          function startProfilerTimer(fiber) {
            profilerStartTime = now$1();
            if (fiber.actualStartTime < 0) {
              fiber.actualStartTime = now$1();
            }
          }
          function stopProfilerTimerIfRunning(fiber) {
            profilerStartTime = -1;
          }
          function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
            if (profilerStartTime >= 0) {
              var elapsedTime = now$1() - profilerStartTime;
              fiber.actualDuration += elapsedTime;
              if (overrideBaseTime) {
                fiber.selfBaseDuration = elapsedTime;
              }
              profilerStartTime = -1;
            }
          }
          function recordLayoutEffectDuration(fiber) {
            if (layoutEffectStartTime >= 0) {
              var elapsedTime = now$1() - layoutEffectStartTime;
              layoutEffectStartTime = -1;
              var parentFiber = fiber.return;
              while (parentFiber !== null) {
                switch (parentFiber.tag) {
                  case HostRoot:
                    var root3 = parentFiber.stateNode;
                    root3.effectDuration += elapsedTime;
                    return;
                  case Profiler:
                    var parentStateNode = parentFiber.stateNode;
                    parentStateNode.effectDuration += elapsedTime;
                    return;
                }
                parentFiber = parentFiber.return;
              }
            }
          }
          function recordPassiveEffectDuration(fiber) {
            if (passiveEffectStartTime >= 0) {
              var elapsedTime = now$1() - passiveEffectStartTime;
              passiveEffectStartTime = -1;
              var parentFiber = fiber.return;
              while (parentFiber !== null) {
                switch (parentFiber.tag) {
                  case HostRoot:
                    var root3 = parentFiber.stateNode;
                    if (root3 !== null) {
                      root3.passiveEffectDuration += elapsedTime;
                    }
                    return;
                  case Profiler:
                    var parentStateNode = parentFiber.stateNode;
                    if (parentStateNode !== null) {
                      parentStateNode.passiveEffectDuration += elapsedTime;
                    }
                    return;
                }
                parentFiber = parentFiber.return;
              }
            }
          }
          function startLayoutEffectTimer() {
            layoutEffectStartTime = now$1();
          }
          function startPassiveEffectTimer() {
            passiveEffectStartTime = now$1();
          }
          function transferActualDuration(fiber) {
            var child = fiber.child;
            while (child) {
              fiber.actualDuration += child.actualDuration;
              child = child.sibling;
            }
          }
          function createCapturedValueAtFiber(value, source) {
            return {
              value,
              source,
              stack: getStackByFiberInDevAndProd(source),
              digest: null
            };
          }
          function createCapturedValue(value, digest2, stack) {
            return {
              value,
              source: null,
              stack: stack != null ? stack : null,
              digest: digest2 != null ? digest2 : null
            };
          }
          function showErrorDialog(boundary, errorInfo) {
            return true;
          }
          function logCapturedError(boundary, errorInfo) {
            try {
              var logError = showErrorDialog(boundary, errorInfo);
              if (logError === false) {
                return;
              }
              var error2 = errorInfo.value;
              if (true) {
                var source = errorInfo.source;
                var stack = errorInfo.stack;
                var componentStack = stack !== null ? stack : "";
                if (error2 != null && error2._suppressLogging) {
                  if (boundary.tag === ClassComponent) {
                    return;
                  }
                  console["error"](error2);
                }
                var componentName = source ? getComponentNameFromFiber(source) : null;
                var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component:" : "The above error occurred in one of your React components:";
                var errorBoundaryMessage;
                if (boundary.tag === HostRoot) {
                  errorBoundaryMessage = "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://reactjs.org/link/error-boundaries to learn more about error boundaries.";
                } else {
                  var errorBoundaryName = getComponentNameFromFiber(boundary) || "Anonymous";
                  errorBoundaryMessage = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + errorBoundaryName + ".");
                }
                var combinedMessage = componentNameMessage + "\n" + componentStack + "\n\n" + ("" + errorBoundaryMessage);
                console["error"](combinedMessage);
              } else {
                console["error"](error2);
              }
            } catch (e9) {
              setTimeout(function() {
                throw e9;
              });
            }
          }
          var PossiblyWeakMap$1 = typeof WeakMap === "function" ? WeakMap : Map;
          function createRootErrorUpdate(fiber, errorInfo, lane) {
            var update2 = createUpdate(NoTimestamp, lane);
            update2.tag = CaptureUpdate;
            update2.payload = {
              element: null
            };
            var error2 = errorInfo.value;
            update2.callback = function() {
              onUncaughtError(error2);
              logCapturedError(fiber, errorInfo);
            };
            return update2;
          }
          function createClassErrorUpdate(fiber, errorInfo, lane) {
            var update2 = createUpdate(NoTimestamp, lane);
            update2.tag = CaptureUpdate;
            var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
            if (typeof getDerivedStateFromError === "function") {
              var error$1 = errorInfo.value;
              update2.payload = function() {
                return getDerivedStateFromError(error$1);
              };
              update2.callback = function() {
                {
                  markFailedErrorBoundaryForHotReloading(fiber);
                }
                logCapturedError(fiber, errorInfo);
              };
            }
            var inst = fiber.stateNode;
            if (inst !== null && typeof inst.componentDidCatch === "function") {
              update2.callback = function callback() {
                {
                  markFailedErrorBoundaryForHotReloading(fiber);
                }
                logCapturedError(fiber, errorInfo);
                if (typeof getDerivedStateFromError !== "function") {
                  markLegacyErrorBoundaryAsFailed(this);
                }
                var error$12 = errorInfo.value;
                var stack = errorInfo.stack;
                this.componentDidCatch(error$12, {
                  componentStack: stack !== null ? stack : ""
                });
                {
                  if (typeof getDerivedStateFromError !== "function") {
                    if (!includesSomeLane(fiber.lanes, SyncLane)) {
                      error("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", getComponentNameFromFiber(fiber) || "Unknown");
                    }
                  }
                }
              };
            }
            return update2;
          }
          function attachPingListener(root3, wakeable, lanes) {
            var pingCache = root3.pingCache;
            var threadIDs;
            if (pingCache === null) {
              pingCache = root3.pingCache = new PossiblyWeakMap$1();
              threadIDs = /* @__PURE__ */ new Set();
              pingCache.set(wakeable, threadIDs);
            } else {
              threadIDs = pingCache.get(wakeable);
              if (threadIDs === void 0) {
                threadIDs = /* @__PURE__ */ new Set();
                pingCache.set(wakeable, threadIDs);
              }
            }
            if (!threadIDs.has(lanes)) {
              threadIDs.add(lanes);
              var ping = pingSuspendedRoot.bind(null, root3, wakeable, lanes);
              {
                if (isDevToolsPresent) {
                  restorePendingUpdaters(root3, lanes);
                }
              }
              wakeable.then(ping, ping);
            }
          }
          function attachRetryListener(suspenseBoundary, root3, wakeable, lanes) {
            var wakeables = suspenseBoundary.updateQueue;
            if (wakeables === null) {
              var updateQueue = /* @__PURE__ */ new Set();
              updateQueue.add(wakeable);
              suspenseBoundary.updateQueue = updateQueue;
            } else {
              wakeables.add(wakeable);
            }
          }
          function resetSuspendedComponent(sourceFiber, rootRenderLanes) {
            var tag = sourceFiber.tag;
            if ((sourceFiber.mode & ConcurrentMode) === NoMode && (tag === FunctionComponent || tag === ForwardRef || tag === SimpleMemoComponent)) {
              var currentSource = sourceFiber.alternate;
              if (currentSource) {
                sourceFiber.updateQueue = currentSource.updateQueue;
                sourceFiber.memoizedState = currentSource.memoizedState;
                sourceFiber.lanes = currentSource.lanes;
              } else {
                sourceFiber.updateQueue = null;
                sourceFiber.memoizedState = null;
              }
            }
          }
          function getNearestSuspenseBoundaryToCapture(returnFiber) {
            var node = returnFiber;
            do {
              if (node.tag === SuspenseComponent && shouldCaptureSuspense(node)) {
                return node;
              }
              node = node.return;
            } while (node !== null);
            return null;
          }
          function markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root3, rootRenderLanes) {
            if ((suspenseBoundary.mode & ConcurrentMode) === NoMode) {
              if (suspenseBoundary === returnFiber) {
                suspenseBoundary.flags |= ShouldCapture;
              } else {
                suspenseBoundary.flags |= DidCapture;
                sourceFiber.flags |= ForceUpdateForLegacySuspense;
                sourceFiber.flags &= ~(LifecycleEffectMask | Incomplete);
                if (sourceFiber.tag === ClassComponent) {
                  var currentSourceFiber = sourceFiber.alternate;
                  if (currentSourceFiber === null) {
                    sourceFiber.tag = IncompleteClassComponent;
                  } else {
                    var update2 = createUpdate(NoTimestamp, SyncLane);
                    update2.tag = ForceUpdate;
                    enqueueUpdate(sourceFiber, update2, SyncLane);
                  }
                }
                sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane);
              }
              return suspenseBoundary;
            }
            suspenseBoundary.flags |= ShouldCapture;
            suspenseBoundary.lanes = rootRenderLanes;
            return suspenseBoundary;
          }
          function throwException(root3, returnFiber, sourceFiber, value, rootRenderLanes) {
            sourceFiber.flags |= Incomplete;
            {
              if (isDevToolsPresent) {
                restorePendingUpdaters(root3, rootRenderLanes);
              }
            }
            if (value !== null && typeof value === "object" && typeof value.then === "function") {
              var wakeable = value;
              resetSuspendedComponent(sourceFiber);
              {
                if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {
                  markDidThrowWhileHydratingDEV();
                }
              }
              var suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);
              if (suspenseBoundary !== null) {
                suspenseBoundary.flags &= ~ForceClientRender;
                markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root3, rootRenderLanes);
                if (suspenseBoundary.mode & ConcurrentMode) {
                  attachPingListener(root3, wakeable, rootRenderLanes);
                }
                attachRetryListener(suspenseBoundary, root3, wakeable);
                return;
              } else {
                if (!includesSyncLane(rootRenderLanes)) {
                  attachPingListener(root3, wakeable, rootRenderLanes);
                  renderDidSuspendDelayIfPossible();
                  return;
                }
                var uncaughtSuspenseError = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
                value = uncaughtSuspenseError;
              }
            } else {
              if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {
                markDidThrowWhileHydratingDEV();
                var _suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);
                if (_suspenseBoundary !== null) {
                  if ((_suspenseBoundary.flags & ShouldCapture) === NoFlags) {
                    _suspenseBoundary.flags |= ForceClientRender;
                  }
                  markSuspenseBoundaryShouldCapture(_suspenseBoundary, returnFiber, sourceFiber, root3, rootRenderLanes);
                  queueHydrationError(createCapturedValueAtFiber(value, sourceFiber));
                  return;
                }
              }
            }
            value = createCapturedValueAtFiber(value, sourceFiber);
            renderDidError(value);
            var workInProgress2 = returnFiber;
            do {
              switch (workInProgress2.tag) {
                case HostRoot: {
                  var _errorInfo = value;
                  workInProgress2.flags |= ShouldCapture;
                  var lane = pickArbitraryLane(rootRenderLanes);
                  workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);
                  var update2 = createRootErrorUpdate(workInProgress2, _errorInfo, lane);
                  enqueueCapturedUpdate(workInProgress2, update2);
                  return;
                }
                case ClassComponent:
                  var errorInfo = value;
                  var ctor = workInProgress2.type;
                  var instance = workInProgress2.stateNode;
                  if ((workInProgress2.flags & DidCapture) === NoFlags && (typeof ctor.getDerivedStateFromError === "function" || instance !== null && typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance))) {
                    workInProgress2.flags |= ShouldCapture;
                    var _lane = pickArbitraryLane(rootRenderLanes);
                    workInProgress2.lanes = mergeLanes(workInProgress2.lanes, _lane);
                    var _update = createClassErrorUpdate(workInProgress2, errorInfo, _lane);
                    enqueueCapturedUpdate(workInProgress2, _update);
                    return;
                  }
                  break;
              }
              workInProgress2 = workInProgress2.return;
            } while (workInProgress2 !== null);
          }
          function getSuspendedCache() {
            {
              return null;
            }
          }
          var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
          var didReceiveUpdate = false;
          var didWarnAboutBadClass;
          var didWarnAboutModulePatternComponent;
          var didWarnAboutContextTypeOnFunctionComponent;
          var didWarnAboutGetDerivedStateOnFunctionComponent;
          var didWarnAboutFunctionRefs;
          var didWarnAboutReassigningProps;
          var didWarnAboutRevealOrder;
          var didWarnAboutTailOptions;
          {
            didWarnAboutBadClass = {};
            didWarnAboutModulePatternComponent = {};
            didWarnAboutContextTypeOnFunctionComponent = {};
            didWarnAboutGetDerivedStateOnFunctionComponent = {};
            didWarnAboutFunctionRefs = {};
            didWarnAboutReassigningProps = false;
            didWarnAboutRevealOrder = {};
            didWarnAboutTailOptions = {};
          }
          function reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2) {
            if (current2 === null) {
              workInProgress2.child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);
            } else {
              workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, nextChildren, renderLanes2);
            }
          }
          function forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2) {
            workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
            workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);
          }
          function updateForwardRef(current2, workInProgress2, Component, nextProps, renderLanes2) {
            {
              if (workInProgress2.type !== workInProgress2.elementType) {
                var innerPropTypes = Component.propTypes;
                if (innerPropTypes) {
                  checkPropTypes(
                    innerPropTypes,
                    nextProps,
                    // Resolved props
                    "prop",
                    getComponentNameFromType(Component)
                  );
                }
              }
            }
            var render2 = Component.render;
            var ref = workInProgress2.ref;
            var nextChildren;
            var hasId;
            prepareToReadContext(workInProgress2, renderLanes2);
            {
              markComponentRenderStarted(workInProgress2);
            }
            {
              ReactCurrentOwner$1.current = workInProgress2;
              setIsRendering(true);
              nextChildren = renderWithHooks(current2, workInProgress2, render2, nextProps, ref, renderLanes2);
              hasId = checkDidRenderIdHook();
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  nextChildren = renderWithHooks(current2, workInProgress2, render2, nextProps, ref, renderLanes2);
                  hasId = checkDidRenderIdHook();
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
              setIsRendering(false);
            }
            {
              markComponentRenderStopped();
            }
            if (current2 !== null && !didReceiveUpdate) {
              bailoutHooks(current2, workInProgress2, renderLanes2);
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            }
            if (getIsHydrating() && hasId) {
              pushMaterializedTreeId(workInProgress2);
            }
            workInProgress2.flags |= PerformedWork;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
            if (current2 === null) {
              var type = Component.type;
              if (isSimpleFunctionComponent(type) && Component.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
              Component.defaultProps === void 0) {
                var resolvedType = type;
                {
                  resolvedType = resolveFunctionForHotReloading(type);
                }
                workInProgress2.tag = SimpleMemoComponent;
                workInProgress2.type = resolvedType;
                {
                  validateFunctionComponentInDev(workInProgress2, type);
                }
                return updateSimpleMemoComponent(current2, workInProgress2, resolvedType, nextProps, renderLanes2);
              }
              {
                var innerPropTypes = type.propTypes;
                if (innerPropTypes) {
                  checkPropTypes(
                    innerPropTypes,
                    nextProps,
                    // Resolved props
                    "prop",
                    getComponentNameFromType(type)
                  );
                }
              }
              var child = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress2, workInProgress2.mode, renderLanes2);
              child.ref = workInProgress2.ref;
              child.return = workInProgress2;
              workInProgress2.child = child;
              return child;
            }
            {
              var _type = Component.type;
              var _innerPropTypes = _type.propTypes;
              if (_innerPropTypes) {
                checkPropTypes(
                  _innerPropTypes,
                  nextProps,
                  // Resolved props
                  "prop",
                  getComponentNameFromType(_type)
                );
              }
            }
            var currentChild = current2.child;
            var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current2, renderLanes2);
            if (!hasScheduledUpdateOrContext) {
              var prevProps = currentChild.memoizedProps;
              var compare2 = Component.compare;
              compare2 = compare2 !== null ? compare2 : shallowEqual;
              if (compare2(prevProps, nextProps) && current2.ref === workInProgress2.ref) {
                return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
              }
            }
            workInProgress2.flags |= PerformedWork;
            var newChild = createWorkInProgress(currentChild, nextProps);
            newChild.ref = workInProgress2.ref;
            newChild.return = workInProgress2;
            workInProgress2.child = newChild;
            return newChild;
          }
          function updateSimpleMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
            {
              if (workInProgress2.type !== workInProgress2.elementType) {
                var outerMemoType = workInProgress2.elementType;
                if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {
                  var lazyComponent = outerMemoType;
                  var payload = lazyComponent._payload;
                  var init2 = lazyComponent._init;
                  try {
                    outerMemoType = init2(payload);
                  } catch (x4) {
                    outerMemoType = null;
                  }
                  var outerPropTypes = outerMemoType && outerMemoType.propTypes;
                  if (outerPropTypes) {
                    checkPropTypes(
                      outerPropTypes,
                      nextProps,
                      // Resolved (SimpleMemoComponent has no defaultProps)
                      "prop",
                      getComponentNameFromType(outerMemoType)
                    );
                  }
                }
              }
            }
            if (current2 !== null) {
              var prevProps = current2.memoizedProps;
              if (shallowEqual(prevProps, nextProps) && current2.ref === workInProgress2.ref && // Prevent bailout if the implementation changed due to hot reload.
              workInProgress2.type === current2.type) {
                didReceiveUpdate = false;
                workInProgress2.pendingProps = nextProps = prevProps;
                if (!checkScheduledUpdateOrContext(current2, renderLanes2)) {
                  workInProgress2.lanes = current2.lanes;
                  return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                } else if ((current2.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
                  didReceiveUpdate = true;
                }
              }
            }
            return updateFunctionComponent(current2, workInProgress2, Component, nextProps, renderLanes2);
          }
          function updateOffscreenComponent(current2, workInProgress2, renderLanes2) {
            var nextProps = workInProgress2.pendingProps;
            var nextChildren = nextProps.children;
            var prevState = current2 !== null ? current2.memoizedState : null;
            if (nextProps.mode === "hidden" || enableLegacyHidden) {
              if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
                var nextState = {
                  baseLanes: NoLanes,
                  cachePool: null,
                  transitions: null
                };
                workInProgress2.memoizedState = nextState;
                pushRenderLanes(workInProgress2, renderLanes2);
              } else if (!includesSomeLane(renderLanes2, OffscreenLane)) {
                var spawnedCachePool = null;
                var nextBaseLanes;
                if (prevState !== null) {
                  var prevBaseLanes = prevState.baseLanes;
                  nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes2);
                } else {
                  nextBaseLanes = renderLanes2;
                }
                workInProgress2.lanes = workInProgress2.childLanes = laneToLanes(OffscreenLane);
                var _nextState = {
                  baseLanes: nextBaseLanes,
                  cachePool: spawnedCachePool,
                  transitions: null
                };
                workInProgress2.memoizedState = _nextState;
                workInProgress2.updateQueue = null;
                pushRenderLanes(workInProgress2, nextBaseLanes);
                return null;
              } else {
                var _nextState2 = {
                  baseLanes: NoLanes,
                  cachePool: null,
                  transitions: null
                };
                workInProgress2.memoizedState = _nextState2;
                var subtreeRenderLanes2 = prevState !== null ? prevState.baseLanes : renderLanes2;
                pushRenderLanes(workInProgress2, subtreeRenderLanes2);
              }
            } else {
              var _subtreeRenderLanes;
              if (prevState !== null) {
                _subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes2);
                workInProgress2.memoizedState = null;
              } else {
                _subtreeRenderLanes = renderLanes2;
              }
              pushRenderLanes(workInProgress2, _subtreeRenderLanes);
            }
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateFragment(current2, workInProgress2, renderLanes2) {
            var nextChildren = workInProgress2.pendingProps;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateMode(current2, workInProgress2, renderLanes2) {
            var nextChildren = workInProgress2.pendingProps.children;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateProfiler(current2, workInProgress2, renderLanes2) {
            {
              workInProgress2.flags |= Update;
              {
                var stateNode = workInProgress2.stateNode;
                stateNode.effectDuration = 0;
                stateNode.passiveEffectDuration = 0;
              }
            }
            var nextProps = workInProgress2.pendingProps;
            var nextChildren = nextProps.children;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function markRef(current2, workInProgress2) {
            var ref = workInProgress2.ref;
            if (current2 === null && ref !== null || current2 !== null && current2.ref !== ref) {
              workInProgress2.flags |= Ref;
              {
                workInProgress2.flags |= RefStatic;
              }
            }
          }
          function updateFunctionComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
            {
              if (workInProgress2.type !== workInProgress2.elementType) {
                var innerPropTypes = Component.propTypes;
                if (innerPropTypes) {
                  checkPropTypes(
                    innerPropTypes,
                    nextProps,
                    // Resolved props
                    "prop",
                    getComponentNameFromType(Component)
                  );
                }
              }
            }
            var context;
            {
              var unmaskedContext = getUnmaskedContext(workInProgress2, Component, true);
              context = getMaskedContext(workInProgress2, unmaskedContext);
            }
            var nextChildren;
            var hasId;
            prepareToReadContext(workInProgress2, renderLanes2);
            {
              markComponentRenderStarted(workInProgress2);
            }
            {
              ReactCurrentOwner$1.current = workInProgress2;
              setIsRendering(true);
              nextChildren = renderWithHooks(current2, workInProgress2, Component, nextProps, context, renderLanes2);
              hasId = checkDidRenderIdHook();
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  nextChildren = renderWithHooks(current2, workInProgress2, Component, nextProps, context, renderLanes2);
                  hasId = checkDidRenderIdHook();
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
              setIsRendering(false);
            }
            {
              markComponentRenderStopped();
            }
            if (current2 !== null && !didReceiveUpdate) {
              bailoutHooks(current2, workInProgress2, renderLanes2);
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            }
            if (getIsHydrating() && hasId) {
              pushMaterializedTreeId(workInProgress2);
            }
            workInProgress2.flags |= PerformedWork;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateClassComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
            {
              switch (shouldError(workInProgress2)) {
                case false: {
                  var _instance = workInProgress2.stateNode;
                  var ctor = workInProgress2.type;
                  var tempInstance = new ctor(workInProgress2.memoizedProps, _instance.context);
                  var state = tempInstance.state;
                  _instance.updater.enqueueSetState(_instance, state, null);
                  break;
                }
                case true: {
                  workInProgress2.flags |= DidCapture;
                  workInProgress2.flags |= ShouldCapture;
                  var error$1 = new Error("Simulated error coming from DevTools");
                  var lane = pickArbitraryLane(renderLanes2);
                  workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);
                  var update2 = createClassErrorUpdate(workInProgress2, createCapturedValueAtFiber(error$1, workInProgress2), lane);
                  enqueueCapturedUpdate(workInProgress2, update2);
                  break;
                }
              }
              if (workInProgress2.type !== workInProgress2.elementType) {
                var innerPropTypes = Component.propTypes;
                if (innerPropTypes) {
                  checkPropTypes(
                    innerPropTypes,
                    nextProps,
                    // Resolved props
                    "prop",
                    getComponentNameFromType(Component)
                  );
                }
              }
            }
            var hasContext;
            if (isContextProvider(Component)) {
              hasContext = true;
              pushContextProvider(workInProgress2);
            } else {
              hasContext = false;
            }
            prepareToReadContext(workInProgress2, renderLanes2);
            var instance = workInProgress2.stateNode;
            var shouldUpdate;
            if (instance === null) {
              resetSuspendedCurrentOnMountInLegacyMode(current2, workInProgress2);
              constructClassInstance(workInProgress2, Component, nextProps);
              mountClassInstance(workInProgress2, Component, nextProps, renderLanes2);
              shouldUpdate = true;
            } else if (current2 === null) {
              shouldUpdate = resumeMountClassInstance(workInProgress2, Component, nextProps, renderLanes2);
            } else {
              shouldUpdate = updateClassInstance(current2, workInProgress2, Component, nextProps, renderLanes2);
            }
            var nextUnitOfWork = finishClassComponent(current2, workInProgress2, Component, shouldUpdate, hasContext, renderLanes2);
            {
              var inst = workInProgress2.stateNode;
              if (shouldUpdate && inst.props !== nextProps) {
                if (!didWarnAboutReassigningProps) {
                  error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromFiber(workInProgress2) || "a component");
                }
                didWarnAboutReassigningProps = true;
              }
            }
            return nextUnitOfWork;
          }
          function finishClassComponent(current2, workInProgress2, Component, shouldUpdate, hasContext, renderLanes2) {
            markRef(current2, workInProgress2);
            var didCaptureError = (workInProgress2.flags & DidCapture) !== NoFlags;
            if (!shouldUpdate && !didCaptureError) {
              if (hasContext) {
                invalidateContextProvider(workInProgress2, Component, false);
              }
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            }
            var instance = workInProgress2.stateNode;
            ReactCurrentOwner$1.current = workInProgress2;
            var nextChildren;
            if (didCaptureError && typeof Component.getDerivedStateFromError !== "function") {
              nextChildren = null;
              {
                stopProfilerTimerIfRunning();
              }
            } else {
              {
                markComponentRenderStarted(workInProgress2);
              }
              {
                setIsRendering(true);
                nextChildren = instance.render();
                if (workInProgress2.mode & StrictLegacyMode) {
                  setIsStrictModeForDevtools(true);
                  try {
                    instance.render();
                  } finally {
                    setIsStrictModeForDevtools(false);
                  }
                }
                setIsRendering(false);
              }
              {
                markComponentRenderStopped();
              }
            }
            workInProgress2.flags |= PerformedWork;
            if (current2 !== null && didCaptureError) {
              forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2);
            } else {
              reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            }
            workInProgress2.memoizedState = instance.state;
            if (hasContext) {
              invalidateContextProvider(workInProgress2, Component, true);
            }
            return workInProgress2.child;
          }
          function pushHostRootContext(workInProgress2) {
            var root3 = workInProgress2.stateNode;
            if (root3.pendingContext) {
              pushTopLevelContextObject(workInProgress2, root3.pendingContext, root3.pendingContext !== root3.context);
            } else if (root3.context) {
              pushTopLevelContextObject(workInProgress2, root3.context, false);
            }
            pushHostContainer(workInProgress2, root3.containerInfo);
          }
          function updateHostRoot(current2, workInProgress2, renderLanes2) {
            pushHostRootContext(workInProgress2);
            if (current2 === null) {
              throw new Error("Should have a current fiber. This is a bug in React.");
            }
            var nextProps = workInProgress2.pendingProps;
            var prevState = workInProgress2.memoizedState;
            var prevChildren = prevState.element;
            cloneUpdateQueue(current2, workInProgress2);
            processUpdateQueue(workInProgress2, nextProps, null, renderLanes2);
            var nextState = workInProgress2.memoizedState;
            var root3 = workInProgress2.stateNode;
            var nextChildren = nextState.element;
            if (prevState.isDehydrated) {
              var overrideState = {
                element: nextChildren,
                isDehydrated: false,
                cache: nextState.cache,
                pendingSuspenseBoundaries: nextState.pendingSuspenseBoundaries,
                transitions: nextState.transitions
              };
              var updateQueue = workInProgress2.updateQueue;
              updateQueue.baseState = overrideState;
              workInProgress2.memoizedState = overrideState;
              if (workInProgress2.flags & ForceClientRender) {
                var recoverableError = createCapturedValueAtFiber(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), workInProgress2);
                return mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, recoverableError);
              } else if (nextChildren !== prevChildren) {
                var _recoverableError = createCapturedValueAtFiber(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), workInProgress2);
                return mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, _recoverableError);
              } else {
                enterHydrationState(workInProgress2);
                var child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);
                workInProgress2.child = child;
                var node = child;
                while (node) {
                  node.flags = node.flags & ~Placement | Hydrating;
                  node = node.sibling;
                }
              }
            } else {
              resetHydrationState();
              if (nextChildren === prevChildren) {
                return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
              }
              reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            }
            return workInProgress2.child;
          }
          function mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, recoverableError) {
            resetHydrationState();
            queueHydrationError(recoverableError);
            workInProgress2.flags |= ForceClientRender;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateHostComponent(current2, workInProgress2, renderLanes2) {
            pushHostContext(workInProgress2);
            if (current2 === null) {
              tryToClaimNextHydratableInstance(workInProgress2);
            }
            var type = workInProgress2.type;
            var nextProps = workInProgress2.pendingProps;
            var prevProps = current2 !== null ? current2.memoizedProps : null;
            var nextChildren = nextProps.children;
            var isDirectTextChild = shouldSetTextContent(type, nextProps);
            if (isDirectTextChild) {
              nextChildren = null;
            } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {
              workInProgress2.flags |= ContentReset;
            }
            markRef(current2, workInProgress2);
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateHostText(current2, workInProgress2) {
            if (current2 === null) {
              tryToClaimNextHydratableInstance(workInProgress2);
            }
            return null;
          }
          function mountLazyComponent(_current, workInProgress2, elementType, renderLanes2) {
            resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
            var props = workInProgress2.pendingProps;
            var lazyComponent = elementType;
            var payload = lazyComponent._payload;
            var init2 = lazyComponent._init;
            var Component = init2(payload);
            workInProgress2.type = Component;
            var resolvedTag = workInProgress2.tag = resolveLazyComponentTag(Component);
            var resolvedProps = resolveDefaultProps(Component, props);
            var child;
            switch (resolvedTag) {
              case FunctionComponent: {
                {
                  validateFunctionComponentInDev(workInProgress2, Component);
                  workInProgress2.type = Component = resolveFunctionForHotReloading(Component);
                }
                child = updateFunctionComponent(null, workInProgress2, Component, resolvedProps, renderLanes2);
                return child;
              }
              case ClassComponent: {
                {
                  workInProgress2.type = Component = resolveClassForHotReloading(Component);
                }
                child = updateClassComponent(null, workInProgress2, Component, resolvedProps, renderLanes2);
                return child;
              }
              case ForwardRef: {
                {
                  workInProgress2.type = Component = resolveForwardRefForHotReloading(Component);
                }
                child = updateForwardRef(null, workInProgress2, Component, resolvedProps, renderLanes2);
                return child;
              }
              case MemoComponent: {
                {
                  if (workInProgress2.type !== workInProgress2.elementType) {
                    var outerPropTypes = Component.propTypes;
                    if (outerPropTypes) {
                      checkPropTypes(
                        outerPropTypes,
                        resolvedProps,
                        // Resolved for outer only
                        "prop",
                        getComponentNameFromType(Component)
                      );
                    }
                  }
                }
                child = updateMemoComponent(
                  null,
                  workInProgress2,
                  Component,
                  resolveDefaultProps(Component.type, resolvedProps),
                  // The inner type can have defaults too
                  renderLanes2
                );
                return child;
              }
            }
            var hint = "";
            {
              if (Component !== null && typeof Component === "object" && Component.$$typeof === REACT_LAZY_TYPE) {
                hint = " Did you wrap a component in React.lazy() more than once?";
              }
            }
            throw new Error("Element type is invalid. Received a promise that resolves to: " + Component + ". " + ("Lazy element type must resolve to a class or function." + hint));
          }
          function mountIncompleteClassComponent(_current, workInProgress2, Component, nextProps, renderLanes2) {
            resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
            workInProgress2.tag = ClassComponent;
            var hasContext;
            if (isContextProvider(Component)) {
              hasContext = true;
              pushContextProvider(workInProgress2);
            } else {
              hasContext = false;
            }
            prepareToReadContext(workInProgress2, renderLanes2);
            constructClassInstance(workInProgress2, Component, nextProps);
            mountClassInstance(workInProgress2, Component, nextProps, renderLanes2);
            return finishClassComponent(null, workInProgress2, Component, true, hasContext, renderLanes2);
          }
          function mountIndeterminateComponent(_current, workInProgress2, Component, renderLanes2) {
            resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
            var props = workInProgress2.pendingProps;
            var context;
            {
              var unmaskedContext = getUnmaskedContext(workInProgress2, Component, false);
              context = getMaskedContext(workInProgress2, unmaskedContext);
            }
            prepareToReadContext(workInProgress2, renderLanes2);
            var value;
            var hasId;
            {
              markComponentRenderStarted(workInProgress2);
            }
            {
              if (Component.prototype && typeof Component.prototype.render === "function") {
                var componentName = getComponentNameFromType(Component) || "Unknown";
                if (!didWarnAboutBadClass[componentName]) {
                  error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
                  didWarnAboutBadClass[componentName] = true;
                }
              }
              if (workInProgress2.mode & StrictLegacyMode) {
                ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, null);
              }
              setIsRendering(true);
              ReactCurrentOwner$1.current = workInProgress2;
              value = renderWithHooks(null, workInProgress2, Component, props, context, renderLanes2);
              hasId = checkDidRenderIdHook();
              setIsRendering(false);
            }
            {
              markComponentRenderStopped();
            }
            workInProgress2.flags |= PerformedWork;
            {
              if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0) {
                var _componentName = getComponentNameFromType(Component) || "Unknown";
                if (!didWarnAboutModulePatternComponent[_componentName]) {
                  error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName);
                  didWarnAboutModulePatternComponent[_componentName] = true;
                }
              }
            }
            if (
              // Run these checks in production only if the flag is off.
              // Eventually we'll delete this branch altogether.
              typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === void 0
            ) {
              {
                var _componentName2 = getComponentNameFromType(Component) || "Unknown";
                if (!didWarnAboutModulePatternComponent[_componentName2]) {
                  error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2);
                  didWarnAboutModulePatternComponent[_componentName2] = true;
                }
              }
              workInProgress2.tag = ClassComponent;
              workInProgress2.memoizedState = null;
              workInProgress2.updateQueue = null;
              var hasContext = false;
              if (isContextProvider(Component)) {
                hasContext = true;
                pushContextProvider(workInProgress2);
              } else {
                hasContext = false;
              }
              workInProgress2.memoizedState = value.state !== null && value.state !== void 0 ? value.state : null;
              initializeUpdateQueue(workInProgress2);
              adoptClassInstance(workInProgress2, value);
              mountClassInstance(workInProgress2, Component, props, renderLanes2);
              return finishClassComponent(null, workInProgress2, Component, true, hasContext, renderLanes2);
            } else {
              workInProgress2.tag = FunctionComponent;
              {
                if (workInProgress2.mode & StrictLegacyMode) {
                  setIsStrictModeForDevtools(true);
                  try {
                    value = renderWithHooks(null, workInProgress2, Component, props, context, renderLanes2);
                    hasId = checkDidRenderIdHook();
                  } finally {
                    setIsStrictModeForDevtools(false);
                  }
                }
              }
              if (getIsHydrating() && hasId) {
                pushMaterializedTreeId(workInProgress2);
              }
              reconcileChildren(null, workInProgress2, value, renderLanes2);
              {
                validateFunctionComponentInDev(workInProgress2, Component);
              }
              return workInProgress2.child;
            }
          }
          function validateFunctionComponentInDev(workInProgress2, Component) {
            {
              if (Component) {
                if (Component.childContextTypes) {
                  error("%s(...): childContextTypes cannot be defined on a function component.", Component.displayName || Component.name || "Component");
                }
              }
              if (workInProgress2.ref !== null) {
                var info = "";
                var ownerName = getCurrentFiberOwnerNameInDevOrNull();
                if (ownerName) {
                  info += "\n\nCheck the render method of `" + ownerName + "`.";
                }
                var warningKey = ownerName || "";
                var debugSource = workInProgress2._debugSource;
                if (debugSource) {
                  warningKey = debugSource.fileName + ":" + debugSource.lineNumber;
                }
                if (!didWarnAboutFunctionRefs[warningKey]) {
                  didWarnAboutFunctionRefs[warningKey] = true;
                  error("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", info);
                }
              }
              if (typeof Component.getDerivedStateFromProps === "function") {
                var _componentName3 = getComponentNameFromType(Component) || "Unknown";
                if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
                  error("%s: Function components do not support getDerivedStateFromProps.", _componentName3);
                  didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
                }
              }
              if (typeof Component.contextType === "object" && Component.contextType !== null) {
                var _componentName4 = getComponentNameFromType(Component) || "Unknown";
                if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
                  error("%s: Function components do not support contextType.", _componentName4);
                  didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
                }
              }
            }
          }
          var SUSPENDED_MARKER = {
            dehydrated: null,
            treeContext: null,
            retryLane: NoLane
          };
          function mountSuspenseOffscreenState(renderLanes2) {
            return {
              baseLanes: renderLanes2,
              cachePool: getSuspendedCache(),
              transitions: null
            };
          }
          function updateSuspenseOffscreenState(prevOffscreenState, renderLanes2) {
            var cachePool = null;
            return {
              baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes2),
              cachePool,
              transitions: prevOffscreenState.transitions
            };
          }
          function shouldRemainOnFallback(suspenseContext, current2, workInProgress2, renderLanes2) {
            if (current2 !== null) {
              var suspenseState = current2.memoizedState;
              if (suspenseState === null) {
                return false;
              }
            }
            return hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
          }
          function getRemainingWorkInPrimaryTree(current2, renderLanes2) {
            return removeLanes(current2.childLanes, renderLanes2);
          }
          function updateSuspenseComponent(current2, workInProgress2, renderLanes2) {
            var nextProps = workInProgress2.pendingProps;
            {
              if (shouldSuspend(workInProgress2)) {
                workInProgress2.flags |= DidCapture;
              }
            }
            var suspenseContext = suspenseStackCursor.current;
            var showFallback = false;
            var didSuspend = (workInProgress2.flags & DidCapture) !== NoFlags;
            if (didSuspend || shouldRemainOnFallback(suspenseContext, current2)) {
              showFallback = true;
              workInProgress2.flags &= ~DidCapture;
            } else {
              if (current2 === null || current2.memoizedState !== null) {
                {
                  suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext);
                }
              }
            }
            suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
            pushSuspenseContext(workInProgress2, suspenseContext);
            if (current2 === null) {
              tryToClaimNextHydratableInstance(workInProgress2);
              var suspenseState = workInProgress2.memoizedState;
              if (suspenseState !== null) {
                var dehydrated = suspenseState.dehydrated;
                if (dehydrated !== null) {
                  return mountDehydratedSuspenseComponent(workInProgress2, dehydrated);
                }
              }
              var nextPrimaryChildren = nextProps.children;
              var nextFallbackChildren = nextProps.fallback;
              if (showFallback) {
                var fallbackFragment = mountSuspenseFallbackChildren(workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2);
                var primaryChildFragment = workInProgress2.child;
                primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes2);
                workInProgress2.memoizedState = SUSPENDED_MARKER;
                return fallbackFragment;
              } else {
                return mountSuspensePrimaryChildren(workInProgress2, nextPrimaryChildren);
              }
            } else {
              var prevState = current2.memoizedState;
              if (prevState !== null) {
                var _dehydrated = prevState.dehydrated;
                if (_dehydrated !== null) {
                  return updateDehydratedSuspenseComponent(current2, workInProgress2, didSuspend, nextProps, _dehydrated, prevState, renderLanes2);
                }
              }
              if (showFallback) {
                var _nextFallbackChildren = nextProps.fallback;
                var _nextPrimaryChildren = nextProps.children;
                var fallbackChildFragment = updateSuspenseFallbackChildren(current2, workInProgress2, _nextPrimaryChildren, _nextFallbackChildren, renderLanes2);
                var _primaryChildFragment2 = workInProgress2.child;
                var prevOffscreenState = current2.child.memoizedState;
                _primaryChildFragment2.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes2) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes2);
                _primaryChildFragment2.childLanes = getRemainingWorkInPrimaryTree(current2, renderLanes2);
                workInProgress2.memoizedState = SUSPENDED_MARKER;
                return fallbackChildFragment;
              } else {
                var _nextPrimaryChildren2 = nextProps.children;
                var _primaryChildFragment3 = updateSuspensePrimaryChildren(current2, workInProgress2, _nextPrimaryChildren2, renderLanes2);
                workInProgress2.memoizedState = null;
                return _primaryChildFragment3;
              }
            }
          }
          function mountSuspensePrimaryChildren(workInProgress2, primaryChildren, renderLanes2) {
            var mode = workInProgress2.mode;
            var primaryChildProps = {
              mode: "visible",
              children: primaryChildren
            };
            var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);
            primaryChildFragment.return = workInProgress2;
            workInProgress2.child = primaryChildFragment;
            return primaryChildFragment;
          }
          function mountSuspenseFallbackChildren(workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
            var mode = workInProgress2.mode;
            var progressedPrimaryFragment = workInProgress2.child;
            var primaryChildProps = {
              mode: "hidden",
              children: primaryChildren
            };
            var primaryChildFragment;
            var fallbackChildFragment;
            if ((mode & ConcurrentMode) === NoMode && progressedPrimaryFragment !== null) {
              primaryChildFragment = progressedPrimaryFragment;
              primaryChildFragment.childLanes = NoLanes;
              primaryChildFragment.pendingProps = primaryChildProps;
              if (workInProgress2.mode & ProfileMode) {
                primaryChildFragment.actualDuration = 0;
                primaryChildFragment.actualStartTime = -1;
                primaryChildFragment.selfBaseDuration = 0;
                primaryChildFragment.treeBaseDuration = 0;
              }
              fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
            } else {
              primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);
              fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
            }
            primaryChildFragment.return = workInProgress2;
            fallbackChildFragment.return = workInProgress2;
            primaryChildFragment.sibling = fallbackChildFragment;
            workInProgress2.child = primaryChildFragment;
            return fallbackChildFragment;
          }
          function mountWorkInProgressOffscreenFiber(offscreenProps, mode, renderLanes2) {
            return createFiberFromOffscreen(offscreenProps, mode, NoLanes, null);
          }
          function updateWorkInProgressOffscreenFiber(current2, offscreenProps) {
            return createWorkInProgress(current2, offscreenProps);
          }
          function updateSuspensePrimaryChildren(current2, workInProgress2, primaryChildren, renderLanes2) {
            var currentPrimaryChildFragment = current2.child;
            var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
            var primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {
              mode: "visible",
              children: primaryChildren
            });
            if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
              primaryChildFragment.lanes = renderLanes2;
            }
            primaryChildFragment.return = workInProgress2;
            primaryChildFragment.sibling = null;
            if (currentFallbackChildFragment !== null) {
              var deletions = workInProgress2.deletions;
              if (deletions === null) {
                workInProgress2.deletions = [currentFallbackChildFragment];
                workInProgress2.flags |= ChildDeletion;
              } else {
                deletions.push(currentFallbackChildFragment);
              }
            }
            workInProgress2.child = primaryChildFragment;
            return primaryChildFragment;
          }
          function updateSuspenseFallbackChildren(current2, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
            var mode = workInProgress2.mode;
            var currentPrimaryChildFragment = current2.child;
            var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
            var primaryChildProps = {
              mode: "hidden",
              children: primaryChildren
            };
            var primaryChildFragment;
            if (
              // In legacy mode, we commit the primary tree as if it successfully
              // completed, even though it's in an inconsistent state.
              (mode & ConcurrentMode) === NoMode && // Make sure we're on the second pass, i.e. the primary child fragment was
              // already cloned. In legacy mode, the only case where this isn't true is
              // when DevTools forces us to display a fallback; we skip the first render
              // pass entirely and go straight to rendering the fallback. (In Concurrent
              // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
              // only codepath.)
              workInProgress2.child !== currentPrimaryChildFragment
            ) {
              var progressedPrimaryFragment = workInProgress2.child;
              primaryChildFragment = progressedPrimaryFragment;
              primaryChildFragment.childLanes = NoLanes;
              primaryChildFragment.pendingProps = primaryChildProps;
              if (workInProgress2.mode & ProfileMode) {
                primaryChildFragment.actualDuration = 0;
                primaryChildFragment.actualStartTime = -1;
                primaryChildFragment.selfBaseDuration = currentPrimaryChildFragment.selfBaseDuration;
                primaryChildFragment.treeBaseDuration = currentPrimaryChildFragment.treeBaseDuration;
              }
              workInProgress2.deletions = null;
            } else {
              primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps);
              primaryChildFragment.subtreeFlags = currentPrimaryChildFragment.subtreeFlags & StaticMask;
            }
            var fallbackChildFragment;
            if (currentFallbackChildFragment !== null) {
              fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren);
            } else {
              fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
              fallbackChildFragment.flags |= Placement;
            }
            fallbackChildFragment.return = workInProgress2;
            primaryChildFragment.return = workInProgress2;
            primaryChildFragment.sibling = fallbackChildFragment;
            workInProgress2.child = primaryChildFragment;
            return fallbackChildFragment;
          }
          function retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, recoverableError) {
            if (recoverableError !== null) {
              queueHydrationError(recoverableError);
            }
            reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
            var nextProps = workInProgress2.pendingProps;
            var primaryChildren = nextProps.children;
            var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress2, primaryChildren);
            primaryChildFragment.flags |= Placement;
            workInProgress2.memoizedState = null;
            return primaryChildFragment;
          }
          function mountSuspenseFallbackAfterRetryWithoutHydrating(current2, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
            var fiberMode = workInProgress2.mode;
            var primaryChildProps = {
              mode: "visible",
              children: primaryChildren
            };
            var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, fiberMode);
            var fallbackChildFragment = createFiberFromFragment(fallbackChildren, fiberMode, renderLanes2, null);
            fallbackChildFragment.flags |= Placement;
            primaryChildFragment.return = workInProgress2;
            fallbackChildFragment.return = workInProgress2;
            primaryChildFragment.sibling = fallbackChildFragment;
            workInProgress2.child = primaryChildFragment;
            if ((workInProgress2.mode & ConcurrentMode) !== NoMode) {
              reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
            }
            return fallbackChildFragment;
          }
          function mountDehydratedSuspenseComponent(workInProgress2, suspenseInstance, renderLanes2) {
            if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
              {
                error("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components.");
              }
              workInProgress2.lanes = laneToLanes(SyncLane);
            } else if (isSuspenseInstanceFallback(suspenseInstance)) {
              workInProgress2.lanes = laneToLanes(DefaultHydrationLane);
            } else {
              workInProgress2.lanes = laneToLanes(OffscreenLane);
            }
            return null;
          }
          function updateDehydratedSuspenseComponent(current2, workInProgress2, didSuspend, nextProps, suspenseInstance, suspenseState, renderLanes2) {
            if (!didSuspend) {
              warnIfHydrating();
              if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
                return retrySuspenseComponentWithoutHydrating(
                  current2,
                  workInProgress2,
                  renderLanes2,
                  // TODO: When we delete legacy mode, we should make this error argument
                  // required  every concurrent mode path that causes hydration to
                  // de-opt to client rendering should have an error message.
                  null
                );
              }
              if (isSuspenseInstanceFallback(suspenseInstance)) {
                var digest2, message, stack;
                {
                  var _getSuspenseInstanceF = getSuspenseInstanceFallbackErrorDetails(suspenseInstance);
                  digest2 = _getSuspenseInstanceF.digest;
                  message = _getSuspenseInstanceF.message;
                  stack = _getSuspenseInstanceF.stack;
                }
                var error2;
                if (message) {
                  error2 = new Error(message);
                } else {
                  error2 = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
                }
                var capturedValue = createCapturedValue(error2, digest2, stack);
                return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, capturedValue);
              }
              var hasContextChanged2 = includesSomeLane(renderLanes2, current2.childLanes);
              if (didReceiveUpdate || hasContextChanged2) {
                var root3 = getWorkInProgressRoot();
                if (root3 !== null) {
                  var attemptHydrationAtLane = getBumpedLaneForHydration(root3, renderLanes2);
                  if (attemptHydrationAtLane !== NoLane && attemptHydrationAtLane !== suspenseState.retryLane) {
                    suspenseState.retryLane = attemptHydrationAtLane;
                    var eventTime = NoTimestamp;
                    enqueueConcurrentRenderForLane(current2, attemptHydrationAtLane);
                    scheduleUpdateOnFiber(root3, current2, attemptHydrationAtLane, eventTime);
                  }
                }
                renderDidSuspendDelayIfPossible();
                var _capturedValue = createCapturedValue(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
                return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, _capturedValue);
              } else if (isSuspenseInstancePending(suspenseInstance)) {
                workInProgress2.flags |= DidCapture;
                workInProgress2.child = current2.child;
                var retry = retryDehydratedSuspenseBoundary.bind(null, current2);
                registerSuspenseInstanceRetry(suspenseInstance, retry);
                return null;
              } else {
                reenterHydrationStateFromDehydratedSuspenseInstance(workInProgress2, suspenseInstance, suspenseState.treeContext);
                var primaryChildren = nextProps.children;
                var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress2, primaryChildren);
                primaryChildFragment.flags |= Hydrating;
                return primaryChildFragment;
              }
            } else {
              if (workInProgress2.flags & ForceClientRender) {
                workInProgress2.flags &= ~ForceClientRender;
                var _capturedValue2 = createCapturedValue(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
                return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, _capturedValue2);
              } else if (workInProgress2.memoizedState !== null) {
                workInProgress2.child = current2.child;
                workInProgress2.flags |= DidCapture;
                return null;
              } else {
                var nextPrimaryChildren = nextProps.children;
                var nextFallbackChildren = nextProps.fallback;
                var fallbackChildFragment = mountSuspenseFallbackAfterRetryWithoutHydrating(current2, workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2);
                var _primaryChildFragment4 = workInProgress2.child;
                _primaryChildFragment4.memoizedState = mountSuspenseOffscreenState(renderLanes2);
                workInProgress2.memoizedState = SUSPENDED_MARKER;
                return fallbackChildFragment;
              }
            }
          }
          function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
            fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
            var alternate = fiber.alternate;
            if (alternate !== null) {
              alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);
            }
            scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);
          }
          function propagateSuspenseContextChange(workInProgress2, firstChild, renderLanes2) {
            var node = firstChild;
            while (node !== null) {
              if (node.tag === SuspenseComponent) {
                var state = node.memoizedState;
                if (state !== null) {
                  scheduleSuspenseWorkOnFiber(node, renderLanes2, workInProgress2);
                }
              } else if (node.tag === SuspenseListComponent) {
                scheduleSuspenseWorkOnFiber(node, renderLanes2, workInProgress2);
              } else if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === workInProgress2) {
                return;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === workInProgress2) {
                  return;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
          }
          function findLastContentRow(firstChild) {
            var row = firstChild;
            var lastContentRow = null;
            while (row !== null) {
              var currentRow = row.alternate;
              if (currentRow !== null && findFirstSuspended(currentRow) === null) {
                lastContentRow = row;
              }
              row = row.sibling;
            }
            return lastContentRow;
          }
          function validateRevealOrder(revealOrder) {
            {
              if (revealOrder !== void 0 && revealOrder !== "forwards" && revealOrder !== "backwards" && revealOrder !== "together" && !didWarnAboutRevealOrder[revealOrder]) {
                didWarnAboutRevealOrder[revealOrder] = true;
                if (typeof revealOrder === "string") {
                  switch (revealOrder.toLowerCase()) {
                    case "together":
                    case "forwards":
                    case "backwards": {
                      error('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', revealOrder, revealOrder.toLowerCase());
                      break;
                    }
                    case "forward":
                    case "backward": {
                      error('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', revealOrder, revealOrder.toLowerCase());
                      break;
                    }
                    default:
                      error('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
                      break;
                  }
                } else {
                  error('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
                }
              }
            }
          }
          function validateTailOptions(tailMode, revealOrder) {
            {
              if (tailMode !== void 0 && !didWarnAboutTailOptions[tailMode]) {
                if (tailMode !== "collapsed" && tailMode !== "hidden") {
                  didWarnAboutTailOptions[tailMode] = true;
                  error('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', tailMode);
                } else if (revealOrder !== "forwards" && revealOrder !== "backwards") {
                  didWarnAboutTailOptions[tailMode] = true;
                  error('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', tailMode);
                }
              }
            }
          }
          function validateSuspenseListNestedChild(childSlot, index3) {
            {
              var isAnArray = isArray2(childSlot);
              var isIterable = !isAnArray && typeof getIteratorFn(childSlot) === "function";
              if (isAnArray || isIterable) {
                var type = isAnArray ? "array" : "iterable";
                error("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", type, index3, type);
                return false;
              }
            }
            return true;
          }
          function validateSuspenseListChildren(children, revealOrder) {
            {
              if ((revealOrder === "forwards" || revealOrder === "backwards") && children !== void 0 && children !== null && children !== false) {
                if (isArray2(children)) {
                  for (var i7 = 0; i7 < children.length; i7++) {
                    if (!validateSuspenseListNestedChild(children[i7], i7)) {
                      return;
                    }
                  }
                } else {
                  var iteratorFn = getIteratorFn(children);
                  if (typeof iteratorFn === "function") {
                    var childrenIterator = iteratorFn.call(children);
                    if (childrenIterator) {
                      var step = childrenIterator.next();
                      var _i = 0;
                      for (; !step.done; step = childrenIterator.next()) {
                        if (!validateSuspenseListNestedChild(step.value, _i)) {
                          return;
                        }
                        _i++;
                      }
                    }
                  } else {
                    error('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', revealOrder);
                  }
                }
              }
            }
          }
          function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode) {
            var renderState = workInProgress2.memoizedState;
            if (renderState === null) {
              workInProgress2.memoizedState = {
                isBackwards,
                rendering: null,
                renderingStartTime: 0,
                last: lastContentRow,
                tail,
                tailMode
              };
            } else {
              renderState.isBackwards = isBackwards;
              renderState.rendering = null;
              renderState.renderingStartTime = 0;
              renderState.last = lastContentRow;
              renderState.tail = tail;
              renderState.tailMode = tailMode;
            }
          }
          function updateSuspenseListComponent(current2, workInProgress2, renderLanes2) {
            var nextProps = workInProgress2.pendingProps;
            var revealOrder = nextProps.revealOrder;
            var tailMode = nextProps.tail;
            var newChildren = nextProps.children;
            validateRevealOrder(revealOrder);
            validateTailOptions(tailMode, revealOrder);
            validateSuspenseListChildren(newChildren, revealOrder);
            reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
            var suspenseContext = suspenseStackCursor.current;
            var shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
            if (shouldForceFallback) {
              suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
              workInProgress2.flags |= DidCapture;
            } else {
              var didSuspendBefore = current2 !== null && (current2.flags & DidCapture) !== NoFlags;
              if (didSuspendBefore) {
                propagateSuspenseContextChange(workInProgress2, workInProgress2.child, renderLanes2);
              }
              suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
            }
            pushSuspenseContext(workInProgress2, suspenseContext);
            if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
              workInProgress2.memoizedState = null;
            } else {
              switch (revealOrder) {
                case "forwards": {
                  var lastContentRow = findLastContentRow(workInProgress2.child);
                  var tail;
                  if (lastContentRow === null) {
                    tail = workInProgress2.child;
                    workInProgress2.child = null;
                  } else {
                    tail = lastContentRow.sibling;
                    lastContentRow.sibling = null;
                  }
                  initSuspenseListRenderState(
                    workInProgress2,
                    false,
                    // isBackwards
                    tail,
                    lastContentRow,
                    tailMode
                  );
                  break;
                }
                case "backwards": {
                  var _tail = null;
                  var row = workInProgress2.child;
                  workInProgress2.child = null;
                  while (row !== null) {
                    var currentRow = row.alternate;
                    if (currentRow !== null && findFirstSuspended(currentRow) === null) {
                      workInProgress2.child = row;
                      break;
                    }
                    var nextRow = row.sibling;
                    row.sibling = _tail;
                    _tail = row;
                    row = nextRow;
                  }
                  initSuspenseListRenderState(
                    workInProgress2,
                    true,
                    // isBackwards
                    _tail,
                    null,
                    // last
                    tailMode
                  );
                  break;
                }
                case "together": {
                  initSuspenseListRenderState(
                    workInProgress2,
                    false,
                    // isBackwards
                    null,
                    // tail
                    null,
                    // last
                    void 0
                  );
                  break;
                }
                default: {
                  workInProgress2.memoizedState = null;
                }
              }
            }
            return workInProgress2.child;
          }
          function updatePortalComponent(current2, workInProgress2, renderLanes2) {
            pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
            var nextChildren = workInProgress2.pendingProps;
            if (current2 === null) {
              workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);
            } else {
              reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            }
            return workInProgress2.child;
          }
          var hasWarnedAboutUsingNoValuePropOnContextProvider = false;
          function updateContextProvider(current2, workInProgress2, renderLanes2) {
            var providerType = workInProgress2.type;
            var context = providerType._context;
            var newProps = workInProgress2.pendingProps;
            var oldProps = workInProgress2.memoizedProps;
            var newValue = newProps.value;
            {
              if (!("value" in newProps)) {
                if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {
                  hasWarnedAboutUsingNoValuePropOnContextProvider = true;
                  error("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?");
                }
              }
              var providerPropTypes = workInProgress2.type.propTypes;
              if (providerPropTypes) {
                checkPropTypes(providerPropTypes, newProps, "prop", "Context.Provider");
              }
            }
            pushProvider(workInProgress2, context, newValue);
            {
              if (oldProps !== null) {
                var oldValue = oldProps.value;
                if (objectIs(oldValue, newValue)) {
                  if (oldProps.children === newProps.children && !hasContextChanged()) {
                    return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                  }
                } else {
                  propagateContextChange(workInProgress2, context, renderLanes2);
                }
              }
            }
            var newChildren = newProps.children;
            reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
            return workInProgress2.child;
          }
          var hasWarnedAboutUsingContextAsConsumer = false;
          function updateContextConsumer(current2, workInProgress2, renderLanes2) {
            var context = workInProgress2.type;
            {
              if (context._context === void 0) {
                if (context !== context.Consumer) {
                  if (!hasWarnedAboutUsingContextAsConsumer) {
                    hasWarnedAboutUsingContextAsConsumer = true;
                    error("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                  }
                }
              } else {
                context = context._context;
              }
            }
            var newProps = workInProgress2.pendingProps;
            var render2 = newProps.children;
            {
              if (typeof render2 !== "function") {
                error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
              }
            }
            prepareToReadContext(workInProgress2, renderLanes2);
            var newValue = readContext(context);
            {
              markComponentRenderStarted(workInProgress2);
            }
            var newChildren;
            {
              ReactCurrentOwner$1.current = workInProgress2;
              setIsRendering(true);
              newChildren = render2(newValue);
              setIsRendering(false);
            }
            {
              markComponentRenderStopped();
            }
            workInProgress2.flags |= PerformedWork;
            reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
            return workInProgress2.child;
          }
          function markWorkInProgressReceivedUpdate() {
            didReceiveUpdate = true;
          }
          function resetSuspendedCurrentOnMountInLegacyMode(current2, workInProgress2) {
            if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
              if (current2 !== null) {
                current2.alternate = null;
                workInProgress2.alternate = null;
                workInProgress2.flags |= Placement;
              }
            }
          }
          function bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2) {
            if (current2 !== null) {
              workInProgress2.dependencies = current2.dependencies;
            }
            {
              stopProfilerTimerIfRunning();
            }
            markSkippedUpdateLanes(workInProgress2.lanes);
            if (!includesSomeLane(renderLanes2, workInProgress2.childLanes)) {
              {
                return null;
              }
            }
            cloneChildFibers(current2, workInProgress2);
            return workInProgress2.child;
          }
          function remountFiber(current2, oldWorkInProgress, newWorkInProgress) {
            {
              var returnFiber = oldWorkInProgress.return;
              if (returnFiber === null) {
                throw new Error("Cannot swap the root fiber.");
              }
              current2.alternate = null;
              oldWorkInProgress.alternate = null;
              newWorkInProgress.index = oldWorkInProgress.index;
              newWorkInProgress.sibling = oldWorkInProgress.sibling;
              newWorkInProgress.return = oldWorkInProgress.return;
              newWorkInProgress.ref = oldWorkInProgress.ref;
              if (oldWorkInProgress === returnFiber.child) {
                returnFiber.child = newWorkInProgress;
              } else {
                var prevSibling = returnFiber.child;
                if (prevSibling === null) {
                  throw new Error("Expected parent to have a child.");
                }
                while (prevSibling.sibling !== oldWorkInProgress) {
                  prevSibling = prevSibling.sibling;
                  if (prevSibling === null) {
                    throw new Error("Expected to find the previous sibling.");
                  }
                }
                prevSibling.sibling = newWorkInProgress;
              }
              var deletions = returnFiber.deletions;
              if (deletions === null) {
                returnFiber.deletions = [current2];
                returnFiber.flags |= ChildDeletion;
              } else {
                deletions.push(current2);
              }
              newWorkInProgress.flags |= Placement;
              return newWorkInProgress;
            }
          }
          function checkScheduledUpdateOrContext(current2, renderLanes2) {
            var updateLanes = current2.lanes;
            if (includesSomeLane(updateLanes, renderLanes2)) {
              return true;
            }
            return false;
          }
          function attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2) {
            switch (workInProgress2.tag) {
              case HostRoot:
                pushHostRootContext(workInProgress2);
                var root3 = workInProgress2.stateNode;
                resetHydrationState();
                break;
              case HostComponent:
                pushHostContext(workInProgress2);
                break;
              case ClassComponent: {
                var Component = workInProgress2.type;
                if (isContextProvider(Component)) {
                  pushContextProvider(workInProgress2);
                }
                break;
              }
              case HostPortal:
                pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
                break;
              case ContextProvider: {
                var newValue = workInProgress2.memoizedProps.value;
                var context = workInProgress2.type._context;
                pushProvider(workInProgress2, context, newValue);
                break;
              }
              case Profiler:
                {
                  var hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
                  if (hasChildWork) {
                    workInProgress2.flags |= Update;
                  }
                  {
                    var stateNode = workInProgress2.stateNode;
                    stateNode.effectDuration = 0;
                    stateNode.passiveEffectDuration = 0;
                  }
                }
                break;
              case SuspenseComponent: {
                var state = workInProgress2.memoizedState;
                if (state !== null) {
                  if (state.dehydrated !== null) {
                    pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                    workInProgress2.flags |= DidCapture;
                    return null;
                  }
                  var primaryChildFragment = workInProgress2.child;
                  var primaryChildLanes = primaryChildFragment.childLanes;
                  if (includesSomeLane(renderLanes2, primaryChildLanes)) {
                    return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
                  } else {
                    pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                    var child = bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                    if (child !== null) {
                      return child.sibling;
                    } else {
                      return null;
                    }
                  }
                } else {
                  pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                }
                break;
              }
              case SuspenseListComponent: {
                var didSuspendBefore = (current2.flags & DidCapture) !== NoFlags;
                var _hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
                if (didSuspendBefore) {
                  if (_hasChildWork) {
                    return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
                  }
                  workInProgress2.flags |= DidCapture;
                }
                var renderState = workInProgress2.memoizedState;
                if (renderState !== null) {
                  renderState.rendering = null;
                  renderState.tail = null;
                  renderState.lastEffect = null;
                }
                pushSuspenseContext(workInProgress2, suspenseStackCursor.current);
                if (_hasChildWork) {
                  break;
                } else {
                  return null;
                }
              }
              case OffscreenComponent:
              case LegacyHiddenComponent: {
                workInProgress2.lanes = NoLanes;
                return updateOffscreenComponent(current2, workInProgress2, renderLanes2);
              }
            }
            return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          }
          function beginWork(current2, workInProgress2, renderLanes2) {
            {
              if (workInProgress2._debugNeedsRemount && current2 !== null) {
                return remountFiber(current2, workInProgress2, createFiberFromTypeAndProps(workInProgress2.type, workInProgress2.key, workInProgress2.pendingProps, workInProgress2._debugOwner || null, workInProgress2.mode, workInProgress2.lanes));
              }
            }
            if (current2 !== null) {
              var oldProps = current2.memoizedProps;
              var newProps = workInProgress2.pendingProps;
              if (oldProps !== newProps || hasContextChanged() || // Force a re-render if the implementation changed due to hot reload:
              workInProgress2.type !== current2.type) {
                didReceiveUpdate = true;
              } else {
                var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current2, renderLanes2);
                if (!hasScheduledUpdateOrContext && // If this is the second pass of an error or suspense boundary, there
                // may not be work scheduled on `current`, so we check for this flag.
                (workInProgress2.flags & DidCapture) === NoFlags) {
                  didReceiveUpdate = false;
                  return attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2);
                }
                if ((current2.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
                  didReceiveUpdate = true;
                } else {
                  didReceiveUpdate = false;
                }
              }
            } else {
              didReceiveUpdate = false;
              if (getIsHydrating() && isForkedChild(workInProgress2)) {
                var slotIndex = workInProgress2.index;
                var numberOfForks = getForksAtLevel();
                pushTreeId(workInProgress2, numberOfForks, slotIndex);
              }
            }
            workInProgress2.lanes = NoLanes;
            switch (workInProgress2.tag) {
              case IndeterminateComponent: {
                return mountIndeterminateComponent(current2, workInProgress2, workInProgress2.type, renderLanes2);
              }
              case LazyComponent: {
                var elementType = workInProgress2.elementType;
                return mountLazyComponent(current2, workInProgress2, elementType, renderLanes2);
              }
              case FunctionComponent: {
                var Component = workInProgress2.type;
                var unresolvedProps = workInProgress2.pendingProps;
                var resolvedProps = workInProgress2.elementType === Component ? unresolvedProps : resolveDefaultProps(Component, unresolvedProps);
                return updateFunctionComponent(current2, workInProgress2, Component, resolvedProps, renderLanes2);
              }
              case ClassComponent: {
                var _Component = workInProgress2.type;
                var _unresolvedProps = workInProgress2.pendingProps;
                var _resolvedProps = workInProgress2.elementType === _Component ? _unresolvedProps : resolveDefaultProps(_Component, _unresolvedProps);
                return updateClassComponent(current2, workInProgress2, _Component, _resolvedProps, renderLanes2);
              }
              case HostRoot:
                return updateHostRoot(current2, workInProgress2, renderLanes2);
              case HostComponent:
                return updateHostComponent(current2, workInProgress2, renderLanes2);
              case HostText:
                return updateHostText(current2, workInProgress2);
              case SuspenseComponent:
                return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
              case HostPortal:
                return updatePortalComponent(current2, workInProgress2, renderLanes2);
              case ForwardRef: {
                var type = workInProgress2.type;
                var _unresolvedProps2 = workInProgress2.pendingProps;
                var _resolvedProps2 = workInProgress2.elementType === type ? _unresolvedProps2 : resolveDefaultProps(type, _unresolvedProps2);
                return updateForwardRef(current2, workInProgress2, type, _resolvedProps2, renderLanes2);
              }
              case Fragment2:
                return updateFragment(current2, workInProgress2, renderLanes2);
              case Mode:
                return updateMode(current2, workInProgress2, renderLanes2);
              case Profiler:
                return updateProfiler(current2, workInProgress2, renderLanes2);
              case ContextProvider:
                return updateContextProvider(current2, workInProgress2, renderLanes2);
              case ContextConsumer:
                return updateContextConsumer(current2, workInProgress2, renderLanes2);
              case MemoComponent: {
                var _type2 = workInProgress2.type;
                var _unresolvedProps3 = workInProgress2.pendingProps;
                var _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);
                {
                  if (workInProgress2.type !== workInProgress2.elementType) {
                    var outerPropTypes = _type2.propTypes;
                    if (outerPropTypes) {
                      checkPropTypes(
                        outerPropTypes,
                        _resolvedProps3,
                        // Resolved for outer only
                        "prop",
                        getComponentNameFromType(_type2)
                      );
                    }
                  }
                }
                _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);
                return updateMemoComponent(current2, workInProgress2, _type2, _resolvedProps3, renderLanes2);
              }
              case SimpleMemoComponent: {
                return updateSimpleMemoComponent(current2, workInProgress2, workInProgress2.type, workInProgress2.pendingProps, renderLanes2);
              }
              case IncompleteClassComponent: {
                var _Component2 = workInProgress2.type;
                var _unresolvedProps4 = workInProgress2.pendingProps;
                var _resolvedProps4 = workInProgress2.elementType === _Component2 ? _unresolvedProps4 : resolveDefaultProps(_Component2, _unresolvedProps4);
                return mountIncompleteClassComponent(current2, workInProgress2, _Component2, _resolvedProps4, renderLanes2);
              }
              case SuspenseListComponent: {
                return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
              }
              case ScopeComponent: {
                break;
              }
              case OffscreenComponent: {
                return updateOffscreenComponent(current2, workInProgress2, renderLanes2);
              }
            }
            throw new Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
          }
          function markUpdate(workInProgress2) {
            workInProgress2.flags |= Update;
          }
          function markRef$1(workInProgress2) {
            workInProgress2.flags |= Ref;
            {
              workInProgress2.flags |= RefStatic;
            }
          }
          var appendAllChildren;
          var updateHostContainer;
          var updateHostComponent$1;
          var updateHostText$1;
          {
            appendAllChildren = function(parent, workInProgress2, needsVisibilityToggle, isHidden) {
              var node = workInProgress2.child;
              while (node !== null) {
                if (node.tag === HostComponent || node.tag === HostText) {
                  appendInitialChild(parent, node.stateNode);
                } else if (node.tag === HostPortal)
                  ;
                else if (node.child !== null) {
                  node.child.return = node;
                  node = node.child;
                  continue;
                }
                if (node === workInProgress2) {
                  return;
                }
                while (node.sibling === null) {
                  if (node.return === null || node.return === workInProgress2) {
                    return;
                  }
                  node = node.return;
                }
                node.sibling.return = node.return;
                node = node.sibling;
              }
            };
            updateHostContainer = function(current2, workInProgress2) {
            };
            updateHostComponent$1 = function(current2, workInProgress2, type, newProps, rootContainerInstance) {
              var oldProps = current2.memoizedProps;
              if (oldProps === newProps) {
                return;
              }
              var instance = workInProgress2.stateNode;
              var currentHostContext = getHostContext();
              var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);
              workInProgress2.updateQueue = updatePayload;
              if (updatePayload) {
                markUpdate(workInProgress2);
              }
            };
            updateHostText$1 = function(current2, workInProgress2, oldText, newText) {
              if (oldText !== newText) {
                markUpdate(workInProgress2);
              }
            };
          }
          function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
            if (getIsHydrating()) {
              return;
            }
            switch (renderState.tailMode) {
              case "hidden": {
                var tailNode = renderState.tail;
                var lastTailNode = null;
                while (tailNode !== null) {
                  if (tailNode.alternate !== null) {
                    lastTailNode = tailNode;
                  }
                  tailNode = tailNode.sibling;
                }
                if (lastTailNode === null) {
                  renderState.tail = null;
                } else {
                  lastTailNode.sibling = null;
                }
                break;
              }
              case "collapsed": {
                var _tailNode = renderState.tail;
                var _lastTailNode = null;
                while (_tailNode !== null) {
                  if (_tailNode.alternate !== null) {
                    _lastTailNode = _tailNode;
                  }
                  _tailNode = _tailNode.sibling;
                }
                if (_lastTailNode === null) {
                  if (!hasRenderedATailFallback && renderState.tail !== null) {
                    renderState.tail.sibling = null;
                  } else {
                    renderState.tail = null;
                  }
                } else {
                  _lastTailNode.sibling = null;
                }
                break;
              }
            }
          }
          function bubbleProperties(completedWork) {
            var didBailout = completedWork.alternate !== null && completedWork.alternate.child === completedWork.child;
            var newChildLanes = NoLanes;
            var subtreeFlags = NoFlags;
            if (!didBailout) {
              if ((completedWork.mode & ProfileMode) !== NoMode) {
                var actualDuration = completedWork.actualDuration;
                var treeBaseDuration = completedWork.selfBaseDuration;
                var child = completedWork.child;
                while (child !== null) {
                  newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));
                  subtreeFlags |= child.subtreeFlags;
                  subtreeFlags |= child.flags;
                  actualDuration += child.actualDuration;
                  treeBaseDuration += child.treeBaseDuration;
                  child = child.sibling;
                }
                completedWork.actualDuration = actualDuration;
                completedWork.treeBaseDuration = treeBaseDuration;
              } else {
                var _child = completedWork.child;
                while (_child !== null) {
                  newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child.lanes, _child.childLanes));
                  subtreeFlags |= _child.subtreeFlags;
                  subtreeFlags |= _child.flags;
                  _child.return = completedWork;
                  _child = _child.sibling;
                }
              }
              completedWork.subtreeFlags |= subtreeFlags;
            } else {
              if ((completedWork.mode & ProfileMode) !== NoMode) {
                var _treeBaseDuration = completedWork.selfBaseDuration;
                var _child2 = completedWork.child;
                while (_child2 !== null) {
                  newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child2.lanes, _child2.childLanes));
                  subtreeFlags |= _child2.subtreeFlags & StaticMask;
                  subtreeFlags |= _child2.flags & StaticMask;
                  _treeBaseDuration += _child2.treeBaseDuration;
                  _child2 = _child2.sibling;
                }
                completedWork.treeBaseDuration = _treeBaseDuration;
              } else {
                var _child3 = completedWork.child;
                while (_child3 !== null) {
                  newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child3.lanes, _child3.childLanes));
                  subtreeFlags |= _child3.subtreeFlags & StaticMask;
                  subtreeFlags |= _child3.flags & StaticMask;
                  _child3.return = completedWork;
                  _child3 = _child3.sibling;
                }
              }
              completedWork.subtreeFlags |= subtreeFlags;
            }
            completedWork.childLanes = newChildLanes;
            return didBailout;
          }
          function completeDehydratedSuspenseBoundary(current2, workInProgress2, nextState) {
            if (hasUnhydratedTailNodes() && (workInProgress2.mode & ConcurrentMode) !== NoMode && (workInProgress2.flags & DidCapture) === NoFlags) {
              warnIfUnhydratedTailNodes(workInProgress2);
              resetHydrationState();
              workInProgress2.flags |= ForceClientRender | Incomplete | ShouldCapture;
              return false;
            }
            var wasHydrated = popHydrationState(workInProgress2);
            if (nextState !== null && nextState.dehydrated !== null) {
              if (current2 === null) {
                if (!wasHydrated) {
                  throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
                }
                prepareToHydrateHostSuspenseInstance(workInProgress2);
                bubbleProperties(workInProgress2);
                {
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    var isTimedOutSuspense = nextState !== null;
                    if (isTimedOutSuspense) {
                      var primaryChildFragment = workInProgress2.child;
                      if (primaryChildFragment !== null) {
                        workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration;
                      }
                    }
                  }
                }
                return false;
              } else {
                resetHydrationState();
                if ((workInProgress2.flags & DidCapture) === NoFlags) {
                  workInProgress2.memoizedState = null;
                }
                workInProgress2.flags |= Update;
                bubbleProperties(workInProgress2);
                {
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    var _isTimedOutSuspense = nextState !== null;
                    if (_isTimedOutSuspense) {
                      var _primaryChildFragment = workInProgress2.child;
                      if (_primaryChildFragment !== null) {
                        workInProgress2.treeBaseDuration -= _primaryChildFragment.treeBaseDuration;
                      }
                    }
                  }
                }
                return false;
              }
            } else {
              upgradeHydrationErrorsToRecoverable();
              return true;
            }
          }
          function completeWork(current2, workInProgress2, renderLanes2) {
            var newProps = workInProgress2.pendingProps;
            popTreeContext(workInProgress2);
            switch (workInProgress2.tag) {
              case IndeterminateComponent:
              case LazyComponent:
              case SimpleMemoComponent:
              case FunctionComponent:
              case ForwardRef:
              case Fragment2:
              case Mode:
              case Profiler:
              case ContextConsumer:
              case MemoComponent:
                bubbleProperties(workInProgress2);
                return null;
              case ClassComponent: {
                var Component = workInProgress2.type;
                if (isContextProvider(Component)) {
                  popContext(workInProgress2);
                }
                bubbleProperties(workInProgress2);
                return null;
              }
              case HostRoot: {
                var fiberRoot = workInProgress2.stateNode;
                popHostContainer(workInProgress2);
                popTopLevelContextObject(workInProgress2);
                resetWorkInProgressVersions();
                if (fiberRoot.pendingContext) {
                  fiberRoot.context = fiberRoot.pendingContext;
                  fiberRoot.pendingContext = null;
                }
                if (current2 === null || current2.child === null) {
                  var wasHydrated = popHydrationState(workInProgress2);
                  if (wasHydrated) {
                    markUpdate(workInProgress2);
                  } else {
                    if (current2 !== null) {
                      var prevState = current2.memoizedState;
                      if (
                        // Check if this is a client root
                        !prevState.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
                        (workInProgress2.flags & ForceClientRender) !== NoFlags
                      ) {
                        workInProgress2.flags |= Snapshot;
                        upgradeHydrationErrorsToRecoverable();
                      }
                    }
                  }
                }
                updateHostContainer(current2, workInProgress2);
                bubbleProperties(workInProgress2);
                return null;
              }
              case HostComponent: {
                popHostContext(workInProgress2);
                var rootContainerInstance = getRootHostContainer();
                var type = workInProgress2.type;
                if (current2 !== null && workInProgress2.stateNode != null) {
                  updateHostComponent$1(current2, workInProgress2, type, newProps, rootContainerInstance);
                  if (current2.ref !== workInProgress2.ref) {
                    markRef$1(workInProgress2);
                  }
                } else {
                  if (!newProps) {
                    if (workInProgress2.stateNode === null) {
                      throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                    }
                    bubbleProperties(workInProgress2);
                    return null;
                  }
                  var currentHostContext = getHostContext();
                  var _wasHydrated = popHydrationState(workInProgress2);
                  if (_wasHydrated) {
                    if (prepareToHydrateHostInstance(workInProgress2, rootContainerInstance, currentHostContext)) {
                      markUpdate(workInProgress2);
                    }
                  } else {
                    var instance = createInstance2(type, newProps, rootContainerInstance, currentHostContext, workInProgress2);
                    appendAllChildren(instance, workInProgress2, false, false);
                    workInProgress2.stateNode = instance;
                    if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance)) {
                      markUpdate(workInProgress2);
                    }
                  }
                  if (workInProgress2.ref !== null) {
                    markRef$1(workInProgress2);
                  }
                }
                bubbleProperties(workInProgress2);
                return null;
              }
              case HostText: {
                var newText = newProps;
                if (current2 && workInProgress2.stateNode != null) {
                  var oldText = current2.memoizedProps;
                  updateHostText$1(current2, workInProgress2, oldText, newText);
                } else {
                  if (typeof newText !== "string") {
                    if (workInProgress2.stateNode === null) {
                      throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                    }
                  }
                  var _rootContainerInstance = getRootHostContainer();
                  var _currentHostContext = getHostContext();
                  var _wasHydrated2 = popHydrationState(workInProgress2);
                  if (_wasHydrated2) {
                    if (prepareToHydrateHostTextInstance(workInProgress2)) {
                      markUpdate(workInProgress2);
                    }
                  } else {
                    workInProgress2.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress2);
                  }
                }
                bubbleProperties(workInProgress2);
                return null;
              }
              case SuspenseComponent: {
                popSuspenseContext(workInProgress2);
                var nextState = workInProgress2.memoizedState;
                if (current2 === null || current2.memoizedState !== null && current2.memoizedState.dehydrated !== null) {
                  var fallthroughToNormalSuspensePath = completeDehydratedSuspenseBoundary(current2, workInProgress2, nextState);
                  if (!fallthroughToNormalSuspensePath) {
                    if (workInProgress2.flags & ShouldCapture) {
                      return workInProgress2;
                    } else {
                      return null;
                    }
                  }
                }
                if ((workInProgress2.flags & DidCapture) !== NoFlags) {
                  workInProgress2.lanes = renderLanes2;
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    transferActualDuration(workInProgress2);
                  }
                  return workInProgress2;
                }
                var nextDidTimeout = nextState !== null;
                var prevDidTimeout = current2 !== null && current2.memoizedState !== null;
                if (nextDidTimeout !== prevDidTimeout) {
                  if (nextDidTimeout) {
                    var _offscreenFiber2 = workInProgress2.child;
                    _offscreenFiber2.flags |= Visibility;
                    if ((workInProgress2.mode & ConcurrentMode) !== NoMode) {
                      var hasInvisibleChildContext = current2 === null && (workInProgress2.memoizedProps.unstable_avoidThisFallback !== true || !enableSuspenseAvoidThisFallback);
                      if (hasInvisibleChildContext || hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext)) {
                        renderDidSuspend();
                      } else {
                        renderDidSuspendDelayIfPossible();
                      }
                    }
                  }
                }
                var wakeables = workInProgress2.updateQueue;
                if (wakeables !== null) {
                  workInProgress2.flags |= Update;
                }
                bubbleProperties(workInProgress2);
                {
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    if (nextDidTimeout) {
                      var primaryChildFragment = workInProgress2.child;
                      if (primaryChildFragment !== null) {
                        workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration;
                      }
                    }
                  }
                }
                return null;
              }
              case HostPortal:
                popHostContainer(workInProgress2);
                updateHostContainer(current2, workInProgress2);
                if (current2 === null) {
                  preparePortalMount(workInProgress2.stateNode.containerInfo);
                }
                bubbleProperties(workInProgress2);
                return null;
              case ContextProvider:
                var context = workInProgress2.type._context;
                popProvider(context, workInProgress2);
                bubbleProperties(workInProgress2);
                return null;
              case IncompleteClassComponent: {
                var _Component = workInProgress2.type;
                if (isContextProvider(_Component)) {
                  popContext(workInProgress2);
                }
                bubbleProperties(workInProgress2);
                return null;
              }
              case SuspenseListComponent: {
                popSuspenseContext(workInProgress2);
                var renderState = workInProgress2.memoizedState;
                if (renderState === null) {
                  bubbleProperties(workInProgress2);
                  return null;
                }
                var didSuspendAlready = (workInProgress2.flags & DidCapture) !== NoFlags;
                var renderedTail = renderState.rendering;
                if (renderedTail === null) {
                  if (!didSuspendAlready) {
                    var cannotBeSuspended = renderHasNotSuspendedYet() && (current2 === null || (current2.flags & DidCapture) === NoFlags);
                    if (!cannotBeSuspended) {
                      var row = workInProgress2.child;
                      while (row !== null) {
                        var suspended = findFirstSuspended(row);
                        if (suspended !== null) {
                          didSuspendAlready = true;
                          workInProgress2.flags |= DidCapture;
                          cutOffTailIfNeeded(renderState, false);
                          var newThenables = suspended.updateQueue;
                          if (newThenables !== null) {
                            workInProgress2.updateQueue = newThenables;
                            workInProgress2.flags |= Update;
                          }
                          workInProgress2.subtreeFlags = NoFlags;
                          resetChildFibers(workInProgress2, renderLanes2);
                          pushSuspenseContext(workInProgress2, setShallowSuspenseContext(suspenseStackCursor.current, ForceSuspenseFallback));
                          return workInProgress2.child;
                        }
                        row = row.sibling;
                      }
                    }
                    if (renderState.tail !== null && now2() > getRenderTargetTime()) {
                      workInProgress2.flags |= DidCapture;
                      didSuspendAlready = true;
                      cutOffTailIfNeeded(renderState, false);
                      workInProgress2.lanes = SomeRetryLane;
                    }
                  } else {
                    cutOffTailIfNeeded(renderState, false);
                  }
                } else {
                  if (!didSuspendAlready) {
                    var _suspended = findFirstSuspended(renderedTail);
                    if (_suspended !== null) {
                      workInProgress2.flags |= DidCapture;
                      didSuspendAlready = true;
                      var _newThenables = _suspended.updateQueue;
                      if (_newThenables !== null) {
                        workInProgress2.updateQueue = _newThenables;
                        workInProgress2.flags |= Update;
                      }
                      cutOffTailIfNeeded(renderState, true);
                      if (renderState.tail === null && renderState.tailMode === "hidden" && !renderedTail.alternate && !getIsHydrating()) {
                        bubbleProperties(workInProgress2);
                        return null;
                      }
                    } else if (
                      // The time it took to render last row is greater than the remaining
                      // time we have to render. So rendering one more row would likely
                      // exceed it.
                      now2() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes2 !== OffscreenLane
                    ) {
                      workInProgress2.flags |= DidCapture;
                      didSuspendAlready = true;
                      cutOffTailIfNeeded(renderState, false);
                      workInProgress2.lanes = SomeRetryLane;
                    }
                  }
                  if (renderState.isBackwards) {
                    renderedTail.sibling = workInProgress2.child;
                    workInProgress2.child = renderedTail;
                  } else {
                    var previousSibling = renderState.last;
                    if (previousSibling !== null) {
                      previousSibling.sibling = renderedTail;
                    } else {
                      workInProgress2.child = renderedTail;
                    }
                    renderState.last = renderedTail;
                  }
                }
                if (renderState.tail !== null) {
                  var next = renderState.tail;
                  renderState.rendering = next;
                  renderState.tail = next.sibling;
                  renderState.renderingStartTime = now2();
                  next.sibling = null;
                  var suspenseContext = suspenseStackCursor.current;
                  if (didSuspendAlready) {
                    suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
                  } else {
                    suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
                  }
                  pushSuspenseContext(workInProgress2, suspenseContext);
                  return next;
                }
                bubbleProperties(workInProgress2);
                return null;
              }
              case ScopeComponent: {
                break;
              }
              case OffscreenComponent:
              case LegacyHiddenComponent: {
                popRenderLanes(workInProgress2);
                var _nextState = workInProgress2.memoizedState;
                var nextIsHidden = _nextState !== null;
                if (current2 !== null) {
                  var _prevState = current2.memoizedState;
                  var prevIsHidden = _prevState !== null;
                  if (prevIsHidden !== nextIsHidden && // LegacyHidden doesn't do any hiding  it only pre-renders.
                  !enableLegacyHidden) {
                    workInProgress2.flags |= Visibility;
                  }
                }
                if (!nextIsHidden || (workInProgress2.mode & ConcurrentMode) === NoMode) {
                  bubbleProperties(workInProgress2);
                } else {
                  if (includesSomeLane(subtreeRenderLanes, OffscreenLane)) {
                    bubbleProperties(workInProgress2);
                    {
                      if (workInProgress2.subtreeFlags & (Placement | Update)) {
                        workInProgress2.flags |= Visibility;
                      }
                    }
                  }
                }
                return null;
              }
              case CacheComponent: {
                return null;
              }
              case TracingMarkerComponent: {
                return null;
              }
            }
            throw new Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
          }
          function unwindWork(current2, workInProgress2, renderLanes2) {
            popTreeContext(workInProgress2);
            switch (workInProgress2.tag) {
              case ClassComponent: {
                var Component = workInProgress2.type;
                if (isContextProvider(Component)) {
                  popContext(workInProgress2);
                }
                var flags = workInProgress2.flags;
                if (flags & ShouldCapture) {
                  workInProgress2.flags = flags & ~ShouldCapture | DidCapture;
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    transferActualDuration(workInProgress2);
                  }
                  return workInProgress2;
                }
                return null;
              }
              case HostRoot: {
                var root3 = workInProgress2.stateNode;
                popHostContainer(workInProgress2);
                popTopLevelContextObject(workInProgress2);
                resetWorkInProgressVersions();
                var _flags = workInProgress2.flags;
                if ((_flags & ShouldCapture) !== NoFlags && (_flags & DidCapture) === NoFlags) {
                  workInProgress2.flags = _flags & ~ShouldCapture | DidCapture;
                  return workInProgress2;
                }
                return null;
              }
              case HostComponent: {
                popHostContext(workInProgress2);
                return null;
              }
              case SuspenseComponent: {
                popSuspenseContext(workInProgress2);
                var suspenseState = workInProgress2.memoizedState;
                if (suspenseState !== null && suspenseState.dehydrated !== null) {
                  if (workInProgress2.alternate === null) {
                    throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
                  }
                  resetHydrationState();
                }
                var _flags2 = workInProgress2.flags;
                if (_flags2 & ShouldCapture) {
                  workInProgress2.flags = _flags2 & ~ShouldCapture | DidCapture;
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    transferActualDuration(workInProgress2);
                  }
                  return workInProgress2;
                }
                return null;
              }
              case SuspenseListComponent: {
                popSuspenseContext(workInProgress2);
                return null;
              }
              case HostPortal:
                popHostContainer(workInProgress2);
                return null;
              case ContextProvider:
                var context = workInProgress2.type._context;
                popProvider(context, workInProgress2);
                return null;
              case OffscreenComponent:
              case LegacyHiddenComponent:
                popRenderLanes(workInProgress2);
                return null;
              case CacheComponent:
                return null;
              default:
                return null;
            }
          }
          function unwindInterruptedWork(current2, interruptedWork, renderLanes2) {
            popTreeContext(interruptedWork);
            switch (interruptedWork.tag) {
              case ClassComponent: {
                var childContextTypes = interruptedWork.type.childContextTypes;
                if (childContextTypes !== null && childContextTypes !== void 0) {
                  popContext(interruptedWork);
                }
                break;
              }
              case HostRoot: {
                var root3 = interruptedWork.stateNode;
                popHostContainer(interruptedWork);
                popTopLevelContextObject(interruptedWork);
                resetWorkInProgressVersions();
                break;
              }
              case HostComponent: {
                popHostContext(interruptedWork);
                break;
              }
              case HostPortal:
                popHostContainer(interruptedWork);
                break;
              case SuspenseComponent:
                popSuspenseContext(interruptedWork);
                break;
              case SuspenseListComponent:
                popSuspenseContext(interruptedWork);
                break;
              case ContextProvider:
                var context = interruptedWork.type._context;
                popProvider(context, interruptedWork);
                break;
              case OffscreenComponent:
              case LegacyHiddenComponent:
                popRenderLanes(interruptedWork);
                break;
            }
          }
          var didWarnAboutUndefinedSnapshotBeforeUpdate = null;
          {
            didWarnAboutUndefinedSnapshotBeforeUpdate = /* @__PURE__ */ new Set();
          }
          var offscreenSubtreeIsHidden = false;
          var offscreenSubtreeWasHidden = false;
          var PossiblyWeakSet = typeof WeakSet === "function" ? WeakSet : Set;
          var nextEffect = null;
          var inProgressLanes = null;
          var inProgressRoot = null;
          function reportUncaughtErrorInDEV(error2) {
            {
              invokeGuardedCallback(null, function() {
                throw error2;
              });
              clearCaughtError();
            }
          }
          var callComponentWillUnmountWithTimer = function(current2, instance) {
            instance.props = current2.memoizedProps;
            instance.state = current2.memoizedState;
            if (current2.mode & ProfileMode) {
              try {
                startLayoutEffectTimer();
                instance.componentWillUnmount();
              } finally {
                recordLayoutEffectDuration(current2);
              }
            } else {
              instance.componentWillUnmount();
            }
          };
          function safelyCallCommitHookLayoutEffectListMount(current2, nearestMountedAncestor) {
            try {
              commitHookEffectListMount(Layout, current2);
            } catch (error2) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error2);
            }
          }
          function safelyCallComponentWillUnmount(current2, nearestMountedAncestor, instance) {
            try {
              callComponentWillUnmountWithTimer(current2, instance);
            } catch (error2) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error2);
            }
          }
          function safelyCallComponentDidMount(current2, nearestMountedAncestor, instance) {
            try {
              instance.componentDidMount();
            } catch (error2) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error2);
            }
          }
          function safelyAttachRef(current2, nearestMountedAncestor) {
            try {
              commitAttachRef(current2);
            } catch (error2) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error2);
            }
          }
          function safelyDetachRef(current2, nearestMountedAncestor) {
            var ref = current2.ref;
            if (ref !== null) {
              if (typeof ref === "function") {
                var retVal;
                try {
                  if (enableProfilerTimer && enableProfilerCommitHooks && current2.mode & ProfileMode) {
                    try {
                      startLayoutEffectTimer();
                      retVal = ref(null);
                    } finally {
                      recordLayoutEffectDuration(current2);
                    }
                  } else {
                    retVal = ref(null);
                  }
                } catch (error2) {
                  captureCommitPhaseError(current2, nearestMountedAncestor, error2);
                }
                {
                  if (typeof retVal === "function") {
                    error("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", getComponentNameFromFiber(current2));
                  }
                }
              } else {
                ref.current = null;
              }
            }
          }
          function safelyCallDestroy(current2, nearestMountedAncestor, destroy) {
            try {
              destroy();
            } catch (error2) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error2);
            }
          }
          var focusedInstanceHandle = null;
          var shouldFireAfterActiveInstanceBlur = false;
          function commitBeforeMutationEffects(root3, firstChild) {
            focusedInstanceHandle = prepareForCommit(root3.containerInfo);
            nextEffect = firstChild;
            commitBeforeMutationEffects_begin();
            var shouldFire = shouldFireAfterActiveInstanceBlur;
            shouldFireAfterActiveInstanceBlur = false;
            focusedInstanceHandle = null;
            return shouldFire;
          }
          function commitBeforeMutationEffects_begin() {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var child = fiber.child;
              if ((fiber.subtreeFlags & BeforeMutationMask) !== NoFlags && child !== null) {
                child.return = fiber;
                nextEffect = child;
              } else {
                commitBeforeMutationEffects_complete();
              }
            }
          }
          function commitBeforeMutationEffects_complete() {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              setCurrentFiber(fiber);
              try {
                commitBeforeMutationEffectsOnFiber(fiber);
              } catch (error2) {
                captureCommitPhaseError(fiber, fiber.return, error2);
              }
              resetCurrentFiber();
              var sibling = fiber.sibling;
              if (sibling !== null) {
                sibling.return = fiber.return;
                nextEffect = sibling;
                return;
              }
              nextEffect = fiber.return;
            }
          }
          function commitBeforeMutationEffectsOnFiber(finishedWork) {
            var current2 = finishedWork.alternate;
            var flags = finishedWork.flags;
            if ((flags & Snapshot) !== NoFlags) {
              setCurrentFiber(finishedWork);
              switch (finishedWork.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent: {
                  break;
                }
                case ClassComponent: {
                  if (current2 !== null) {
                    var prevProps = current2.memoizedProps;
                    var prevState = current2.memoizedState;
                    var instance = finishedWork.stateNode;
                    {
                      if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                        if (instance.props !== finishedWork.memoizedProps) {
                          error("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                        }
                        if (instance.state !== finishedWork.memoizedState) {
                          error("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                        }
                      }
                    }
                    var snapshot4 = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);
                    {
                      var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;
                      if (snapshot4 === void 0 && !didWarnSet.has(finishedWork.type)) {
                        didWarnSet.add(finishedWork.type);
                        error("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", getComponentNameFromFiber(finishedWork));
                      }
                    }
                    instance.__reactInternalSnapshotBeforeUpdate = snapshot4;
                  }
                  break;
                }
                case HostRoot: {
                  {
                    var root3 = finishedWork.stateNode;
                    clearContainer(root3.containerInfo);
                  }
                  break;
                }
                case HostComponent:
                case HostText:
                case HostPortal:
                case IncompleteClassComponent:
                  break;
                default: {
                  throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
              resetCurrentFiber();
            }
          }
          function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {
            var updateQueue = finishedWork.updateQueue;
            var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
            if (lastEffect !== null) {
              var firstEffect = lastEffect.next;
              var effect = firstEffect;
              do {
                if ((effect.tag & flags) === flags) {
                  var destroy = effect.destroy;
                  effect.destroy = void 0;
                  if (destroy !== void 0) {
                    {
                      if ((flags & Passive$1) !== NoFlags$1) {
                        markComponentPassiveEffectUnmountStarted(finishedWork);
                      } else if ((flags & Layout) !== NoFlags$1) {
                        markComponentLayoutEffectUnmountStarted(finishedWork);
                      }
                    }
                    {
                      if ((flags & Insertion) !== NoFlags$1) {
                        setIsRunningInsertionEffect(true);
                      }
                    }
                    safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy);
                    {
                      if ((flags & Insertion) !== NoFlags$1) {
                        setIsRunningInsertionEffect(false);
                      }
                    }
                    {
                      if ((flags & Passive$1) !== NoFlags$1) {
                        markComponentPassiveEffectUnmountStopped();
                      } else if ((flags & Layout) !== NoFlags$1) {
                        markComponentLayoutEffectUnmountStopped();
                      }
                    }
                  }
                }
                effect = effect.next;
              } while (effect !== firstEffect);
            }
          }
          function commitHookEffectListMount(flags, finishedWork) {
            var updateQueue = finishedWork.updateQueue;
            var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
            if (lastEffect !== null) {
              var firstEffect = lastEffect.next;
              var effect = firstEffect;
              do {
                if ((effect.tag & flags) === flags) {
                  {
                    if ((flags & Passive$1) !== NoFlags$1) {
                      markComponentPassiveEffectMountStarted(finishedWork);
                    } else if ((flags & Layout) !== NoFlags$1) {
                      markComponentLayoutEffectMountStarted(finishedWork);
                    }
                  }
                  var create3 = effect.create;
                  {
                    if ((flags & Insertion) !== NoFlags$1) {
                      setIsRunningInsertionEffect(true);
                    }
                  }
                  effect.destroy = create3();
                  {
                    if ((flags & Insertion) !== NoFlags$1) {
                      setIsRunningInsertionEffect(false);
                    }
                  }
                  {
                    if ((flags & Passive$1) !== NoFlags$1) {
                      markComponentPassiveEffectMountStopped();
                    } else if ((flags & Layout) !== NoFlags$1) {
                      markComponentLayoutEffectMountStopped();
                    }
                  }
                  {
                    var destroy = effect.destroy;
                    if (destroy !== void 0 && typeof destroy !== "function") {
                      var hookName = void 0;
                      if ((effect.tag & Layout) !== NoFlags) {
                        hookName = "useLayoutEffect";
                      } else if ((effect.tag & Insertion) !== NoFlags) {
                        hookName = "useInsertionEffect";
                      } else {
                        hookName = "useEffect";
                      }
                      var addendum = void 0;
                      if (destroy === null) {
                        addendum = " You returned null. If your effect does not require clean up, return undefined (or nothing).";
                      } else if (typeof destroy.then === "function") {
                        addendum = "\n\nIt looks like you wrote " + hookName + "(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\n" + hookName + "(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching";
                      } else {
                        addendum = " You returned: " + destroy;
                      }
                      error("%s must not return anything besides a function, which is used for clean-up.%s", hookName, addendum);
                    }
                  }
                }
                effect = effect.next;
              } while (effect !== firstEffect);
            }
          }
          function commitPassiveEffectDurations(finishedRoot, finishedWork) {
            {
              if ((finishedWork.flags & Update) !== NoFlags) {
                switch (finishedWork.tag) {
                  case Profiler: {
                    var passiveEffectDuration = finishedWork.stateNode.passiveEffectDuration;
                    var _finishedWork$memoize = finishedWork.memoizedProps, id3 = _finishedWork$memoize.id, onPostCommit = _finishedWork$memoize.onPostCommit;
                    var commitTime2 = getCommitTime();
                    var phase = finishedWork.alternate === null ? "mount" : "update";
                    {
                      if (isCurrentUpdateNested()) {
                        phase = "nested-update";
                      }
                    }
                    if (typeof onPostCommit === "function") {
                      onPostCommit(id3, phase, passiveEffectDuration, commitTime2);
                    }
                    var parentFiber = finishedWork.return;
                    outer:
                      while (parentFiber !== null) {
                        switch (parentFiber.tag) {
                          case HostRoot:
                            var root3 = parentFiber.stateNode;
                            root3.passiveEffectDuration += passiveEffectDuration;
                            break outer;
                          case Profiler:
                            var parentStateNode = parentFiber.stateNode;
                            parentStateNode.passiveEffectDuration += passiveEffectDuration;
                            break outer;
                        }
                        parentFiber = parentFiber.return;
                      }
                    break;
                  }
                }
              }
            }
          }
          function commitLayoutEffectOnFiber(finishedRoot, current2, finishedWork, committedLanes) {
            if ((finishedWork.flags & LayoutMask) !== NoFlags) {
              switch (finishedWork.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent: {
                  if (!offscreenSubtreeWasHidden) {
                    if (finishedWork.mode & ProfileMode) {
                      try {
                        startLayoutEffectTimer();
                        commitHookEffectListMount(Layout | HasEffect, finishedWork);
                      } finally {
                        recordLayoutEffectDuration(finishedWork);
                      }
                    } else {
                      commitHookEffectListMount(Layout | HasEffect, finishedWork);
                    }
                  }
                  break;
                }
                case ClassComponent: {
                  var instance = finishedWork.stateNode;
                  if (finishedWork.flags & Update) {
                    if (!offscreenSubtreeWasHidden) {
                      if (current2 === null) {
                        {
                          if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                            if (instance.props !== finishedWork.memoizedProps) {
                              error("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                            }
                            if (instance.state !== finishedWork.memoizedState) {
                              error("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                            }
                          }
                        }
                        if (finishedWork.mode & ProfileMode) {
                          try {
                            startLayoutEffectTimer();
                            instance.componentDidMount();
                          } finally {
                            recordLayoutEffectDuration(finishedWork);
                          }
                        } else {
                          instance.componentDidMount();
                        }
                      } else {
                        var prevProps = finishedWork.elementType === finishedWork.type ? current2.memoizedProps : resolveDefaultProps(finishedWork.type, current2.memoizedProps);
                        var prevState = current2.memoizedState;
                        {
                          if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                            if (instance.props !== finishedWork.memoizedProps) {
                              error("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                            }
                            if (instance.state !== finishedWork.memoizedState) {
                              error("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                            }
                          }
                        }
                        if (finishedWork.mode & ProfileMode) {
                          try {
                            startLayoutEffectTimer();
                            instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                          } finally {
                            recordLayoutEffectDuration(finishedWork);
                          }
                        } else {
                          instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                        }
                      }
                    }
                  }
                  var updateQueue = finishedWork.updateQueue;
                  if (updateQueue !== null) {
                    {
                      if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                        if (instance.props !== finishedWork.memoizedProps) {
                          error("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                        }
                        if (instance.state !== finishedWork.memoizedState) {
                          error("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                        }
                      }
                    }
                    commitUpdateQueue(finishedWork, updateQueue, instance);
                  }
                  break;
                }
                case HostRoot: {
                  var _updateQueue = finishedWork.updateQueue;
                  if (_updateQueue !== null) {
                    var _instance = null;
                    if (finishedWork.child !== null) {
                      switch (finishedWork.child.tag) {
                        case HostComponent:
                          _instance = getPublicInstance(finishedWork.child.stateNode);
                          break;
                        case ClassComponent:
                          _instance = finishedWork.child.stateNode;
                          break;
                      }
                    }
                    commitUpdateQueue(finishedWork, _updateQueue, _instance);
                  }
                  break;
                }
                case HostComponent: {
                  var _instance2 = finishedWork.stateNode;
                  if (current2 === null && finishedWork.flags & Update) {
                    var type = finishedWork.type;
                    var props = finishedWork.memoizedProps;
                    commitMount(_instance2, type, props);
                  }
                  break;
                }
                case HostText: {
                  break;
                }
                case HostPortal: {
                  break;
                }
                case Profiler: {
                  {
                    var _finishedWork$memoize2 = finishedWork.memoizedProps, onCommit = _finishedWork$memoize2.onCommit, onRender = _finishedWork$memoize2.onRender;
                    var effectDuration = finishedWork.stateNode.effectDuration;
                    var commitTime2 = getCommitTime();
                    var phase = current2 === null ? "mount" : "update";
                    {
                      if (isCurrentUpdateNested()) {
                        phase = "nested-update";
                      }
                    }
                    if (typeof onRender === "function") {
                      onRender(finishedWork.memoizedProps.id, phase, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime2);
                    }
                    {
                      if (typeof onCommit === "function") {
                        onCommit(finishedWork.memoizedProps.id, phase, effectDuration, commitTime2);
                      }
                      enqueuePendingPassiveProfilerEffect(finishedWork);
                      var parentFiber = finishedWork.return;
                      outer:
                        while (parentFiber !== null) {
                          switch (parentFiber.tag) {
                            case HostRoot:
                              var root3 = parentFiber.stateNode;
                              root3.effectDuration += effectDuration;
                              break outer;
                            case Profiler:
                              var parentStateNode = parentFiber.stateNode;
                              parentStateNode.effectDuration += effectDuration;
                              break outer;
                          }
                          parentFiber = parentFiber.return;
                        }
                    }
                  }
                  break;
                }
                case SuspenseComponent: {
                  commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
                  break;
                }
                case SuspenseListComponent:
                case IncompleteClassComponent:
                case ScopeComponent:
                case OffscreenComponent:
                case LegacyHiddenComponent:
                case TracingMarkerComponent: {
                  break;
                }
                default:
                  throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            if (!offscreenSubtreeWasHidden) {
              {
                if (finishedWork.flags & Ref) {
                  commitAttachRef(finishedWork);
                }
              }
            }
          }
          function reappearLayoutEffectsOnFiber(node) {
            switch (node.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                if (node.mode & ProfileMode) {
                  try {
                    startLayoutEffectTimer();
                    safelyCallCommitHookLayoutEffectListMount(node, node.return);
                  } finally {
                    recordLayoutEffectDuration(node);
                  }
                } else {
                  safelyCallCommitHookLayoutEffectListMount(node, node.return);
                }
                break;
              }
              case ClassComponent: {
                var instance = node.stateNode;
                if (typeof instance.componentDidMount === "function") {
                  safelyCallComponentDidMount(node, node.return, instance);
                }
                safelyAttachRef(node, node.return);
                break;
              }
              case HostComponent: {
                safelyAttachRef(node, node.return);
                break;
              }
            }
          }
          function hideOrUnhideAllChildren(finishedWork, isHidden) {
            var hostSubtreeRoot = null;
            {
              var node = finishedWork;
              while (true) {
                if (node.tag === HostComponent) {
                  if (hostSubtreeRoot === null) {
                    hostSubtreeRoot = node;
                    try {
                      var instance = node.stateNode;
                      if (isHidden) {
                        hideInstance(instance);
                      } else {
                        unhideInstance(node.stateNode, node.memoizedProps);
                      }
                    } catch (error2) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                    }
                  }
                } else if (node.tag === HostText) {
                  if (hostSubtreeRoot === null) {
                    try {
                      var _instance3 = node.stateNode;
                      if (isHidden) {
                        hideTextInstance(_instance3);
                      } else {
                        unhideTextInstance(_instance3, node.memoizedProps);
                      }
                    } catch (error2) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                    }
                  }
                } else if ((node.tag === OffscreenComponent || node.tag === LegacyHiddenComponent) && node.memoizedState !== null && node !== finishedWork)
                  ;
                else if (node.child !== null) {
                  node.child.return = node;
                  node = node.child;
                  continue;
                }
                if (node === finishedWork) {
                  return;
                }
                while (node.sibling === null) {
                  if (node.return === null || node.return === finishedWork) {
                    return;
                  }
                  if (hostSubtreeRoot === node) {
                    hostSubtreeRoot = null;
                  }
                  node = node.return;
                }
                if (hostSubtreeRoot === node) {
                  hostSubtreeRoot = null;
                }
                node.sibling.return = node.return;
                node = node.sibling;
              }
            }
          }
          function commitAttachRef(finishedWork) {
            var ref = finishedWork.ref;
            if (ref !== null) {
              var instance = finishedWork.stateNode;
              var instanceToUse;
              switch (finishedWork.tag) {
                case HostComponent:
                  instanceToUse = getPublicInstance(instance);
                  break;
                default:
                  instanceToUse = instance;
              }
              if (typeof ref === "function") {
                var retVal;
                if (finishedWork.mode & ProfileMode) {
                  try {
                    startLayoutEffectTimer();
                    retVal = ref(instanceToUse);
                  } finally {
                    recordLayoutEffectDuration(finishedWork);
                  }
                } else {
                  retVal = ref(instanceToUse);
                }
                {
                  if (typeof retVal === "function") {
                    error("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", getComponentNameFromFiber(finishedWork));
                  }
                }
              } else {
                {
                  if (!ref.hasOwnProperty("current")) {
                    error("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", getComponentNameFromFiber(finishedWork));
                  }
                }
                ref.current = instanceToUse;
              }
            }
          }
          function detachFiberMutation(fiber) {
            var alternate = fiber.alternate;
            if (alternate !== null) {
              alternate.return = null;
            }
            fiber.return = null;
          }
          function detachFiberAfterEffects(fiber) {
            var alternate = fiber.alternate;
            if (alternate !== null) {
              fiber.alternate = null;
              detachFiberAfterEffects(alternate);
            }
            {
              fiber.child = null;
              fiber.deletions = null;
              fiber.sibling = null;
              if (fiber.tag === HostComponent) {
                var hostInstance = fiber.stateNode;
                if (hostInstance !== null) {
                  detachDeletedInstance(hostInstance);
                }
              }
              fiber.stateNode = null;
              {
                fiber._debugOwner = null;
              }
              {
                fiber.return = null;
                fiber.dependencies = null;
                fiber.memoizedProps = null;
                fiber.memoizedState = null;
                fiber.pendingProps = null;
                fiber.stateNode = null;
                fiber.updateQueue = null;
              }
            }
          }
          function getHostParentFiber(fiber) {
            var parent = fiber.return;
            while (parent !== null) {
              if (isHostParent(parent)) {
                return parent;
              }
              parent = parent.return;
            }
            throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
          }
          function isHostParent(fiber) {
            return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
          }
          function getHostSibling(fiber) {
            var node = fiber;
            siblings:
              while (true) {
                while (node.sibling === null) {
                  if (node.return === null || isHostParent(node.return)) {
                    return null;
                  }
                  node = node.return;
                }
                node.sibling.return = node.return;
                node = node.sibling;
                while (node.tag !== HostComponent && node.tag !== HostText && node.tag !== DehydratedFragment) {
                  if (node.flags & Placement) {
                    continue siblings;
                  }
                  if (node.child === null || node.tag === HostPortal) {
                    continue siblings;
                  } else {
                    node.child.return = node;
                    node = node.child;
                  }
                }
                if (!(node.flags & Placement)) {
                  return node.stateNode;
                }
              }
          }
          function commitPlacement(finishedWork) {
            var parentFiber = getHostParentFiber(finishedWork);
            switch (parentFiber.tag) {
              case HostComponent: {
                var parent = parentFiber.stateNode;
                if (parentFiber.flags & ContentReset) {
                  resetTextContent(parent);
                  parentFiber.flags &= ~ContentReset;
                }
                var before = getHostSibling(finishedWork);
                insertOrAppendPlacementNode(finishedWork, before, parent);
                break;
              }
              case HostRoot:
              case HostPortal: {
                var _parent = parentFiber.stateNode.containerInfo;
                var _before = getHostSibling(finishedWork);
                insertOrAppendPlacementNodeIntoContainer(finishedWork, _before, _parent);
                break;
              }
              default:
                throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
            var tag = node.tag;
            var isHost = tag === HostComponent || tag === HostText;
            if (isHost) {
              var stateNode = node.stateNode;
              if (before) {
                insertInContainerBefore(parent, stateNode, before);
              } else {
                appendChildToContainer(parent, stateNode);
              }
            } else if (tag === HostPortal)
              ;
            else {
              var child = node.child;
              if (child !== null) {
                insertOrAppendPlacementNodeIntoContainer(child, before, parent);
                var sibling = child.sibling;
                while (sibling !== null) {
                  insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);
                  sibling = sibling.sibling;
                }
              }
            }
          }
          function insertOrAppendPlacementNode(node, before, parent) {
            var tag = node.tag;
            var isHost = tag === HostComponent || tag === HostText;
            if (isHost) {
              var stateNode = node.stateNode;
              if (before) {
                insertBefore(parent, stateNode, before);
              } else {
                appendChild(parent, stateNode);
              }
            } else if (tag === HostPortal)
              ;
            else {
              var child = node.child;
              if (child !== null) {
                insertOrAppendPlacementNode(child, before, parent);
                var sibling = child.sibling;
                while (sibling !== null) {
                  insertOrAppendPlacementNode(sibling, before, parent);
                  sibling = sibling.sibling;
                }
              }
            }
          }
          var hostParent = null;
          var hostParentIsContainer = false;
          function commitDeletionEffects(root3, returnFiber, deletedFiber) {
            {
              var parent = returnFiber;
              findParent:
                while (parent !== null) {
                  switch (parent.tag) {
                    case HostComponent: {
                      hostParent = parent.stateNode;
                      hostParentIsContainer = false;
                      break findParent;
                    }
                    case HostRoot: {
                      hostParent = parent.stateNode.containerInfo;
                      hostParentIsContainer = true;
                      break findParent;
                    }
                    case HostPortal: {
                      hostParent = parent.stateNode.containerInfo;
                      hostParentIsContainer = true;
                      break findParent;
                    }
                  }
                  parent = parent.return;
                }
              if (hostParent === null) {
                throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
              }
              commitDeletionEffectsOnFiber(root3, returnFiber, deletedFiber);
              hostParent = null;
              hostParentIsContainer = false;
            }
            detachFiberMutation(deletedFiber);
          }
          function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
            var child = parent.child;
            while (child !== null) {
              commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, child);
              child = child.sibling;
            }
          }
          function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
            onCommitUnmount(deletedFiber);
            switch (deletedFiber.tag) {
              case HostComponent: {
                if (!offscreenSubtreeWasHidden) {
                  safelyDetachRef(deletedFiber, nearestMountedAncestor);
                }
              }
              case HostText: {
                {
                  var prevHostParent = hostParent;
                  var prevHostParentIsContainer = hostParentIsContainer;
                  hostParent = null;
                  recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                  hostParent = prevHostParent;
                  hostParentIsContainer = prevHostParentIsContainer;
                  if (hostParent !== null) {
                    if (hostParentIsContainer) {
                      removeChildFromContainer(hostParent, deletedFiber.stateNode);
                    } else {
                      removeChild(hostParent, deletedFiber.stateNode);
                    }
                  }
                }
                return;
              }
              case DehydratedFragment: {
                {
                  if (hostParent !== null) {
                    if (hostParentIsContainer) {
                      clearSuspenseBoundaryFromContainer(hostParent, deletedFiber.stateNode);
                    } else {
                      clearSuspenseBoundary(hostParent, deletedFiber.stateNode);
                    }
                  }
                }
                return;
              }
              case HostPortal: {
                {
                  var _prevHostParent = hostParent;
                  var _prevHostParentIsContainer = hostParentIsContainer;
                  hostParent = deletedFiber.stateNode.containerInfo;
                  hostParentIsContainer = true;
                  recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                  hostParent = _prevHostParent;
                  hostParentIsContainer = _prevHostParentIsContainer;
                }
                return;
              }
              case FunctionComponent:
              case ForwardRef:
              case MemoComponent:
              case SimpleMemoComponent: {
                if (!offscreenSubtreeWasHidden) {
                  var updateQueue = deletedFiber.updateQueue;
                  if (updateQueue !== null) {
                    var lastEffect = updateQueue.lastEffect;
                    if (lastEffect !== null) {
                      var firstEffect = lastEffect.next;
                      var effect = firstEffect;
                      do {
                        var _effect = effect, destroy = _effect.destroy, tag = _effect.tag;
                        if (destroy !== void 0) {
                          if ((tag & Insertion) !== NoFlags$1) {
                            safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                          } else if ((tag & Layout) !== NoFlags$1) {
                            {
                              markComponentLayoutEffectUnmountStarted(deletedFiber);
                            }
                            if (deletedFiber.mode & ProfileMode) {
                              startLayoutEffectTimer();
                              safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                              recordLayoutEffectDuration(deletedFiber);
                            } else {
                              safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                            }
                            {
                              markComponentLayoutEffectUnmountStopped();
                            }
                          }
                        }
                        effect = effect.next;
                      } while (effect !== firstEffect);
                    }
                  }
                }
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                return;
              }
              case ClassComponent: {
                if (!offscreenSubtreeWasHidden) {
                  safelyDetachRef(deletedFiber, nearestMountedAncestor);
                  var instance = deletedFiber.stateNode;
                  if (typeof instance.componentWillUnmount === "function") {
                    safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, instance);
                  }
                }
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                return;
              }
              case ScopeComponent: {
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                return;
              }
              case OffscreenComponent: {
                if (
                  // TODO: Remove this dead flag
                  deletedFiber.mode & ConcurrentMode
                ) {
                  var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                  offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || deletedFiber.memoizedState !== null;
                  recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                  offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
                } else {
                  recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                }
                break;
              }
              default: {
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                return;
              }
            }
          }
          function commitSuspenseCallback(finishedWork) {
            var newState = finishedWork.memoizedState;
          }
          function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
            var newState = finishedWork.memoizedState;
            if (newState === null) {
              var current2 = finishedWork.alternate;
              if (current2 !== null) {
                var prevState = current2.memoizedState;
                if (prevState !== null) {
                  var suspenseInstance = prevState.dehydrated;
                  if (suspenseInstance !== null) {
                    commitHydratedSuspenseInstance(suspenseInstance);
                  }
                }
              }
            }
          }
          function attachSuspenseRetryListeners(finishedWork) {
            var wakeables = finishedWork.updateQueue;
            if (wakeables !== null) {
              finishedWork.updateQueue = null;
              var retryCache = finishedWork.stateNode;
              if (retryCache === null) {
                retryCache = finishedWork.stateNode = new PossiblyWeakSet();
              }
              wakeables.forEach(function(wakeable) {
                var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
                if (!retryCache.has(wakeable)) {
                  retryCache.add(wakeable);
                  {
                    if (isDevToolsPresent) {
                      if (inProgressLanes !== null && inProgressRoot !== null) {
                        restorePendingUpdaters(inProgressRoot, inProgressLanes);
                      } else {
                        throw Error("Expected finished root and lanes to be set. This is a bug in React.");
                      }
                    }
                  }
                  wakeable.then(retry, retry);
                }
              });
            }
          }
          function commitMutationEffects(root3, finishedWork, committedLanes) {
            inProgressLanes = committedLanes;
            inProgressRoot = root3;
            setCurrentFiber(finishedWork);
            commitMutationEffectsOnFiber(finishedWork, root3);
            setCurrentFiber(finishedWork);
            inProgressLanes = null;
            inProgressRoot = null;
          }
          function recursivelyTraverseMutationEffects(root3, parentFiber, lanes) {
            var deletions = parentFiber.deletions;
            if (deletions !== null) {
              for (var i7 = 0; i7 < deletions.length; i7++) {
                var childToDelete = deletions[i7];
                try {
                  commitDeletionEffects(root3, parentFiber, childToDelete);
                } catch (error2) {
                  captureCommitPhaseError(childToDelete, parentFiber, error2);
                }
              }
            }
            var prevDebugFiber = getCurrentFiber();
            if (parentFiber.subtreeFlags & MutationMask) {
              var child = parentFiber.child;
              while (child !== null) {
                setCurrentFiber(child);
                commitMutationEffectsOnFiber(child, root3);
                child = child.sibling;
              }
            }
            setCurrentFiber(prevDebugFiber);
          }
          function commitMutationEffectsOnFiber(finishedWork, root3, lanes) {
            var current2 = finishedWork.alternate;
            var flags = finishedWork.flags;
            switch (finishedWork.tag) {
              case FunctionComponent:
              case ForwardRef:
              case MemoComponent:
              case SimpleMemoComponent: {
                recursivelyTraverseMutationEffects(root3, finishedWork);
                commitReconciliationEffects(finishedWork);
                if (flags & Update) {
                  try {
                    commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return);
                    commitHookEffectListMount(Insertion | HasEffect, finishedWork);
                  } catch (error2) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                  }
                  if (finishedWork.mode & ProfileMode) {
                    try {
                      startLayoutEffectTimer();
                      commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);
                    } catch (error2) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                    }
                    recordLayoutEffectDuration(finishedWork);
                  } else {
                    try {
                      commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);
                    } catch (error2) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                    }
                  }
                }
                return;
              }
              case ClassComponent: {
                recursivelyTraverseMutationEffects(root3, finishedWork);
                commitReconciliationEffects(finishedWork);
                if (flags & Ref) {
                  if (current2 !== null) {
                    safelyDetachRef(current2, current2.return);
                  }
                }
                return;
              }
              case HostComponent: {
                recursivelyTraverseMutationEffects(root3, finishedWork);
                commitReconciliationEffects(finishedWork);
                if (flags & Ref) {
                  if (current2 !== null) {
                    safelyDetachRef(current2, current2.return);
                  }
                }
                {
                  if (finishedWork.flags & ContentReset) {
                    var instance = finishedWork.stateNode;
                    try {
                      resetTextContent(instance);
                    } catch (error2) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                    }
                  }
                  if (flags & Update) {
                    var _instance4 = finishedWork.stateNode;
                    if (_instance4 != null) {
                      var newProps = finishedWork.memoizedProps;
                      var oldProps = current2 !== null ? current2.memoizedProps : newProps;
                      var type = finishedWork.type;
                      var updatePayload = finishedWork.updateQueue;
                      finishedWork.updateQueue = null;
                      if (updatePayload !== null) {
                        try {
                          commitUpdate(_instance4, updatePayload, type, oldProps, newProps, finishedWork);
                        } catch (error2) {
                          captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                        }
                      }
                    }
                  }
                }
                return;
              }
              case HostText: {
                recursivelyTraverseMutationEffects(root3, finishedWork);
                commitReconciliationEffects(finishedWork);
                if (flags & Update) {
                  {
                    if (finishedWork.stateNode === null) {
                      throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
                    }
                    var textInstance = finishedWork.stateNode;
                    var newText = finishedWork.memoizedProps;
                    var oldText = current2 !== null ? current2.memoizedProps : newText;
                    try {
                      commitTextUpdate(textInstance, oldText, newText);
                    } catch (error2) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                    }
                  }
                }
                return;
              }
              case HostRoot: {
                recursivelyTraverseMutationEffects(root3, finishedWork);
                commitReconciliationEffects(finishedWork);
                if (flags & Update) {
                  {
                    if (current2 !== null) {
                      var prevRootState = current2.memoizedState;
                      if (prevRootState.isDehydrated) {
                        try {
                          commitHydratedContainer(root3.containerInfo);
                        } catch (error2) {
                          captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                        }
                      }
                    }
                  }
                }
                return;
              }
              case HostPortal: {
                recursivelyTraverseMutationEffects(root3, finishedWork);
                commitReconciliationEffects(finishedWork);
                return;
              }
              case SuspenseComponent: {
                recursivelyTraverseMutationEffects(root3, finishedWork);
                commitReconciliationEffects(finishedWork);
                var offscreenFiber = finishedWork.child;
                if (offscreenFiber.flags & Visibility) {
                  var offscreenInstance = offscreenFiber.stateNode;
                  var newState = offscreenFiber.memoizedState;
                  var isHidden = newState !== null;
                  offscreenInstance.isHidden = isHidden;
                  if (isHidden) {
                    var wasHidden = offscreenFiber.alternate !== null && offscreenFiber.alternate.memoizedState !== null;
                    if (!wasHidden) {
                      markCommitTimeOfFallback();
                    }
                  }
                }
                if (flags & Update) {
                  try {
                    commitSuspenseCallback(finishedWork);
                  } catch (error2) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                  }
                  attachSuspenseRetryListeners(finishedWork);
                }
                return;
              }
              case OffscreenComponent: {
                var _wasHidden = current2 !== null && current2.memoizedState !== null;
                if (
                  // TODO: Remove this dead flag
                  finishedWork.mode & ConcurrentMode
                ) {
                  var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                  offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || _wasHidden;
                  recursivelyTraverseMutationEffects(root3, finishedWork);
                  offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
                } else {
                  recursivelyTraverseMutationEffects(root3, finishedWork);
                }
                commitReconciliationEffects(finishedWork);
                if (flags & Visibility) {
                  var _offscreenInstance = finishedWork.stateNode;
                  var _newState = finishedWork.memoizedState;
                  var _isHidden = _newState !== null;
                  var offscreenBoundary = finishedWork;
                  _offscreenInstance.isHidden = _isHidden;
                  {
                    if (_isHidden) {
                      if (!_wasHidden) {
                        if ((offscreenBoundary.mode & ConcurrentMode) !== NoMode) {
                          nextEffect = offscreenBoundary;
                          var offscreenChild = offscreenBoundary.child;
                          while (offscreenChild !== null) {
                            nextEffect = offscreenChild;
                            disappearLayoutEffects_begin(offscreenChild);
                            offscreenChild = offscreenChild.sibling;
                          }
                        }
                      }
                    }
                  }
                  {
                    hideOrUnhideAllChildren(offscreenBoundary, _isHidden);
                  }
                }
                return;
              }
              case SuspenseListComponent: {
                recursivelyTraverseMutationEffects(root3, finishedWork);
                commitReconciliationEffects(finishedWork);
                if (flags & Update) {
                  attachSuspenseRetryListeners(finishedWork);
                }
                return;
              }
              case ScopeComponent: {
                return;
              }
              default: {
                recursivelyTraverseMutationEffects(root3, finishedWork);
                commitReconciliationEffects(finishedWork);
                return;
              }
            }
          }
          function commitReconciliationEffects(finishedWork) {
            var flags = finishedWork.flags;
            if (flags & Placement) {
              try {
                commitPlacement(finishedWork);
              } catch (error2) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error2);
              }
              finishedWork.flags &= ~Placement;
            }
            if (flags & Hydrating) {
              finishedWork.flags &= ~Hydrating;
            }
          }
          function commitLayoutEffects(finishedWork, root3, committedLanes) {
            inProgressLanes = committedLanes;
            inProgressRoot = root3;
            nextEffect = finishedWork;
            commitLayoutEffects_begin(finishedWork, root3, committedLanes);
            inProgressLanes = null;
            inProgressRoot = null;
          }
          function commitLayoutEffects_begin(subtreeRoot, root3, committedLanes) {
            var isModernRoot = (subtreeRoot.mode & ConcurrentMode) !== NoMode;
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var firstChild = fiber.child;
              if (fiber.tag === OffscreenComponent && isModernRoot) {
                var isHidden = fiber.memoizedState !== null;
                var newOffscreenSubtreeIsHidden = isHidden || offscreenSubtreeIsHidden;
                if (newOffscreenSubtreeIsHidden) {
                  commitLayoutMountEffects_complete(subtreeRoot, root3, committedLanes);
                  continue;
                } else {
                  var current2 = fiber.alternate;
                  var wasHidden = current2 !== null && current2.memoizedState !== null;
                  var newOffscreenSubtreeWasHidden = wasHidden || offscreenSubtreeWasHidden;
                  var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden;
                  var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                  offscreenSubtreeIsHidden = newOffscreenSubtreeIsHidden;
                  offscreenSubtreeWasHidden = newOffscreenSubtreeWasHidden;
                  if (offscreenSubtreeWasHidden && !prevOffscreenSubtreeWasHidden) {
                    nextEffect = fiber;
                    reappearLayoutEffects_begin(fiber);
                  }
                  var child = firstChild;
                  while (child !== null) {
                    nextEffect = child;
                    commitLayoutEffects_begin(
                      child,
                      // New root; bubble back up to here and stop.
                      root3,
                      committedLanes
                    );
                    child = child.sibling;
                  }
                  nextEffect = fiber;
                  offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
                  offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
                  commitLayoutMountEffects_complete(subtreeRoot, root3, committedLanes);
                  continue;
                }
              }
              if ((fiber.subtreeFlags & LayoutMask) !== NoFlags && firstChild !== null) {
                firstChild.return = fiber;
                nextEffect = firstChild;
              } else {
                commitLayoutMountEffects_complete(subtreeRoot, root3, committedLanes);
              }
            }
          }
          function commitLayoutMountEffects_complete(subtreeRoot, root3, committedLanes) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              if ((fiber.flags & LayoutMask) !== NoFlags) {
                var current2 = fiber.alternate;
                setCurrentFiber(fiber);
                try {
                  commitLayoutEffectOnFiber(root3, current2, fiber, committedLanes);
                } catch (error2) {
                  captureCommitPhaseError(fiber, fiber.return, error2);
                }
                resetCurrentFiber();
              }
              if (fiber === subtreeRoot) {
                nextEffect = null;
                return;
              }
              var sibling = fiber.sibling;
              if (sibling !== null) {
                sibling.return = fiber.return;
                nextEffect = sibling;
                return;
              }
              nextEffect = fiber.return;
            }
          }
          function disappearLayoutEffects_begin(subtreeRoot) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var firstChild = fiber.child;
              switch (fiber.tag) {
                case FunctionComponent:
                case ForwardRef:
                case MemoComponent:
                case SimpleMemoComponent: {
                  if (fiber.mode & ProfileMode) {
                    try {
                      startLayoutEffectTimer();
                      commitHookEffectListUnmount(Layout, fiber, fiber.return);
                    } finally {
                      recordLayoutEffectDuration(fiber);
                    }
                  } else {
                    commitHookEffectListUnmount(Layout, fiber, fiber.return);
                  }
                  break;
                }
                case ClassComponent: {
                  safelyDetachRef(fiber, fiber.return);
                  var instance = fiber.stateNode;
                  if (typeof instance.componentWillUnmount === "function") {
                    safelyCallComponentWillUnmount(fiber, fiber.return, instance);
                  }
                  break;
                }
                case HostComponent: {
                  safelyDetachRef(fiber, fiber.return);
                  break;
                }
                case OffscreenComponent: {
                  var isHidden = fiber.memoizedState !== null;
                  if (isHidden) {
                    disappearLayoutEffects_complete(subtreeRoot);
                    continue;
                  }
                  break;
                }
              }
              if (firstChild !== null) {
                firstChild.return = fiber;
                nextEffect = firstChild;
              } else {
                disappearLayoutEffects_complete(subtreeRoot);
              }
            }
          }
          function disappearLayoutEffects_complete(subtreeRoot) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              if (fiber === subtreeRoot) {
                nextEffect = null;
                return;
              }
              var sibling = fiber.sibling;
              if (sibling !== null) {
                sibling.return = fiber.return;
                nextEffect = sibling;
                return;
              }
              nextEffect = fiber.return;
            }
          }
          function reappearLayoutEffects_begin(subtreeRoot) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var firstChild = fiber.child;
              if (fiber.tag === OffscreenComponent) {
                var isHidden = fiber.memoizedState !== null;
                if (isHidden) {
                  reappearLayoutEffects_complete(subtreeRoot);
                  continue;
                }
              }
              if (firstChild !== null) {
                firstChild.return = fiber;
                nextEffect = firstChild;
              } else {
                reappearLayoutEffects_complete(subtreeRoot);
              }
            }
          }
          function reappearLayoutEffects_complete(subtreeRoot) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              setCurrentFiber(fiber);
              try {
                reappearLayoutEffectsOnFiber(fiber);
              } catch (error2) {
                captureCommitPhaseError(fiber, fiber.return, error2);
              }
              resetCurrentFiber();
              if (fiber === subtreeRoot) {
                nextEffect = null;
                return;
              }
              var sibling = fiber.sibling;
              if (sibling !== null) {
                sibling.return = fiber.return;
                nextEffect = sibling;
                return;
              }
              nextEffect = fiber.return;
            }
          }
          function commitPassiveMountEffects(root3, finishedWork, committedLanes, committedTransitions) {
            nextEffect = finishedWork;
            commitPassiveMountEffects_begin(finishedWork, root3, committedLanes, committedTransitions);
          }
          function commitPassiveMountEffects_begin(subtreeRoot, root3, committedLanes, committedTransitions) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var firstChild = fiber.child;
              if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && firstChild !== null) {
                firstChild.return = fiber;
                nextEffect = firstChild;
              } else {
                commitPassiveMountEffects_complete(subtreeRoot, root3, committedLanes, committedTransitions);
              }
            }
          }
          function commitPassiveMountEffects_complete(subtreeRoot, root3, committedLanes, committedTransitions) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              if ((fiber.flags & Passive) !== NoFlags) {
                setCurrentFiber(fiber);
                try {
                  commitPassiveMountOnFiber(root3, fiber, committedLanes, committedTransitions);
                } catch (error2) {
                  captureCommitPhaseError(fiber, fiber.return, error2);
                }
                resetCurrentFiber();
              }
              if (fiber === subtreeRoot) {
                nextEffect = null;
                return;
              }
              var sibling = fiber.sibling;
              if (sibling !== null) {
                sibling.return = fiber.return;
                nextEffect = sibling;
                return;
              }
              nextEffect = fiber.return;
            }
          }
          function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
            switch (finishedWork.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                if (finishedWork.mode & ProfileMode) {
                  startPassiveEffectTimer();
                  try {
                    commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);
                  } finally {
                    recordPassiveEffectDuration(finishedWork);
                  }
                } else {
                  commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);
                }
                break;
              }
            }
          }
          function commitPassiveUnmountEffects(firstChild) {
            nextEffect = firstChild;
            commitPassiveUnmountEffects_begin();
          }
          function commitPassiveUnmountEffects_begin() {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var child = fiber.child;
              if ((nextEffect.flags & ChildDeletion) !== NoFlags) {
                var deletions = fiber.deletions;
                if (deletions !== null) {
                  for (var i7 = 0; i7 < deletions.length; i7++) {
                    var fiberToDelete = deletions[i7];
                    nextEffect = fiberToDelete;
                    commitPassiveUnmountEffectsInsideOfDeletedTree_begin(fiberToDelete, fiber);
                  }
                  {
                    var previousFiber = fiber.alternate;
                    if (previousFiber !== null) {
                      var detachedChild = previousFiber.child;
                      if (detachedChild !== null) {
                        previousFiber.child = null;
                        do {
                          var detachedSibling = detachedChild.sibling;
                          detachedChild.sibling = null;
                          detachedChild = detachedSibling;
                        } while (detachedChild !== null);
                      }
                    }
                  }
                  nextEffect = fiber;
                }
              }
              if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && child !== null) {
                child.return = fiber;
                nextEffect = child;
              } else {
                commitPassiveUnmountEffects_complete();
              }
            }
          }
          function commitPassiveUnmountEffects_complete() {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              if ((fiber.flags & Passive) !== NoFlags) {
                setCurrentFiber(fiber);
                commitPassiveUnmountOnFiber(fiber);
                resetCurrentFiber();
              }
              var sibling = fiber.sibling;
              if (sibling !== null) {
                sibling.return = fiber.return;
                nextEffect = sibling;
                return;
              }
              nextEffect = fiber.return;
            }
          }
          function commitPassiveUnmountOnFiber(finishedWork) {
            switch (finishedWork.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                if (finishedWork.mode & ProfileMode) {
                  startPassiveEffectTimer();
                  commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);
                  recordPassiveEffectDuration(finishedWork);
                } else {
                  commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);
                }
                break;
              }
            }
          }
          function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              setCurrentFiber(fiber);
              commitPassiveUnmountInsideDeletedTreeOnFiber(fiber, nearestMountedAncestor);
              resetCurrentFiber();
              var child = fiber.child;
              if (child !== null) {
                child.return = fiber;
                nextEffect = child;
              } else {
                commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot);
              }
            }
          }
          function commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var sibling = fiber.sibling;
              var returnFiber = fiber.return;
              {
                detachFiberAfterEffects(fiber);
                if (fiber === deletedSubtreeRoot) {
                  nextEffect = null;
                  return;
                }
              }
              if (sibling !== null) {
                sibling.return = returnFiber;
                nextEffect = sibling;
                return;
              }
              nextEffect = returnFiber;
            }
          }
          function commitPassiveUnmountInsideDeletedTreeOnFiber(current2, nearestMountedAncestor) {
            switch (current2.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                if (current2.mode & ProfileMode) {
                  startPassiveEffectTimer();
                  commitHookEffectListUnmount(Passive$1, current2, nearestMountedAncestor);
                  recordPassiveEffectDuration(current2);
                } else {
                  commitHookEffectListUnmount(Passive$1, current2, nearestMountedAncestor);
                }
                break;
              }
            }
          }
          function invokeLayoutEffectMountInDEV(fiber) {
            {
              switch (fiber.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent: {
                  try {
                    commitHookEffectListMount(Layout | HasEffect, fiber);
                  } catch (error2) {
                    captureCommitPhaseError(fiber, fiber.return, error2);
                  }
                  break;
                }
                case ClassComponent: {
                  var instance = fiber.stateNode;
                  try {
                    instance.componentDidMount();
                  } catch (error2) {
                    captureCommitPhaseError(fiber, fiber.return, error2);
                  }
                  break;
                }
              }
            }
          }
          function invokePassiveEffectMountInDEV(fiber) {
            {
              switch (fiber.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent: {
                  try {
                    commitHookEffectListMount(Passive$1 | HasEffect, fiber);
                  } catch (error2) {
                    captureCommitPhaseError(fiber, fiber.return, error2);
                  }
                  break;
                }
              }
            }
          }
          function invokeLayoutEffectUnmountInDEV(fiber) {
            {
              switch (fiber.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent: {
                  try {
                    commitHookEffectListUnmount(Layout | HasEffect, fiber, fiber.return);
                  } catch (error2) {
                    captureCommitPhaseError(fiber, fiber.return, error2);
                  }
                  break;
                }
                case ClassComponent: {
                  var instance = fiber.stateNode;
                  if (typeof instance.componentWillUnmount === "function") {
                    safelyCallComponentWillUnmount(fiber, fiber.return, instance);
                  }
                  break;
                }
              }
            }
          }
          function invokePassiveEffectUnmountInDEV(fiber) {
            {
              switch (fiber.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent: {
                  try {
                    commitHookEffectListUnmount(Passive$1 | HasEffect, fiber, fiber.return);
                  } catch (error2) {
                    captureCommitPhaseError(fiber, fiber.return, error2);
                  }
                }
              }
            }
          }
          var COMPONENT_TYPE = 0;
          var HAS_PSEUDO_CLASS_TYPE = 1;
          var ROLE_TYPE = 2;
          var TEST_NAME_TYPE = 3;
          var TEXT_TYPE = 4;
          if (typeof Symbol === "function" && Symbol.for) {
            var symbolFor = Symbol.for;
            COMPONENT_TYPE = symbolFor("selector.component");
            HAS_PSEUDO_CLASS_TYPE = symbolFor("selector.has_pseudo_class");
            ROLE_TYPE = symbolFor("selector.role");
            TEST_NAME_TYPE = symbolFor("selector.test_id");
            TEXT_TYPE = symbolFor("selector.text");
          }
          var commitHooks = [];
          function onCommitRoot$1() {
            {
              commitHooks.forEach(function(commitHook) {
                return commitHook();
              });
            }
          }
          var ReactCurrentActQueue = ReactSharedInternals.ReactCurrentActQueue;
          function isLegacyActEnvironment(fiber) {
            {
              var isReactActEnvironmentGlobal = (
                // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
                typeof IS_REACT_ACT_ENVIRONMENT !== "undefined" ? IS_REACT_ACT_ENVIRONMENT : void 0
              );
              var jestIsDefined = typeof jest !== "undefined";
              return jestIsDefined && isReactActEnvironmentGlobal !== false;
            }
          }
          function isConcurrentActEnvironment() {
            {
              var isReactActEnvironmentGlobal = (
                // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
                typeof IS_REACT_ACT_ENVIRONMENT !== "undefined" ? IS_REACT_ACT_ENVIRONMENT : void 0
              );
              if (!isReactActEnvironmentGlobal && ReactCurrentActQueue.current !== null) {
                error("The current testing environment is not configured to support act(...)");
              }
              return isReactActEnvironmentGlobal;
            }
          }
          var ceil = Math.ceil;
          var ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner, ReactCurrentBatchConfig$3 = ReactSharedInternals.ReactCurrentBatchConfig, ReactCurrentActQueue$1 = ReactSharedInternals.ReactCurrentActQueue;
          var NoContext = (
            /*             */
            0
          );
          var BatchedContext = (
            /*               */
            1
          );
          var RenderContext = (
            /*                */
            2
          );
          var CommitContext = (
            /*                */
            4
          );
          var RootInProgress = 0;
          var RootFatalErrored = 1;
          var RootErrored = 2;
          var RootSuspended = 3;
          var RootSuspendedWithDelay = 4;
          var RootCompleted = 5;
          var RootDidNotComplete = 6;
          var executionContext = NoContext;
          var workInProgressRoot = null;
          var workInProgress = null;
          var workInProgressRootRenderLanes = NoLanes;
          var subtreeRenderLanes = NoLanes;
          var subtreeRenderLanesCursor = createCursor(NoLanes);
          var workInProgressRootExitStatus = RootInProgress;
          var workInProgressRootFatalError = null;
          var workInProgressRootIncludedLanes = NoLanes;
          var workInProgressRootSkippedLanes = NoLanes;
          var workInProgressRootInterleavedUpdatedLanes = NoLanes;
          var workInProgressRootPingedLanes = NoLanes;
          var workInProgressRootConcurrentErrors = null;
          var workInProgressRootRecoverableErrors = null;
          var globalMostRecentFallbackTime = 0;
          var FALLBACK_THROTTLE_MS = 500;
          var workInProgressRootRenderTargetTime = Infinity;
          var RENDER_TIMEOUT_MS = 500;
          var workInProgressTransitions = null;
          function resetRenderTimer() {
            workInProgressRootRenderTargetTime = now2() + RENDER_TIMEOUT_MS;
          }
          function getRenderTargetTime() {
            return workInProgressRootRenderTargetTime;
          }
          var hasUncaughtError = false;
          var firstUncaughtError = null;
          var legacyErrorBoundariesThatAlreadyFailed = null;
          var rootDoesHavePassiveEffects = false;
          var rootWithPendingPassiveEffects = null;
          var pendingPassiveEffectsLanes = NoLanes;
          var pendingPassiveProfilerEffects = [];
          var pendingPassiveTransitions = null;
          var NESTED_UPDATE_LIMIT = 50;
          var nestedUpdateCount = 0;
          var rootWithNestedUpdates = null;
          var isFlushingPassiveEffects = false;
          var didScheduleUpdateDuringPassiveEffects = false;
          var NESTED_PASSIVE_UPDATE_LIMIT = 50;
          var nestedPassiveUpdateCount = 0;
          var rootWithPassiveNestedUpdates = null;
          var currentEventTime = NoTimestamp;
          var currentEventTransitionLane = NoLanes;
          var isRunningInsertionEffect = false;
          function getWorkInProgressRoot() {
            return workInProgressRoot;
          }
          function requestEventTime() {
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
              return now2();
            }
            if (currentEventTime !== NoTimestamp) {
              return currentEventTime;
            }
            currentEventTime = now2();
            return currentEventTime;
          }
          function requestUpdateLane(fiber) {
            var mode = fiber.mode;
            if ((mode & ConcurrentMode) === NoMode) {
              return SyncLane;
            } else if ((executionContext & RenderContext) !== NoContext && workInProgressRootRenderLanes !== NoLanes) {
              return pickArbitraryLane(workInProgressRootRenderLanes);
            }
            var isTransition = requestCurrentTransition() !== NoTransition;
            if (isTransition) {
              if (ReactCurrentBatchConfig$3.transition !== null) {
                var transition = ReactCurrentBatchConfig$3.transition;
                if (!transition._updatedFibers) {
                  transition._updatedFibers = /* @__PURE__ */ new Set();
                }
                transition._updatedFibers.add(fiber);
              }
              if (currentEventTransitionLane === NoLane) {
                currentEventTransitionLane = claimNextTransitionLane();
              }
              return currentEventTransitionLane;
            }
            var updateLane = getCurrentUpdatePriority();
            if (updateLane !== NoLane) {
              return updateLane;
            }
            var eventLane = getCurrentEventPriority();
            return eventLane;
          }
          function requestRetryLane(fiber) {
            var mode = fiber.mode;
            if ((mode & ConcurrentMode) === NoMode) {
              return SyncLane;
            }
            return claimNextRetryLane();
          }
          function scheduleUpdateOnFiber(root3, fiber, lane, eventTime) {
            checkForNestedUpdates();
            {
              if (isRunningInsertionEffect) {
                error("useInsertionEffect must not schedule updates.");
              }
            }
            {
              if (isFlushingPassiveEffects) {
                didScheduleUpdateDuringPassiveEffects = true;
              }
            }
            markRootUpdated(root3, lane, eventTime);
            if ((executionContext & RenderContext) !== NoLanes && root3 === workInProgressRoot) {
              warnAboutRenderPhaseUpdatesInDEV(fiber);
            } else {
              {
                if (isDevToolsPresent) {
                  addFiberToLanesMap(root3, fiber, lane);
                }
              }
              warnIfUpdatesNotWrappedWithActDEV(fiber);
              if (root3 === workInProgressRoot) {
                if ((executionContext & RenderContext) === NoContext) {
                  workInProgressRootInterleavedUpdatedLanes = mergeLanes(workInProgressRootInterleavedUpdatedLanes, lane);
                }
                if (workInProgressRootExitStatus === RootSuspendedWithDelay) {
                  markRootSuspended$1(root3, workInProgressRootRenderLanes);
                }
              }
              ensureRootIsScheduled(root3, eventTime);
              if (lane === SyncLane && executionContext === NoContext && (fiber.mode & ConcurrentMode) === NoMode && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
              !ReactCurrentActQueue$1.isBatchingLegacy) {
                resetRenderTimer();
                flushSyncCallbacksOnlyInLegacyMode();
              }
            }
          }
          function scheduleInitialHydrationOnRoot(root3, lane, eventTime) {
            var current2 = root3.current;
            current2.lanes = lane;
            markRootUpdated(root3, lane, eventTime);
            ensureRootIsScheduled(root3, eventTime);
          }
          function isUnsafeClassRenderPhaseUpdate(fiber) {
            return (
              // TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We
              // decided not to enable it.
              (executionContext & RenderContext) !== NoContext
            );
          }
          function ensureRootIsScheduled(root3, currentTime) {
            var existingCallbackNode = root3.callbackNode;
            markStarvedLanesAsExpired(root3, currentTime);
            var nextLanes = getNextLanes(root3, root3 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
            if (nextLanes === NoLanes) {
              if (existingCallbackNode !== null) {
                cancelCallback$1(existingCallbackNode);
              }
              root3.callbackNode = null;
              root3.callbackPriority = NoLane;
              return;
            }
            var newCallbackPriority = getHighestPriorityLane(nextLanes);
            var existingCallbackPriority = root3.callbackPriority;
            if (existingCallbackPriority === newCallbackPriority && // Special case related to `act`. If the currently scheduled task is a
            // Scheduler task, rather than an `act` task, cancel it and re-scheduled
            // on the `act` queue.
            !(ReactCurrentActQueue$1.current !== null && existingCallbackNode !== fakeActCallbackNode)) {
              {
                if (existingCallbackNode == null && existingCallbackPriority !== SyncLane) {
                  error("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
              return;
            }
            if (existingCallbackNode != null) {
              cancelCallback$1(existingCallbackNode);
            }
            var newCallbackNode;
            if (newCallbackPriority === SyncLane) {
              if (root3.tag === LegacyRoot) {
                if (ReactCurrentActQueue$1.isBatchingLegacy !== null) {
                  ReactCurrentActQueue$1.didScheduleLegacyUpdate = true;
                }
                scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null, root3));
              } else {
                scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root3));
              }
              {
                if (ReactCurrentActQueue$1.current !== null) {
                  ReactCurrentActQueue$1.current.push(flushSyncCallbacks);
                } else {
                  scheduleMicrotask2(function() {
                    if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
                      flushSyncCallbacks();
                    }
                  });
                }
              }
              newCallbackNode = null;
            } else {
              var schedulerPriorityLevel;
              switch (lanesToEventPriority(nextLanes)) {
                case DiscreteEventPriority:
                  schedulerPriorityLevel = ImmediatePriority;
                  break;
                case ContinuousEventPriority:
                  schedulerPriorityLevel = UserBlockingPriority;
                  break;
                case DefaultEventPriority:
                  schedulerPriorityLevel = NormalPriority;
                  break;
                case IdleEventPriority:
                  schedulerPriorityLevel = IdlePriority;
                  break;
                default:
                  schedulerPriorityLevel = NormalPriority;
                  break;
              }
              newCallbackNode = scheduleCallback$1(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root3));
            }
            root3.callbackPriority = newCallbackPriority;
            root3.callbackNode = newCallbackNode;
          }
          function performConcurrentWorkOnRoot(root3, didTimeout) {
            {
              resetNestedUpdateFlag();
            }
            currentEventTime = NoTimestamp;
            currentEventTransitionLane = NoLanes;
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
              throw new Error("Should not already be working.");
            }
            var originalCallbackNode = root3.callbackNode;
            var didFlushPassiveEffects = flushPassiveEffects();
            if (didFlushPassiveEffects) {
              if (root3.callbackNode !== originalCallbackNode) {
                return null;
              }
            }
            var lanes = getNextLanes(root3, root3 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
            if (lanes === NoLanes) {
              return null;
            }
            var shouldTimeSlice = !includesBlockingLane(root3, lanes) && !includesExpiredLane(root3, lanes) && !didTimeout;
            var exitStatus = shouldTimeSlice ? renderRootConcurrent(root3, lanes) : renderRootSync(root3, lanes);
            if (exitStatus !== RootInProgress) {
              if (exitStatus === RootErrored) {
                var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root3);
                if (errorRetryLanes !== NoLanes) {
                  lanes = errorRetryLanes;
                  exitStatus = recoverFromConcurrentError(root3, errorRetryLanes);
                }
              }
              if (exitStatus === RootFatalErrored) {
                var fatalError = workInProgressRootFatalError;
                prepareFreshStack(root3, NoLanes);
                markRootSuspended$1(root3, lanes);
                ensureRootIsScheduled(root3, now2());
                throw fatalError;
              }
              if (exitStatus === RootDidNotComplete) {
                markRootSuspended$1(root3, lanes);
              } else {
                var renderWasConcurrent = !includesBlockingLane(root3, lanes);
                var finishedWork = root3.current.alternate;
                if (renderWasConcurrent && !isRenderConsistentWithExternalStores(finishedWork)) {
                  exitStatus = renderRootSync(root3, lanes);
                  if (exitStatus === RootErrored) {
                    var _errorRetryLanes = getLanesToRetrySynchronouslyOnError(root3);
                    if (_errorRetryLanes !== NoLanes) {
                      lanes = _errorRetryLanes;
                      exitStatus = recoverFromConcurrentError(root3, _errorRetryLanes);
                    }
                  }
                  if (exitStatus === RootFatalErrored) {
                    var _fatalError = workInProgressRootFatalError;
                    prepareFreshStack(root3, NoLanes);
                    markRootSuspended$1(root3, lanes);
                    ensureRootIsScheduled(root3, now2());
                    throw _fatalError;
                  }
                }
                root3.finishedWork = finishedWork;
                root3.finishedLanes = lanes;
                finishConcurrentRender(root3, exitStatus, lanes);
              }
            }
            ensureRootIsScheduled(root3, now2());
            if (root3.callbackNode === originalCallbackNode) {
              return performConcurrentWorkOnRoot.bind(null, root3);
            }
            return null;
          }
          function recoverFromConcurrentError(root3, errorRetryLanes) {
            var errorsFromFirstAttempt = workInProgressRootConcurrentErrors;
            if (isRootDehydrated(root3)) {
              var rootWorkInProgress = prepareFreshStack(root3, errorRetryLanes);
              rootWorkInProgress.flags |= ForceClientRender;
              {
                errorHydratingContainer(root3.containerInfo);
              }
            }
            var exitStatus = renderRootSync(root3, errorRetryLanes);
            if (exitStatus !== RootErrored) {
              var errorsFromSecondAttempt = workInProgressRootRecoverableErrors;
              workInProgressRootRecoverableErrors = errorsFromFirstAttempt;
              if (errorsFromSecondAttempt !== null) {
                queueRecoverableErrors(errorsFromSecondAttempt);
              }
            }
            return exitStatus;
          }
          function queueRecoverableErrors(errors) {
            if (workInProgressRootRecoverableErrors === null) {
              workInProgressRootRecoverableErrors = errors;
            } else {
              workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, errors);
            }
          }
          function finishConcurrentRender(root3, exitStatus, lanes) {
            switch (exitStatus) {
              case RootInProgress:
              case RootFatalErrored: {
                throw new Error("Root did not complete. This is a bug in React.");
              }
              case RootErrored: {
                commitRoot(root3, workInProgressRootRecoverableErrors, workInProgressTransitions);
                break;
              }
              case RootSuspended: {
                markRootSuspended$1(root3, lanes);
                if (includesOnlyRetries(lanes) && // do not delay if we're inside an act() scope
                !shouldForceFlushFallbacksInDEV()) {
                  var msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now2();
                  if (msUntilTimeout > 10) {
                    var nextLanes = getNextLanes(root3, NoLanes);
                    if (nextLanes !== NoLanes) {
                      break;
                    }
                    var suspendedLanes = root3.suspendedLanes;
                    if (!isSubsetOfLanes(suspendedLanes, lanes)) {
                      var eventTime = requestEventTime();
                      markRootPinged(root3, suspendedLanes);
                      break;
                    }
                    root3.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root3, workInProgressRootRecoverableErrors, workInProgressTransitions), msUntilTimeout);
                    break;
                  }
                }
                commitRoot(root3, workInProgressRootRecoverableErrors, workInProgressTransitions);
                break;
              }
              case RootSuspendedWithDelay: {
                markRootSuspended$1(root3, lanes);
                if (includesOnlyTransitions(lanes)) {
                  break;
                }
                if (!shouldForceFlushFallbacksInDEV()) {
                  var mostRecentEventTime = getMostRecentEventTime(root3, lanes);
                  var eventTimeMs = mostRecentEventTime;
                  var timeElapsedMs = now2() - eventTimeMs;
                  var _msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs;
                  if (_msUntilTimeout > 10) {
                    root3.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root3, workInProgressRootRecoverableErrors, workInProgressTransitions), _msUntilTimeout);
                    break;
                  }
                }
                commitRoot(root3, workInProgressRootRecoverableErrors, workInProgressTransitions);
                break;
              }
              case RootCompleted: {
                commitRoot(root3, workInProgressRootRecoverableErrors, workInProgressTransitions);
                break;
              }
              default: {
                throw new Error("Unknown root exit status.");
              }
            }
          }
          function isRenderConsistentWithExternalStores(finishedWork) {
            var node = finishedWork;
            while (true) {
              if (node.flags & StoreConsistency) {
                var updateQueue = node.updateQueue;
                if (updateQueue !== null) {
                  var checks = updateQueue.stores;
                  if (checks !== null) {
                    for (var i7 = 0; i7 < checks.length; i7++) {
                      var check = checks[i7];
                      var getSnapshot = check.getSnapshot;
                      var renderedValue = check.value;
                      try {
                        if (!objectIs(getSnapshot(), renderedValue)) {
                          return false;
                        }
                      } catch (error2) {
                        return false;
                      }
                    }
                  }
                }
              }
              var child = node.child;
              if (node.subtreeFlags & StoreConsistency && child !== null) {
                child.return = node;
                node = child;
                continue;
              }
              if (node === finishedWork) {
                return true;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === finishedWork) {
                  return true;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
            return true;
          }
          function markRootSuspended$1(root3, suspendedLanes) {
            suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);
            suspendedLanes = removeLanes(suspendedLanes, workInProgressRootInterleavedUpdatedLanes);
            markRootSuspended(root3, suspendedLanes);
          }
          function performSyncWorkOnRoot(root3) {
            {
              syncNestedUpdateFlag();
            }
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
              throw new Error("Should not already be working.");
            }
            flushPassiveEffects();
            var lanes = getNextLanes(root3, NoLanes);
            if (!includesSomeLane(lanes, SyncLane)) {
              ensureRootIsScheduled(root3, now2());
              return null;
            }
            var exitStatus = renderRootSync(root3, lanes);
            if (root3.tag !== LegacyRoot && exitStatus === RootErrored) {
              var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root3);
              if (errorRetryLanes !== NoLanes) {
                lanes = errorRetryLanes;
                exitStatus = recoverFromConcurrentError(root3, errorRetryLanes);
              }
            }
            if (exitStatus === RootFatalErrored) {
              var fatalError = workInProgressRootFatalError;
              prepareFreshStack(root3, NoLanes);
              markRootSuspended$1(root3, lanes);
              ensureRootIsScheduled(root3, now2());
              throw fatalError;
            }
            if (exitStatus === RootDidNotComplete) {
              throw new Error("Root did not complete. This is a bug in React.");
            }
            var finishedWork = root3.current.alternate;
            root3.finishedWork = finishedWork;
            root3.finishedLanes = lanes;
            commitRoot(root3, workInProgressRootRecoverableErrors, workInProgressTransitions);
            ensureRootIsScheduled(root3, now2());
            return null;
          }
          function flushRoot(root3, lanes) {
            if (lanes !== NoLanes) {
              markRootEntangled(root3, mergeLanes(lanes, SyncLane));
              ensureRootIsScheduled(root3, now2());
              if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
                resetRenderTimer();
                flushSyncCallbacks();
              }
            }
          }
          function batchedUpdates$1(fn2, a6) {
            var prevExecutionContext = executionContext;
            executionContext |= BatchedContext;
            try {
              return fn2(a6);
            } finally {
              executionContext = prevExecutionContext;
              if (executionContext === NoContext && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
              !ReactCurrentActQueue$1.isBatchingLegacy) {
                resetRenderTimer();
                flushSyncCallbacksOnlyInLegacyMode();
              }
            }
          }
          function discreteUpdates(fn2, a6, b7, c9, d7) {
            var previousPriority = getCurrentUpdatePriority();
            var prevTransition = ReactCurrentBatchConfig$3.transition;
            try {
              ReactCurrentBatchConfig$3.transition = null;
              setCurrentUpdatePriority(DiscreteEventPriority);
              return fn2(a6, b7, c9, d7);
            } finally {
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig$3.transition = prevTransition;
              if (executionContext === NoContext) {
                resetRenderTimer();
              }
            }
          }
          function flushSync(fn2) {
            if (rootWithPendingPassiveEffects !== null && rootWithPendingPassiveEffects.tag === LegacyRoot && (executionContext & (RenderContext | CommitContext)) === NoContext) {
              flushPassiveEffects();
            }
            var prevExecutionContext = executionContext;
            executionContext |= BatchedContext;
            var prevTransition = ReactCurrentBatchConfig$3.transition;
            var previousPriority = getCurrentUpdatePriority();
            try {
              ReactCurrentBatchConfig$3.transition = null;
              setCurrentUpdatePriority(DiscreteEventPriority);
              if (fn2) {
                return fn2();
              } else {
                return void 0;
              }
            } finally {
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig$3.transition = prevTransition;
              executionContext = prevExecutionContext;
              if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
                flushSyncCallbacks();
              }
            }
          }
          function isAlreadyRendering() {
            return (executionContext & (RenderContext | CommitContext)) !== NoContext;
          }
          function pushRenderLanes(fiber, lanes) {
            push(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);
            subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);
            workInProgressRootIncludedLanes = mergeLanes(workInProgressRootIncludedLanes, lanes);
          }
          function popRenderLanes(fiber) {
            subtreeRenderLanes = subtreeRenderLanesCursor.current;
            pop(subtreeRenderLanesCursor, fiber);
          }
          function prepareFreshStack(root3, lanes) {
            root3.finishedWork = null;
            root3.finishedLanes = NoLanes;
            var timeoutHandle = root3.timeoutHandle;
            if (timeoutHandle !== noTimeout) {
              root3.timeoutHandle = noTimeout;
              cancelTimeout(timeoutHandle);
            }
            if (workInProgress !== null) {
              var interruptedWork = workInProgress.return;
              while (interruptedWork !== null) {
                var current2 = interruptedWork.alternate;
                unwindInterruptedWork(current2, interruptedWork);
                interruptedWork = interruptedWork.return;
              }
            }
            workInProgressRoot = root3;
            var rootWorkInProgress = createWorkInProgress(root3.current, null);
            workInProgress = rootWorkInProgress;
            workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;
            workInProgressRootExitStatus = RootInProgress;
            workInProgressRootFatalError = null;
            workInProgressRootSkippedLanes = NoLanes;
            workInProgressRootInterleavedUpdatedLanes = NoLanes;
            workInProgressRootPingedLanes = NoLanes;
            workInProgressRootConcurrentErrors = null;
            workInProgressRootRecoverableErrors = null;
            finishQueueingConcurrentUpdates();
            {
              ReactStrictModeWarnings.discardPendingWarnings();
            }
            return rootWorkInProgress;
          }
          function handleError(root3, thrownValue) {
            do {
              var erroredWork = workInProgress;
              try {
                resetContextDependencies();
                resetHooksAfterThrow();
                resetCurrentFiber();
                ReactCurrentOwner$2.current = null;
                if (erroredWork === null || erroredWork.return === null) {
                  workInProgressRootExitStatus = RootFatalErrored;
                  workInProgressRootFatalError = thrownValue;
                  workInProgress = null;
                  return;
                }
                if (enableProfilerTimer && erroredWork.mode & ProfileMode) {
                  stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);
                }
                if (enableSchedulingProfiler) {
                  markComponentRenderStopped();
                  if (thrownValue !== null && typeof thrownValue === "object" && typeof thrownValue.then === "function") {
                    var wakeable = thrownValue;
                    markComponentSuspended(erroredWork, wakeable, workInProgressRootRenderLanes);
                  } else {
                    markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);
                  }
                }
                throwException(root3, erroredWork.return, erroredWork, thrownValue, workInProgressRootRenderLanes);
                completeUnitOfWork(erroredWork);
              } catch (yetAnotherThrownValue) {
                thrownValue = yetAnotherThrownValue;
                if (workInProgress === erroredWork && erroredWork !== null) {
                  erroredWork = erroredWork.return;
                  workInProgress = erroredWork;
                } else {
                  erroredWork = workInProgress;
                }
                continue;
              }
              return;
            } while (true);
          }
          function pushDispatcher() {
            var prevDispatcher = ReactCurrentDispatcher$2.current;
            ReactCurrentDispatcher$2.current = ContextOnlyDispatcher;
            if (prevDispatcher === null) {
              return ContextOnlyDispatcher;
            } else {
              return prevDispatcher;
            }
          }
          function popDispatcher(prevDispatcher) {
            ReactCurrentDispatcher$2.current = prevDispatcher;
          }
          function markCommitTimeOfFallback() {
            globalMostRecentFallbackTime = now2();
          }
          function markSkippedUpdateLanes(lane) {
            workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);
          }
          function renderDidSuspend() {
            if (workInProgressRootExitStatus === RootInProgress) {
              workInProgressRootExitStatus = RootSuspended;
            }
          }
          function renderDidSuspendDelayIfPossible() {
            if (workInProgressRootExitStatus === RootInProgress || workInProgressRootExitStatus === RootSuspended || workInProgressRootExitStatus === RootErrored) {
              workInProgressRootExitStatus = RootSuspendedWithDelay;
            }
            if (workInProgressRoot !== null && (includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes))) {
              markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes);
            }
          }
          function renderDidError(error2) {
            if (workInProgressRootExitStatus !== RootSuspendedWithDelay) {
              workInProgressRootExitStatus = RootErrored;
            }
            if (workInProgressRootConcurrentErrors === null) {
              workInProgressRootConcurrentErrors = [error2];
            } else {
              workInProgressRootConcurrentErrors.push(error2);
            }
          }
          function renderHasNotSuspendedYet() {
            return workInProgressRootExitStatus === RootInProgress;
          }
          function renderRootSync(root3, lanes) {
            var prevExecutionContext = executionContext;
            executionContext |= RenderContext;
            var prevDispatcher = pushDispatcher();
            if (workInProgressRoot !== root3 || workInProgressRootRenderLanes !== lanes) {
              {
                if (isDevToolsPresent) {
                  var memoizedUpdaters = root3.memoizedUpdaters;
                  if (memoizedUpdaters.size > 0) {
                    restorePendingUpdaters(root3, workInProgressRootRenderLanes);
                    memoizedUpdaters.clear();
                  }
                  movePendingFibersToMemoized(root3, lanes);
                }
              }
              workInProgressTransitions = getTransitionsForLanes();
              prepareFreshStack(root3, lanes);
            }
            {
              markRenderStarted(lanes);
            }
            do {
              try {
                workLoopSync();
                break;
              } catch (thrownValue) {
                handleError(root3, thrownValue);
              }
            } while (true);
            resetContextDependencies();
            executionContext = prevExecutionContext;
            popDispatcher(prevDispatcher);
            if (workInProgress !== null) {
              throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
            }
            {
              markRenderStopped();
            }
            workInProgressRoot = null;
            workInProgressRootRenderLanes = NoLanes;
            return workInProgressRootExitStatus;
          }
          function workLoopSync() {
            while (workInProgress !== null) {
              performUnitOfWork(workInProgress);
            }
          }
          function renderRootConcurrent(root3, lanes) {
            var prevExecutionContext = executionContext;
            executionContext |= RenderContext;
            var prevDispatcher = pushDispatcher();
            if (workInProgressRoot !== root3 || workInProgressRootRenderLanes !== lanes) {
              {
                if (isDevToolsPresent) {
                  var memoizedUpdaters = root3.memoizedUpdaters;
                  if (memoizedUpdaters.size > 0) {
                    restorePendingUpdaters(root3, workInProgressRootRenderLanes);
                    memoizedUpdaters.clear();
                  }
                  movePendingFibersToMemoized(root3, lanes);
                }
              }
              workInProgressTransitions = getTransitionsForLanes();
              resetRenderTimer();
              prepareFreshStack(root3, lanes);
            }
            {
              markRenderStarted(lanes);
            }
            do {
              try {
                workLoopConcurrent();
                break;
              } catch (thrownValue) {
                handleError(root3, thrownValue);
              }
            } while (true);
            resetContextDependencies();
            popDispatcher(prevDispatcher);
            executionContext = prevExecutionContext;
            if (workInProgress !== null) {
              {
                markRenderYielded();
              }
              return RootInProgress;
            } else {
              {
                markRenderStopped();
              }
              workInProgressRoot = null;
              workInProgressRootRenderLanes = NoLanes;
              return workInProgressRootExitStatus;
            }
          }
          function workLoopConcurrent() {
            while (workInProgress !== null && !shouldYield()) {
              performUnitOfWork(workInProgress);
            }
          }
          function performUnitOfWork(unitOfWork) {
            var current2 = unitOfWork.alternate;
            setCurrentFiber(unitOfWork);
            var next;
            if ((unitOfWork.mode & ProfileMode) !== NoMode) {
              startProfilerTimer(unitOfWork);
              next = beginWork$1(current2, unitOfWork, subtreeRenderLanes);
              stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);
            } else {
              next = beginWork$1(current2, unitOfWork, subtreeRenderLanes);
            }
            resetCurrentFiber();
            unitOfWork.memoizedProps = unitOfWork.pendingProps;
            if (next === null) {
              completeUnitOfWork(unitOfWork);
            } else {
              workInProgress = next;
            }
            ReactCurrentOwner$2.current = null;
          }
          function completeUnitOfWork(unitOfWork) {
            var completedWork = unitOfWork;
            do {
              var current2 = completedWork.alternate;
              var returnFiber = completedWork.return;
              if ((completedWork.flags & Incomplete) === NoFlags) {
                setCurrentFiber(completedWork);
                var next = void 0;
                if ((completedWork.mode & ProfileMode) === NoMode) {
                  next = completeWork(current2, completedWork, subtreeRenderLanes);
                } else {
                  startProfilerTimer(completedWork);
                  next = completeWork(current2, completedWork, subtreeRenderLanes);
                  stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
                }
                resetCurrentFiber();
                if (next !== null) {
                  workInProgress = next;
                  return;
                }
              } else {
                var _next = unwindWork(current2, completedWork);
                if (_next !== null) {
                  _next.flags &= HostEffectMask;
                  workInProgress = _next;
                  return;
                }
                if ((completedWork.mode & ProfileMode) !== NoMode) {
                  stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
                  var actualDuration = completedWork.actualDuration;
                  var child = completedWork.child;
                  while (child !== null) {
                    actualDuration += child.actualDuration;
                    child = child.sibling;
                  }
                  completedWork.actualDuration = actualDuration;
                }
                if (returnFiber !== null) {
                  returnFiber.flags |= Incomplete;
                  returnFiber.subtreeFlags = NoFlags;
                  returnFiber.deletions = null;
                } else {
                  workInProgressRootExitStatus = RootDidNotComplete;
                  workInProgress = null;
                  return;
                }
              }
              var siblingFiber = completedWork.sibling;
              if (siblingFiber !== null) {
                workInProgress = siblingFiber;
                return;
              }
              completedWork = returnFiber;
              workInProgress = completedWork;
            } while (completedWork !== null);
            if (workInProgressRootExitStatus === RootInProgress) {
              workInProgressRootExitStatus = RootCompleted;
            }
          }
          function commitRoot(root3, recoverableErrors, transitions) {
            var previousUpdateLanePriority = getCurrentUpdatePriority();
            var prevTransition = ReactCurrentBatchConfig$3.transition;
            try {
              ReactCurrentBatchConfig$3.transition = null;
              setCurrentUpdatePriority(DiscreteEventPriority);
              commitRootImpl(root3, recoverableErrors, transitions, previousUpdateLanePriority);
            } finally {
              ReactCurrentBatchConfig$3.transition = prevTransition;
              setCurrentUpdatePriority(previousUpdateLanePriority);
            }
            return null;
          }
          function commitRootImpl(root3, recoverableErrors, transitions, renderPriorityLevel) {
            do {
              flushPassiveEffects();
            } while (rootWithPendingPassiveEffects !== null);
            flushRenderPhaseStrictModeWarningsInDEV();
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
              throw new Error("Should not already be working.");
            }
            var finishedWork = root3.finishedWork;
            var lanes = root3.finishedLanes;
            {
              markCommitStarted(lanes);
            }
            if (finishedWork === null) {
              {
                markCommitStopped();
              }
              return null;
            } else {
              {
                if (lanes === NoLanes) {
                  error("root.finishedLanes should not be empty during a commit. This is a bug in React.");
                }
              }
            }
            root3.finishedWork = null;
            root3.finishedLanes = NoLanes;
            if (finishedWork === root3.current) {
              throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
            }
            root3.callbackNode = null;
            root3.callbackPriority = NoLane;
            var remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);
            markRootFinished(root3, remainingLanes);
            if (root3 === workInProgressRoot) {
              workInProgressRoot = null;
              workInProgress = null;
              workInProgressRootRenderLanes = NoLanes;
            }
            if ((finishedWork.subtreeFlags & PassiveMask) !== NoFlags || (finishedWork.flags & PassiveMask) !== NoFlags) {
              if (!rootDoesHavePassiveEffects) {
                rootDoesHavePassiveEffects = true;
                pendingPassiveTransitions = transitions;
                scheduleCallback$1(NormalPriority, function() {
                  flushPassiveEffects();
                  return null;
                });
              }
            }
            var subtreeHasEffects = (finishedWork.subtreeFlags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;
            var rootHasEffect = (finishedWork.flags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;
            if (subtreeHasEffects || rootHasEffect) {
              var prevTransition = ReactCurrentBatchConfig$3.transition;
              ReactCurrentBatchConfig$3.transition = null;
              var previousPriority = getCurrentUpdatePriority();
              setCurrentUpdatePriority(DiscreteEventPriority);
              var prevExecutionContext = executionContext;
              executionContext |= CommitContext;
              ReactCurrentOwner$2.current = null;
              var shouldFireAfterActiveInstanceBlur2 = commitBeforeMutationEffects(root3, finishedWork);
              {
                recordCommitTime();
              }
              commitMutationEffects(root3, finishedWork, lanes);
              resetAfterCommit(root3.containerInfo);
              root3.current = finishedWork;
              {
                markLayoutEffectsStarted(lanes);
              }
              commitLayoutEffects(finishedWork, root3, lanes);
              {
                markLayoutEffectsStopped();
              }
              requestPaint();
              executionContext = prevExecutionContext;
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig$3.transition = prevTransition;
            } else {
              root3.current = finishedWork;
              {
                recordCommitTime();
              }
            }
            var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;
            if (rootDoesHavePassiveEffects) {
              rootDoesHavePassiveEffects = false;
              rootWithPendingPassiveEffects = root3;
              pendingPassiveEffectsLanes = lanes;
            } else {
              {
                nestedPassiveUpdateCount = 0;
                rootWithPassiveNestedUpdates = null;
              }
            }
            remainingLanes = root3.pendingLanes;
            if (remainingLanes === NoLanes) {
              legacyErrorBoundariesThatAlreadyFailed = null;
            }
            {
              if (!rootDidHavePassiveEffects) {
                commitDoubleInvokeEffectsInDEV(root3.current, false);
              }
            }
            onCommitRoot(finishedWork.stateNode, renderPriorityLevel);
            {
              if (isDevToolsPresent) {
                root3.memoizedUpdaters.clear();
              }
            }
            {
              onCommitRoot$1();
            }
            ensureRootIsScheduled(root3, now2());
            if (recoverableErrors !== null) {
              var onRecoverableError = root3.onRecoverableError;
              for (var i7 = 0; i7 < recoverableErrors.length; i7++) {
                var recoverableError = recoverableErrors[i7];
                var componentStack = recoverableError.stack;
                var digest2 = recoverableError.digest;
                onRecoverableError(recoverableError.value, {
                  componentStack,
                  digest: digest2
                });
              }
            }
            if (hasUncaughtError) {
              hasUncaughtError = false;
              var error$1 = firstUncaughtError;
              firstUncaughtError = null;
              throw error$1;
            }
            if (includesSomeLane(pendingPassiveEffectsLanes, SyncLane) && root3.tag !== LegacyRoot) {
              flushPassiveEffects();
            }
            remainingLanes = root3.pendingLanes;
            if (includesSomeLane(remainingLanes, SyncLane)) {
              {
                markNestedUpdateScheduled();
              }
              if (root3 === rootWithNestedUpdates) {
                nestedUpdateCount++;
              } else {
                nestedUpdateCount = 0;
                rootWithNestedUpdates = root3;
              }
            } else {
              nestedUpdateCount = 0;
            }
            flushSyncCallbacks();
            {
              markCommitStopped();
            }
            return null;
          }
          function flushPassiveEffects() {
            if (rootWithPendingPassiveEffects !== null) {
              var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes);
              var priority = lowerEventPriority(DefaultEventPriority, renderPriority);
              var prevTransition = ReactCurrentBatchConfig$3.transition;
              var previousPriority = getCurrentUpdatePriority();
              try {
                ReactCurrentBatchConfig$3.transition = null;
                setCurrentUpdatePriority(priority);
                return flushPassiveEffectsImpl();
              } finally {
                setCurrentUpdatePriority(previousPriority);
                ReactCurrentBatchConfig$3.transition = prevTransition;
              }
            }
            return false;
          }
          function enqueuePendingPassiveProfilerEffect(fiber) {
            {
              pendingPassiveProfilerEffects.push(fiber);
              if (!rootDoesHavePassiveEffects) {
                rootDoesHavePassiveEffects = true;
                scheduleCallback$1(NormalPriority, function() {
                  flushPassiveEffects();
                  return null;
                });
              }
            }
          }
          function flushPassiveEffectsImpl() {
            if (rootWithPendingPassiveEffects === null) {
              return false;
            }
            var transitions = pendingPassiveTransitions;
            pendingPassiveTransitions = null;
            var root3 = rootWithPendingPassiveEffects;
            var lanes = pendingPassiveEffectsLanes;
            rootWithPendingPassiveEffects = null;
            pendingPassiveEffectsLanes = NoLanes;
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
              throw new Error("Cannot flush passive effects while already rendering.");
            }
            {
              isFlushingPassiveEffects = true;
              didScheduleUpdateDuringPassiveEffects = false;
            }
            {
              markPassiveEffectsStarted(lanes);
            }
            var prevExecutionContext = executionContext;
            executionContext |= CommitContext;
            commitPassiveUnmountEffects(root3.current);
            commitPassiveMountEffects(root3, root3.current, lanes, transitions);
            {
              var profilerEffects = pendingPassiveProfilerEffects;
              pendingPassiveProfilerEffects = [];
              for (var i7 = 0; i7 < profilerEffects.length; i7++) {
                var _fiber = profilerEffects[i7];
                commitPassiveEffectDurations(root3, _fiber);
              }
            }
            {
              markPassiveEffectsStopped();
            }
            {
              commitDoubleInvokeEffectsInDEV(root3.current, true);
            }
            executionContext = prevExecutionContext;
            flushSyncCallbacks();
            {
              if (didScheduleUpdateDuringPassiveEffects) {
                if (root3 === rootWithPassiveNestedUpdates) {
                  nestedPassiveUpdateCount++;
                } else {
                  nestedPassiveUpdateCount = 0;
                  rootWithPassiveNestedUpdates = root3;
                }
              } else {
                nestedPassiveUpdateCount = 0;
              }
              isFlushingPassiveEffects = false;
              didScheduleUpdateDuringPassiveEffects = false;
            }
            onPostCommitRoot(root3);
            {
              var stateNode = root3.current.stateNode;
              stateNode.effectDuration = 0;
              stateNode.passiveEffectDuration = 0;
            }
            return true;
          }
          function isAlreadyFailedLegacyErrorBoundary(instance) {
            return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);
          }
          function markLegacyErrorBoundaryAsFailed(instance) {
            if (legacyErrorBoundariesThatAlreadyFailed === null) {
              legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([instance]);
            } else {
              legacyErrorBoundariesThatAlreadyFailed.add(instance);
            }
          }
          function prepareToThrowUncaughtError(error2) {
            if (!hasUncaughtError) {
              hasUncaughtError = true;
              firstUncaughtError = error2;
            }
          }
          var onUncaughtError = prepareToThrowUncaughtError;
          function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error2) {
            var errorInfo = createCapturedValueAtFiber(error2, sourceFiber);
            var update2 = createRootErrorUpdate(rootFiber, errorInfo, SyncLane);
            var root3 = enqueueUpdate(rootFiber, update2, SyncLane);
            var eventTime = requestEventTime();
            if (root3 !== null) {
              markRootUpdated(root3, SyncLane, eventTime);
              ensureRootIsScheduled(root3, eventTime);
            }
          }
          function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error$1) {
            {
              reportUncaughtErrorInDEV(error$1);
              setIsRunningInsertionEffect(false);
            }
            if (sourceFiber.tag === HostRoot) {
              captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error$1);
              return;
            }
            var fiber = null;
            {
              fiber = nearestMountedAncestor;
            }
            while (fiber !== null) {
              if (fiber.tag === HostRoot) {
                captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error$1);
                return;
              } else if (fiber.tag === ClassComponent) {
                var ctor = fiber.type;
                var instance = fiber.stateNode;
                if (typeof ctor.getDerivedStateFromError === "function" || typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance)) {
                  var errorInfo = createCapturedValueAtFiber(error$1, sourceFiber);
                  var update2 = createClassErrorUpdate(fiber, errorInfo, SyncLane);
                  var root3 = enqueueUpdate(fiber, update2, SyncLane);
                  var eventTime = requestEventTime();
                  if (root3 !== null) {
                    markRootUpdated(root3, SyncLane, eventTime);
                    ensureRootIsScheduled(root3, eventTime);
                  }
                  return;
                }
              }
              fiber = fiber.return;
            }
            {
              error("Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\n\nError message:\n\n%s", error$1);
            }
          }
          function pingSuspendedRoot(root3, wakeable, pingedLanes) {
            var pingCache = root3.pingCache;
            if (pingCache !== null) {
              pingCache.delete(wakeable);
            }
            var eventTime = requestEventTime();
            markRootPinged(root3, pingedLanes);
            warnIfSuspenseResolutionNotWrappedWithActDEV(root3);
            if (workInProgressRoot === root3 && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)) {
              if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now2() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) {
                prepareFreshStack(root3, NoLanes);
              } else {
                workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes);
              }
            }
            ensureRootIsScheduled(root3, eventTime);
          }
          function retryTimedOutBoundary(boundaryFiber, retryLane) {
            if (retryLane === NoLane) {
              retryLane = requestRetryLane(boundaryFiber);
            }
            var eventTime = requestEventTime();
            var root3 = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
            if (root3 !== null) {
              markRootUpdated(root3, retryLane, eventTime);
              ensureRootIsScheduled(root3, eventTime);
            }
          }
          function retryDehydratedSuspenseBoundary(boundaryFiber) {
            var suspenseState = boundaryFiber.memoizedState;
            var retryLane = NoLane;
            if (suspenseState !== null) {
              retryLane = suspenseState.retryLane;
            }
            retryTimedOutBoundary(boundaryFiber, retryLane);
          }
          function resolveRetryWakeable(boundaryFiber, wakeable) {
            var retryLane = NoLane;
            var retryCache;
            switch (boundaryFiber.tag) {
              case SuspenseComponent:
                retryCache = boundaryFiber.stateNode;
                var suspenseState = boundaryFiber.memoizedState;
                if (suspenseState !== null) {
                  retryLane = suspenseState.retryLane;
                }
                break;
              case SuspenseListComponent:
                retryCache = boundaryFiber.stateNode;
                break;
              default:
                throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
            }
            if (retryCache !== null) {
              retryCache.delete(wakeable);
            }
            retryTimedOutBoundary(boundaryFiber, retryLane);
          }
          function jnd(timeElapsed) {
            return timeElapsed < 120 ? 120 : timeElapsed < 480 ? 480 : timeElapsed < 1080 ? 1080 : timeElapsed < 1920 ? 1920 : timeElapsed < 3e3 ? 3e3 : timeElapsed < 4320 ? 4320 : ceil(timeElapsed / 1960) * 1960;
          }
          function checkForNestedUpdates() {
            if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
              nestedUpdateCount = 0;
              rootWithNestedUpdates = null;
              throw new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
            }
            {
              if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {
                nestedPassiveUpdateCount = 0;
                rootWithPassiveNestedUpdates = null;
                error("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render.");
              }
            }
          }
          function flushRenderPhaseStrictModeWarningsInDEV() {
            {
              ReactStrictModeWarnings.flushLegacyContextWarning();
              {
                ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
              }
            }
          }
          function commitDoubleInvokeEffectsInDEV(fiber, hasPassiveEffects) {
            {
              setCurrentFiber(fiber);
              invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectUnmountInDEV);
              if (hasPassiveEffects) {
                invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectUnmountInDEV);
              }
              invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectMountInDEV);
              if (hasPassiveEffects) {
                invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectMountInDEV);
              }
              resetCurrentFiber();
            }
          }
          function invokeEffectsInDev(firstChild, fiberFlags, invokeEffectFn) {
            {
              var current2 = firstChild;
              var subtreeRoot = null;
              while (current2 !== null) {
                var primarySubtreeFlag = current2.subtreeFlags & fiberFlags;
                if (current2 !== subtreeRoot && current2.child !== null && primarySubtreeFlag !== NoFlags) {
                  current2 = current2.child;
                } else {
                  if ((current2.flags & fiberFlags) !== NoFlags) {
                    invokeEffectFn(current2);
                  }
                  if (current2.sibling !== null) {
                    current2 = current2.sibling;
                  } else {
                    current2 = subtreeRoot = current2.return;
                  }
                }
              }
            }
          }
          var didWarnStateUpdateForNotYetMountedComponent = null;
          function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
            {
              if ((executionContext & RenderContext) !== NoContext) {
                return;
              }
              if (!(fiber.mode & ConcurrentMode)) {
                return;
              }
              var tag = fiber.tag;
              if (tag !== IndeterminateComponent && tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent) {
                return;
              }
              var componentName = getComponentNameFromFiber(fiber) || "ReactComponent";
              if (didWarnStateUpdateForNotYetMountedComponent !== null) {
                if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {
                  return;
                }
                didWarnStateUpdateForNotYetMountedComponent.add(componentName);
              } else {
                didWarnStateUpdateForNotYetMountedComponent = /* @__PURE__ */ new Set([componentName]);
              }
              var previousFiber = current;
              try {
                setCurrentFiber(fiber);
                error("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
              } finally {
                if (previousFiber) {
                  setCurrentFiber(fiber);
                } else {
                  resetCurrentFiber();
                }
              }
            }
          }
          var beginWork$1;
          {
            var dummyFiber = null;
            beginWork$1 = function(current2, unitOfWork, lanes) {
              var originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);
              try {
                return beginWork(current2, unitOfWork, lanes);
              } catch (originalError) {
                if (didSuspendOrErrorWhileHydratingDEV() || originalError !== null && typeof originalError === "object" && typeof originalError.then === "function") {
                  throw originalError;
                }
                resetContextDependencies();
                resetHooksAfterThrow();
                unwindInterruptedWork(current2, unitOfWork);
                assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);
                if (unitOfWork.mode & ProfileMode) {
                  startProfilerTimer(unitOfWork);
                }
                invokeGuardedCallback(null, beginWork, null, current2, unitOfWork, lanes);
                if (hasCaughtError()) {
                  var replayError = clearCaughtError();
                  if (typeof replayError === "object" && replayError !== null && replayError._suppressLogging && typeof originalError === "object" && originalError !== null && !originalError._suppressLogging) {
                    originalError._suppressLogging = true;
                  }
                }
                throw originalError;
              }
            };
          }
          var didWarnAboutUpdateInRender = false;
          var didWarnAboutUpdateInRenderForAnotherComponent;
          {
            didWarnAboutUpdateInRenderForAnotherComponent = /* @__PURE__ */ new Set();
          }
          function warnAboutRenderPhaseUpdatesInDEV(fiber) {
            {
              if (isRendering && !getIsUpdatingOpaqueValueInRenderPhaseInDEV()) {
                switch (fiber.tag) {
                  case FunctionComponent:
                  case ForwardRef:
                  case SimpleMemoComponent: {
                    var renderingComponentName = workInProgress && getComponentNameFromFiber(workInProgress) || "Unknown";
                    var dedupeKey = renderingComponentName;
                    if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {
                      didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);
                      var setStateComponentName = getComponentNameFromFiber(fiber) || "Unknown";
                      error("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", setStateComponentName, renderingComponentName, renderingComponentName);
                    }
                    break;
                  }
                  case ClassComponent: {
                    if (!didWarnAboutUpdateInRender) {
                      error("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state.");
                      didWarnAboutUpdateInRender = true;
                    }
                    break;
                  }
                }
              }
            }
          }
          function restorePendingUpdaters(root3, lanes) {
            {
              if (isDevToolsPresent) {
                var memoizedUpdaters = root3.memoizedUpdaters;
                memoizedUpdaters.forEach(function(schedulingFiber) {
                  addFiberToLanesMap(root3, schedulingFiber, lanes);
                });
              }
            }
          }
          var fakeActCallbackNode = {};
          function scheduleCallback$1(priorityLevel, callback) {
            {
              var actQueue = ReactCurrentActQueue$1.current;
              if (actQueue !== null) {
                actQueue.push(callback);
                return fakeActCallbackNode;
              } else {
                return scheduleCallback(priorityLevel, callback);
              }
            }
          }
          function cancelCallback$1(callbackNode) {
            if (callbackNode === fakeActCallbackNode) {
              return;
            }
            return cancelCallback(callbackNode);
          }
          function shouldForceFlushFallbacksInDEV() {
            return ReactCurrentActQueue$1.current !== null;
          }
          function warnIfUpdatesNotWrappedWithActDEV(fiber) {
            {
              if (fiber.mode & ConcurrentMode) {
                if (!isConcurrentActEnvironment()) {
                  return;
                }
              } else {
                if (!isLegacyActEnvironment()) {
                  return;
                }
                if (executionContext !== NoContext) {
                  return;
                }
                if (fiber.tag !== FunctionComponent && fiber.tag !== ForwardRef && fiber.tag !== SimpleMemoComponent) {
                  return;
                }
              }
              if (ReactCurrentActQueue$1.current === null) {
                var previousFiber = current;
                try {
                  setCurrentFiber(fiber);
                  error("An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act", getComponentNameFromFiber(fiber));
                } finally {
                  if (previousFiber) {
                    setCurrentFiber(fiber);
                  } else {
                    resetCurrentFiber();
                  }
                }
              }
            }
          }
          function warnIfSuspenseResolutionNotWrappedWithActDEV(root3) {
            {
              if (root3.tag !== LegacyRoot && isConcurrentActEnvironment() && ReactCurrentActQueue$1.current === null) {
                error("A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\n\nWhen testing, code that resolves suspended data should be wrapped into act(...):\n\nact(() => {\n  /* finish loading suspended data */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act");
              }
            }
          }
          function setIsRunningInsertionEffect(isRunning) {
            {
              isRunningInsertionEffect = isRunning;
            }
          }
          var resolveFamily = null;
          var failedBoundaries = null;
          var setRefreshHandler = function(handler) {
            {
              resolveFamily = handler;
            }
          };
          function resolveFunctionForHotReloading(type) {
            {
              if (resolveFamily === null) {
                return type;
              }
              var family = resolveFamily(type);
              if (family === void 0) {
                return type;
              }
              return family.current;
            }
          }
          function resolveClassForHotReloading(type) {
            return resolveFunctionForHotReloading(type);
          }
          function resolveForwardRefForHotReloading(type) {
            {
              if (resolveFamily === null) {
                return type;
              }
              var family = resolveFamily(type);
              if (family === void 0) {
                if (type !== null && type !== void 0 && typeof type.render === "function") {
                  var currentRender = resolveFunctionForHotReloading(type.render);
                  if (type.render !== currentRender) {
                    var syntheticType = {
                      $$typeof: REACT_FORWARD_REF_TYPE,
                      render: currentRender
                    };
                    if (type.displayName !== void 0) {
                      syntheticType.displayName = type.displayName;
                    }
                    return syntheticType;
                  }
                }
                return type;
              }
              return family.current;
            }
          }
          function isCompatibleFamilyForHotReloading(fiber, element) {
            {
              if (resolveFamily === null) {
                return false;
              }
              var prevType = fiber.elementType;
              var nextType = element.type;
              var needsCompareFamilies = false;
              var $$typeofNextType = typeof nextType === "object" && nextType !== null ? nextType.$$typeof : null;
              switch (fiber.tag) {
                case ClassComponent: {
                  if (typeof nextType === "function") {
                    needsCompareFamilies = true;
                  }
                  break;
                }
                case FunctionComponent: {
                  if (typeof nextType === "function") {
                    needsCompareFamilies = true;
                  } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                    needsCompareFamilies = true;
                  }
                  break;
                }
                case ForwardRef: {
                  if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {
                    needsCompareFamilies = true;
                  } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                    needsCompareFamilies = true;
                  }
                  break;
                }
                case MemoComponent:
                case SimpleMemoComponent: {
                  if ($$typeofNextType === REACT_MEMO_TYPE) {
                    needsCompareFamilies = true;
                  } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                    needsCompareFamilies = true;
                  }
                  break;
                }
                default:
                  return false;
              }
              if (needsCompareFamilies) {
                var prevFamily = resolveFamily(prevType);
                if (prevFamily !== void 0 && prevFamily === resolveFamily(nextType)) {
                  return true;
                }
              }
              return false;
            }
          }
          function markFailedErrorBoundaryForHotReloading(fiber) {
            {
              if (resolveFamily === null) {
                return;
              }
              if (typeof WeakSet !== "function") {
                return;
              }
              if (failedBoundaries === null) {
                failedBoundaries = /* @__PURE__ */ new WeakSet();
              }
              failedBoundaries.add(fiber);
            }
          }
          var scheduleRefresh = function(root3, update2) {
            {
              if (resolveFamily === null) {
                return;
              }
              var staleFamilies = update2.staleFamilies, updatedFamilies = update2.updatedFamilies;
              flushPassiveEffects();
              flushSync(function() {
                scheduleFibersWithFamiliesRecursively(root3.current, updatedFamilies, staleFamilies);
              });
            }
          };
          var scheduleRoot = function(root3, element) {
            {
              if (root3.context !== emptyContextObject) {
                return;
              }
              flushPassiveEffects();
              flushSync(function() {
                updateContainer(element, root3, null, null);
              });
            }
          };
          function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
            {
              var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;
              var candidateType = null;
              switch (tag) {
                case FunctionComponent:
                case SimpleMemoComponent:
                case ClassComponent:
                  candidateType = type;
                  break;
                case ForwardRef:
                  candidateType = type.render;
                  break;
              }
              if (resolveFamily === null) {
                throw new Error("Expected resolveFamily to be set during hot reload.");
              }
              var needsRender = false;
              var needsRemount = false;
              if (candidateType !== null) {
                var family = resolveFamily(candidateType);
                if (family !== void 0) {
                  if (staleFamilies.has(family)) {
                    needsRemount = true;
                  } else if (updatedFamilies.has(family)) {
                    if (tag === ClassComponent) {
                      needsRemount = true;
                    } else {
                      needsRender = true;
                    }
                  }
                }
              }
              if (failedBoundaries !== null) {
                if (failedBoundaries.has(fiber) || alternate !== null && failedBoundaries.has(alternate)) {
                  needsRemount = true;
                }
              }
              if (needsRemount) {
                fiber._debugNeedsRemount = true;
              }
              if (needsRemount || needsRender) {
                var _root = enqueueConcurrentRenderForLane(fiber, SyncLane);
                if (_root !== null) {
                  scheduleUpdateOnFiber(_root, fiber, SyncLane, NoTimestamp);
                }
              }
              if (child !== null && !needsRemount) {
                scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);
              }
              if (sibling !== null) {
                scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);
              }
            }
          }
          var findHostInstancesForRefresh = function(root3, families) {
            {
              var hostInstances = /* @__PURE__ */ new Set();
              var types = new Set(families.map(function(family) {
                return family.current;
              }));
              findHostInstancesForMatchingFibersRecursively(root3.current, types, hostInstances);
              return hostInstances;
            }
          };
          function findHostInstancesForMatchingFibersRecursively(fiber, types, hostInstances) {
            {
              var child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;
              var candidateType = null;
              switch (tag) {
                case FunctionComponent:
                case SimpleMemoComponent:
                case ClassComponent:
                  candidateType = type;
                  break;
                case ForwardRef:
                  candidateType = type.render;
                  break;
              }
              var didMatch = false;
              if (candidateType !== null) {
                if (types.has(candidateType)) {
                  didMatch = true;
                }
              }
              if (didMatch) {
                findHostInstancesForFiberShallowly(fiber, hostInstances);
              } else {
                if (child !== null) {
                  findHostInstancesForMatchingFibersRecursively(child, types, hostInstances);
                }
              }
              if (sibling !== null) {
                findHostInstancesForMatchingFibersRecursively(sibling, types, hostInstances);
              }
            }
          }
          function findHostInstancesForFiberShallowly(fiber, hostInstances) {
            {
              var foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);
              if (foundHostInstances) {
                return;
              }
              var node = fiber;
              while (true) {
                switch (node.tag) {
                  case HostComponent:
                    hostInstances.add(node.stateNode);
                    return;
                  case HostPortal:
                    hostInstances.add(node.stateNode.containerInfo);
                    return;
                  case HostRoot:
                    hostInstances.add(node.stateNode.containerInfo);
                    return;
                }
                if (node.return === null) {
                  throw new Error("Expected to reach root first.");
                }
                node = node.return;
              }
            }
          }
          function findChildHostInstancesForFiberShallowly(fiber, hostInstances) {
            {
              var node = fiber;
              var foundHostInstances = false;
              while (true) {
                if (node.tag === HostComponent) {
                  foundHostInstances = true;
                  hostInstances.add(node.stateNode);
                } else if (node.child !== null) {
                  node.child.return = node;
                  node = node.child;
                  continue;
                }
                if (node === fiber) {
                  return foundHostInstances;
                }
                while (node.sibling === null) {
                  if (node.return === null || node.return === fiber) {
                    return foundHostInstances;
                  }
                  node = node.return;
                }
                node.sibling.return = node.return;
                node = node.sibling;
              }
            }
            return false;
          }
          var hasBadMapPolyfill;
          {
            hasBadMapPolyfill = false;
            try {
              var nonExtensibleObject = Object.preventExtensions({});
              /* @__PURE__ */ new Map([[nonExtensibleObject, null]]);
              /* @__PURE__ */ new Set([nonExtensibleObject]);
            } catch (e9) {
              hasBadMapPolyfill = true;
            }
          }
          function FiberNode(tag, pendingProps, key2, mode) {
            this.tag = tag;
            this.key = key2;
            this.elementType = null;
            this.type = null;
            this.stateNode = null;
            this.return = null;
            this.child = null;
            this.sibling = null;
            this.index = 0;
            this.ref = null;
            this.pendingProps = pendingProps;
            this.memoizedProps = null;
            this.updateQueue = null;
            this.memoizedState = null;
            this.dependencies = null;
            this.mode = mode;
            this.flags = NoFlags;
            this.subtreeFlags = NoFlags;
            this.deletions = null;
            this.lanes = NoLanes;
            this.childLanes = NoLanes;
            this.alternate = null;
            {
              this.actualDuration = Number.NaN;
              this.actualStartTime = Number.NaN;
              this.selfBaseDuration = Number.NaN;
              this.treeBaseDuration = Number.NaN;
              this.actualDuration = 0;
              this.actualStartTime = -1;
              this.selfBaseDuration = 0;
              this.treeBaseDuration = 0;
            }
            {
              this._debugSource = null;
              this._debugOwner = null;
              this._debugNeedsRemount = false;
              this._debugHookTypes = null;
              if (!hasBadMapPolyfill && typeof Object.preventExtensions === "function") {
                Object.preventExtensions(this);
              }
            }
          }
          var createFiber = function(tag, pendingProps, key2, mode) {
            return new FiberNode(tag, pendingProps, key2, mode);
          };
          function shouldConstruct$1(Component) {
            var prototype3 = Component.prototype;
            return !!(prototype3 && prototype3.isReactComponent);
          }
          function isSimpleFunctionComponent(type) {
            return typeof type === "function" && !shouldConstruct$1(type) && type.defaultProps === void 0;
          }
          function resolveLazyComponentTag(Component) {
            if (typeof Component === "function") {
              return shouldConstruct$1(Component) ? ClassComponent : FunctionComponent;
            } else if (Component !== void 0 && Component !== null) {
              var $$typeof = Component.$$typeof;
              if ($$typeof === REACT_FORWARD_REF_TYPE) {
                return ForwardRef;
              }
              if ($$typeof === REACT_MEMO_TYPE) {
                return MemoComponent;
              }
            }
            return IndeterminateComponent;
          }
          function createWorkInProgress(current2, pendingProps) {
            var workInProgress2 = current2.alternate;
            if (workInProgress2 === null) {
              workInProgress2 = createFiber(current2.tag, pendingProps, current2.key, current2.mode);
              workInProgress2.elementType = current2.elementType;
              workInProgress2.type = current2.type;
              workInProgress2.stateNode = current2.stateNode;
              {
                workInProgress2._debugSource = current2._debugSource;
                workInProgress2._debugOwner = current2._debugOwner;
                workInProgress2._debugHookTypes = current2._debugHookTypes;
              }
              workInProgress2.alternate = current2;
              current2.alternate = workInProgress2;
            } else {
              workInProgress2.pendingProps = pendingProps;
              workInProgress2.type = current2.type;
              workInProgress2.flags = NoFlags;
              workInProgress2.subtreeFlags = NoFlags;
              workInProgress2.deletions = null;
              {
                workInProgress2.actualDuration = 0;
                workInProgress2.actualStartTime = -1;
              }
            }
            workInProgress2.flags = current2.flags & StaticMask;
            workInProgress2.childLanes = current2.childLanes;
            workInProgress2.lanes = current2.lanes;
            workInProgress2.child = current2.child;
            workInProgress2.memoizedProps = current2.memoizedProps;
            workInProgress2.memoizedState = current2.memoizedState;
            workInProgress2.updateQueue = current2.updateQueue;
            var currentDependencies = current2.dependencies;
            workInProgress2.dependencies = currentDependencies === null ? null : {
              lanes: currentDependencies.lanes,
              firstContext: currentDependencies.firstContext
            };
            workInProgress2.sibling = current2.sibling;
            workInProgress2.index = current2.index;
            workInProgress2.ref = current2.ref;
            {
              workInProgress2.selfBaseDuration = current2.selfBaseDuration;
              workInProgress2.treeBaseDuration = current2.treeBaseDuration;
            }
            {
              workInProgress2._debugNeedsRemount = current2._debugNeedsRemount;
              switch (workInProgress2.tag) {
                case IndeterminateComponent:
                case FunctionComponent:
                case SimpleMemoComponent:
                  workInProgress2.type = resolveFunctionForHotReloading(current2.type);
                  break;
                case ClassComponent:
                  workInProgress2.type = resolveClassForHotReloading(current2.type);
                  break;
                case ForwardRef:
                  workInProgress2.type = resolveForwardRefForHotReloading(current2.type);
                  break;
              }
            }
            return workInProgress2;
          }
          function resetWorkInProgress(workInProgress2, renderLanes2) {
            workInProgress2.flags &= StaticMask | Placement;
            var current2 = workInProgress2.alternate;
            if (current2 === null) {
              workInProgress2.childLanes = NoLanes;
              workInProgress2.lanes = renderLanes2;
              workInProgress2.child = null;
              workInProgress2.subtreeFlags = NoFlags;
              workInProgress2.memoizedProps = null;
              workInProgress2.memoizedState = null;
              workInProgress2.updateQueue = null;
              workInProgress2.dependencies = null;
              workInProgress2.stateNode = null;
              {
                workInProgress2.selfBaseDuration = 0;
                workInProgress2.treeBaseDuration = 0;
              }
            } else {
              workInProgress2.childLanes = current2.childLanes;
              workInProgress2.lanes = current2.lanes;
              workInProgress2.child = current2.child;
              workInProgress2.subtreeFlags = NoFlags;
              workInProgress2.deletions = null;
              workInProgress2.memoizedProps = current2.memoizedProps;
              workInProgress2.memoizedState = current2.memoizedState;
              workInProgress2.updateQueue = current2.updateQueue;
              workInProgress2.type = current2.type;
              var currentDependencies = current2.dependencies;
              workInProgress2.dependencies = currentDependencies === null ? null : {
                lanes: currentDependencies.lanes,
                firstContext: currentDependencies.firstContext
              };
              {
                workInProgress2.selfBaseDuration = current2.selfBaseDuration;
                workInProgress2.treeBaseDuration = current2.treeBaseDuration;
              }
            }
            return workInProgress2;
          }
          function createHostRootFiber(tag, isStrictMode, concurrentUpdatesByDefaultOverride) {
            var mode;
            if (tag === ConcurrentRoot) {
              mode = ConcurrentMode;
              if (isStrictMode === true) {
                mode |= StrictLegacyMode;
                {
                  mode |= StrictEffectsMode;
                }
              }
            } else {
              mode = NoMode;
            }
            if (isDevToolsPresent) {
              mode |= ProfileMode;
            }
            return createFiber(HostRoot, null, null, mode);
          }
          function createFiberFromTypeAndProps(type, key2, pendingProps, owner, mode, lanes) {
            var fiberTag = IndeterminateComponent;
            var resolvedType = type;
            if (typeof type === "function") {
              if (shouldConstruct$1(type)) {
                fiberTag = ClassComponent;
                {
                  resolvedType = resolveClassForHotReloading(resolvedType);
                }
              } else {
                {
                  resolvedType = resolveFunctionForHotReloading(resolvedType);
                }
              }
            } else if (typeof type === "string") {
              fiberTag = HostComponent;
            } else {
              getTag:
                switch (type) {
                  case REACT_FRAGMENT_TYPE:
                    return createFiberFromFragment(pendingProps.children, mode, lanes, key2);
                  case REACT_STRICT_MODE_TYPE:
                    fiberTag = Mode;
                    mode |= StrictLegacyMode;
                    if ((mode & ConcurrentMode) !== NoMode) {
                      mode |= StrictEffectsMode;
                    }
                    break;
                  case REACT_PROFILER_TYPE:
                    return createFiberFromProfiler(pendingProps, mode, lanes, key2);
                  case REACT_SUSPENSE_TYPE:
                    return createFiberFromSuspense(pendingProps, mode, lanes, key2);
                  case REACT_SUSPENSE_LIST_TYPE:
                    return createFiberFromSuspenseList(pendingProps, mode, lanes, key2);
                  case REACT_OFFSCREEN_TYPE:
                    return createFiberFromOffscreen(pendingProps, mode, lanes, key2);
                  case REACT_LEGACY_HIDDEN_TYPE:
                  case REACT_SCOPE_TYPE:
                  case REACT_CACHE_TYPE:
                  case REACT_TRACING_MARKER_TYPE:
                  case REACT_DEBUG_TRACING_MODE_TYPE:
                  default: {
                    if (typeof type === "object" && type !== null) {
                      switch (type.$$typeof) {
                        case REACT_PROVIDER_TYPE:
                          fiberTag = ContextProvider;
                          break getTag;
                        case REACT_CONTEXT_TYPE:
                          fiberTag = ContextConsumer;
                          break getTag;
                        case REACT_FORWARD_REF_TYPE:
                          fiberTag = ForwardRef;
                          {
                            resolvedType = resolveForwardRefForHotReloading(resolvedType);
                          }
                          break getTag;
                        case REACT_MEMO_TYPE:
                          fiberTag = MemoComponent;
                          break getTag;
                        case REACT_LAZY_TYPE:
                          fiberTag = LazyComponent;
                          resolvedType = null;
                          break getTag;
                      }
                    }
                    var info = "";
                    {
                      if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                        info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                      }
                      var ownerName = owner ? getComponentNameFromFiber(owner) : null;
                      if (ownerName) {
                        info += "\n\nCheck the render method of `" + ownerName + "`.";
                      }
                    }
                    throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (type == null ? type : typeof type) + "." + info));
                  }
                }
            }
            var fiber = createFiber(fiberTag, pendingProps, key2, mode);
            fiber.elementType = type;
            fiber.type = resolvedType;
            fiber.lanes = lanes;
            {
              fiber._debugOwner = owner;
            }
            return fiber;
          }
          function createFiberFromElement(element, mode, lanes) {
            var owner = null;
            {
              owner = element._owner;
            }
            var type = element.type;
            var key2 = element.key;
            var pendingProps = element.props;
            var fiber = createFiberFromTypeAndProps(type, key2, pendingProps, owner, mode, lanes);
            {
              fiber._debugSource = element._source;
              fiber._debugOwner = element._owner;
            }
            return fiber;
          }
          function createFiberFromFragment(elements, mode, lanes, key2) {
            var fiber = createFiber(Fragment2, elements, key2, mode);
            fiber.lanes = lanes;
            return fiber;
          }
          function createFiberFromProfiler(pendingProps, mode, lanes, key2) {
            {
              if (typeof pendingProps.id !== "string") {
                error('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof pendingProps.id);
              }
            }
            var fiber = createFiber(Profiler, pendingProps, key2, mode | ProfileMode);
            fiber.elementType = REACT_PROFILER_TYPE;
            fiber.lanes = lanes;
            {
              fiber.stateNode = {
                effectDuration: 0,
                passiveEffectDuration: 0
              };
            }
            return fiber;
          }
          function createFiberFromSuspense(pendingProps, mode, lanes, key2) {
            var fiber = createFiber(SuspenseComponent, pendingProps, key2, mode);
            fiber.elementType = REACT_SUSPENSE_TYPE;
            fiber.lanes = lanes;
            return fiber;
          }
          function createFiberFromSuspenseList(pendingProps, mode, lanes, key2) {
            var fiber = createFiber(SuspenseListComponent, pendingProps, key2, mode);
            fiber.elementType = REACT_SUSPENSE_LIST_TYPE;
            fiber.lanes = lanes;
            return fiber;
          }
          function createFiberFromOffscreen(pendingProps, mode, lanes, key2) {
            var fiber = createFiber(OffscreenComponent, pendingProps, key2, mode);
            fiber.elementType = REACT_OFFSCREEN_TYPE;
            fiber.lanes = lanes;
            var primaryChildInstance = {
              isHidden: false
            };
            fiber.stateNode = primaryChildInstance;
            return fiber;
          }
          function createFiberFromText(content, mode, lanes) {
            var fiber = createFiber(HostText, content, null, mode);
            fiber.lanes = lanes;
            return fiber;
          }
          function createFiberFromHostInstanceForDeletion() {
            var fiber = createFiber(HostComponent, null, null, NoMode);
            fiber.elementType = "DELETED";
            return fiber;
          }
          function createFiberFromDehydratedFragment(dehydratedNode) {
            var fiber = createFiber(DehydratedFragment, null, null, NoMode);
            fiber.stateNode = dehydratedNode;
            return fiber;
          }
          function createFiberFromPortal(portal, mode, lanes) {
            var pendingProps = portal.children !== null ? portal.children : [];
            var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);
            fiber.lanes = lanes;
            fiber.stateNode = {
              containerInfo: portal.containerInfo,
              pendingChildren: null,
              // Used by persistent updates
              implementation: portal.implementation
            };
            return fiber;
          }
          function assignFiberPropertiesInDEV(target, source) {
            if (target === null) {
              target = createFiber(IndeterminateComponent, null, null, NoMode);
            }
            target.tag = source.tag;
            target.key = source.key;
            target.elementType = source.elementType;
            target.type = source.type;
            target.stateNode = source.stateNode;
            target.return = source.return;
            target.child = source.child;
            target.sibling = source.sibling;
            target.index = source.index;
            target.ref = source.ref;
            target.pendingProps = source.pendingProps;
            target.memoizedProps = source.memoizedProps;
            target.updateQueue = source.updateQueue;
            target.memoizedState = source.memoizedState;
            target.dependencies = source.dependencies;
            target.mode = source.mode;
            target.flags = source.flags;
            target.subtreeFlags = source.subtreeFlags;
            target.deletions = source.deletions;
            target.lanes = source.lanes;
            target.childLanes = source.childLanes;
            target.alternate = source.alternate;
            {
              target.actualDuration = source.actualDuration;
              target.actualStartTime = source.actualStartTime;
              target.selfBaseDuration = source.selfBaseDuration;
              target.treeBaseDuration = source.treeBaseDuration;
            }
            target._debugSource = source._debugSource;
            target._debugOwner = source._debugOwner;
            target._debugNeedsRemount = source._debugNeedsRemount;
            target._debugHookTypes = source._debugHookTypes;
            return target;
          }
          function FiberRootNode(containerInfo, tag, hydrate3, identifierPrefix, onRecoverableError) {
            this.tag = tag;
            this.containerInfo = containerInfo;
            this.pendingChildren = null;
            this.current = null;
            this.pingCache = null;
            this.finishedWork = null;
            this.timeoutHandle = noTimeout;
            this.context = null;
            this.pendingContext = null;
            this.callbackNode = null;
            this.callbackPriority = NoLane;
            this.eventTimes = createLaneMap(NoLanes);
            this.expirationTimes = createLaneMap(NoTimestamp);
            this.pendingLanes = NoLanes;
            this.suspendedLanes = NoLanes;
            this.pingedLanes = NoLanes;
            this.expiredLanes = NoLanes;
            this.mutableReadLanes = NoLanes;
            this.finishedLanes = NoLanes;
            this.entangledLanes = NoLanes;
            this.entanglements = createLaneMap(NoLanes);
            this.identifierPrefix = identifierPrefix;
            this.onRecoverableError = onRecoverableError;
            {
              this.mutableSourceEagerHydrationData = null;
            }
            {
              this.effectDuration = 0;
              this.passiveEffectDuration = 0;
            }
            {
              this.memoizedUpdaters = /* @__PURE__ */ new Set();
              var pendingUpdatersLaneMap = this.pendingUpdatersLaneMap = [];
              for (var _i = 0; _i < TotalLanes; _i++) {
                pendingUpdatersLaneMap.push(/* @__PURE__ */ new Set());
              }
            }
            {
              switch (tag) {
                case ConcurrentRoot:
                  this._debugRootType = hydrate3 ? "hydrateRoot()" : "createRoot()";
                  break;
                case LegacyRoot:
                  this._debugRootType = hydrate3 ? "hydrate()" : "render()";
                  break;
              }
            }
          }
          function createFiberRoot(containerInfo, tag, hydrate3, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
            var root3 = new FiberRootNode(containerInfo, tag, hydrate3, identifierPrefix, onRecoverableError);
            var uninitializedFiber = createHostRootFiber(tag, isStrictMode);
            root3.current = uninitializedFiber;
            uninitializedFiber.stateNode = root3;
            {
              var _initialState = {
                element: initialChildren,
                isDehydrated: hydrate3,
                cache: null,
                // not enabled yet
                transitions: null,
                pendingSuspenseBoundaries: null
              };
              uninitializedFiber.memoizedState = _initialState;
            }
            initializeUpdateQueue(uninitializedFiber);
            return root3;
          }
          var ReactVersion = "18.2.0";
          function createPortal(children, containerInfo, implementation) {
            var key2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
            {
              checkKeyStringCoercion(key2);
            }
            return {
              // This tag allow us to uniquely identify this as a React Portal
              $$typeof: REACT_PORTAL_TYPE,
              key: key2 == null ? null : "" + key2,
              children,
              containerInfo,
              implementation
            };
          }
          var didWarnAboutNestedUpdates;
          var didWarnAboutFindNodeInStrictMode;
          {
            didWarnAboutNestedUpdates = false;
            didWarnAboutFindNodeInStrictMode = {};
          }
          function getContextForSubtree(parentComponent) {
            if (!parentComponent) {
              return emptyContextObject;
            }
            var fiber = get2(parentComponent);
            var parentContext = findCurrentUnmaskedContext(fiber);
            if (fiber.tag === ClassComponent) {
              var Component = fiber.type;
              if (isContextProvider(Component)) {
                return processChildContext(fiber, Component, parentContext);
              }
            }
            return parentContext;
          }
          function findHostInstanceWithWarning(component, methodName) {
            {
              var fiber = get2(component);
              if (fiber === void 0) {
                if (typeof component.render === "function") {
                  throw new Error("Unable to find node on an unmounted component.");
                } else {
                  var keys2 = Object.keys(component).join(",");
                  throw new Error("Argument appears to not be a ReactComponent. Keys: " + keys2);
                }
              }
              var hostFiber = findCurrentHostFiber(fiber);
              if (hostFiber === null) {
                return null;
              }
              if (hostFiber.mode & StrictLegacyMode) {
                var componentName = getComponentNameFromFiber(fiber) || "Component";
                if (!didWarnAboutFindNodeInStrictMode[componentName]) {
                  didWarnAboutFindNodeInStrictMode[componentName] = true;
                  var previousFiber = current;
                  try {
                    setCurrentFiber(hostFiber);
                    if (fiber.mode & StrictLegacyMode) {
                      error("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
                    } else {
                      error("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
                    }
                  } finally {
                    if (previousFiber) {
                      setCurrentFiber(previousFiber);
                    } else {
                      resetCurrentFiber();
                    }
                  }
                }
              }
              return hostFiber.stateNode;
            }
          }
          function createContainer(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
            var hydrate3 = false;
            var initialChildren = null;
            return createFiberRoot(containerInfo, tag, hydrate3, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
          }
          function createHydrationContainer(initialChildren, callback, containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
            var hydrate3 = true;
            var root3 = createFiberRoot(containerInfo, tag, hydrate3, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
            root3.context = getContextForSubtree(null);
            var current2 = root3.current;
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(current2);
            var update2 = createUpdate(eventTime, lane);
            update2.callback = callback !== void 0 && callback !== null ? callback : null;
            enqueueUpdate(current2, update2, lane);
            scheduleInitialHydrationOnRoot(root3, lane, eventTime);
            return root3;
          }
          function updateContainer(element, container, parentComponent, callback) {
            {
              onScheduleRoot(container, element);
            }
            var current$1 = container.current;
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(current$1);
            {
              markRenderScheduled(lane);
            }
            var context = getContextForSubtree(parentComponent);
            if (container.context === null) {
              container.context = context;
            } else {
              container.pendingContext = context;
            }
            {
              if (isRendering && current !== null && !didWarnAboutNestedUpdates) {
                didWarnAboutNestedUpdates = true;
                error("Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.", getComponentNameFromFiber(current) || "Unknown");
              }
            }
            var update2 = createUpdate(eventTime, lane);
            update2.payload = {
              element
            };
            callback = callback === void 0 ? null : callback;
            if (callback !== null) {
              {
                if (typeof callback !== "function") {
                  error("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callback);
                }
              }
              update2.callback = callback;
            }
            var root3 = enqueueUpdate(current$1, update2, lane);
            if (root3 !== null) {
              scheduleUpdateOnFiber(root3, current$1, lane, eventTime);
              entangleTransitions(root3, current$1, lane);
            }
            return lane;
          }
          function getPublicRootInstance(container) {
            var containerFiber = container.current;
            if (!containerFiber.child) {
              return null;
            }
            switch (containerFiber.child.tag) {
              case HostComponent:
                return getPublicInstance(containerFiber.child.stateNode);
              default:
                return containerFiber.child.stateNode;
            }
          }
          function attemptSynchronousHydration$1(fiber) {
            switch (fiber.tag) {
              case HostRoot: {
                var root3 = fiber.stateNode;
                if (isRootDehydrated(root3)) {
                  var lanes = getHighestPriorityPendingLanes(root3);
                  flushRoot(root3, lanes);
                }
                break;
              }
              case SuspenseComponent: {
                flushSync(function() {
                  var root4 = enqueueConcurrentRenderForLane(fiber, SyncLane);
                  if (root4 !== null) {
                    var eventTime = requestEventTime();
                    scheduleUpdateOnFiber(root4, fiber, SyncLane, eventTime);
                  }
                });
                var retryLane = SyncLane;
                markRetryLaneIfNotHydrated(fiber, retryLane);
                break;
              }
            }
          }
          function markRetryLaneImpl(fiber, retryLane) {
            var suspenseState = fiber.memoizedState;
            if (suspenseState !== null && suspenseState.dehydrated !== null) {
              suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane);
            }
          }
          function markRetryLaneIfNotHydrated(fiber, retryLane) {
            markRetryLaneImpl(fiber, retryLane);
            var alternate = fiber.alternate;
            if (alternate) {
              markRetryLaneImpl(alternate, retryLane);
            }
          }
          function attemptContinuousHydration$1(fiber) {
            if (fiber.tag !== SuspenseComponent) {
              return;
            }
            var lane = SelectiveHydrationLane;
            var root3 = enqueueConcurrentRenderForLane(fiber, lane);
            if (root3 !== null) {
              var eventTime = requestEventTime();
              scheduleUpdateOnFiber(root3, fiber, lane, eventTime);
            }
            markRetryLaneIfNotHydrated(fiber, lane);
          }
          function attemptHydrationAtCurrentPriority$1(fiber) {
            if (fiber.tag !== SuspenseComponent) {
              return;
            }
            var lane = requestUpdateLane(fiber);
            var root3 = enqueueConcurrentRenderForLane(fiber, lane);
            if (root3 !== null) {
              var eventTime = requestEventTime();
              scheduleUpdateOnFiber(root3, fiber, lane, eventTime);
            }
            markRetryLaneIfNotHydrated(fiber, lane);
          }
          function findHostInstanceWithNoPortals(fiber) {
            var hostFiber = findCurrentHostFiberWithNoPortals(fiber);
            if (hostFiber === null) {
              return null;
            }
            return hostFiber.stateNode;
          }
          var shouldErrorImpl = function(fiber) {
            return null;
          };
          function shouldError(fiber) {
            return shouldErrorImpl(fiber);
          }
          var shouldSuspendImpl = function(fiber) {
            return false;
          };
          function shouldSuspend(fiber) {
            return shouldSuspendImpl(fiber);
          }
          var overrideHookState = null;
          var overrideHookStateDeletePath = null;
          var overrideHookStateRenamePath = null;
          var overrideProps = null;
          var overridePropsDeletePath = null;
          var overridePropsRenamePath = null;
          var scheduleUpdate = null;
          var setErrorHandler = null;
          var setSuspenseHandler = null;
          {
            var copyWithDeleteImpl = function(obj, path, index3) {
              var key2 = path[index3];
              var updated = isArray2(obj) ? obj.slice() : assign({}, obj);
              if (index3 + 1 === path.length) {
                if (isArray2(updated)) {
                  updated.splice(key2, 1);
                } else {
                  delete updated[key2];
                }
                return updated;
              }
              updated[key2] = copyWithDeleteImpl(obj[key2], path, index3 + 1);
              return updated;
            };
            var copyWithDelete = function(obj, path) {
              return copyWithDeleteImpl(obj, path, 0);
            };
            var copyWithRenameImpl = function(obj, oldPath, newPath, index3) {
              var oldKey = oldPath[index3];
              var updated = isArray2(obj) ? obj.slice() : assign({}, obj);
              if (index3 + 1 === oldPath.length) {
                var newKey = newPath[index3];
                updated[newKey] = updated[oldKey];
                if (isArray2(updated)) {
                  updated.splice(oldKey, 1);
                } else {
                  delete updated[oldKey];
                }
              } else {
                updated[oldKey] = copyWithRenameImpl(
                  // $FlowFixMe number or string is fine here
                  obj[oldKey],
                  oldPath,
                  newPath,
                  index3 + 1
                );
              }
              return updated;
            };
            var copyWithRename = function(obj, oldPath, newPath) {
              if (oldPath.length !== newPath.length) {
                warn("copyWithRename() expects paths of the same length");
                return;
              } else {
                for (var i7 = 0; i7 < newPath.length - 1; i7++) {
                  if (oldPath[i7] !== newPath[i7]) {
                    warn("copyWithRename() expects paths to be the same except for the deepest key");
                    return;
                  }
                }
              }
              return copyWithRenameImpl(obj, oldPath, newPath, 0);
            };
            var copyWithSetImpl = function(obj, path, index3, value) {
              if (index3 >= path.length) {
                return value;
              }
              var key2 = path[index3];
              var updated = isArray2(obj) ? obj.slice() : assign({}, obj);
              updated[key2] = copyWithSetImpl(obj[key2], path, index3 + 1, value);
              return updated;
            };
            var copyWithSet = function(obj, path, value) {
              return copyWithSetImpl(obj, path, 0, value);
            };
            var findHook = function(fiber, id3) {
              var currentHook2 = fiber.memoizedState;
              while (currentHook2 !== null && id3 > 0) {
                currentHook2 = currentHook2.next;
                id3--;
              }
              return currentHook2;
            };
            overrideHookState = function(fiber, id3, path, value) {
              var hook = findHook(fiber, id3);
              if (hook !== null) {
                var newState = copyWithSet(hook.memoizedState, path, value);
                hook.memoizedState = newState;
                hook.baseState = newState;
                fiber.memoizedProps = assign({}, fiber.memoizedProps);
                var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
                if (root3 !== null) {
                  scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
                }
              }
            };
            overrideHookStateDeletePath = function(fiber, id3, path) {
              var hook = findHook(fiber, id3);
              if (hook !== null) {
                var newState = copyWithDelete(hook.memoizedState, path);
                hook.memoizedState = newState;
                hook.baseState = newState;
                fiber.memoizedProps = assign({}, fiber.memoizedProps);
                var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
                if (root3 !== null) {
                  scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
                }
              }
            };
            overrideHookStateRenamePath = function(fiber, id3, oldPath, newPath) {
              var hook = findHook(fiber, id3);
              if (hook !== null) {
                var newState = copyWithRename(hook.memoizedState, oldPath, newPath);
                hook.memoizedState = newState;
                hook.baseState = newState;
                fiber.memoizedProps = assign({}, fiber.memoizedProps);
                var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
                if (root3 !== null) {
                  scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
                }
              }
            };
            overrideProps = function(fiber, path, value) {
              fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);
              if (fiber.alternate) {
                fiber.alternate.pendingProps = fiber.pendingProps;
              }
              var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root3 !== null) {
                scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
              }
            };
            overridePropsDeletePath = function(fiber, path) {
              fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path);
              if (fiber.alternate) {
                fiber.alternate.pendingProps = fiber.pendingProps;
              }
              var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root3 !== null) {
                scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
              }
            };
            overridePropsRenamePath = function(fiber, oldPath, newPath) {
              fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);
              if (fiber.alternate) {
                fiber.alternate.pendingProps = fiber.pendingProps;
              }
              var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root3 !== null) {
                scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
              }
            };
            scheduleUpdate = function(fiber) {
              var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root3 !== null) {
                scheduleUpdateOnFiber(root3, fiber, SyncLane, NoTimestamp);
              }
            };
            setErrorHandler = function(newShouldErrorImpl) {
              shouldErrorImpl = newShouldErrorImpl;
            };
            setSuspenseHandler = function(newShouldSuspendImpl) {
              shouldSuspendImpl = newShouldSuspendImpl;
            };
          }
          function findHostInstanceByFiber(fiber) {
            var hostFiber = findCurrentHostFiber(fiber);
            if (hostFiber === null) {
              return null;
            }
            return hostFiber.stateNode;
          }
          function emptyFindFiberByHostInstance(instance) {
            return null;
          }
          function getCurrentFiberForDevTools() {
            return current;
          }
          function injectIntoDevTools(devToolsConfig) {
            var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
            var ReactCurrentDispatcher2 = ReactSharedInternals.ReactCurrentDispatcher;
            return injectInternals({
              bundleType: devToolsConfig.bundleType,
              version: devToolsConfig.version,
              rendererPackageName: devToolsConfig.rendererPackageName,
              rendererConfig: devToolsConfig.rendererConfig,
              overrideHookState,
              overrideHookStateDeletePath,
              overrideHookStateRenamePath,
              overrideProps,
              overridePropsDeletePath,
              overridePropsRenamePath,
              setErrorHandler,
              setSuspenseHandler,
              scheduleUpdate,
              currentDispatcherRef: ReactCurrentDispatcher2,
              findHostInstanceByFiber,
              findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,
              // React Refresh
              findHostInstancesForRefresh,
              scheduleRefresh,
              scheduleRoot,
              setRefreshHandler,
              // Enables DevTools to append owner stacks to error messages in DEV mode.
              getCurrentFiber: getCurrentFiberForDevTools,
              // Enables DevTools to detect reconciler version rather than renderer version
              // which may not match for third party renderers.
              reconcilerVersion: ReactVersion
            });
          }
          var defaultOnRecoverableError = typeof reportError === "function" ? (
            // In modern browsers, reportError will dispatch an error event,
            // emulating an uncaught JavaScript error.
            reportError
          ) : function(error2) {
            console["error"](error2);
          };
          function ReactDOMRoot(internalRoot) {
            this._internalRoot = internalRoot;
          }
          ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
            var root3 = this._internalRoot;
            if (root3 === null) {
              throw new Error("Cannot update an unmounted root.");
            }
            {
              if (typeof arguments[1] === "function") {
                error("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
              } else if (isValidContainer(arguments[1])) {
                error("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.");
              } else if (typeof arguments[1] !== "undefined") {
                error("You passed a second argument to root.render(...) but it only accepts one argument.");
              }
              var container = root3.containerInfo;
              if (container.nodeType !== COMMENT_NODE) {
                var hostInstance = findHostInstanceWithNoPortals(root3.current);
                if (hostInstance) {
                  if (hostInstance.parentNode !== container) {
                    error("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
                  }
                }
              }
            }
            updateContainer(children, root3, null, null);
          };
          ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
            {
              if (typeof arguments[0] === "function") {
                error("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
              }
            }
            var root3 = this._internalRoot;
            if (root3 !== null) {
              this._internalRoot = null;
              var container = root3.containerInfo;
              {
                if (isAlreadyRendering()) {
                  error("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition.");
                }
              }
              flushSync(function() {
                updateContainer(null, root3, null, null);
              });
              unmarkContainerAsRoot(container);
            }
          };
          function createRoot(container, options3) {
            if (!isValidContainer(container)) {
              throw new Error("createRoot(...): Target container is not a DOM element.");
            }
            warnIfReactDOMContainerInDEV(container);
            var isStrictMode = false;
            var concurrentUpdatesByDefaultOverride = false;
            var identifierPrefix = "";
            var onRecoverableError = defaultOnRecoverableError;
            var transitionCallbacks = null;
            if (options3 !== null && options3 !== void 0) {
              {
                if (options3.hydrate) {
                  warn("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.");
                } else {
                  if (typeof options3 === "object" && options3 !== null && options3.$$typeof === REACT_ELEMENT_TYPE) {
                    error("You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:\n\n  let root = createRoot(domContainer);\n  root.render(<App />);");
                  }
                }
              }
              if (options3.unstable_strictMode === true) {
                isStrictMode = true;
              }
              if (options3.identifierPrefix !== void 0) {
                identifierPrefix = options3.identifierPrefix;
              }
              if (options3.onRecoverableError !== void 0) {
                onRecoverableError = options3.onRecoverableError;
              }
              if (options3.transitionCallbacks !== void 0) {
                transitionCallbacks = options3.transitionCallbacks;
              }
            }
            var root3 = createContainer(container, ConcurrentRoot, null, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
            markContainerAsRoot(root3.current, container);
            var rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
            listenToAllSupportedEvents(rootContainerElement);
            return new ReactDOMRoot(root3);
          }
          function ReactDOMHydrationRoot(internalRoot) {
            this._internalRoot = internalRoot;
          }
          function scheduleHydration(target) {
            if (target) {
              queueExplicitHydrationTarget(target);
            }
          }
          ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = scheduleHydration;
          function hydrateRoot(container, initialChildren, options3) {
            if (!isValidContainer(container)) {
              throw new Error("hydrateRoot(...): Target container is not a DOM element.");
            }
            warnIfReactDOMContainerInDEV(container);
            {
              if (initialChildren === void 0) {
                error("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
              }
            }
            var hydrationCallbacks = options3 != null ? options3 : null;
            var mutableSources = options3 != null && options3.hydratedSources || null;
            var isStrictMode = false;
            var concurrentUpdatesByDefaultOverride = false;
            var identifierPrefix = "";
            var onRecoverableError = defaultOnRecoverableError;
            if (options3 !== null && options3 !== void 0) {
              if (options3.unstable_strictMode === true) {
                isStrictMode = true;
              }
              if (options3.identifierPrefix !== void 0) {
                identifierPrefix = options3.identifierPrefix;
              }
              if (options3.onRecoverableError !== void 0) {
                onRecoverableError = options3.onRecoverableError;
              }
            }
            var root3 = createHydrationContainer(initialChildren, null, container, ConcurrentRoot, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
            markContainerAsRoot(root3.current, container);
            listenToAllSupportedEvents(container);
            if (mutableSources) {
              for (var i7 = 0; i7 < mutableSources.length; i7++) {
                var mutableSource = mutableSources[i7];
                registerMutableSourceForHydration(root3, mutableSource);
              }
            }
            return new ReactDOMHydrationRoot(root3);
          }
          function isValidContainer(node) {
            return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || !disableCommentsAsDOMContainers));
          }
          function isValidContainerLegacy(node) {
            return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE && node.nodeValue === " react-mount-point-unstable "));
          }
          function warnIfReactDOMContainerInDEV(container) {
            {
              if (container.nodeType === ELEMENT_NODE && container.tagName && container.tagName.toUpperCase() === "BODY") {
                error("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app.");
              }
              if (isContainerMarkedAsRoot(container)) {
                if (container._reactRootContainer) {
                  error("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.");
                } else {
                  error("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it.");
                }
              }
            }
          }
          var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;
          var topLevelUpdateWarnings;
          {
            topLevelUpdateWarnings = function(container) {
              if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {
                var hostInstance = findHostInstanceWithNoPortals(container._reactRootContainer.current);
                if (hostInstance) {
                  if (hostInstance.parentNode !== container) {
                    error("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
                  }
                }
              }
              var isRootRenderedBySomeReact = !!container._reactRootContainer;
              var rootEl = getReactRootElementInContainer(container);
              var hasNonRootReactChild = !!(rootEl && getInstanceFromNode(rootEl));
              if (hasNonRootReactChild && !isRootRenderedBySomeReact) {
                error("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render.");
              }
              if (container.nodeType === ELEMENT_NODE && container.tagName && container.tagName.toUpperCase() === "BODY") {
                error("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
              }
            };
          }
          function getReactRootElementInContainer(container) {
            if (!container) {
              return null;
            }
            if (container.nodeType === DOCUMENT_NODE) {
              return container.documentElement;
            } else {
              return container.firstChild;
            }
          }
          function noopOnRecoverableError() {
          }
          function legacyCreateRootFromDOMContainer(container, initialChildren, parentComponent, callback, isHydrationContainer) {
            if (isHydrationContainer) {
              if (typeof callback === "function") {
                var originalCallback = callback;
                callback = function() {
                  var instance = getPublicRootInstance(root3);
                  originalCallback.call(instance);
                };
              }
              var root3 = createHydrationContainer(
                initialChildren,
                callback,
                container,
                LegacyRoot,
                null,
                // hydrationCallbacks
                false,
                // isStrictMode
                false,
                // concurrentUpdatesByDefaultOverride,
                "",
                // identifierPrefix
                noopOnRecoverableError
              );
              container._reactRootContainer = root3;
              markContainerAsRoot(root3.current, container);
              var rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
              listenToAllSupportedEvents(rootContainerElement);
              flushSync();
              return root3;
            } else {
              var rootSibling;
              while (rootSibling = container.lastChild) {
                container.removeChild(rootSibling);
              }
              if (typeof callback === "function") {
                var _originalCallback = callback;
                callback = function() {
                  var instance = getPublicRootInstance(_root);
                  _originalCallback.call(instance);
                };
              }
              var _root = createContainer(
                container,
                LegacyRoot,
                null,
                // hydrationCallbacks
                false,
                // isStrictMode
                false,
                // concurrentUpdatesByDefaultOverride,
                "",
                // identifierPrefix
                noopOnRecoverableError
              );
              container._reactRootContainer = _root;
              markContainerAsRoot(_root.current, container);
              var _rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
              listenToAllSupportedEvents(_rootContainerElement);
              flushSync(function() {
                updateContainer(initialChildren, _root, parentComponent, callback);
              });
              return _root;
            }
          }
          function warnOnInvalidCallback$1(callback, callerName) {
            {
              if (callback !== null && typeof callback !== "function") {
                error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
              }
            }
          }
          function legacyRenderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {
            {
              topLevelUpdateWarnings(container);
              warnOnInvalidCallback$1(callback === void 0 ? null : callback, "render");
            }
            var maybeRoot = container._reactRootContainer;
            var root3;
            if (!maybeRoot) {
              root3 = legacyCreateRootFromDOMContainer(container, children, parentComponent, callback, forceHydrate);
            } else {
              root3 = maybeRoot;
              if (typeof callback === "function") {
                var originalCallback = callback;
                callback = function() {
                  var instance = getPublicRootInstance(root3);
                  originalCallback.call(instance);
                };
              }
              updateContainer(children, root3, parentComponent, callback);
            }
            return getPublicRootInstance(root3);
          }
          function findDOMNode(componentOrElement) {
            {
              var owner = ReactCurrentOwner$3.current;
              if (owner !== null && owner.stateNode !== null) {
                var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;
                if (!warnedAboutRefsInRender) {
                  error("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentNameFromType(owner.type) || "A component");
                }
                owner.stateNode._warnedAboutRefsInRender = true;
              }
            }
            if (componentOrElement == null) {
              return null;
            }
            if (componentOrElement.nodeType === ELEMENT_NODE) {
              return componentOrElement;
            }
            {
              return findHostInstanceWithWarning(componentOrElement, "findDOMNode");
            }
          }
          function hydrate2(element, container, callback) {
            {
              error("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
            }
            if (!isValidContainerLegacy(container)) {
              throw new Error("Target container is not a DOM element.");
            }
            {
              var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;
              if (isModernRoot) {
                error("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?");
              }
            }
            return legacyRenderSubtreeIntoContainer(null, element, container, true, callback);
          }
          function render(element, container, callback) {
            {
              error("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
            }
            if (!isValidContainerLegacy(container)) {
              throw new Error("Target container is not a DOM element.");
            }
            {
              var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;
              if (isModernRoot) {
                error("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?");
              }
            }
            return legacyRenderSubtreeIntoContainer(null, element, container, false, callback);
          }
          function unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
            {
              error("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
            }
            if (!isValidContainerLegacy(containerNode)) {
              throw new Error("Target container is not a DOM element.");
            }
            if (parentComponent == null || !has(parentComponent)) {
              throw new Error("parentComponent must be a valid React Component");
            }
            return legacyRenderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);
          }
          function unmountComponentAtNode(container) {
            if (!isValidContainerLegacy(container)) {
              throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
            }
            {
              var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;
              if (isModernRoot) {
                error("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?");
              }
            }
            if (container._reactRootContainer) {
              {
                var rootEl = getReactRootElementInContainer(container);
                var renderedByDifferentReact = rootEl && !getInstanceFromNode(rootEl);
                if (renderedByDifferentReact) {
                  error("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
                }
              }
              flushSync(function() {
                legacyRenderSubtreeIntoContainer(null, null, container, false, function() {
                  container._reactRootContainer = null;
                  unmarkContainerAsRoot(container);
                });
              });
              return true;
            } else {
              {
                var _rootEl = getReactRootElementInContainer(container);
                var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode(_rootEl));
                var isContainerReactRoot = container.nodeType === ELEMENT_NODE && isValidContainerLegacy(container.parentNode) && !!container.parentNode._reactRootContainer;
                if (hasNonRootReactChild) {
                  error("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", isContainerReactRoot ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
                }
              }
              return false;
            }
          }
          setAttemptSynchronousHydration(attemptSynchronousHydration$1);
          setAttemptContinuousHydration(attemptContinuousHydration$1);
          setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority$1);
          setGetCurrentUpdatePriority(getCurrentUpdatePriority);
          setAttemptHydrationAtPriority(runWithPriority);
          {
            if (typeof Map !== "function" || // $FlowIssue Flow incorrectly thinks Map has no prototype
            Map.prototype == null || typeof Map.prototype.forEach !== "function" || typeof Set !== "function" || // $FlowIssue Flow incorrectly thinks Set has no prototype
            Set.prototype == null || typeof Set.prototype.clear !== "function" || typeof Set.prototype.forEach !== "function") {
              error("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
            }
          }
          setRestoreImplementation(restoreControlledState$3);
          setBatchingImplementation(batchedUpdates$1, discreteUpdates, flushSync);
          function createPortal$1(children, container) {
            var key2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
            if (!isValidContainer(container)) {
              throw new Error("Target container is not a DOM element.");
            }
            return createPortal(children, container, null, key2);
          }
          function renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
            return unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback);
          }
          var Internals = {
            usingClientEntryPoint: false,
            // Keep in sync with ReactTestUtils.js.
            // This is an array for better minification.
            Events: [getInstanceFromNode, getNodeFromInstance, getFiberCurrentPropsFromNode, enqueueStateRestore, restoreStateIfNeeded, batchedUpdates$1]
          };
          function createRoot$1(container, options3) {
            {
              if (!Internals.usingClientEntryPoint && true) {
                error('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".');
              }
            }
            return createRoot(container, options3);
          }
          function hydrateRoot$1(container, initialChildren, options3) {
            {
              if (!Internals.usingClientEntryPoint && true) {
                error('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".');
              }
            }
            return hydrateRoot(container, initialChildren, options3);
          }
          function flushSync$1(fn2) {
            {
              if (isAlreadyRendering()) {
                error("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task.");
              }
            }
            return flushSync(fn2);
          }
          var foundDevTools = injectIntoDevTools({
            findFiberByHostInstance: getClosestInstanceFromNode,
            bundleType: 1,
            version: ReactVersion,
            rendererPackageName: "react-dom"
          });
          {
            if (!foundDevTools && canUseDOM && window.top === window.self) {
              if (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1) {
                var protocol2 = window.location.protocol;
                if (/^(https?|file):$/.test(protocol2)) {
                  console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (protocol2 === "file:" ? "\nYou might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq" : ""), "font-weight:bold");
                }
              }
            }
          }
          exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Internals;
          exports.createPortal = createPortal$1;
          exports.createRoot = createRoot$1;
          exports.findDOMNode = findDOMNode;
          exports.flushSync = flushSync$1;
          exports.hydrate = hydrate2;
          exports.hydrateRoot = hydrateRoot$1;
          exports.render = render;
          exports.unmountComponentAtNode = unmountComponentAtNode;
          exports.unstable_batchedUpdates = batchedUpdates$1;
          exports.unstable_renderSubtreeIntoContainer = renderSubtreeIntoContainer;
          exports.version = ReactVersion;
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
          }
        })();
      }
    }
  });

  // node_modules/react-dom/index.js
  var require_react_dom = __commonJS({
    "node_modules/react-dom/index.js"(exports, module) {
      "use strict";
      if (false) {
        checkDCE();
        module.exports = null;
      } else {
        module.exports = require_react_dom_development();
      }
    }
  });

  // node_modules/react-dom/client.js
  var require_client = __commonJS({
    "node_modules/react-dom/client.js"(exports) {
      "use strict";
      var m6 = require_react_dom();
      if (false) {
        exports.createRoot = m6.createRoot;
        exports.hydrateRoot = m6.hydrateRoot;
      } else {
        i7 = m6.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        exports.createRoot = function(c9, o9) {
          i7.usingClientEntryPoint = true;
          try {
            return m6.createRoot(c9, o9);
          } finally {
            i7.usingClientEntryPoint = false;
          }
        };
        exports.hydrateRoot = function(c9, h10, o9) {
          i7.usingClientEntryPoint = true;
          try {
            return m6.hydrateRoot(c9, h10, o9);
          } finally {
            i7.usingClientEntryPoint = false;
          }
        };
      }
      var i7;
    }
  });

  // node_modules/viem/dist/esm/errors/version.js
  var version;
  var init_version = __esm({
    "node_modules/viem/dist/esm/errors/version.js"() {
      version = "0.3.50";
    }
  });

  // node_modules/viem/dist/esm/errors/utils.js
  var getContractAddress, getUrl, getVersion;
  var init_utils = __esm({
    "node_modules/viem/dist/esm/errors/utils.js"() {
      init_version();
      getContractAddress = (address) => address;
      getUrl = (url) => url;
      getVersion = () => `viem@${version}`;
    }
  });

  // node_modules/viem/dist/esm/errors/base.js
  var __classPrivateFieldGet, _BaseError_instances, _BaseError_walk, BaseError;
  var init_base = __esm({
    "node_modules/viem/dist/esm/errors/base.js"() {
      init_utils();
      __classPrivateFieldGet = function(receiver, state, kind, f7) {
        if (kind === "a" && !f7)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f7 : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f7 : kind === "a" ? f7.call(receiver) : f7 ? f7.value : state.get(receiver);
      };
      BaseError = class extends Error {
        constructor(shortMessage, args = {}) {
          super();
          _BaseError_instances.add(this);
          Object.defineProperty(this, "details", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "docsPath", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "metaMessages", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "shortMessage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ViemError"
          });
          Object.defineProperty(this, "version", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: getVersion()
          });
          const details = args.cause instanceof BaseError ? args.cause.details : args.cause?.message ? args.cause.message : args.details;
          const docsPath4 = args.cause instanceof BaseError ? args.cause.docsPath || args.docsPath : args.docsPath;
          this.message = [
            shortMessage || "An error occurred.",
            "",
            ...args.metaMessages ? [...args.metaMessages, ""] : [],
            ...docsPath4 ? [
              `Docs: https://viem.sh${docsPath4}.html${args.docsSlug ? `#${args.docsSlug}` : ""}`
            ] : [],
            ...details ? [`Details: ${details}`] : [],
            `Version: ${this.version}`
          ].join("\n");
          if (args.cause)
            this.cause = args.cause;
          this.details = details;
          this.docsPath = docsPath4;
          this.metaMessages = args.metaMessages;
          this.shortMessage = shortMessage;
        }
        walk(fn2) {
          return __classPrivateFieldGet(this, _BaseError_instances, "m", _BaseError_walk).call(this, this, fn2);
        }
      };
      _BaseError_instances = /* @__PURE__ */ new WeakSet(), _BaseError_walk = function _BaseError_walk2(err, fn2) {
        if (fn2?.(err))
          return err;
        if (err.cause)
          return __classPrivateFieldGet(this, _BaseError_instances, "m", _BaseError_walk2).call(this, err.cause, fn2);
        return err;
      };
    }
  });

  // node_modules/viem/dist/esm/errors/chain.js
  var ChainDoesNotSupportContract, ChainMismatchError, ChainNotFoundError, ClientChainNotConfiguredError;
  var init_chain = __esm({
    "node_modules/viem/dist/esm/errors/chain.js"() {
      init_base();
      ChainDoesNotSupportContract = class extends BaseError {
        constructor({ blockNumber, chain, contract }) {
          super(`Chain "${chain.name}" does not support contract "${contract.name}".`, {
            metaMessages: [
              "This could be due to any of the following:",
              ...blockNumber && contract.blockCreated && contract.blockCreated > blockNumber ? [
                `- The contract "${contract.name}" was not deployed until block ${contract.blockCreated} (current block ${blockNumber}).`
              ] : [
                `- The chain does not have the contract "${contract.name}" configured.`
              ]
            ]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ChainDoesNotSupportContract"
          });
        }
      };
      ChainMismatchError = class extends BaseError {
        constructor({ chain, currentChainId }) {
          super(`The current chain of the wallet (id: ${currentChainId}) does not match the target chain for the transaction (id: ${chain.id} \u2013 ${chain.name}).`, {
            metaMessages: [
              `Current Chain ID:  ${currentChainId}`,
              `Expected Chain ID: ${chain.id} \u2013 ${chain.name}`
            ]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ChainMismatchError"
          });
        }
      };
      ChainNotFoundError = class extends BaseError {
        constructor() {
          super([
            "No chain was provided to the request.",
            "Please provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient."
          ].join("\n"));
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ChainNotFoundError"
          });
        }
      };
      ClientChainNotConfiguredError = class extends BaseError {
        constructor() {
          super("No chain was provided to the Client.");
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ClientChainNotConfiguredError"
          });
        }
      };
    }
  });

  // node_modules/viem/dist/esm/utils/chain.js
  function assertCurrentChain({ chain, currentChainId }) {
    if (!chain)
      throw new ChainNotFoundError();
    if (currentChainId !== chain.id)
      throw new ChainMismatchError({ chain, currentChainId });
  }
  function defineChain(chain) {
    return chain;
  }
  function getChainContractAddress({ blockNumber, chain, contract: name2 }) {
    const contract = chain?.contracts?.[name2];
    if (!contract)
      throw new ChainDoesNotSupportContract({
        chain,
        contract: { name: name2 }
      });
    if (blockNumber && contract.blockCreated && contract.blockCreated > blockNumber)
      throw new ChainDoesNotSupportContract({
        blockNumber,
        chain,
        contract: {
          name: name2,
          blockCreated: contract.blockCreated
        }
      });
    return contract.address;
  }
  var init_chain2 = __esm({
    "node_modules/viem/dist/esm/utils/chain.js"() {
      init_chain();
    }
  });

  // node_modules/viem/dist/esm/utils/formatters/format.js
  function format(data2, { formatter }) {
    return formatter(data2);
  }
  function defineFormatter({ format: format2 }) {
    return ({ exclude, format: formatOverride }) => (data2) => {
      const formatted = format2(data2);
      if (exclude) {
        for (const key2 of exclude) {
          delete formatted[key2];
        }
      }
      return {
        ...formatted,
        ...formatOverride?.(data2)
      };
    };
  }
  var init_format = __esm({
    "node_modules/viem/dist/esm/utils/formatters/format.js"() {
    }
  });

  // node_modules/viem/dist/esm/errors/encoding.js
  var IntegerOutOfRangeError, InvalidHexBooleanError, SizeOverflowError;
  var init_encoding = __esm({
    "node_modules/viem/dist/esm/errors/encoding.js"() {
      init_base();
      IntegerOutOfRangeError = class extends BaseError {
        constructor({ max, min, signed: signed3, size: size3, value }) {
          super(`Number "${value}" is not in safe ${size3 ? `${size3 * 8}-bit ${signed3 ? "signed" : "unsigned"} ` : ""}integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "IntegerOutOfRangeError"
          });
        }
      };
      InvalidHexBooleanError = class extends BaseError {
        constructor(hex) {
          super(`Hex value "${hex}" is not a valid boolean. The hex value must be "0x0" (false) or "0x1" (true).`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidHexBooleanError"
          });
        }
      };
      SizeOverflowError = class extends BaseError {
        constructor({ givenSize, maxSize }) {
          super(`Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "SizeOverflowError"
          });
        }
      };
    }
  });

  // node_modules/viem/dist/esm/utils/data/isHex.js
  function isHex(value, { strict = true } = {}) {
    if (!value)
      return false;
    if (typeof value !== "string")
      return false;
    return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith("0x");
  }
  var init_isHex = __esm({
    "node_modules/viem/dist/esm/utils/data/isHex.js"() {
    }
  });

  // node_modules/viem/dist/esm/utils/data/size.js
  function size(value) {
    if (isHex(value, { strict: false }))
      return Math.ceil((value.length - 2) / 2);
    return value.length;
  }
  var init_size = __esm({
    "node_modules/viem/dist/esm/utils/data/size.js"() {
      init_isHex();
    }
  });

  // node_modules/viem/dist/esm/utils/data/trim.js
  function trim(hexOrBytes, { dir = "left" } = {}) {
    let data2 = typeof hexOrBytes === "string" ? hexOrBytes.replace("0x", "") : hexOrBytes;
    let sliceLength = 0;
    for (let i7 = 0; i7 < data2.length - 1; i7++) {
      if (data2[dir === "left" ? i7 : data2.length - i7 - 1].toString() === "0")
        sliceLength++;
      else
        break;
    }
    data2 = dir === "left" ? data2.slice(sliceLength) : data2.slice(0, data2.length - sliceLength);
    if (typeof hexOrBytes === "string") {
      if (data2.length === 1 && dir === "right")
        data2 = `${data2}0`;
      return `0x${data2.length % 2 === 1 ? `0${data2}` : data2}`;
    }
    return data2;
  }
  var init_trim = __esm({
    "node_modules/viem/dist/esm/utils/data/trim.js"() {
    }
  });

  // node_modules/viem/dist/esm/errors/data.js
  var SliceOffsetOutOfBoundsError, SizeExceedsPaddingSizeError;
  var init_data = __esm({
    "node_modules/viem/dist/esm/errors/data.js"() {
      init_base();
      SliceOffsetOutOfBoundsError = class extends BaseError {
        constructor({ offset, position, size: size3 }) {
          super(`Slice ${position === "start" ? "starting" : "ending"} at offset "${offset}" is out-of-bounds (size: ${size3}).`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "SliceOffsetOutOfBoundsError"
          });
        }
      };
      SizeExceedsPaddingSizeError = class extends BaseError {
        constructor({ size: size3, targetSize, type }) {
          super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (${size3}) exceeds padding size (${targetSize}).`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "SizeExceedsPaddingSizeError"
          });
        }
      };
    }
  });

  // node_modules/viem/dist/esm/utils/data/pad.js
  function pad(hexOrBytes, { dir, size: size3 = 32 } = {}) {
    if (typeof hexOrBytes === "string")
      return padHex(hexOrBytes, { dir, size: size3 });
    return padBytes(hexOrBytes, { dir, size: size3 });
  }
  function padHex(hex_, { dir, size: size3 = 32 } = {}) {
    if (size3 === null)
      return hex_;
    const hex = hex_.replace("0x", "");
    if (hex.length > size3 * 2)
      throw new SizeExceedsPaddingSizeError({
        size: Math.ceil(hex.length / 2),
        targetSize: size3,
        type: "hex"
      });
    return `0x${hex[dir === "right" ? "padEnd" : "padStart"](size3 * 2, "0")}`;
  }
  function padBytes(bytes3, { dir, size: size3 = 32 } = {}) {
    if (size3 === null)
      return bytes3;
    if (bytes3.length > size3)
      throw new SizeExceedsPaddingSizeError({
        size: bytes3.length,
        targetSize: size3,
        type: "bytes"
      });
    const paddedBytes = new Uint8Array(size3);
    for (let i7 = 0; i7 < size3; i7++) {
      const padEnd = dir === "right";
      paddedBytes[padEnd ? i7 : size3 - i7 - 1] = bytes3[padEnd ? i7 : bytes3.length - i7 - 1];
    }
    return paddedBytes;
  }
  var init_pad = __esm({
    "node_modules/viem/dist/esm/utils/data/pad.js"() {
      init_data();
    }
  });

  // node_modules/viem/dist/esm/utils/encoding/toHex.js
  function toHex(value, opts = {}) {
    if (typeof value === "number" || typeof value === "bigint")
      return numberToHex(value, opts);
    if (typeof value === "string") {
      return stringToHex(value, opts);
    }
    if (typeof value === "boolean")
      return boolToHex(value, opts);
    return bytesToHex(value, opts);
  }
  function boolToHex(value, opts = {}) {
    const hex = `0x${Number(value)}`;
    if (typeof opts.size === "number") {
      assertSize(hex, { size: opts.size });
      return pad(hex, { size: opts.size });
    }
    return hex;
  }
  function bytesToHex(value, opts = {}) {
    let hexString = "";
    for (let i7 = 0; i7 < value.length; i7++) {
      hexString += hexes[value[i7]];
    }
    const hex = `0x${hexString}`;
    if (typeof opts.size === "number") {
      assertSize(hex, { size: opts.size });
      return pad(hex, { dir: "right", size: opts.size });
    }
    return hex;
  }
  function numberToHex(value_, opts = {}) {
    const { signed: signed3, size: size3 } = opts;
    const value = BigInt(value_);
    let maxValue;
    if (size3) {
      if (signed3)
        maxValue = (1n << BigInt(size3) * 8n - 1n) - 1n;
      else
        maxValue = 2n ** (BigInt(size3) * 8n) - 1n;
    } else if (typeof value_ === "number") {
      maxValue = BigInt(Number.MAX_SAFE_INTEGER);
    }
    const minValue = typeof maxValue === "bigint" && signed3 ? -maxValue - 1n : 0;
    if (maxValue && value > maxValue || value < minValue) {
      const suffix = typeof value_ === "bigint" ? "n" : "";
      throw new IntegerOutOfRangeError({
        max: maxValue ? `${maxValue}${suffix}` : void 0,
        min: `${minValue}${suffix}`,
        signed: signed3,
        size: size3,
        value: `${value_}${suffix}`
      });
    }
    const hex = `0x${(signed3 && value < 0 ? (1n << BigInt(size3 * 8)) + BigInt(value) : value).toString(16)}`;
    if (size3)
      return pad(hex, { size: size3 });
    return hex;
  }
  function stringToHex(value_, opts = {}) {
    const value = encoder.encode(value_);
    return bytesToHex(value, opts);
  }
  var hexes, encoder;
  var init_toHex = __esm({
    "node_modules/viem/dist/esm/utils/encoding/toHex.js"() {
      init_encoding();
      init_pad();
      init_fromHex();
      hexes = Array.from({ length: 256 }, (_v, i7) => i7.toString(16).padStart(2, "0"));
      encoder = new TextEncoder();
    }
  });

  // node_modules/viem/dist/esm/utils/encoding/toBytes.js
  function toBytes(value, opts = {}) {
    if (typeof value === "number" || typeof value === "bigint")
      return numberToBytes(value, opts);
    if (typeof value === "boolean")
      return boolToBytes(value, opts);
    if (isHex(value))
      return hexToBytes(value, opts);
    return stringToBytes(value, opts);
  }
  function boolToBytes(value, opts = {}) {
    const bytes3 = new Uint8Array(1);
    bytes3[0] = Number(value);
    if (typeof opts.size === "number") {
      assertSize(bytes3, { size: opts.size });
      return pad(bytes3, { size: opts.size });
    }
    return bytes3;
  }
  function hexToBytes(hex_, opts = {}) {
    let hex = hex_;
    if (opts.size) {
      assertSize(hex, { size: opts.size });
      hex = pad(hex, { dir: "right", size: opts.size });
    }
    let hexString = hex.slice(2);
    if (hexString.length % 2)
      hexString = `0${hexString}`;
    const bytes3 = new Uint8Array(hexString.length / 2);
    for (let index2 = 0; index2 < bytes3.length; index2++) {
      const start = index2 * 2;
      const hexByte = hexString.slice(start, start + 2);
      const byte = Number.parseInt(hexByte, 16);
      if (Number.isNaN(byte) || byte < 0)
        throw new BaseError(`Invalid byte sequence ("${hexByte}" in "${hexString}").`);
      bytes3[index2] = byte;
    }
    return bytes3;
  }
  function numberToBytes(value, opts) {
    const hex = numberToHex(value, opts);
    return hexToBytes(hex);
  }
  function stringToBytes(value, opts = {}) {
    const bytes3 = encoder2.encode(value);
    if (typeof opts.size === "number") {
      assertSize(bytes3, { size: opts.size });
      return pad(bytes3, { dir: "right", size: opts.size });
    }
    return bytes3;
  }
  var encoder2;
  var init_toBytes = __esm({
    "node_modules/viem/dist/esm/utils/encoding/toBytes.js"() {
      init_base();
      init_isHex();
      init_pad();
      init_fromHex();
      init_toHex();
      encoder2 = new TextEncoder();
    }
  });

  // node_modules/viem/dist/esm/utils/encoding/fromHex.js
  function assertSize(hexOrBytes, { size: size3 }) {
    if (size(hexOrBytes) > size3)
      throw new SizeOverflowError({
        givenSize: size(hexOrBytes),
        maxSize: size3
      });
  }
  function hexToBigInt(hex, opts = {}) {
    const { signed: signed3 } = opts;
    if (opts.size)
      assertSize(hex, { size: opts.size });
    const value = BigInt(hex);
    if (!signed3)
      return value;
    const size3 = (hex.length - 2) / 2;
    const max = (1n << BigInt(size3) * 8n - 1n) - 1n;
    if (value <= max)
      return value;
    return value - BigInt(`0x${"f".padStart(size3 * 2, "f")}`) - 1n;
  }
  function hexToBool(hex_, opts = {}) {
    let hex = hex_;
    if (opts.size) {
      assertSize(hex, { size: opts.size });
      hex = trim(hex);
    }
    if (trim(hex) === "0x00")
      return false;
    if (trim(hex) === "0x01")
      return true;
    throw new InvalidHexBooleanError(hex);
  }
  function hexToNumber(hex, opts = {}) {
    return Number(hexToBigInt(hex, opts));
  }
  function hexToString(hex, opts = {}) {
    let bytes3 = hexToBytes(hex);
    if (opts.size) {
      assertSize(bytes3, { size: opts.size });
      bytes3 = trim(bytes3, { dir: "right" });
    }
    return new TextDecoder().decode(bytes3);
  }
  var init_fromHex = __esm({
    "node_modules/viem/dist/esm/utils/encoding/fromHex.js"() {
      init_encoding();
      init_size();
      init_trim();
      init_toBytes();
    }
  });

  // node_modules/viem/dist/esm/utils/formatters/transactionRequest.js
  function formatTransactionRequest(transactionRequest) {
    return {
      ...transactionRequest,
      gas: typeof transactionRequest.gas !== "undefined" ? numberToHex(transactionRequest.gas) : void 0,
      gasPrice: typeof transactionRequest.gasPrice !== "undefined" ? numberToHex(transactionRequest.gasPrice) : void 0,
      maxFeePerGas: typeof transactionRequest.maxFeePerGas !== "undefined" ? numberToHex(transactionRequest.maxFeePerGas) : void 0,
      maxPriorityFeePerGas: typeof transactionRequest.maxPriorityFeePerGas !== "undefined" ? numberToHex(transactionRequest.maxPriorityFeePerGas) : void 0,
      nonce: typeof transactionRequest.nonce !== "undefined" ? numberToHex(transactionRequest.nonce) : void 0,
      value: typeof transactionRequest.value !== "undefined" ? numberToHex(transactionRequest.value) : void 0
    };
  }
  var defineTransactionRequest;
  var init_transactionRequest = __esm({
    "node_modules/viem/dist/esm/utils/formatters/transactionRequest.js"() {
      init_toHex();
      init_format();
      defineTransactionRequest = defineFormatter({
        format: formatTransactionRequest
      });
    }
  });

  // node_modules/eventemitter3/index.js
  var require_eventemitter3 = __commonJS({
    "node_modules/eventemitter3/index.js"(exports, module) {
      "use strict";
      var has = Object.prototype.hasOwnProperty;
      var prefix = "~";
      function Events() {
      }
      if (Object.create) {
        Events.prototype = /* @__PURE__ */ Object.create(null);
        if (!new Events().__proto__)
          prefix = false;
      }
      function EE(fn2, context, once) {
        this.fn = fn2;
        this.context = context;
        this.once = once || false;
      }
      function addListener(emitter, event, fn2, context, once) {
        if (typeof fn2 !== "function") {
          throw new TypeError("The listener must be a function");
        }
        var listener = new EE(fn2, context || emitter, once), evt = prefix ? prefix + event : event;
        if (!emitter._events[evt])
          emitter._events[evt] = listener, emitter._eventsCount++;
        else if (!emitter._events[evt].fn)
          emitter._events[evt].push(listener);
        else
          emitter._events[evt] = [emitter._events[evt], listener];
        return emitter;
      }
      function clearEvent(emitter, evt) {
        if (--emitter._eventsCount === 0)
          emitter._events = new Events();
        else
          delete emitter._events[evt];
      }
      function EventEmitter4() {
        this._events = new Events();
        this._eventsCount = 0;
      }
      EventEmitter4.prototype.eventNames = function eventNames() {
        var names2 = [], events, name2;
        if (this._eventsCount === 0)
          return names2;
        for (name2 in events = this._events) {
          if (has.call(events, name2))
            names2.push(prefix ? name2.slice(1) : name2);
        }
        if (Object.getOwnPropertySymbols) {
          return names2.concat(Object.getOwnPropertySymbols(events));
        }
        return names2;
      };
      EventEmitter4.prototype.listeners = function listeners(event) {
        var evt = prefix ? prefix + event : event, handlers = this._events[evt];
        if (!handlers)
          return [];
        if (handlers.fn)
          return [handlers.fn];
        for (var i7 = 0, l9 = handlers.length, ee6 = new Array(l9); i7 < l9; i7++) {
          ee6[i7] = handlers[i7].fn;
        }
        return ee6;
      };
      EventEmitter4.prototype.listenerCount = function listenerCount(event) {
        var evt = prefix ? prefix + event : event, listeners = this._events[evt];
        if (!listeners)
          return 0;
        if (listeners.fn)
          return 1;
        return listeners.length;
      };
      EventEmitter4.prototype.emit = function emit(event, a1, a22, a32, a42, a52) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
          return false;
        var listeners = this._events[evt], len = arguments.length, args, i7;
        if (listeners.fn) {
          if (listeners.once)
            this.removeListener(event, listeners.fn, void 0, true);
          switch (len) {
            case 1:
              return listeners.fn.call(listeners.context), true;
            case 2:
              return listeners.fn.call(listeners.context, a1), true;
            case 3:
              return listeners.fn.call(listeners.context, a1, a22), true;
            case 4:
              return listeners.fn.call(listeners.context, a1, a22, a32), true;
            case 5:
              return listeners.fn.call(listeners.context, a1, a22, a32, a42), true;
            case 6:
              return listeners.fn.call(listeners.context, a1, a22, a32, a42, a52), true;
          }
          for (i7 = 1, args = new Array(len - 1); i7 < len; i7++) {
            args[i7 - 1] = arguments[i7];
          }
          listeners.fn.apply(listeners.context, args);
        } else {
          var length2 = listeners.length, j7;
          for (i7 = 0; i7 < length2; i7++) {
            if (listeners[i7].once)
              this.removeListener(event, listeners[i7].fn, void 0, true);
            switch (len) {
              case 1:
                listeners[i7].fn.call(listeners[i7].context);
                break;
              case 2:
                listeners[i7].fn.call(listeners[i7].context, a1);
                break;
              case 3:
                listeners[i7].fn.call(listeners[i7].context, a1, a22);
                break;
              case 4:
                listeners[i7].fn.call(listeners[i7].context, a1, a22, a32);
                break;
              default:
                if (!args)
                  for (j7 = 1, args = new Array(len - 1); j7 < len; j7++) {
                    args[j7 - 1] = arguments[j7];
                  }
                listeners[i7].fn.apply(listeners[i7].context, args);
            }
          }
        }
        return true;
      };
      EventEmitter4.prototype.on = function on2(event, fn2, context) {
        return addListener(this, event, fn2, context, false);
      };
      EventEmitter4.prototype.once = function once(event, fn2, context) {
        return addListener(this, event, fn2, context, true);
      };
      EventEmitter4.prototype.removeListener = function removeListener(event, fn2, context, once) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
          return this;
        if (!fn2) {
          clearEvent(this, evt);
          return this;
        }
        var listeners = this._events[evt];
        if (listeners.fn) {
          if (listeners.fn === fn2 && (!once || listeners.once) && (!context || listeners.context === context)) {
            clearEvent(this, evt);
          }
        } else {
          for (var i7 = 0, events = [], length2 = listeners.length; i7 < length2; i7++) {
            if (listeners[i7].fn !== fn2 || once && !listeners[i7].once || context && listeners[i7].context !== context) {
              events.push(listeners[i7]);
            }
          }
          if (events.length)
            this._events[evt] = events.length === 1 ? events[0] : events;
          else
            clearEvent(this, evt);
        }
        return this;
      };
      EventEmitter4.prototype.removeAllListeners = function removeAllListeners(event) {
        var evt;
        if (event) {
          evt = prefix ? prefix + event : event;
          if (this._events[evt])
            clearEvent(this, evt);
        } else {
          this._events = new Events();
          this._eventsCount = 0;
        }
        return this;
      };
      EventEmitter4.prototype.off = EventEmitter4.prototype.removeListener;
      EventEmitter4.prototype.addListener = EventEmitter4.prototype.on;
      EventEmitter4.prefixed = prefix;
      EventEmitter4.EventEmitter = EventEmitter4;
      if ("undefined" !== typeof module) {
        module.exports = EventEmitter4;
      }
    }
  });

  // node_modules/viem/dist/esm/utils/abi/formatAbiItem.js
  function formatAbiItem(abiItem, { includeName = false } = {}) {
    if (abiItem.type !== "function" && abiItem.type !== "event" && abiItem.type !== "error")
      throw new InvalidDefinitionTypeError(abiItem.type);
    return `${abiItem.name}(${formatAbiParams(abiItem.inputs, { includeName })})`;
  }
  function formatAbiParams(params, { includeName = false } = {}) {
    if (!params)
      return "";
    return params.map((param) => formatAbiParam(param, { includeName })).join(includeName ? ", " : ",");
  }
  function formatAbiParam(param, { includeName }) {
    if (param.type.startsWith("tuple")) {
      return `(${formatAbiParams(param.components, { includeName })})${param.type.slice("tuple".length)}`;
    }
    return param.type + (includeName && param.name ? ` ${param.name}` : "");
  }
  var init_formatAbiItem = __esm({
    "node_modules/viem/dist/esm/utils/abi/formatAbiItem.js"() {
      init_abi();
    }
  });

  // node_modules/viem/dist/esm/errors/abi.js
  var AbiConstructorNotFoundError, AbiConstructorParamsNotFoundError, AbiDecodingDataSizeTooSmallError, AbiDecodingZeroDataError, AbiEncodingArrayLengthMismatchError, AbiEncodingBytesSizeMismatchError, AbiEncodingLengthMismatchError, AbiErrorSignatureNotFoundError, AbiEventSignatureEmptyTopicsError, AbiEventSignatureNotFoundError, AbiEventNotFoundError, AbiFunctionNotFoundError, AbiFunctionOutputsNotFoundError, BytesSizeMismatchError, DecodeLogDataMismatch, DecodeLogTopicsMismatch, InvalidAbiEncodingTypeError, InvalidAbiDecodingTypeError, InvalidArrayError, InvalidDefinitionTypeError;
  var init_abi = __esm({
    "node_modules/viem/dist/esm/errors/abi.js"() {
      init_formatAbiItem();
      init_size();
      init_base();
      AbiConstructorNotFoundError = class extends BaseError {
        constructor({ docsPath: docsPath4 }) {
          super([
            "A constructor was not found on the ABI.",
            "Make sure you are using the correct ABI and that the constructor exists on it."
          ].join("\n"), {
            docsPath: docsPath4
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiConstructorNotFoundError"
          });
        }
      };
      AbiConstructorParamsNotFoundError = class extends BaseError {
        constructor({ docsPath: docsPath4 }) {
          super([
            "Constructor arguments were provided (`args`), but a constructor parameters (`inputs`) were not found on the ABI.",
            "Make sure you are using the correct ABI, and that the `inputs` attribute on the constructor exists."
          ].join("\n"), {
            docsPath: docsPath4
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiConstructorParamsNotFoundError"
          });
        }
      };
      AbiDecodingDataSizeTooSmallError = class extends BaseError {
        constructor({ data: data2, params, size: size3 }) {
          super([`Data size of ${size3} bytes is too small for given parameters.`].join("\n"), {
            metaMessages: [
              `Params: (${formatAbiParams(params, { includeName: true })})`,
              `Data:   ${data2} (${size3} bytes)`
            ]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiDecodingDataSizeTooSmallError"
          });
          Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "params", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "size", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.data = data2;
          this.params = params;
          this.size = size3;
        }
      };
      AbiDecodingZeroDataError = class extends BaseError {
        constructor() {
          super('Cannot decode zero data ("0x") with ABI parameters.');
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiDecodingZeroDataError"
          });
        }
      };
      AbiEncodingArrayLengthMismatchError = class extends BaseError {
        constructor({ expectedLength, givenLength, type }) {
          super([
            `ABI encoding array length mismatch for type ${type}.`,
            `Expected length: ${expectedLength}`,
            `Given length: ${givenLength}`
          ].join("\n"));
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiEncodingArrayLengthMismatchError"
          });
        }
      };
      AbiEncodingBytesSizeMismatchError = class extends BaseError {
        constructor({ expectedSize, value }) {
          super(`Size of bytes "${value}" (bytes${size(value)}) does not match expected size (bytes${expectedSize}).`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiEncodingBytesSizeMismatchError"
          });
        }
      };
      AbiEncodingLengthMismatchError = class extends BaseError {
        constructor({ expectedLength, givenLength }) {
          super([
            "ABI encoding params/values length mismatch.",
            `Expected length (params): ${expectedLength}`,
            `Given length (values): ${givenLength}`
          ].join("\n"));
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiEncodingLengthMismatchError"
          });
        }
      };
      AbiErrorSignatureNotFoundError = class extends BaseError {
        constructor(signature2, { docsPath: docsPath4 }) {
          super([
            `Encoded error signature "${signature2}" not found on ABI.`,
            "Make sure you are using the correct ABI and that the error exists on it.",
            `You can look up the signature here: https://openchain.xyz/signatures?query=${signature2}.`
          ].join("\n"), {
            docsPath: docsPath4
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiErrorSignatureNotFoundError"
          });
        }
      };
      AbiEventSignatureEmptyTopicsError = class extends BaseError {
        constructor({ docsPath: docsPath4 }) {
          super("Cannot extract event signature from empty topics.", {
            docsPath: docsPath4
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiEventSignatureEmptyTopicsError"
          });
        }
      };
      AbiEventSignatureNotFoundError = class extends BaseError {
        constructor(signature2, { docsPath: docsPath4 }) {
          super([
            `Encoded event signature "${signature2}" not found on ABI.`,
            "Make sure you are using the correct ABI and that the event exists on it.",
            `You can look up the signature here: https://openchain.xyz/signatures?query=${signature2}.`
          ].join("\n"), {
            docsPath: docsPath4
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiEventSignatureNotFoundError"
          });
        }
      };
      AbiEventNotFoundError = class extends BaseError {
        constructor(eventName, { docsPath: docsPath4 } = {}) {
          super([
            `Event ${eventName ? `"${eventName}" ` : ""}not found on ABI.`,
            "Make sure you are using the correct ABI and that the event exists on it."
          ].join("\n"), {
            docsPath: docsPath4
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiEventNotFoundError"
          });
        }
      };
      AbiFunctionNotFoundError = class extends BaseError {
        constructor(functionName, { docsPath: docsPath4 } = {}) {
          super([
            `Function ${functionName ? `"${functionName}" ` : ""}not found on ABI.`,
            "Make sure you are using the correct ABI and that the function exists on it."
          ].join("\n"), {
            docsPath: docsPath4
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiFunctionNotFoundError"
          });
        }
      };
      AbiFunctionOutputsNotFoundError = class extends BaseError {
        constructor(functionName, { docsPath: docsPath4 }) {
          super([
            `Function "${functionName}" does not contain any \`outputs\` on ABI.`,
            "Cannot decode function result without knowing what the parameter types are.",
            "Make sure you are using the correct ABI and that the function exists on it."
          ].join("\n"), {
            docsPath: docsPath4
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "AbiFunctionOutputsNotFoundError"
          });
        }
      };
      BytesSizeMismatchError = class extends BaseError {
        constructor({ expectedSize, givenSize }) {
          super(`Expected bytes${expectedSize}, got bytes${givenSize}.`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "BytesSizeMismatchError"
          });
        }
      };
      DecodeLogDataMismatch = class extends BaseError {
        constructor({ data: data2, params, size: size3 }) {
          super([
            `Data size of ${size3} bytes is too small for non-indexed event parameters.`
          ].join("\n"), {
            metaMessages: [
              `Params: (${formatAbiParams(params, { includeName: true })})`,
              `Data:   ${data2} (${size3} bytes)`
            ]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "DecodeLogDataMismatch"
          });
          Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "params", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "size", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.data = data2;
          this.params = params;
          this.size = size3;
        }
      };
      DecodeLogTopicsMismatch = class extends BaseError {
        constructor({ abiItem, param }) {
          super([
            `Expected a topic for indexed event parameter${param.name ? ` "${param.name}"` : ""} on event "${formatAbiItem(abiItem, { includeName: true })}".`
          ].join("\n"));
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "DecodeLogTopicsMismatch"
          });
        }
      };
      InvalidAbiEncodingTypeError = class extends BaseError {
        constructor(type, { docsPath: docsPath4 }) {
          super([
            `Type "${type}" is not a valid encoding type.`,
            "Please provide a valid ABI type."
          ].join("\n"), { docsPath: docsPath4 });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidAbiEncodingType"
          });
        }
      };
      InvalidAbiDecodingTypeError = class extends BaseError {
        constructor(type, { docsPath: docsPath4 }) {
          super([
            `Type "${type}" is not a valid decoding type.`,
            "Please provide a valid ABI type."
          ].join("\n"), { docsPath: docsPath4 });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidAbiDecodingType"
          });
        }
      };
      InvalidArrayError = class extends BaseError {
        constructor(value) {
          super([`Value "${value}" is not a valid array.`].join("\n"));
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidArrayError"
          });
        }
      };
      InvalidDefinitionTypeError = class extends BaseError {
        constructor(type) {
          super([
            `"${type}" is not a valid definition type.`,
            'Valid types: "function", "event", "error"'
          ].join("\n"));
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidDefinitionTypeError"
          });
        }
      };
    }
  });

  // node_modules/viem/dist/esm/utils/contract/extractFunctionParts.js
  function extractFunctionParts(def) {
    const parts = def.match(paramsRegex);
    const type = parts?.[2] || void 0;
    const name2 = parts?.[3];
    const params = parts?.[5] || void 0;
    return { type, name: name2, params };
  }
  function extractFunctionName(def) {
    return extractFunctionParts(def).name;
  }
  function extractFunctionParams(def) {
    const params = extractFunctionParts(def).params;
    const splitParams = params?.split(",").map((x4) => x4.trim().split(" "));
    return splitParams?.map((param) => ({
      type: param[0],
      name: param[1] === "indexed" ? param[2] : param[1],
      ...param[1] === "indexed" ? { indexed: true } : {}
    }));
  }
  var paramsRegex;
  var init_extractFunctionParts = __esm({
    "node_modules/viem/dist/esm/utils/contract/extractFunctionParts.js"() {
      paramsRegex = /((function|event)\s)?(.*)(\((.*)\))/;
    }
  });

  // node_modules/viem/node_modules/@noble/hashes/esm/_assert.js
  function number(n9) {
    if (!Number.isSafeInteger(n9) || n9 < 0)
      throw new Error(`Wrong positive integer: ${n9}`);
  }
  function bool(b7) {
    if (typeof b7 !== "boolean")
      throw new Error(`Expected boolean, not ${b7}`);
  }
  function bytes(b7, ...lengths) {
    if (!(b7 instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (lengths.length > 0 && !lengths.includes(b7.length))
      throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b7.length}`);
  }
  function hash(hash5) {
    if (typeof hash5 !== "function" || typeof hash5.create !== "function")
      throw new Error("Hash should be wrapped by utils.wrapConstructor");
    number(hash5.outputLen);
    number(hash5.blockLen);
  }
  function exists(instance, checkFinished = true) {
    if (instance.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished)
      throw new Error("Hash#digest() has already been called");
  }
  function output(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
      throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
  }
  var assert, assert_default;
  var init_assert = __esm({
    "node_modules/viem/node_modules/@noble/hashes/esm/_assert.js"() {
      assert = {
        number,
        bool,
        bytes,
        hash,
        exists,
        output
      };
      assert_default = assert;
    }
  });

  // node_modules/viem/node_modules/@noble/hashes/esm/_u64.js
  function fromBig(n9, le8 = false) {
    if (le8)
      return { h: Number(n9 & U32_MASK64), l: Number(n9 >> _32n & U32_MASK64) };
    return { h: Number(n9 >> _32n & U32_MASK64) | 0, l: Number(n9 & U32_MASK64) | 0 };
  }
  function split(lst, le8 = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i7 = 0; i7 < lst.length; i7++) {
      const { h: h10, l: l9 } = fromBig(lst[i7], le8);
      [Ah[i7], Al[i7]] = [h10, l9];
    }
    return [Ah, Al];
  }
  function add(Ah, Al, Bh, Bl) {
    const l9 = (Al >>> 0) + (Bl >>> 0);
    return { h: Ah + Bh + (l9 / 2 ** 32 | 0) | 0, l: l9 | 0 };
  }
  var U32_MASK64, _32n, toBig, shrSH, shrSL, rotrSH, rotrSL, rotrBH, rotrBL, rotr32H, rotr32L, rotlSH, rotlSL, rotlBH, rotlBL, add3L, add3H, add4L, add4H, add5L, add5H, u64, u64_default;
  var init_u64 = __esm({
    "node_modules/viem/node_modules/@noble/hashes/esm/_u64.js"() {
      U32_MASK64 = BigInt(2 ** 32 - 1);
      _32n = BigInt(32);
      toBig = (h10, l9) => BigInt(h10 >>> 0) << _32n | BigInt(l9 >>> 0);
      shrSH = (h10, l9, s7) => h10 >>> s7;
      shrSL = (h10, l9, s7) => h10 << 32 - s7 | l9 >>> s7;
      rotrSH = (h10, l9, s7) => h10 >>> s7 | l9 << 32 - s7;
      rotrSL = (h10, l9, s7) => h10 << 32 - s7 | l9 >>> s7;
      rotrBH = (h10, l9, s7) => h10 << 64 - s7 | l9 >>> s7 - 32;
      rotrBL = (h10, l9, s7) => h10 >>> s7 - 32 | l9 << 64 - s7;
      rotr32H = (h10, l9) => l9;
      rotr32L = (h10, l9) => h10;
      rotlSH = (h10, l9, s7) => h10 << s7 | l9 >>> 32 - s7;
      rotlSL = (h10, l9, s7) => l9 << s7 | h10 >>> 32 - s7;
      rotlBH = (h10, l9, s7) => l9 << s7 - 32 | h10 >>> 64 - s7;
      rotlBL = (h10, l9, s7) => h10 << s7 - 32 | l9 >>> 64 - s7;
      add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
      add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
      add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
      add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
      add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
      add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
      u64 = {
        fromBig,
        split,
        toBig,
        shrSH,
        shrSL,
        rotrSH,
        rotrSL,
        rotrBH,
        rotrBL,
        rotr32H,
        rotr32L,
        rotlSH,
        rotlSL,
        rotlBH,
        rotlBL,
        add,
        add3L,
        add3H,
        add4L,
        add4H,
        add5H,
        add5L
      };
      u64_default = u64;
    }
  });

  // node_modules/viem/node_modules/@noble/hashes/esm/crypto.js
  var crypto2;
  var init_crypto = __esm({
    "node_modules/viem/node_modules/@noble/hashes/esm/crypto.js"() {
      crypto2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
    }
  });

  // node_modules/viem/node_modules/@noble/hashes/esm/utils.js
  function utf8ToBytes(str) {
    if (typeof str !== "string") {
      throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);
    }
    return new TextEncoder().encode(str);
  }
  function toBytes2(data2) {
    if (typeof data2 === "string")
      data2 = utf8ToBytes(data2);
    if (!(data2 instanceof Uint8Array))
      throw new TypeError(`Expected input type is Uint8Array (got ${typeof data2})`);
    return data2;
  }
  function wrapConstructor(hashConstructor) {
    const hashC = (message) => hashConstructor().update(toBytes2(message)).digest();
    const tmp = hashConstructor();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashConstructor();
    return hashC;
  }
  function wrapConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes2(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
  }
  var u32, isLE, hexes2, Hash;
  var init_utils2 = __esm({
    "node_modules/viem/node_modules/@noble/hashes/esm/utils.js"() {
      init_crypto();
      u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
      isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
      if (!isLE)
        throw new Error("Non little-endian hardware is not supported");
      hexes2 = Array.from({ length: 256 }, (v6, i7) => i7.toString(16).padStart(2, "0"));
      Hash = class {
        // Safe version that clones internal state
        clone() {
          return this._cloneInto();
        }
      };
    }
  });

  // node_modules/viem/node_modules/@noble/hashes/esm/sha3.js
  function keccakP(s7, rounds = 24) {
    const B10 = new Uint32Array(5 * 2);
    for (let round = 24 - rounds; round < 24; round++) {
      for (let x4 = 0; x4 < 10; x4++)
        B10[x4] = s7[x4] ^ s7[x4 + 10] ^ s7[x4 + 20] ^ s7[x4 + 30] ^ s7[x4 + 40];
      for (let x4 = 0; x4 < 10; x4 += 2) {
        const idx1 = (x4 + 8) % 10;
        const idx0 = (x4 + 2) % 10;
        const B0 = B10[idx0];
        const B1 = B10[idx0 + 1];
        const Th = rotlH(B0, B1, 1) ^ B10[idx1];
        const Tl = rotlL(B0, B1, 1) ^ B10[idx1 + 1];
        for (let y11 = 0; y11 < 50; y11 += 10) {
          s7[x4 + y11] ^= Th;
          s7[x4 + y11 + 1] ^= Tl;
        }
      }
      let curH = s7[2];
      let curL = s7[3];
      for (let t6 = 0; t6 < 24; t6++) {
        const shift = SHA3_ROTL[t6];
        const Th = rotlH(curH, curL, shift);
        const Tl = rotlL(curH, curL, shift);
        const PI = SHA3_PI[t6];
        curH = s7[PI];
        curL = s7[PI + 1];
        s7[PI] = Th;
        s7[PI + 1] = Tl;
      }
      for (let y11 = 0; y11 < 50; y11 += 10) {
        for (let x4 = 0; x4 < 10; x4++)
          B10[x4] = s7[y11 + x4];
        for (let x4 = 0; x4 < 10; x4++)
          s7[y11 + x4] ^= ~B10[(x4 + 2) % 10] & B10[(x4 + 4) % 10];
      }
      s7[0] ^= SHA3_IOTA_H[round];
      s7[1] ^= SHA3_IOTA_L[round];
    }
    B10.fill(0);
  }
  var SHA3_PI, SHA3_ROTL, _SHA3_IOTA, _0n, _1n, _2n, _7n, _256n, _0x71n, SHA3_IOTA_H, SHA3_IOTA_L, rotlH, rotlL, Keccak, gen, sha3_224, sha3_256, sha3_384, sha3_512, keccak_224, keccak_256, keccak_384, keccak_512, genShake, shake128, shake256;
  var init_sha3 = __esm({
    "node_modules/viem/node_modules/@noble/hashes/esm/sha3.js"() {
      init_assert();
      init_u64();
      init_utils2();
      [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
      _0n = BigInt(0);
      _1n = BigInt(1);
      _2n = BigInt(2);
      _7n = BigInt(7);
      _256n = BigInt(256);
      _0x71n = BigInt(113);
      for (let round = 0, R7 = _1n, x4 = 1, y11 = 0; round < 24; round++) {
        [x4, y11] = [y11, (2 * x4 + 3 * y11) % 5];
        SHA3_PI.push(2 * (5 * y11 + x4));
        SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
        let t6 = _0n;
        for (let j7 = 0; j7 < 7; j7++) {
          R7 = (R7 << _1n ^ (R7 >> _7n) * _0x71n) % _256n;
          if (R7 & _2n)
            t6 ^= _1n << (_1n << BigInt(j7)) - _1n;
        }
        _SHA3_IOTA.push(t6);
      }
      [SHA3_IOTA_H, SHA3_IOTA_L] = u64_default.split(_SHA3_IOTA, true);
      rotlH = (h10, l9, s7) => s7 > 32 ? u64_default.rotlBH(h10, l9, s7) : u64_default.rotlSH(h10, l9, s7);
      rotlL = (h10, l9, s7) => s7 > 32 ? u64_default.rotlBL(h10, l9, s7) : u64_default.rotlSL(h10, l9, s7);
      Keccak = class extends Hash {
        // NOTE: we accept arguments in bytes instead of bits here.
        constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
          super();
          this.blockLen = blockLen;
          this.suffix = suffix;
          this.outputLen = outputLen;
          this.enableXOF = enableXOF;
          this.rounds = rounds;
          this.pos = 0;
          this.posOut = 0;
          this.finished = false;
          this.destroyed = false;
          assert_default.number(outputLen);
          if (0 >= this.blockLen || this.blockLen >= 200)
            throw new Error("Sha3 supports only keccak-f1600 function");
          this.state = new Uint8Array(200);
          this.state32 = u32(this.state);
        }
        keccak() {
          keccakP(this.state32, this.rounds);
          this.posOut = 0;
          this.pos = 0;
        }
        update(data2) {
          assert_default.exists(this);
          const { blockLen, state } = this;
          data2 = toBytes2(data2);
          const len = data2.length;
          for (let pos = 0; pos < len; ) {
            const take = Math.min(blockLen - this.pos, len - pos);
            for (let i7 = 0; i7 < take; i7++)
              state[this.pos++] ^= data2[pos++];
            if (this.pos === blockLen)
              this.keccak();
          }
          return this;
        }
        finish() {
          if (this.finished)
            return;
          this.finished = true;
          const { state, suffix, pos, blockLen } = this;
          state[pos] ^= suffix;
          if ((suffix & 128) !== 0 && pos === blockLen - 1)
            this.keccak();
          state[blockLen - 1] ^= 128;
          this.keccak();
        }
        writeInto(out) {
          assert_default.exists(this, false);
          assert_default.bytes(out);
          this.finish();
          const bufferOut = this.state;
          const { blockLen } = this;
          for (let pos = 0, len = out.length; pos < len; ) {
            if (this.posOut >= blockLen)
              this.keccak();
            const take = Math.min(blockLen - this.posOut, len - pos);
            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
            this.posOut += take;
            pos += take;
          }
          return out;
        }
        xofInto(out) {
          if (!this.enableXOF)
            throw new Error("XOF is not possible for this instance");
          return this.writeInto(out);
        }
        xof(bytes3) {
          assert_default.number(bytes3);
          return this.xofInto(new Uint8Array(bytes3));
        }
        digestInto(out) {
          assert_default.output(out, this);
          if (this.finished)
            throw new Error("digest() was already called");
          this.writeInto(out);
          this.destroy();
          return out;
        }
        digest() {
          return this.digestInto(new Uint8Array(this.outputLen));
        }
        destroy() {
          this.destroyed = true;
          this.state.fill(0);
        }
        _cloneInto(to3) {
          const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
          to3 || (to3 = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
          to3.state32.set(this.state32);
          to3.pos = this.pos;
          to3.posOut = this.posOut;
          to3.finished = this.finished;
          to3.rounds = rounds;
          to3.suffix = suffix;
          to3.outputLen = outputLen;
          to3.enableXOF = enableXOF;
          to3.destroyed = this.destroyed;
          return to3;
        }
      };
      gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
      sha3_224 = gen(6, 144, 224 / 8);
      sha3_256 = gen(6, 136, 256 / 8);
      sha3_384 = gen(6, 104, 384 / 8);
      sha3_512 = gen(6, 72, 512 / 8);
      keccak_224 = gen(1, 144, 224 / 8);
      keccak_256 = gen(1, 136, 256 / 8);
      keccak_384 = gen(1, 104, 384 / 8);
      keccak_512 = gen(1, 72, 512 / 8);
      genShake = (suffix, blockLen, outputLen) => wrapConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
      shake128 = genShake(31, 168, 128 / 8);
      shake256 = genShake(31, 136, 256 / 8);
    }
  });

  // node_modules/viem/dist/esm/utils/hash/keccak256.js
  function keccak256(value, to_) {
    const to3 = to_ || "hex";
    const bytes3 = keccak_256(isHex(value, { strict: false }) ? toBytes(value) : value);
    if (to3 === "bytes")
      return bytes3;
    return toHex(bytes3);
  }
  var init_keccak256 = __esm({
    "node_modules/viem/dist/esm/utils/hash/keccak256.js"() {
      init_sha3();
      init_isHex();
      init_toBytes();
      init_toHex();
    }
  });

  // node_modules/viem/dist/esm/utils/hash/hashFunction.js
  function hashFunction(def) {
    const name2 = extractFunctionName(def);
    const params = extractFunctionParams(def) || [];
    return hash2(`${name2}(${params.map(({ type }) => type).join(",")})`);
  }
  var hash2;
  var init_hashFunction = __esm({
    "node_modules/viem/dist/esm/utils/hash/hashFunction.js"() {
      init_extractFunctionParts();
      init_toBytes();
      init_keccak256();
      hash2 = (value) => keccak256(toBytes(value));
    }
  });

  // node_modules/viem/dist/esm/errors/address.js
  var InvalidAddressError;
  var init_address = __esm({
    "node_modules/viem/dist/esm/errors/address.js"() {
      init_base();
      InvalidAddressError = class extends BaseError {
        constructor({ address }) {
          super(`Address "${address}" is invalid.`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidAddressError"
          });
        }
      };
    }
  });

  // node_modules/viem/dist/esm/utils/address/isAddress.js
  function isAddress(address) {
    return addressRegex.test(address);
  }
  var addressRegex;
  var init_isAddress = __esm({
    "node_modules/viem/dist/esm/utils/address/isAddress.js"() {
      addressRegex = /^0x[a-fA-F0-9]{40}$/;
    }
  });

  // node_modules/viem/dist/esm/utils/data/concat.js
  function concat(values) {
    if (typeof values[0] === "string")
      return concatHex(values);
    return concatBytes(values);
  }
  function concatBytes(values) {
    let length2 = 0;
    for (const arr of values) {
      length2 += arr.length;
    }
    const result = new Uint8Array(length2);
    let offset = 0;
    for (const arr of values) {
      result.set(arr, offset);
      offset += arr.length;
    }
    return result;
  }
  function concatHex(values) {
    return `0x${values.reduce((acc, x4) => acc + x4.replace("0x", ""), "")}`;
  }
  var init_concat = __esm({
    "node_modules/viem/dist/esm/utils/data/concat.js"() {
    }
  });

  // node_modules/viem/dist/esm/utils/data/slice.js
  function slice(value, start, end, { strict } = {}) {
    if (isHex(value, { strict: false }))
      return sliceHex(value, start, end, {
        strict
      });
    return sliceBytes(value, start, end, {
      strict
    });
  }
  function assertStartOffset(value, start) {
    if (typeof start === "number" && start > 0 && start > size(value) - 1)
      throw new SliceOffsetOutOfBoundsError({
        offset: start,
        position: "start",
        size: size(value)
      });
  }
  function assertEndOffset(value, start, end) {
    if (typeof start === "number" && typeof end === "number" && size(value) !== end - start) {
      throw new SliceOffsetOutOfBoundsError({
        offset: end,
        position: "end",
        size: size(value)
      });
    }
  }
  function sliceBytes(value_, start, end, { strict } = {}) {
    assertStartOffset(value_, start);
    const value = value_.slice(start, end);
    if (strict)
      assertEndOffset(value, start, end);
    return value;
  }
  function sliceHex(value_, start, end, { strict } = {}) {
    assertStartOffset(value_, start);
    const value = `0x${value_.replace("0x", "").slice((start ?? 0) * 2, (end ?? value_.length) * 2)}`;
    if (strict)
      assertEndOffset(value, start, end);
    return value;
  }
  var init_slice = __esm({
    "node_modules/viem/dist/esm/utils/data/slice.js"() {
      init_data();
      init_isHex();
      init_size();
    }
  });

  // node_modules/viem/dist/esm/utils/abi/encodeAbiParameters.js
  function encodeAbiParameters(params, values) {
    if (params.length !== values.length)
      throw new AbiEncodingLengthMismatchError({
        expectedLength: params.length,
        givenLength: values.length
      });
    const preparedParams = prepareParams({
      params,
      values
    });
    const data2 = encodeParams(preparedParams);
    if (data2.length === 0)
      return "0x";
    return data2;
  }
  function prepareParams({ params, values }) {
    const preparedParams = [];
    for (let i7 = 0; i7 < params.length; i7++) {
      preparedParams.push(prepareParam({ param: params[i7], value: values[i7] }));
    }
    return preparedParams;
  }
  function prepareParam({ param, value }) {
    const arrayComponents = getArrayComponents(param.type);
    if (arrayComponents) {
      const [length2, type] = arrayComponents;
      return encodeArray(value, { length: length2, param: { ...param, type } });
    }
    if (param.type === "tuple") {
      return encodeTuple(value, {
        param
      });
    }
    if (param.type === "address") {
      return encodeAddress(value);
    }
    if (param.type === "bool") {
      return encodeBool(value);
    }
    if (param.type.startsWith("uint") || param.type.startsWith("int")) {
      const signed3 = param.type.startsWith("int");
      return encodeNumber(value, { signed: signed3 });
    }
    if (param.type.startsWith("bytes")) {
      return encodeBytes(value, { param });
    }
    if (param.type === "string") {
      return encodeString(value);
    }
    throw new InvalidAbiEncodingTypeError(param.type, {
      docsPath: "/docs/contract/encodeAbiParameters"
    });
  }
  function encodeParams(preparedParams) {
    let staticSize = 0;
    for (let i7 = 0; i7 < preparedParams.length; i7++) {
      const { dynamic, encoded } = preparedParams[i7];
      if (dynamic)
        staticSize += 32;
      else
        staticSize += size(encoded);
    }
    const staticParams = [];
    const dynamicParams = [];
    let dynamicSize = 0;
    for (let i7 = 0; i7 < preparedParams.length; i7++) {
      const { dynamic, encoded } = preparedParams[i7];
      if (dynamic) {
        staticParams.push(numberToHex(staticSize + dynamicSize, { size: 32 }));
        dynamicParams.push(encoded);
        dynamicSize += size(encoded);
      } else {
        staticParams.push(encoded);
      }
    }
    return concat([...staticParams, ...dynamicParams]);
  }
  function encodeAddress(value) {
    if (!isAddress(value))
      throw new InvalidAddressError({ address: value });
    return { dynamic: false, encoded: padHex(value.toLowerCase()) };
  }
  function encodeArray(value, { length: length2, param }) {
    const dynamic = length2 === null;
    if (!Array.isArray(value))
      throw new InvalidArrayError(value);
    if (!dynamic && value.length !== length2)
      throw new AbiEncodingArrayLengthMismatchError({
        expectedLength: length2,
        givenLength: value.length,
        type: `${param.type}[${length2}]`
      });
    let dynamicChild = false;
    const preparedParams = [];
    for (let i7 = 0; i7 < value.length; i7++) {
      const preparedParam = prepareParam({ param, value: value[i7] });
      if (preparedParam.dynamic)
        dynamicChild = true;
      preparedParams.push(preparedParam);
    }
    if (dynamic || dynamicChild) {
      const data2 = encodeParams(preparedParams);
      if (dynamic) {
        const length3 = numberToHex(preparedParams.length, { size: 32 });
        return {
          dynamic: true,
          encoded: preparedParams.length > 0 ? concat([length3, data2]) : length3
        };
      }
      if (dynamicChild)
        return { dynamic: true, encoded: data2 };
    }
    return {
      dynamic: false,
      encoded: concat(preparedParams.map(({ encoded }) => encoded))
    };
  }
  function encodeBytes(value, { param }) {
    const [_8, size_] = param.type.split("bytes");
    if (!size_) {
      const partsLength = Math.ceil(size(value) / 32);
      const parts = [];
      for (let i7 = 0; i7 < partsLength; i7++) {
        parts.push(padHex(slice(value, i7 * 32, (i7 + 1) * 32), {
          dir: "right"
        }));
      }
      return {
        dynamic: true,
        encoded: concat([
          padHex(numberToHex(size(value), { size: 32 })),
          ...parts
        ])
      };
    }
    if (size(value) !== parseInt(size_))
      throw new AbiEncodingBytesSizeMismatchError({
        expectedSize: parseInt(size_),
        value
      });
    return { dynamic: false, encoded: padHex(value, { dir: "right" }) };
  }
  function encodeBool(value) {
    return { dynamic: false, encoded: padHex(boolToHex(value)) };
  }
  function encodeNumber(value, { signed: signed3 }) {
    return {
      dynamic: false,
      encoded: numberToHex(value, {
        size: 32,
        signed: signed3
      })
    };
  }
  function encodeString(value) {
    const hexValue2 = stringToHex(value);
    const partsLength = Math.ceil(size(hexValue2) / 32);
    const parts = [];
    for (let i7 = 0; i7 < partsLength; i7++) {
      parts.push(padHex(slice(hexValue2, i7 * 32, (i7 + 1) * 32), {
        dir: "right"
      }));
    }
    return {
      dynamic: true,
      encoded: concat([
        padHex(numberToHex(size(hexValue2), { size: 32 })),
        ...parts
      ])
    };
  }
  function encodeTuple(value, { param }) {
    let dynamic = false;
    const preparedParams = [];
    for (let i7 = 0; i7 < param.components.length; i7++) {
      const param_ = param.components[i7];
      const index2 = Array.isArray(value) ? i7 : param_.name;
      const preparedParam = prepareParam({
        param: param_,
        value: value[index2]
      });
      preparedParams.push(preparedParam);
      if (preparedParam.dynamic)
        dynamic = true;
    }
    return {
      dynamic,
      encoded: dynamic ? encodeParams(preparedParams) : concat(preparedParams.map(({ encoded }) => encoded))
    };
  }
  function getArrayComponents(type) {
    const matches = type.match(/^(.*)\[(\d+)?\]$/);
    return matches ? [matches[2] ? Number(matches[2]) : null, matches[1]] : void 0;
  }
  var init_encodeAbiParameters = __esm({
    "node_modules/viem/dist/esm/utils/abi/encodeAbiParameters.js"() {
      init_abi();
      init_address();
      init_isAddress();
      init_concat();
      init_pad();
      init_size();
      init_slice();
      init_toHex();
    }
  });

  // node_modules/viem/dist/esm/utils/abi/getAbiItem.js
  function getAbiItem({ abi, args = [], name: name2 }) {
    const abiItems = abi.filter((x4) => "name" in x4 && x4.name === name2);
    if (abiItems.length === 0)
      return void 0;
    if (abiItems.length === 1)
      return abiItems[0];
    for (const abiItem of abiItems) {
      if (!("inputs" in abiItem))
        continue;
      if (!args || args.length === 0) {
        if (!abiItem.inputs || abiItem.inputs.length === 0)
          return abiItem;
        continue;
      }
      if (!abiItem.inputs)
        continue;
      if (abiItem.inputs.length === 0)
        continue;
      const matched = args.every((arg, index2) => {
        const abiParameter = "inputs" in abiItem && abiItem.inputs[index2];
        if (!abiParameter)
          return false;
        return isArgOfType(arg, abiParameter);
      });
      if (matched)
        return abiItem;
    }
    return abiItems[0];
  }
  function isArgOfType(arg, abiParameter) {
    const argType = typeof arg;
    const abiParameterType = abiParameter.type;
    switch (abiParameterType) {
      case "address":
        return isAddress(arg);
      case "bool":
        return argType === "boolean";
      case "function":
        return argType === "string";
      case "string":
        return argType === "string";
      default: {
        if (abiParameterType === "tuple" && "components" in abiParameter)
          return Object.values(abiParameter.components).every((component, index2) => {
            return isArgOfType(Object.values(arg)[index2], component);
          });
        if (/^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/.test(abiParameterType))
          return argType === "number" || argType === "bigint";
        if (/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/.test(abiParameterType))
          return argType === "string" || arg instanceof Uint8Array;
        if (/[a-z]+[1-9]{0,3}(\[[0-9]{0,}\])+$/.test(abiParameterType)) {
          return Array.isArray(arg) && arg.every((x4) => isArgOfType(x4, {
            ...abiParameter,
            type: abiParameterType.replace(/(\[[0-9]{0,}\])$/, "")
          }));
        }
        return false;
      }
    }
  }
  var init_getAbiItem = __esm({
    "node_modules/viem/dist/esm/utils/abi/getAbiItem.js"() {
      init_isAddress();
    }
  });

  // node_modules/viem/dist/esm/accounts/utils/parseAccount.js
  function parseAccount(account) {
    if (typeof account === "string")
      return { address: account, type: "json-rpc" };
    return account;
  }
  var init_parseAccount = __esm({
    "node_modules/viem/dist/esm/accounts/utils/parseAccount.js"() {
    }
  });

  // node_modules/viem/dist/esm/utils/hash/getFunctionSelector.js
  var getFunctionSelector;
  var init_getFunctionSelector = __esm({
    "node_modules/viem/dist/esm/utils/hash/getFunctionSelector.js"() {
      init_slice();
      init_hashFunction();
      getFunctionSelector = (fn2) => slice(hashFunction(fn2), 0, 4);
    }
  });

  // node_modules/viem/dist/esm/utils/abi/encodeFunctionData.js
  function encodeFunctionData({ abi, args, functionName }) {
    let abiItem = abi[0];
    if (functionName) {
      abiItem = getAbiItem({
        abi,
        args,
        name: functionName
      });
      if (!abiItem)
        throw new AbiFunctionNotFoundError(functionName, {
          docsPath: "/docs/contract/encodeFunctionData"
        });
    }
    if (abiItem.type !== "function")
      throw new AbiFunctionNotFoundError(void 0, {
        docsPath: "/docs/contract/encodeFunctionData"
      });
    const definition = formatAbiItem(abiItem);
    const signature2 = getFunctionSelector(definition);
    const data2 = "inputs" in abiItem && abiItem.inputs ? encodeAbiParameters(abiItem.inputs, args ?? []) : void 0;
    return concatHex([signature2, data2 ?? "0x"]);
  }
  var init_encodeFunctionData = __esm({
    "node_modules/viem/dist/esm/utils/abi/encodeFunctionData.js"() {
      init_abi();
      init_concat();
      init_getFunctionSelector();
      init_encodeAbiParameters();
      init_formatAbiItem();
      init_getAbiItem();
    }
  });

  // node_modules/viem/dist/esm/constants/solidity.js
  var panicReasons, solidityError, solidityPanic;
  var init_solidity = __esm({
    "node_modules/viem/dist/esm/constants/solidity.js"() {
      panicReasons = {
        1: "An `assert` condition failed.",
        17: "Arithmic operation resulted in underflow or overflow.",
        18: "Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",
        33: "Attempted to convert to an invalid type.",
        34: "Attempted to access a storage byte array that is incorrectly encoded.",
        49: "Performed `.pop()` on an empty array",
        50: "Array index is out of bounds.",
        65: "Allocated too much memory or created an array which is too large.",
        81: "Attempted to call a zero-initialized variable of internal function type."
      };
      solidityError = {
        inputs: [
          {
            name: "message",
            type: "string"
          }
        ],
        name: "Error",
        type: "error"
      };
      solidityPanic = {
        inputs: [
          {
            name: "reason",
            type: "uint256"
          }
        ],
        name: "Panic",
        type: "error"
      };
    }
  });

  // node_modules/viem/dist/esm/utils/address/getAddress.js
  function checksumAddress(address_, chainId) {
    const hexAddress = chainId ? `${chainId}${address_.toLowerCase()}` : address_.substring(2).toLowerCase();
    const hash5 = keccak256(stringToBytes(hexAddress), "bytes");
    const address = (chainId ? hexAddress.substring(`${chainId}0x`.length) : hexAddress).split("");
    for (let i7 = 0; i7 < 40; i7 += 2) {
      if (hash5[i7 >> 1] >> 4 >= 8 && address[i7]) {
        address[i7] = address[i7].toUpperCase();
      }
      if ((hash5[i7 >> 1] & 15) >= 8 && address[i7 + 1]) {
        address[i7 + 1] = address[i7 + 1].toUpperCase();
      }
    }
    return `0x${address.join("")}`;
  }
  function getAddress(address, chainId) {
    if (!isAddress(address))
      throw new InvalidAddressError({ address });
    return checksumAddress(address, chainId);
  }
  var init_getAddress = __esm({
    "node_modules/viem/dist/esm/utils/address/getAddress.js"() {
      init_address();
      init_toBytes();
      init_keccak256();
      init_isAddress();
    }
  });

  // node_modules/viem/dist/esm/utils/abi/decodeAbiParameters.js
  function decodeAbiParameters(params, data2) {
    if (data2 === "0x" && params.length > 0)
      throw new AbiDecodingZeroDataError();
    if (size(data2) && size(data2) < 32)
      throw new AbiDecodingDataSizeTooSmallError({
        data: data2,
        params,
        size: size(data2)
      });
    return decodeParams({
      data: data2,
      params
    });
  }
  function decodeParams({ data: data2, params }) {
    const decodedValues = [];
    let position = 0;
    for (let i7 = 0; i7 < params.length; i7++) {
      if (position >= size(data2))
        throw new AbiDecodingDataSizeTooSmallError({
          data: data2,
          params,
          size: size(data2)
        });
      const param = params[i7];
      const { consumed, value } = decodeParam({ data: data2, param, position });
      decodedValues.push(value);
      position += consumed;
    }
    return decodedValues;
  }
  function decodeParam({ data: data2, param, position }) {
    const arrayComponents = getArrayComponents(param.type);
    if (arrayComponents) {
      const [length2, type] = arrayComponents;
      return decodeArray(data2, {
        length: length2,
        param: { ...param, type },
        position
      });
    }
    if (param.type === "tuple") {
      return decodeTuple(data2, { param, position });
    }
    if (param.type === "string") {
      return decodeString(data2, { position });
    }
    if (param.type.startsWith("bytes")) {
      return decodeBytes(data2, { param, position });
    }
    const value = slice(data2, position, position + 32, { strict: true });
    if (param.type.startsWith("uint") || param.type.startsWith("int")) {
      return decodeNumber(value, { param });
    }
    if (param.type === "address") {
      return decodeAddress(value);
    }
    if (param.type === "bool") {
      return decodeBool(value);
    }
    throw new InvalidAbiDecodingTypeError(param.type, {
      docsPath: "/docs/contract/decodeAbiParameters"
    });
  }
  function decodeAddress(value) {
    return { consumed: 32, value: checksumAddress(slice(value, -20)) };
  }
  function decodeArray(data2, { param, length: length2, position }) {
    if (!length2) {
      const offset = hexToNumber(slice(data2, position, position + 32, { strict: true }));
      const length3 = hexToNumber(slice(data2, offset, offset + 32, { strict: true }));
      let consumed2 = 0;
      const value2 = [];
      for (let i7 = 0; i7 < length3; ++i7) {
        const decodedChild = decodeParam({
          data: slice(data2, offset + 32),
          param,
          position: consumed2
        });
        consumed2 += decodedChild.consumed;
        value2.push(decodedChild.value);
      }
      return { value: value2, consumed: 32 };
    }
    if (hasDynamicChild(param)) {
      const arrayComponents = getArrayComponents(param.type);
      const dynamicChild = !arrayComponents?.[0];
      let consumed2 = 0;
      const value2 = [];
      for (let i7 = 0; i7 < length2; ++i7) {
        const offset = hexToNumber(slice(data2, position, position + 32, { strict: true }));
        const decodedChild = decodeParam({
          data: slice(data2, offset),
          param,
          position: dynamicChild ? consumed2 : i7 * 32
        });
        consumed2 += decodedChild.consumed;
        value2.push(decodedChild.value);
      }
      return { value: value2, consumed: 32 };
    }
    let consumed = 0;
    const value = [];
    for (let i7 = 0; i7 < length2; ++i7) {
      const decodedChild = decodeParam({
        data: data2,
        param,
        position: position + consumed
      });
      consumed += decodedChild.consumed;
      value.push(decodedChild.value);
    }
    return { value, consumed };
  }
  function decodeBool(value) {
    return { consumed: 32, value: hexToBool(value) };
  }
  function decodeBytes(data2, { param, position }) {
    const [_8, size3] = param.type.split("bytes");
    if (!size3) {
      const offset = hexToNumber(slice(data2, position, position + 32, { strict: true }));
      const length2 = hexToNumber(slice(data2, offset, offset + 32, { strict: true }));
      if (length2 === 0)
        return { consumed: 32, value: "0x" };
      const value2 = slice(data2, offset + 32, offset + 32 + length2, {
        strict: true
      });
      return { consumed: 32, value: value2 };
    }
    const value = slice(data2, position, position + parseInt(size3), {
      strict: true
    });
    return { consumed: 32, value };
  }
  function decodeNumber(value, { param }) {
    const signed3 = param.type.startsWith("int");
    const size3 = parseInt(param.type.split("int")[1] || "256");
    return {
      consumed: 32,
      value: size3 > 48 ? hexToBigInt(value, { signed: signed3 }) : hexToNumber(value, { signed: signed3 })
    };
  }
  function decodeString(data2, { position }) {
    const offset = hexToNumber(slice(data2, position, position + 32, { strict: true }));
    const length2 = hexToNumber(slice(data2, offset, offset + 32, { strict: true }));
    if (length2 === 0)
      return { consumed: 32, value: "" };
    const value = hexToString(trim(slice(data2, offset + 32, offset + 32 + length2, { strict: true })));
    return { consumed: 32, value };
  }
  function decodeTuple(data2, { param, position }) {
    const hasUnnamedChild = param.components.length === 0 || param.components.some(({ name: name2 }) => !name2);
    const value = hasUnnamedChild ? [] : {};
    let consumed = 0;
    if (hasDynamicChild(param)) {
      const offset = hexToNumber(slice(data2, position, position + 32, { strict: true }));
      for (let i7 = 0; i7 < param.components.length; ++i7) {
        const component = param.components[i7];
        const decodedChild = decodeParam({
          data: slice(data2, offset),
          param: component,
          position: consumed
        });
        consumed += decodedChild.consumed;
        value[hasUnnamedChild ? i7 : component?.name] = decodedChild.value;
      }
      return { consumed: 32, value };
    }
    for (let i7 = 0; i7 < param.components.length; ++i7) {
      const component = param.components[i7];
      const decodedChild = decodeParam({
        data: data2,
        param: component,
        position: position + consumed
      });
      consumed += decodedChild.consumed;
      value[hasUnnamedChild ? i7 : component?.name] = decodedChild.value;
    }
    return { consumed, value };
  }
  function hasDynamicChild(param) {
    const { type } = param;
    if (type === "string")
      return true;
    if (type === "bytes")
      return true;
    if (type.endsWith("[]"))
      return true;
    if (type === "tuple")
      return param.components?.some(hasDynamicChild);
    const arrayComponents = getArrayComponents(param.type);
    if (arrayComponents && hasDynamicChild({ ...param, type: arrayComponents[1] }))
      return true;
    return false;
  }
  var init_decodeAbiParameters = __esm({
    "node_modules/viem/dist/esm/utils/abi/decodeAbiParameters.js"() {
      init_abi();
      init_getAddress();
      init_size();
      init_slice();
      init_trim();
      init_fromHex();
      init_encodeAbiParameters();
    }
  });

  // node_modules/viem/dist/esm/utils/abi/decodeErrorResult.js
  function decodeErrorResult({ abi, data: data2 }) {
    const signature2 = slice(data2, 0, 4);
    if (signature2 === "0x")
      throw new AbiDecodingZeroDataError();
    const abi_ = [...abi || [], solidityError, solidityPanic];
    const abiItem = abi_.find((x4) => x4.type === "error" && signature2 === getFunctionSelector(formatAbiItem(x4)));
    if (!abiItem)
      throw new AbiErrorSignatureNotFoundError(signature2, {
        docsPath: "/docs/contract/decodeErrorResult"
      });
    return {
      abiItem,
      args: "inputs" in abiItem && abiItem.inputs && abiItem.inputs.length > 0 ? decodeAbiParameters(abiItem.inputs, slice(data2, 4)) : void 0,
      errorName: abiItem.name
    };
  }
  var init_decodeErrorResult = __esm({
    "node_modules/viem/dist/esm/utils/abi/decodeErrorResult.js"() {
      init_solidity();
      init_abi();
      init_slice();
      init_getFunctionSelector();
      init_decodeAbiParameters();
      init_formatAbiItem();
    }
  });

  // node_modules/viem/dist/esm/utils/stringify.js
  var stringify;
  var init_stringify = __esm({
    "node_modules/viem/dist/esm/utils/stringify.js"() {
      stringify = (value, replacer, space) => JSON.stringify(value, (key2, value_) => {
        const value2 = typeof value_ === "bigint" ? value_.toString() : value_;
        return typeof replacer === "function" ? replacer(key2, value2) : value2;
      }, space);
    }
  });

  // node_modules/viem/dist/esm/utils/abi/formatAbiItemWithArgs.js
  function formatAbiItemWithArgs({ abiItem, args, includeFunctionName = true, includeName = false }) {
    if (!("name" in abiItem))
      return;
    if (!("inputs" in abiItem))
      return;
    if (!abiItem.inputs)
      return;
    return `${includeFunctionName ? abiItem.name : ""}(${abiItem.inputs.map((input, i7) => `${includeName && input.name ? `${input.name}: ` : ""}${typeof args[i7] === "object" ? stringify(args[i7]) : args[i7]}`).join(", ")})`;
  }
  var init_formatAbiItemWithArgs = __esm({
    "node_modules/viem/dist/esm/utils/abi/formatAbiItemWithArgs.js"() {
      init_stringify();
    }
  });

  // node_modules/viem/dist/esm/constants/unit.js
  var etherUnits, gweiUnits, weiUnits;
  var init_unit = __esm({
    "node_modules/viem/dist/esm/constants/unit.js"() {
      etherUnits = {
        gwei: 9,
        wei: 18
      };
      gweiUnits = {
        ether: -9,
        wei: 9
      };
      weiUnits = {
        ether: -18,
        gwei: -9
      };
    }
  });

  // node_modules/viem/dist/esm/utils/unit/formatUnits.js
  function formatUnits(value, decimals) {
    let display = value.toString();
    const negative = display.startsWith("-");
    if (negative)
      display = display.slice(1);
    display = display.padStart(decimals, "0");
    let [integer, fraction] = [
      display.slice(0, display.length - decimals),
      display.slice(display.length - decimals)
    ];
    fraction = fraction.replace(/(0+)$/, "");
    return `${negative ? "-" : ""}${integer || "0"}${fraction ? `.${fraction}` : ""}`;
  }
  var init_formatUnits = __esm({
    "node_modules/viem/dist/esm/utils/unit/formatUnits.js"() {
    }
  });

  // node_modules/viem/dist/esm/utils/unit/formatEther.js
  function formatEther(wei, unit = "wei") {
    return formatUnits(wei, etherUnits[unit]);
  }
  var init_formatEther = __esm({
    "node_modules/viem/dist/esm/utils/unit/formatEther.js"() {
      init_unit();
      init_formatUnits();
    }
  });

  // node_modules/viem/dist/esm/utils/unit/formatGwei.js
  function formatGwei(wei, unit = "wei") {
    return formatUnits(wei, gweiUnits[unit]);
  }
  var init_formatGwei = __esm({
    "node_modules/viem/dist/esm/utils/unit/formatGwei.js"() {
      init_unit();
      init_formatUnits();
    }
  });

  // node_modules/viem/dist/esm/errors/transaction.js
  function prettyPrint(args) {
    const entries = Object.entries(args).map(([key2, value]) => {
      if (value === void 0 || value === false)
        return null;
      return [key2, value];
    }).filter(Boolean);
    const maxLength = entries.reduce((acc, [key2]) => Math.max(acc, key2.length), 0);
    return entries.map(([key2, value]) => `  ${`${key2}:`.padEnd(maxLength + 1)}  ${value}`).join("\n");
  }
  var FeeConflictError, TransactionExecutionError, TransactionNotFoundError, TransactionReceiptNotFoundError, WaitForTransactionReceiptTimeoutError;
  var init_transaction = __esm({
    "node_modules/viem/dist/esm/errors/transaction.js"() {
      init_formatEther();
      init_formatGwei();
      init_base();
      FeeConflictError = class extends BaseError {
        constructor() {
          super([
            "Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.",
            "Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others."
          ].join("\n"));
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "FeeConflictError"
          });
        }
      };
      TransactionExecutionError = class extends BaseError {
        constructor(cause, { account, docsPath: docsPath4, chain, data: data2, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to: to3, value }) {
          const prettyArgs = prettyPrint({
            chain: chain && `${chain?.name} (id: ${chain?.id})`,
            from: account?.address,
            to: to3,
            value: typeof value !== "undefined" && `${formatEther(value)} ${chain?.nativeCurrency.symbol || "ETH"}`,
            data: data2,
            gas,
            gasPrice: typeof gasPrice !== "undefined" && `${formatGwei(gasPrice)} gwei`,
            maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${formatGwei(maxFeePerGas)} gwei`,
            maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${formatGwei(maxPriorityFeePerGas)} gwei`,
            nonce
          });
          super(cause.shortMessage, {
            cause,
            docsPath: docsPath4,
            metaMessages: [
              ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
              "Request Arguments:",
              prettyArgs
            ].filter(Boolean)
          });
          Object.defineProperty(this, "cause", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "TransactionExecutionError"
          });
          this.cause = cause;
        }
      };
      TransactionNotFoundError = class extends BaseError {
        constructor({ blockHash, blockNumber, blockTag, hash: hash5, index: index2 }) {
          let identifier = "Transaction";
          if (blockTag && index2 !== void 0)
            identifier = `Transaction at block time "${blockTag}" at index "${index2}"`;
          if (blockHash && index2 !== void 0)
            identifier = `Transaction at block hash "${blockHash}" at index "${index2}"`;
          if (blockNumber && index2 !== void 0)
            identifier = `Transaction at block number "${blockNumber}" at index "${index2}"`;
          if (hash5)
            identifier = `Transaction with hash "${hash5}"`;
          super(`${identifier} could not be found.`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "TransactionNotFoundError"
          });
        }
      };
      TransactionReceiptNotFoundError = class extends BaseError {
        constructor({ hash: hash5 }) {
          super(`Transaction receipt with hash "${hash5}" could not be found. The Transaction may not be processed on a block yet.`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "TransactionReceiptNotFoundError"
          });
        }
      };
      WaitForTransactionReceiptTimeoutError = class extends BaseError {
        constructor({ hash: hash5 }) {
          super(`Timed out while waiting for transaction with hash "${hash5}" to be confirmed.`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "WaitForTransactionReceiptTimeoutError"
          });
        }
      };
    }
  });

  // node_modules/viem/dist/esm/errors/contract.js
  var CallExecutionError, ContractFunctionExecutionError, ContractFunctionRevertedError, ContractFunctionZeroDataError, RawContractError;
  var init_contract = __esm({
    "node_modules/viem/dist/esm/errors/contract.js"() {
      init_parseAccount();
      init_solidity();
      init_decodeErrorResult();
      init_formatAbiItem();
      init_formatAbiItemWithArgs();
      init_getAbiItem();
      init_formatEther();
      init_formatGwei();
      init_base();
      init_transaction();
      init_utils();
      CallExecutionError = class extends BaseError {
        constructor(cause, { account: account_, docsPath: docsPath4, chain, data: data2, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to: to3, value }) {
          const account = account_ ? parseAccount(account_) : void 0;
          const prettyArgs = prettyPrint({
            from: account?.address,
            to: to3,
            value: typeof value !== "undefined" && `${formatEther(value)} ${chain?.nativeCurrency.symbol || "ETH"}`,
            data: data2,
            gas,
            gasPrice: typeof gasPrice !== "undefined" && `${formatGwei(gasPrice)} gwei`,
            maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${formatGwei(maxFeePerGas)} gwei`,
            maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${formatGwei(maxPriorityFeePerGas)} gwei`,
            nonce
          });
          super(cause.shortMessage, {
            cause,
            docsPath: docsPath4,
            metaMessages: [
              ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
              "Raw Call Arguments:",
              prettyArgs
            ].filter(Boolean)
          });
          Object.defineProperty(this, "cause", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "CallExecutionError"
          });
          this.cause = cause;
        }
      };
      ContractFunctionExecutionError = class extends BaseError {
        constructor(cause, { abi, args, contractAddress, docsPath: docsPath4, functionName, sender }) {
          const abiItem = getAbiItem({ abi, args, name: functionName });
          const formattedArgs = abiItem ? formatAbiItemWithArgs({
            abiItem,
            args,
            includeFunctionName: false,
            includeName: false
          }) : void 0;
          const functionWithParams = abiItem ? formatAbiItem(abiItem, { includeName: true }) : void 0;
          const prettyArgs = prettyPrint({
            address: contractAddress && getContractAddress(contractAddress),
            function: functionWithParams,
            args: formattedArgs && formattedArgs !== "()" && `${[...Array(functionName?.length ?? 0).keys()].map(() => " ").join("")}${formattedArgs}`,
            sender
          });
          super(cause.shortMessage || `An unknown error occurred while executing the contract function "${functionName}".`, {
            cause,
            docsPath: docsPath4,
            metaMessages: [
              ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
              "Contract Call:",
              prettyArgs
            ].filter(Boolean)
          });
          Object.defineProperty(this, "abi", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "args", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "cause", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "contractAddress", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "formattedArgs", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "functionName", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "sender", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ContractFunctionExecutionError"
          });
          this.abi = abi;
          this.args = args;
          this.cause = cause;
          this.contractAddress = contractAddress;
          this.functionName = functionName;
          this.sender = sender;
        }
      };
      ContractFunctionRevertedError = class extends BaseError {
        constructor({ abi, data: data2, functionName, message }) {
          let decodedData = void 0;
          let metaMessages;
          let reason;
          if (data2 && data2 !== "0x") {
            decodedData = decodeErrorResult({ abi, data: data2 });
            const { abiItem, errorName, args: errorArgs } = decodedData;
            if (errorName === "Error") {
              reason = errorArgs[0];
            } else if (errorName === "Panic") {
              const [firstArg] = errorArgs;
              reason = panicReasons[firstArg];
            } else {
              const errorWithParams = abiItem ? formatAbiItem(abiItem, { includeName: true }) : void 0;
              const formattedArgs = abiItem && errorArgs ? formatAbiItemWithArgs({
                abiItem,
                args: errorArgs,
                includeFunctionName: false,
                includeName: false
              }) : void 0;
              metaMessages = [
                errorWithParams ? `Error: ${errorWithParams}` : "",
                formattedArgs && formattedArgs !== "()" ? `       ${[...Array(errorName?.length ?? 0).keys()].map(() => " ").join("")}${formattedArgs}` : ""
              ];
            }
          } else if (message)
            reason = message;
          super(reason && reason !== "execution reverted" ? [
            `The contract function "${functionName}" reverted with the following reason:`,
            reason
          ].join("\n") : `The contract function "${functionName}" reverted.`, {
            metaMessages
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ContractFunctionRevertedError"
          });
          Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "reason", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.reason = reason;
          this.data = decodedData;
        }
      };
      ContractFunctionZeroDataError = class extends BaseError {
        constructor({ functionName }) {
          super(`The contract function "${functionName}" returned no data ("0x").`, {
            metaMessages: [
              "This could be due to any of the following:",
              `  - The contract does not have the function "${functionName}",`,
              "  - The parameters passed to the contract function may be invalid, or",
              "  - The address is not a contract."
            ]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ContractFunctionZeroDataError"
          });
        }
      };
      RawContractError = class extends BaseError {
        constructor({ data: data2, message }) {
          super(message || "");
          Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 3
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "RawContractError"
          });
          Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.data = data2;
        }
      };
    }
  });

  // node_modules/viem/dist/esm/utils/errors/getContractError.js
  function getContractError(err, { abi, address, args, docsPath: docsPath4, functionName, sender }) {
    const { code: code2, data: data2, message, shortMessage } = err instanceof RawContractError ? err : err instanceof BaseError ? err.walk((err2) => "data" in err2) : {};
    let cause = err;
    if (err instanceof AbiDecodingZeroDataError) {
      cause = new ContractFunctionZeroDataError({ functionName });
    } else if (code2 === EXECUTION_REVERTED_ERROR_CODE && (data2 || message || shortMessage)) {
      cause = new ContractFunctionRevertedError({
        abi,
        data: typeof data2 === "object" ? data2.data : data2,
        functionName,
        message: shortMessage ?? message
      });
    }
    return new ContractFunctionExecutionError(cause, {
      abi,
      args,
      contractAddress: address,
      docsPath: docsPath4,
      functionName,
      sender
    });
  }
  var EXECUTION_REVERTED_ERROR_CODE;
  var init_getContractError = __esm({
    "node_modules/viem/dist/esm/utils/errors/getContractError.js"() {
      init_abi();
      init_base();
      init_contract();
      EXECUTION_REVERTED_ERROR_CODE = 3;
    }
  });

  // node_modules/viem/dist/esm/errors/node.js
  var ExecutionRevertedError, FeeCapTooHighError, FeeCapTooLowError, NonceTooHighError, NonceTooLowError, NonceMaxValueError, InsufficientFundsError, IntrinsicGasTooHighError, IntrinsicGasTooLowError, TransactionTypeNotSupportedError, TipAboveFeeCapError, UnknownNodeError;
  var init_node = __esm({
    "node_modules/viem/dist/esm/errors/node.js"() {
      init_formatGwei();
      init_base();
      ExecutionRevertedError = class extends BaseError {
        constructor({ cause, message } = {}) {
          const reason = message?.replace("execution reverted: ", "")?.replace("execution reverted", "");
          super(`Execution reverted ${reason ? `with reason: ${reason}` : "for an unknown reason"}.`, {
            cause
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ExecutionRevertedError"
          });
        }
      };
      Object.defineProperty(ExecutionRevertedError, "code", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: 3
      });
      Object.defineProperty(ExecutionRevertedError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /execution reverted/
      });
      FeeCapTooHighError = class extends BaseError {
        constructor({ cause, maxFeePerGas } = {}) {
          super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`, {
            cause
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "FeeCapTooHigh"
          });
        }
      };
      Object.defineProperty(FeeCapTooHighError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
      });
      FeeCapTooLowError = class extends BaseError {
        constructor({ cause, maxFeePerGas } = {}) {
          super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)}` : ""} gwei) cannot be lower than the block base fee.`, {
            cause
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "FeeCapTooLow"
          });
        }
      };
      Object.defineProperty(FeeCapTooLowError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
      });
      NonceTooHighError = class extends BaseError {
        constructor({ cause, nonce } = {}) {
          super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is higher than the next one expected.`, { cause });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "NonceTooHighError"
          });
        }
      };
      Object.defineProperty(NonceTooHighError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /nonce too high/
      });
      NonceTooLowError = class extends BaseError {
        constructor({ cause, nonce } = {}) {
          super([
            `Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is lower than the current nonce of the account.`,
            "Try increasing the nonce or find the latest nonce with `getTransactionCount`."
          ].join("\n"), { cause });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "NonceTooLowError"
          });
        }
      };
      Object.defineProperty(NonceTooLowError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /nonce too low|transaction already imported/
      });
      NonceMaxValueError = class extends BaseError {
        constructor({ cause, nonce } = {}) {
          super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}exceeds the maximum allowed nonce.`, { cause });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "NonceMaxValueError"
          });
        }
      };
      Object.defineProperty(NonceMaxValueError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /nonce has max value/
      });
      InsufficientFundsError = class extends BaseError {
        constructor({ cause } = {}) {
          super([
            "The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."
          ].join("\n"), {
            cause,
            metaMessages: [
              "This error could arise when the account does not have enough funds to:",
              " - pay for the total gas fee,",
              " - pay for the value to send.",
              " ",
              "The cost of the transaction is calculated as `gas * gas fee + value`, where:",
              " - `gas` is the amount of gas needed for transaction to execute,",
              " - `gas fee` is the gas fee,",
              " - `value` is the amount of ether to send to the recipient."
            ]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InsufficientFundsError"
          });
        }
      };
      Object.defineProperty(InsufficientFundsError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /insufficient funds/
      });
      IntrinsicGasTooHighError = class extends BaseError {
        constructor({ cause, gas } = {}) {
          super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction exceeds the limit allowed for the block.`, {
            cause
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "IntrinsicGasTooHighError"
          });
        }
      };
      Object.defineProperty(IntrinsicGasTooHighError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /intrinsic gas too high|gas limit reached/
      });
      IntrinsicGasTooLowError = class extends BaseError {
        constructor({ cause, gas } = {}) {
          super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction is too low.`, {
            cause
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "IntrinsicGasTooLowError"
          });
        }
      };
      Object.defineProperty(IntrinsicGasTooLowError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /intrinsic gas too low/
      });
      TransactionTypeNotSupportedError = class extends BaseError {
        constructor({ cause }) {
          super("The transaction type is not supported for this chain.", {
            cause
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "TransactionTypeNotSupportedError"
          });
        }
      };
      Object.defineProperty(TransactionTypeNotSupportedError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /transaction type not valid/
      });
      TipAboveFeeCapError = class extends BaseError {
        constructor({ cause, maxPriorityFeePerGas, maxFeePerGas } = {}) {
          super([
            `The provided tip (\`maxPriorityFeePerGas\`${maxPriorityFeePerGas ? ` = ${formatGwei(maxPriorityFeePerGas)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ""}).`
          ].join("\n"), {
            cause
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "TipAboveFeeCapError"
          });
        }
      };
      Object.defineProperty(TipAboveFeeCapError, "nodeMessage", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
      });
      UnknownNodeError = class extends BaseError {
        constructor({ cause }) {
          super(`An error occurred while executing: ${cause?.message}`, {
            cause
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "UnknownNodeError"
          });
        }
      };
    }
  });

  // node_modules/viem/dist/esm/errors/request.js
  var HttpRequestError, WebSocketRequestError, RpcRequestError, TimeoutError;
  var init_request = __esm({
    "node_modules/viem/dist/esm/errors/request.js"() {
      init_stringify();
      init_base();
      init_utils();
      HttpRequestError = class extends BaseError {
        constructor({ body, details, headers, status, url }) {
          super("HTTP request failed.", {
            details,
            metaMessages: [
              status && `Status: ${status}`,
              `URL: ${getUrl(url)}`,
              body && `Request body: ${stringify(body)}`
            ].filter(Boolean)
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "HttpRequestError"
          });
          Object.defineProperty(this, "body", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "headers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "status", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          Object.defineProperty(this, "url", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.body = body;
          this.headers = headers;
          this.status = status;
          this.url = url;
        }
      };
      WebSocketRequestError = class extends BaseError {
        constructor({ body, details, url }) {
          super("WebSocket request failed.", {
            details,
            metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "WebSocketRequestError"
          });
        }
      };
      RpcRequestError = class extends BaseError {
        constructor({ body, error, url }) {
          super("RPC Request failed.", {
            cause: error,
            details: error.message,
            metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "RpcRequestError"
          });
          Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.code = error.code;
        }
      };
      TimeoutError = class extends BaseError {
        constructor({ body, url }) {
          super("The request took too long to respond.", {
            details: "The request timed out.",
            metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "TimeoutError"
          });
        }
      };
    }
  });

  // node_modules/viem/dist/esm/errors/rpc.js
  var unknownErrorCode, RpcError, ProviderRpcError, ParseRpcError, InvalidRequestRpcError, MethodNotFoundRpcError, InvalidParamsRpcError, InternalRpcError, InvalidInputRpcError, ResourceNotFoundRpcError, ResourceUnavailableRpcError, TransactionRejectedRpcError, MethodNotSupportedRpcError, LimitExceededRpcError, JsonRpcVersionUnsupportedError, UserRejectedRequestError, UnauthorizedProviderError, UnsupportedProviderMethodError, ProviderDisconnectedError, ChainDisconnectedError, SwitchChainError, UnknownRpcError;
  var init_rpc = __esm({
    "node_modules/viem/dist/esm/errors/rpc.js"() {
      init_base();
      init_request();
      unknownErrorCode = -1;
      RpcError = class extends BaseError {
        constructor(cause, { code: code2, docsPath: docsPath4, metaMessages, shortMessage }) {
          super(shortMessage, {
            cause,
            docsPath: docsPath4,
            metaMessages: metaMessages || cause?.metaMessages
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "RpcError"
          });
          Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.name = cause.name;
          this.code = cause instanceof RpcRequestError ? cause.code : code2 ?? unknownErrorCode;
        }
      };
      ProviderRpcError = class extends RpcError {
        constructor(cause, options2) {
          super(cause, options2);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ProviderRpcError"
          });
          Object.defineProperty(this, "data", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
          });
          this.data = options2.data;
        }
      };
      ParseRpcError = class extends RpcError {
        constructor(cause) {
          super(cause, {
            code: -32700,
            shortMessage: "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ParseRpcError"
          });
        }
      };
      InvalidRequestRpcError = class extends RpcError {
        constructor(cause) {
          super(cause, {
            code: -32600,
            shortMessage: "JSON is not a valid request object."
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidRequestRpcError"
          });
        }
      };
      MethodNotFoundRpcError = class extends RpcError {
        constructor(cause) {
          super(cause, {
            code: -32601,
            shortMessage: "The method does not exist / is not available."
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "MethodNotFoundRpcError"
          });
        }
      };
      InvalidParamsRpcError = class extends RpcError {
        constructor(cause) {
          super(cause, {
            code: -32602,
            shortMessage: [
              "Invalid parameters were provided to the RPC method.",
              "Double check you have provided the correct parameters."
            ].join("\n")
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidParamsRpcError"
          });
        }
      };
      InternalRpcError = class extends RpcError {
        constructor(cause) {
          super(cause, {
            code: -32603,
            shortMessage: "An internal error was received."
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InternalRpcError"
          });
        }
      };
      InvalidInputRpcError = class extends RpcError {
        constructor(cause) {
          super(cause, {
            code: -32e3,
            shortMessage: [
              "Missing or invalid parameters.",
              "Double check you have provided the correct parameters."
            ].join("\n")
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "InvalidInputRpcError"
          });
        }
      };
      ResourceNotFoundRpcError = class extends RpcError {
        constructor(cause) {
          super(cause, {
            code: -32001,
            shortMessage: "Requested resource not found."
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ResourceNotFoundRpcError"
          });
        }
      };
      ResourceUnavailableRpcError = class extends RpcError {
        constructor(cause) {
          super(cause, {
            code: -32002,
            shortMessage: "Requested resource not available."
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ResourceUnavailableRpcError"
          });
        }
      };
      TransactionRejectedRpcError = class extends RpcError {
        constructor(cause) {
          super(cause, { code: -32003, shortMessage: "Transaction creation failed." });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "TransactionRejectedRpcError"
          });
        }
      };
      MethodNotSupportedRpcError = class extends RpcError {
        constructor(cause) {
          super(cause, { code: -32004, shortMessage: "Method is not implemented." });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "MethodNotSupportedRpcError"
          });
        }
      };
      LimitExceededRpcError = class extends RpcError {
        constructor(cause) {
          super(cause, {
            code: -32005,
            shortMessage: "Request exceeds defined limit."
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "LimitExceededRpcError"
          });
        }
      };
      JsonRpcVersionUnsupportedError = class extends RpcError {
        constructor(cause) {
          super(cause, {
            code: -32006,
            shortMessage: "Version of JSON-RPC protocol is not supported."
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "JsonRpcVersionUnsupportedError"
          });
        }
      };
      UserRejectedRequestError = class extends ProviderRpcError {
        constructor(cause) {
          super(cause, {
            code: 4001,
            shortMessage: "User rejected the request."
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "UserRejectedRequestError"
          });
        }
      };
      UnauthorizedProviderError = class extends ProviderRpcError {
        constructor(cause) {
          super(cause, {
            code: 4100,
            shortMessage: "The requested method and/or account has not been authorized by the user."
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "UnauthorizedProviderError"
          });
        }
      };
      UnsupportedProviderMethodError = class extends ProviderRpcError {
        constructor(cause) {
          super(cause, {
            code: 4200,
            shortMessage: "The Provider does not support the requested method."
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "UnsupportedProviderMethodError"
          });
        }
      };
      ProviderDisconnectedError = class extends ProviderRpcError {
        constructor(cause) {
          super(cause, {
            code: 4900,
            shortMessage: "The Provider is disconnected from all chains."
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ProviderDisconnectedError"
          });
        }
      };
      ChainDisconnectedError = class extends ProviderRpcError {
        constructor(cause) {
          super(cause, {
            code: 4901,
            shortMessage: "The Provider is not connected to the requested chain."
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "ChainDisconnectedError"
          });
        }
      };
      SwitchChainError = class extends ProviderRpcError {
        constructor(cause) {
          super(cause, {
            code: 4902,
            shortMessage: "An error occurred when attempting to switch chain."
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "SwitchChainError"
          });
        }
      };
      UnknownRpcError = class extends RpcError {
        constructor(cause) {
          super(cause, {
            shortMessage: "An unknown RPC error occurred."
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "UnknownRpcError"
          });
        }
      };
    }
  });

  // node_modules/viem/dist/esm/utils/errors/getNodeError.js
  function containsNodeError(err) {
    return err instanceof TransactionRejectedRpcError || err instanceof InvalidInputRpcError || err instanceof RpcRequestError && err.code === ExecutionRevertedError.code;
  }
  function getNodeError(err, args) {
    const message = err.details.toLowerCase();
    if (FeeCapTooHighError.nodeMessage.test(message))
      return new FeeCapTooHighError({
        cause: err,
        maxFeePerGas: args?.maxFeePerGas
      });
    else if (FeeCapTooLowError.nodeMessage.test(message))
      return new FeeCapTooLowError({
        cause: err,
        maxFeePerGas: args?.maxFeePerGas
      });
    else if (NonceTooHighError.nodeMessage.test(message))
      return new NonceTooHighError({ cause: err, nonce: args?.nonce });
    else if (NonceTooLowError.nodeMessage.test(message))
      return new NonceTooLowError({ cause: err, nonce: args?.nonce });
    else if (NonceMaxValueError.nodeMessage.test(message))
      return new NonceMaxValueError({ cause: err, nonce: args?.nonce });
    else if (InsufficientFundsError.nodeMessage.test(message))
      return new InsufficientFundsError({ cause: err });
    else if (IntrinsicGasTooHighError.nodeMessage.test(message))
      return new IntrinsicGasTooHighError({ cause: err, gas: args?.gas });
    else if (IntrinsicGasTooLowError.nodeMessage.test(message))
      return new IntrinsicGasTooLowError({ cause: err, gas: args?.gas });
    else if (TransactionTypeNotSupportedError.nodeMessage.test(message))
      return new TransactionTypeNotSupportedError({ cause: err });
    else if (TipAboveFeeCapError.nodeMessage.test(message))
      return new TipAboveFeeCapError({
        cause: err,
        maxFeePerGas: args?.maxFeePerGas,
        maxPriorityFeePerGas: args?.maxPriorityFeePerGas
      });
    else if (message.match(ExecutionRevertedError.nodeMessage) || "code" in err.cause && err.cause?.code === ExecutionRevertedError.code)
      return new ExecutionRevertedError({
        cause: err,
        message: err.cause.details || err.details
      });
    return new UnknownNodeError({
      cause: err.cause.cause
    });
  }
  var init_getNodeError = __esm({
    "node_modules/viem/dist/esm/utils/errors/getNodeError.js"() {
      init_node();
      init_request();
      init_rpc();
    }
  });

  // node_modules/viem/dist/esm/utils/formatters/extract.js
  function extract(value, { formatter }) {
    if (!formatter)
      return {};
    const keys2 = Object.keys(formatter({}));
    return keys2.reduce((data2, key2) => {
      if (value?.hasOwnProperty(key2)) {
        ;
        data2[key2] = value[key2];
      }
      return data2;
    }, {});
  }
  var init_extract = __esm({
    "node_modules/viem/dist/esm/utils/formatters/extract.js"() {
    }
  });

  // node_modules/viem/dist/esm/utils/transaction/assertRequest.js
  function assertRequest(args) {
    const { account: account_, gasPrice, maxFeePerGas, maxPriorityFeePerGas, to: to3 } = args;
    const account = account_ ? parseAccount(account_) : void 0;
    if (account && !isAddress(account.address))
      throw new InvalidAddressError({ address: account.address });
    if (to3 && !isAddress(to3))
      throw new InvalidAddressError({ address: to3 });
    if (typeof gasPrice !== "undefined" && (typeof maxFeePerGas !== "undefined" || typeof maxPriorityFeePerGas !== "undefined"))
      throw new FeeConflictError();
    if (maxFeePerGas && maxFeePerGas > 2n ** 256n - 1n)
      throw new FeeCapTooHighError({ maxFeePerGas });
    if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas)
      throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
  }
  var init_assertRequest = __esm({
    "node_modules/viem/dist/esm/utils/transaction/assertRequest.js"() {
      init_parseAccount();
      init_address();
      init_node();
      init_transaction();
      init_isAddress();
    }
  });

  // node_modules/viem/dist/esm/utils/abi/decodeFunctionResult.js
  function decodeFunctionResult({ abi, args, functionName, data: data2 }) {
    let abiItem = abi[0];
    if (functionName) {
      abiItem = getAbiItem({
        abi,
        args,
        name: functionName
      });
      if (!abiItem)
        throw new AbiFunctionNotFoundError(functionName, { docsPath });
    }
    if (abiItem.type !== "function")
      throw new AbiFunctionNotFoundError(void 0, { docsPath });
    if (!abiItem.outputs)
      throw new AbiFunctionOutputsNotFoundError(abiItem.name, { docsPath });
    const values = decodeAbiParameters(abiItem.outputs, data2);
    if (values && values.length > 1)
      return values;
    if (values && values.length === 1)
      return values[0];
    return void 0;
  }
  var docsPath;
  var init_decodeFunctionResult = __esm({
    "node_modules/viem/dist/esm/utils/abi/decodeFunctionResult.js"() {
      init_abi();
      init_decodeAbiParameters();
      init_getAbiItem();
      docsPath = "/docs/contract/decodeFunctionResult";
    }
  });

  // node_modules/viem/dist/esm/constants/abis.js
  var multicall3Abi, universalResolverAbi, textResolverAbi, singleAddressResolverAbi, universalSignatureValidatorAbi;
  var init_abis = __esm({
    "node_modules/viem/dist/esm/constants/abis.js"() {
      multicall3Abi = [
        {
          inputs: [
            {
              components: [
                {
                  name: "target",
                  type: "address"
                },
                {
                  name: "allowFailure",
                  type: "bool"
                },
                {
                  name: "callData",
                  type: "bytes"
                }
              ],
              name: "calls",
              type: "tuple[]"
            }
          ],
          name: "aggregate3",
          outputs: [
            {
              components: [
                {
                  name: "success",
                  type: "bool"
                },
                {
                  name: "returnData",
                  type: "bytes"
                }
              ],
              name: "returnData",
              type: "tuple[]"
            }
          ],
          stateMutability: "view",
          type: "function"
        }
      ];
      universalResolverAbi = [
        {
          name: "resolve",
          type: "function",
          stateMutability: "view",
          inputs: [
            { name: "name", type: "bytes" },
            { name: "data", type: "bytes" }
          ],
          outputs: [
            { name: "", type: "bytes" },
            { name: "address", type: "address" }
          ]
        }
      ];
      textResolverAbi = [
        {
          name: "text",
          type: "function",
          stateMutability: "view",
          inputs: [
            { name: "name", type: "bytes32" },
            { name: "key", type: "string" }
          ],
          outputs: [{ name: "", type: "string" }]
        }
      ];
      singleAddressResolverAbi = [
        {
          name: "addr",
          type: "function",
          stateMutability: "view",
          inputs: [{ name: "name", type: "bytes32" }],
          outputs: [{ name: "", type: "address" }]
        }
      ];
      universalSignatureValidatorAbi = [
        {
          inputs: [
            {
              internalType: "address",
              name: "_signer",
              type: "address"
            },
            {
              internalType: "bytes32",
              name: "_hash",
              type: "bytes32"
            },
            {
              internalType: "bytes",
              name: "_signature",
              type: "bytes"
            }
          ],
          stateMutability: "nonpayable",
          type: "constructor"
        }
      ];
    }
  });

  // node_modules/viem/dist/esm/constants/contract.js
  var aggregate3Signature;
  var init_contract2 = __esm({
    "node_modules/viem/dist/esm/constants/contract.js"() {
      aggregate3Signature = "0x82ad56cb";
    }
  });

  // node_modules/viem/dist/esm/utils/errors/getCallError.js
  function getCallError(err, { docsPath: docsPath4, ...args }) {
    let cause = err;
    if (containsNodeError(err))
      cause = getNodeError(err, args);
    return new CallExecutionError(cause, {
      docsPath: docsPath4,
      ...args
    });
  }
  var init_getCallError = __esm({
    "node_modules/viem/dist/esm/utils/errors/getCallError.js"() {
      init_contract();
      init_getNodeError();
    }
  });

  // node_modules/viem/dist/esm/utils/promise/createBatchScheduler.js
  function createBatchScheduler({ fn: fn2, id: id3, shouldSplitBatch, wait: wait2 = 0 }) {
    const exec = async () => {
      const scheduler = getScheduler();
      flush();
      const args = scheduler.map(({ args: args2 }) => args2);
      if (args.length === 0)
        return;
      fn2(args).then((data2) => {
        scheduler.forEach(({ pendingPromise }, i7) => pendingPromise.resolve?.([data2[i7], data2]));
      }).catch((err) => {
        scheduler.forEach(({ pendingPromise }) => pendingPromise.reject?.(err));
      });
    };
    const flush = () => schedulerCache.delete(id3);
    const getBatchedArgs = () => getScheduler().map(({ args }) => args);
    const getScheduler = () => schedulerCache.get(id3) || [];
    const setScheduler = (item) => schedulerCache.set(id3, [...getScheduler(), item]);
    return {
      flush,
      async schedule(args) {
        const pendingPromise = {};
        const promise = new Promise((resolve, reject) => {
          pendingPromise.resolve = resolve;
          pendingPromise.reject = reject;
        });
        const split2 = shouldSplitBatch?.([...getBatchedArgs(), args]);
        if (split2)
          exec();
        const hasActiveScheduler = getScheduler().length > 0;
        if (hasActiveScheduler) {
          setScheduler({ args, pendingPromise });
          return promise;
        }
        setScheduler({ args, pendingPromise });
        setTimeout(exec, wait2);
        return promise;
      }
    };
  }
  var schedulerCache;
  var init_createBatchScheduler = __esm({
    "node_modules/viem/dist/esm/utils/promise/createBatchScheduler.js"() {
      schedulerCache = /* @__PURE__ */ new Map();
    }
  });

  // node_modules/viem/dist/esm/errors/ccip.js
  var OffchainLookupError, OffchainLookupResponseMalformedError, OffchainLookupSenderMismatchError;
  var init_ccip = __esm({
    "node_modules/viem/dist/esm/errors/ccip.js"() {
      init_stringify();
      init_base();
      init_utils();
      OffchainLookupError = class extends BaseError {
        constructor({ callbackSelector, cause, data: data2, extraData, sender, urls }) {
          super(cause.shortMessage || "An error occurred while fetching for an offchain result.", {
            cause,
            metaMessages: [
              ...cause.metaMessages || [],
              cause.metaMessages?.length ? "" : [],
              "Offchain Gateway Call:",
              urls && [
                "  Gateway URL(s):",
                ...urls.map((url) => `    ${getUrl(url)}`)
              ],
              `  Sender: ${sender}`,
              `  Data: ${data2}`,
              `  Callback selector: ${callbackSelector}`,
              `  Extra data: ${extraData}`
            ].flat()
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "OffchainLookupError"
          });
        }
      };
      OffchainLookupResponseMalformedError = class extends BaseError {
        constructor({ result, url }) {
          super("Offchain gateway response is malformed. Response data must be a hex value.", {
            metaMessages: [
              `Gateway URL: ${getUrl(url)}`,
              `Response: ${stringify(result)}`
            ]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "OffchainLookupResponseMalformedError"
          });
        }
      };
      OffchainLookupSenderMismatchError = class extends BaseError {
        constructor({ sender, to: to3 }) {
          super("Reverted sender address does not match target contract address (`to`).", {
            metaMessages: [
              `Contract address: ${to3}`,
              `OffchainLookup sender address: ${sender}`
            ]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "OffchainLookupSenderMismatchError"
          });
        }
      };
    }
  });

  // node_modules/viem/dist/esm/utils/address/isAddressEqual.js
  function isAddressEqual(a6, b7) {
    if (!isAddress(a6))
      throw new InvalidAddressError({ address: a6 });
    if (!isAddress(b7))
      throw new InvalidAddressError({ address: b7 });
    return a6.toLowerCase() === b7.toLowerCase();
  }
  var init_isAddressEqual = __esm({
    "node_modules/viem/dist/esm/utils/address/isAddressEqual.js"() {
      init_address();
      init_isAddress();
    }
  });

  // node_modules/viem/dist/esm/utils/ccip.js
  var ccip_exports = {};
  __export(ccip_exports, {
    ccipFetch: () => ccipFetch,
    offchainLookup: () => offchainLookup,
    offchainLookupAbiItem: () => offchainLookupAbiItem,
    offchainLookupSignature: () => offchainLookupSignature
  });
  async function offchainLookup(client, { blockNumber, blockTag, data: data2, to: to3 }) {
    const { args } = decodeErrorResult({
      data: data2,
      abi: [offchainLookupAbiItem]
    });
    const [sender, urls, callData, callbackSelector, extraData] = args;
    try {
      if (!isAddressEqual(to3, sender))
        throw new OffchainLookupSenderMismatchError({ sender, to: to3 });
      const result = await ccipFetch({ data: callData, sender, urls });
      const { data: data_ } = await call(client, {
        blockNumber,
        blockTag,
        data: concat([
          callbackSelector,
          encodeAbiParameters([{ type: "bytes" }, { type: "bytes" }], [result, extraData])
        ]),
        to: to3
      });
      return data_;
    } catch (err) {
      throw new OffchainLookupError({
        callbackSelector,
        cause: err,
        data: data2,
        extraData,
        sender,
        urls
      });
    }
  }
  async function ccipFetch({ data: data2, sender, urls }) {
    let error = new Error("An unknown error occurred.");
    for (let i7 = 0; i7 < urls.length; i7++) {
      const url = urls[i7];
      const method = url.includes("{sender}") || url.includes("{data}") ? "GET" : "POST";
      const body = method === "POST" ? { data: data2, sender } : void 0;
      try {
        const response = await fetch(url.replace("{sender}", sender).replace("{data}", data2), {
          body: JSON.stringify(body),
          method
        });
        let result;
        if (response.headers.get("Content-Type")?.startsWith("application/json")) {
          result = (await response.json()).data;
        } else {
          result = await response.text();
        }
        if (!response.ok) {
          error = new HttpRequestError({
            body,
            details: stringify(result.error) || response.statusText,
            headers: response.headers,
            status: response.status,
            url
          });
          continue;
        }
        if (!isHex(result)) {
          error = new OffchainLookupResponseMalformedError({
            result,
            url
          });
          continue;
        }
        return result;
      } catch (err) {
        error = new HttpRequestError({
          body,
          details: err.message,
          url
        });
      }
    }
    throw error;
  }
  var offchainLookupSignature, offchainLookupAbiItem;
  var init_ccip2 = __esm({
    "node_modules/viem/dist/esm/utils/ccip.js"() {
      init_call();
      init_base();
      init_ccip();
      init_request();
      init_decodeErrorResult();
      init_encodeAbiParameters();
      init_isAddressEqual();
      init_concat();
      init_isHex();
      init_stringify();
      offchainLookupSignature = "0x556f1830";
      offchainLookupAbiItem = {
        name: "OffchainLookup",
        type: "error",
        inputs: [
          {
            name: "sender",
            type: "address"
          },
          {
            name: "urls",
            type: "string[]"
          },
          {
            name: "callData",
            type: "bytes"
          },
          {
            name: "callbackFunction",
            type: "bytes4"
          },
          {
            name: "extraData",
            type: "bytes"
          }
        ]
      };
    }
  });

  // node_modules/viem/dist/esm/actions/public/call.js
  async function call(client, args) {
    const { account: account_, batch = Boolean(client.batch?.multicall), blockNumber, blockTag = "latest", accessList, data: data2, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to: to3, value, ...rest } = args;
    const account = account_ ? parseAccount(account_) : void 0;
    try {
      assertRequest(args);
      const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;
      const block2 = blockNumberHex || blockTag;
      const formatter = client.chain?.formatters?.transactionRequest;
      const request = format({
        from: account?.address,
        accessList,
        data: data2,
        gas,
        gasPrice,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        to: to3,
        value,
        ...extract(rest, { formatter })
      }, {
        formatter: formatter || formatTransactionRequest
      });
      if (batch && shouldPerformMulticall({ request })) {
        try {
          return await scheduleMulticall(client, {
            ...request,
            blockNumber,
            blockTag
          });
        } catch (err) {
          if (!(err instanceof ClientChainNotConfiguredError) && !(err instanceof ChainDoesNotSupportContract))
            throw err;
        }
      }
      const response = await client.request({
        method: "eth_call",
        params: block2 ? [request, block2] : [request]
      });
      if (response === "0x")
        return { data: void 0 };
      return { data: response };
    } catch (err) {
      const data3 = getRevertErrorData(err);
      const { offchainLookup: offchainLookup2, offchainLookupSignature: offchainLookupSignature2 } = await Promise.resolve().then(() => (init_ccip2(), ccip_exports));
      if (data3?.slice(0, 10) === offchainLookupSignature2 && to3) {
        return { data: await offchainLookup2(client, { data: data3, to: to3 }) };
      }
      throw getCallError(err, {
        ...args,
        account,
        chain: client.chain
      });
    }
  }
  function shouldPerformMulticall({ request }) {
    const { data: data2, to: to3, ...request_ } = request;
    if (!data2)
      return false;
    if (data2.startsWith(aggregate3Signature))
      return false;
    if (!to3)
      return false;
    if (Object.values(request_).filter((x4) => typeof x4 !== "undefined").length > 0)
      return false;
    return true;
  }
  async function scheduleMulticall(client, args) {
    const { batchSize = 1024, wait: wait2 = 0 } = typeof client.batch?.multicall === "object" ? client.batch?.multicall : {};
    const { blockNumber, blockTag = "latest", data: data2, multicallAddress: multicallAddress_, to: to3 } = args;
    let multicallAddress = multicallAddress_;
    if (!multicallAddress) {
      if (!client.chain)
        throw new ClientChainNotConfiguredError();
      multicallAddress = getChainContractAddress({
        blockNumber,
        chain: client.chain,
        contract: "multicall3"
      });
    }
    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;
    const block2 = blockNumberHex || blockTag;
    const { schedule } = createBatchScheduler({
      id: `${client.uid}.${block2}`,
      wait: wait2,
      shouldSplitBatch(args2) {
        const size3 = args2.reduce((size4, { data: data3 }) => size4 + (data3.length - 2), 0);
        return size3 > batchSize * 2;
      },
      fn: async (requests) => {
        const calls = requests.map((request) => ({
          allowFailure: true,
          callData: request.data,
          target: request.to
        }));
        const calldata = encodeFunctionData({
          abi: multicall3Abi,
          args: [calls],
          functionName: "aggregate3"
        });
        const data3 = await client.request({
          method: "eth_call",
          params: [
            {
              data: calldata,
              to: multicallAddress
            },
            block2
          ]
        });
        return decodeFunctionResult({
          abi: multicall3Abi,
          args: [calls],
          functionName: "aggregate3",
          data: data3 || "0x"
        });
      }
    });
    const [{ returnData, success }] = await schedule({ data: data2, to: to3 });
    if (!success)
      throw new RawContractError({ data: returnData });
    if (returnData === "0x")
      return { data: void 0 };
    return { data: returnData };
  }
  function getRevertErrorData(err) {
    if (!(err instanceof BaseError))
      return void 0;
    const error = err.walk();
    return typeof error.data === "object" ? error.data.data : error.data;
  }
  var init_call = __esm({
    "node_modules/viem/dist/esm/actions/public/call.js"() {
      init_parseAccount();
      init_abis();
      init_contract2();
      init_base();
      init_chain();
      init_contract();
      init_decodeFunctionResult();
      init_encodeFunctionData();
      init_chain2();
      init_toHex();
      init_getCallError();
      init_extract();
      init_format();
      init_transactionRequest();
      init_createBatchScheduler();
      init_assertRequest();
    }
  });

  // node_modules/viem/dist/esm/actions/public/readContract.js
  async function readContract(client, { abi, address, args, functionName, ...callRequest }) {
    const calldata = encodeFunctionData({
      abi,
      args,
      functionName
    });
    try {
      const { data: data2 } = await call(client, {
        data: calldata,
        to: address,
        ...callRequest
      });
      return decodeFunctionResult({
        abi,
        args,
        functionName,
        data: data2 || "0x"
      });
    } catch (err) {
      throw getContractError(err, {
        abi,
        address,
        args,
        docsPath: "/docs/contract/readContract",
        functionName
      });
    }
  }
  var init_readContract = __esm({
    "node_modules/viem/dist/esm/actions/public/readContract.js"() {
      init_decodeFunctionResult();
      init_encodeFunctionData();
      init_getContractError();
      init_call();
    }
  });

  // node_modules/viem/dist/esm/utils/ens/namehash.js
  function namehash(name2) {
    let result = new Uint8Array(32).fill(0);
    if (!name2)
      return bytesToHex(result);
    const labels = name2.split(".");
    for (let i7 = labels.length - 1; i7 >= 0; i7 -= 1) {
      const hashed = keccak256(stringToBytes(labels[i7]), "bytes");
      result = keccak256(concat([result, hashed]), "bytes");
    }
    return bytesToHex(result);
  }
  var init_namehash = __esm({
    "node_modules/viem/dist/esm/utils/ens/namehash.js"() {
      init_concat();
      init_toBytes();
      init_toHex();
      init_keccak256();
    }
  });

  // node_modules/viem/dist/esm/utils/ens/packetToBytes.js
  function packetToBytes(packet) {
    function length2(value2) {
      if (value2 === "." || value2 === "..")
        return 1;
      return stringToBytes(value2.replace(/^\.|\.$/gm, "")).length + 2;
    }
    const bytes3 = new Uint8Array(length2(packet));
    const value = packet.replace(/^\.|\.$/gm, "");
    if (!value.length)
      return bytes3;
    let offset = 0;
    const list = value.split(".");
    for (let i7 = 0; i7 < list.length; i7++) {
      const encoded = stringToBytes(list[i7]);
      bytes3[offset] = encoded.length;
      bytes3.set(encoded, offset + 1);
      offset += encoded.length + 1;
    }
    return bytes3;
  }
  var init_packetToBytes = __esm({
    "node_modules/viem/dist/esm/utils/ens/packetToBytes.js"() {
      init_toBytes();
    }
  });

  // node_modules/viem/dist/esm/actions/ens/getEnsAddress.js
  async function getEnsAddress(client, { blockNumber, blockTag, name: name2, universalResolverAddress: universalResolverAddress_ }) {
    let universalResolverAddress = universalResolverAddress_;
    if (!universalResolverAddress) {
      if (!client.chain)
        throw new Error("client chain not configured. universalResolverAddress is required.");
      universalResolverAddress = getChainContractAddress({
        blockNumber,
        chain: client.chain,
        contract: "ensUniversalResolver"
      });
    }
    const res = await readContract(client, {
      address: universalResolverAddress,
      abi: universalResolverAbi,
      functionName: "resolve",
      args: [
        toHex(packetToBytes(name2)),
        encodeFunctionData({
          abi: singleAddressResolverAbi,
          functionName: "addr",
          args: [namehash(name2)]
        })
      ],
      blockNumber,
      blockTag
    });
    if (res[0] === "0x")
      return null;
    const address = decodeFunctionResult({
      abi: singleAddressResolverAbi,
      functionName: "addr",
      data: res[0]
    });
    return trim(address) === "0x00" ? null : address;
  }
  var init_getEnsAddress = __esm({
    "node_modules/viem/dist/esm/actions/ens/getEnsAddress.js"() {
      init_abis();
      init_decodeFunctionResult();
      init_encodeFunctionData();
      init_chain2();
      init_trim();
      init_toHex();
      init_namehash();
      init_packetToBytes();
      init_readContract();
    }
  });

  // node_modules/viem/dist/esm/actions/ens/getEnsName.js
  async function getEnsName(client, { address, blockNumber, blockTag, universalResolverAddress: universalResolverAddress_ }) {
    let universalResolverAddress = universalResolverAddress_;
    if (!universalResolverAddress) {
      if (!client.chain)
        throw new Error("client chain not configured. universalResolverAddress is required.");
      universalResolverAddress = getChainContractAddress({
        blockNumber,
        chain: client.chain,
        contract: "ensUniversalResolver"
      });
    }
    const reverseNode = `${address.toLowerCase().substring(2)}.addr.reverse`;
    try {
      const res = await readContract(client, {
        address: universalResolverAddress,
        abi: [
          {
            name: "reverse",
            type: "function",
            stateMutability: "view",
            inputs: [{ type: "bytes", name: "reverseName" }],
            outputs: [
              { type: "string", name: "resolvedName" },
              { type: "address", name: "resolvedAddress" },
              { type: "address", name: "reverseResolver" },
              { type: "address", name: "resolver" }
            ]
          }
        ],
        functionName: "reverse",
        args: [toHex(packetToBytes(reverseNode))],
        blockNumber,
        blockTag
      });
      return res[0];
    } catch (error) {
      if (error instanceof ContractFunctionExecutionError && error.cause.reason === panicReasons[50])
        return null;
      throw error;
    }
  }
  var init_getEnsName = __esm({
    "node_modules/viem/dist/esm/actions/ens/getEnsName.js"() {
      init_solidity();
      init_contract();
      init_chain2();
      init_toHex();
      init_packetToBytes();
      init_readContract();
    }
  });

  // node_modules/viem/dist/esm/actions/ens/getEnsResolver.js
  async function getEnsResolver(client, { blockNumber, blockTag, name: name2, universalResolverAddress: universalResolverAddress_ }) {
    let universalResolverAddress = universalResolverAddress_;
    if (!universalResolverAddress) {
      if (!client.chain)
        throw new Error("client chain not configured. universalResolverAddress is required.");
      universalResolverAddress = getChainContractAddress({
        blockNumber,
        chain: client.chain,
        contract: "ensUniversalResolver"
      });
    }
    const [resolverAddress] = await readContract(client, {
      address: universalResolverAddress,
      abi: [
        {
          inputs: [{ type: "bytes" }],
          name: "findResolver",
          outputs: [{ type: "address" }, { type: "bytes32" }],
          stateMutability: "view",
          type: "function"
        }
      ],
      functionName: "findResolver",
      args: [toHex(packetToBytes(name2))],
      blockNumber,
      blockTag
    });
    return resolverAddress;
  }
  var init_getEnsResolver = __esm({
    "node_modules/viem/dist/esm/actions/ens/getEnsResolver.js"() {
      init_chain2();
      init_toHex();
      init_packetToBytes();
      init_readContract();
    }
  });

  // node_modules/isomorphic-ws/browser.js
  var browser_exports = {};
  __export(browser_exports, {
    default: () => browser_default
  });
  var ws, browser_default;
  var init_browser = __esm({
    "node_modules/isomorphic-ws/browser.js"() {
      ws = null;
      if (typeof WebSocket !== "undefined") {
        ws = WebSocket;
      } else if (typeof MozWebSocket !== "undefined") {
        ws = MozWebSocket;
      } else if (typeof global !== "undefined") {
        ws = global.WebSocket || global.MozWebSocket;
      } else if (typeof window !== "undefined") {
        ws = window.WebSocket || window.MozWebSocket;
      } else if (typeof self !== "undefined") {
        ws = self.WebSocket || self.MozWebSocket;
      }
      browser_default = ws;
    }
  });

  // node_modules/viem/dist/esm/errors/ens.js
  var EnsAvatarInvalidMetadataError, EnsAvatarInvalidNftUriError, EnsAvatarUriResolutionError, EnsAvatarUnsupportedNamespaceError;
  var init_ens = __esm({
    "node_modules/viem/dist/esm/errors/ens.js"() {
      init_base();
      EnsAvatarInvalidMetadataError = class extends BaseError {
        constructor({ data: data2 }) {
          super("Unable to extract image from metadata. The metadata may be malformed or invalid.", {
            metaMessages: [
              "- Metadata must be a JSON object with at least an `image`, `image_url` or `image_data` property.",
              "",
              `Provided data: ${JSON.stringify(data2)}`
            ]
          });
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "EnsAvatarInvalidMetadataError"
          });
        }
      };
      EnsAvatarInvalidNftUriError = class extends BaseError {
        constructor({ reason }) {
          super(`ENS NFT avatar URI is invalid. ${reason}`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "EnsAvatarInvalidNftUriError"
          });
        }
      };
      EnsAvatarUriResolutionError = class extends BaseError {
        constructor({ uri }) {
          super(`Unable to resolve ENS avatar URI "${uri}". The URI may be malformed, invalid, or does not respond with a valid image.`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "EnsAvatarUriResolutionError"
          });
        }
      };
      EnsAvatarUnsupportedNamespaceError = class extends BaseError {
        constructor({ namespace }) {
          super(`ENS NFT avatar namespace "${namespace}" is not supported. Must be "erc721" or "erc1155".`);
          Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: "EnsAvatarUnsupportedNamespaceError"
          });
        }
      };
    }
  });

  // node_modules/viem/dist/esm/utils/ens/avatar/utils.js
  async function isImageUri(uri) {
    try {
      const res = await fetch(uri, { method: "HEAD" });
      if (res.status === 200) {
        const contentType = res.headers.get("content-type");
        return contentType?.startsWith("image/");
      }
      return false;
    } catch (error) {
      if (typeof error === "object" && typeof error.response !== "undefined") {
        return false;
      }
      if (!globalThis.hasOwnProperty("Image"))
        return false;
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          resolve(true);
        };
        img.onerror = () => {
          resolve(false);
        };
        img.src = uri;
      });
    }
  }
  function getGateway(custom2, defaultGateway) {
    if (!custom2)
      return defaultGateway;
    if (custom2.endsWith("/"))
      return custom2.slice(0, -1);
    return custom2;
  }
  function resolveAvatarUri({ uri, gatewayUrls }) {
    const isEncoded = base64Regex.test(uri);
    if (isEncoded)
      return { uri, isOnChain: true, isEncoded };
    const ipfsGateway = getGateway(gatewayUrls?.ipfs, "https://ipfs.io");
    const arweaveGateway = getGateway(gatewayUrls?.arweave, "https://arweave.net");
    const networkRegexMatch = uri.match(networkRegex);
    const { protocol: protocol2, subpath, target, subtarget = "" } = networkRegexMatch?.groups || {};
    const isIPNS = protocol2 === "ipns:/" || subpath === "ipns/";
    const isIPFS = protocol2 === "ipfs:/" || subpath === "ipfs/" || ipfsHashRegex.test(uri);
    if (uri.startsWith("http") && !isIPNS && !isIPFS) {
      let replacedUri = uri;
      if (gatewayUrls?.arweave)
        replacedUri = uri.replace(/https:\/\/arweave.net/g, gatewayUrls?.arweave);
      return { uri: replacedUri, isOnChain: false, isEncoded: false };
    }
    if ((isIPNS || isIPFS) && target) {
      return {
        uri: `${ipfsGateway}/${isIPNS ? "ipns" : "ipfs"}/${target}${subtarget}`,
        isOnChain: false,
        isEncoded: false
      };
    } else if (protocol2 === "ar:/" && target) {
      return {
        uri: `${arweaveGateway}/${target}${subtarget || ""}`,
        isOnChain: false,
        isEncoded: false
      };
    }
    let parsedUri = uri.replace(dataURIRegex, "");
    if (parsedUri.startsWith("<svg")) {
      parsedUri = `data:image/svg+xml;base64,${btoa(parsedUri)}`;
    }
    if (parsedUri.startsWith("data:") || parsedUri.startsWith("{")) {
      return {
        uri: parsedUri,
        isOnChain: true,
        isEncoded: false
      };
    }
    throw new EnsAvatarUriResolutionError({ uri });
  }
  function getJsonImage(data2) {
    if (typeof data2 !== "object" || !("image" in data2) && !("image_url" in data2) && !("image_data" in data2)) {
      throw new EnsAvatarInvalidMetadataError({ data: data2 });
    }
    return data2.image || data2.image_url || data2.image_data;
  }
  async function getMetadataAvatarUri({ gatewayUrls, uri }) {
    try {
      const res = await fetch(uri).then((res2) => res2.json());
      const image = await parseAvatarUri({
        gatewayUrls,
        uri: getJsonImage(res)
      });
      return image;
    } catch {
      throw new EnsAvatarUriResolutionError({ uri });
    }
  }
  async function parseAvatarUri({ gatewayUrls, uri }) {
    const { uri: resolvedURI, isOnChain } = resolveAvatarUri({ uri, gatewayUrls });
    if (isOnChain)
      return resolvedURI;
    const isImage = await isImageUri(resolvedURI);
    if (isImage)
      return resolvedURI;
    throw new EnsAvatarUriResolutionError({ uri });
  }
  function parseNftUri(uri) {
    if (uri.startsWith("did:nft:")) {
      uri = uri.replace("did:nft:", "").replace(/_/g, "/");
    }
    const [reference, asset_namespace, tokenID] = uri.split("/");
    const [eip_namespace, chainID] = reference.split(":");
    const [erc_namespace, contractAddress] = asset_namespace.split(":");
    if (!eip_namespace || eip_namespace.toLowerCase() !== "eip155")
      throw new EnsAvatarInvalidNftUriError({ reason: "Only EIP-155 supported" });
    if (!chainID)
      throw new EnsAvatarInvalidNftUriError({ reason: "Chain ID not found" });
    if (!contractAddress)
      throw new EnsAvatarInvalidNftUriError({
        reason: "Contract address not found"
      });
    if (!tokenID)
      throw new EnsAvatarInvalidNftUriError({ reason: "Token ID not found" });
    if (!erc_namespace)
      throw new EnsAvatarInvalidNftUriError({ reason: "ERC namespace not found" });
    return {
      chainID: parseInt(chainID),
      namespace: erc_namespace.toLowerCase(),
      contractAddress,
      tokenID
    };
  }
  async function getNftTokenUri(client, { nft }) {
    if (nft.namespace === "erc721") {
      return readContract(client, {
        address: nft.contractAddress,
        abi: [
          {
            name: "tokenURI",
            type: "function",
            stateMutability: "view",
            inputs: [{ name: "tokenId", type: "uint256" }],
            outputs: [{ name: "", type: "string" }]
          }
        ],
        functionName: "tokenURI",
        args: [BigInt(nft.tokenID)]
      });
    }
    if (nft.namespace === "erc1155") {
      return readContract(client, {
        address: nft.contractAddress,
        abi: [
          {
            name: "uri",
            type: "function",
            stateMutability: "view",
            inputs: [{ name: "_id", type: "uint256" }],
            outputs: [{ name: "", type: "string" }]
          }
        ],
        functionName: "uri",
        args: [BigInt(nft.tokenID)]
      });
    }
    throw new EnsAvatarUnsupportedNamespaceError({ namespace: nft.namespace });
  }
  var networkRegex, ipfsHashRegex, base64Regex, dataURIRegex;
  var init_utils3 = __esm({
    "node_modules/viem/dist/esm/utils/ens/avatar/utils.js"() {
      init_readContract();
      init_ens();
      networkRegex = /(?<protocol>https?:\/\/[^\/]*|ipfs:\/|ipns:\/|ar:\/)?(?<root>\/)?(?<subpath>ipfs\/|ipns\/)?(?<target>[\w\-.]+)(?<subtarget>\/.*)?/;
      ipfsHashRegex = /^(Qm[1-9A-HJ-NP-Za-km-z]{44,}|b[A-Za-z2-7]{58,}|B[A-Z2-7]{58,}|z[1-9A-HJ-NP-Za-km-z]{48,}|F[0-9A-F]{50,})(\/(?<target>[\w\-.]+))?(?<subtarget>\/.*)?$/;
      base64Regex = /^data:([a-zA-Z\-/+]*);base64,([^"].*)/;
      dataURIRegex = /^data:([a-zA-Z\-/+]*)?(;[a-zA-Z0-9].*?)?(,)/;
    }
  });

  // node_modules/viem/dist/esm/utils/ens/avatar/parseAvatarRecord.js
  async function parseAvatarRecord(client, { gatewayUrls, record }) {
    if (/eip155:/i.test(record))
      return parseNftAvatarUri(client, { gatewayUrls, record });
    return parseAvatarUri({ uri: record, gatewayUrls });
  }
  async function parseNftAvatarUri(client, { gatewayUrls, record }) {
    const nft = parseNftUri(record);
    const nftUri = await getNftTokenUri(client, { nft });
    const { uri: resolvedNftUri, isOnChain, isEncoded } = resolveAvatarUri({ uri: nftUri, gatewayUrls });
    if (isOnChain && (resolvedNftUri.includes("data:application/json;base64,") || resolvedNftUri.startsWith("{"))) {
      const encodedJson = isEncoded ? atob(resolvedNftUri.replace("data:application/json;base64,", "")) : resolvedNftUri;
      const decoded = JSON.parse(encodedJson);
      return parseAvatarUri({ uri: getJsonImage(decoded), gatewayUrls });
    }
    let uriTokenId = nft.tokenID;
    if (nft.namespace === "erc1155")
      uriTokenId = uriTokenId.replace("0x", "").padStart(64, "0");
    return getMetadataAvatarUri({
      gatewayUrls,
      uri: resolvedNftUri.replace(/(?:0x)?{id}/, uriTokenId)
    });
  }
  var init_parseAvatarRecord = __esm({
    "node_modules/viem/dist/esm/utils/ens/avatar/parseAvatarRecord.js"() {
      init_utils3();
    }
  });

  // node_modules/viem/dist/esm/actions/ens/getEnsText.js
  async function getEnsText(client, { blockNumber, blockTag, name: name2, key: key2, universalResolverAddress: universalResolverAddress_ }) {
    let universalResolverAddress = universalResolverAddress_;
    if (!universalResolverAddress) {
      if (!client.chain)
        throw new Error("client chain not configured. universalResolverAddress is required.");
      universalResolverAddress = getChainContractAddress({
        blockNumber,
        chain: client.chain,
        contract: "ensUniversalResolver"
      });
    }
    const res = await readContract(client, {
      address: universalResolverAddress,
      abi: universalResolverAbi,
      functionName: "resolve",
      args: [
        toHex(packetToBytes(name2)),
        encodeFunctionData({
          abi: textResolverAbi,
          functionName: "text",
          args: [namehash(name2), key2]
        })
      ],
      blockNumber,
      blockTag
    });
    if (res[0] === "0x")
      return null;
    const record = decodeFunctionResult({
      abi: textResolverAbi,
      functionName: "text",
      data: res[0]
    });
    return record === "" ? null : record;
  }
  var init_getEnsText = __esm({
    "node_modules/viem/dist/esm/actions/ens/getEnsText.js"() {
      init_abis();
      init_decodeFunctionResult();
      init_encodeFunctionData();
      init_chain2();
      init_toHex();
      init_namehash();
      init_packetToBytes();
      init_readContract();
    }
  });

  // node_modules/viem/dist/esm/actions/ens/getEnsAvatar.js
  async function getEnsAvatar(client, { blockNumber, blockTag, gatewayUrls, name: name2, universalResolverAddress }) {
    const record = await getEnsText(client, {
      blockNumber,
      blockTag,
      key: "avatar",
      name: name2,
      universalResolverAddress
    });
    if (!record)
      return null;
    try {
      return await parseAvatarRecord(client, { record, gatewayUrls });
    } catch {
      return null;
    }
  }
  var init_getEnsAvatar = __esm({
    "node_modules/viem/dist/esm/actions/ens/getEnsAvatar.js"() {
      init_parseAvatarRecord();
      init_getEnsText();
    }
  });

  // node_modules/@noble/curves/esm/abstract/utils.js
  function equalBytes(b1, b22) {
    if (b1.length !== b22.length)
      return false;
    for (let i7 = 0; i7 < b1.length; i7++)
      if (b1[i7] !== b22[i7])
        return false;
    return true;
  }
  var _0n2, _1n2, _2n2, hexes3;
  var init_utils4 = __esm({
    "node_modules/@noble/curves/esm/abstract/utils.js"() {
      _0n2 = BigInt(0);
      _1n2 = BigInt(1);
      _2n2 = BigInt(2);
      hexes3 = Array.from({ length: 256 }, (v6, i7) => i7.toString(16).padStart(2, "0"));
    }
  });

  // node_modules/viem/dist/esm/utils/ens/labelhash.js
  function labelhash(label) {
    const result = new Uint8Array(32).fill(0);
    if (!label)
      return bytesToHex(result);
    return keccak256(stringToBytes(label));
  }
  var init_labelhash = __esm({
    "node_modules/viem/dist/esm/utils/ens/labelhash.js"() {
      init_toBytes();
      init_toHex();
      init_keccak256();
    }
  });

  // node_modules/@adraffy/ens-normalize/dist/index.js
  function decode_arithmetic(bytes3) {
    let pos = 0;
    function u16() {
      return bytes3[pos++] << 8 | bytes3[pos++];
    }
    let symbol_count = u16();
    let total = 1;
    let acc = [0, 1];
    for (let i7 = 1; i7 < symbol_count; i7++) {
      acc.push(total += u16());
    }
    let skip = u16();
    let pos_payload = pos;
    pos += skip;
    let read_width = 0;
    let read_buffer = 0;
    function read_bit() {
      if (read_width == 0) {
        read_buffer = read_buffer << 8 | bytes3[pos++];
        read_width = 8;
      }
      return read_buffer >> --read_width & 1;
    }
    const N17 = 31;
    const FULL = 2 ** N17;
    const HALF = FULL >>> 1;
    const QRTR = HALF >> 1;
    const MASK = FULL - 1;
    let register = 0;
    for (let i7 = 0; i7 < N17; i7++)
      register = register << 1 | read_bit();
    let symbols = [];
    let low = 0;
    let range = FULL;
    while (true) {
      let value = Math.floor(((register - low + 1) * total - 1) / range);
      let start = 0;
      let end = symbol_count;
      while (end - start > 1) {
        let mid = start + end >>> 1;
        if (value < acc[mid]) {
          end = mid;
        } else {
          start = mid;
        }
      }
      if (start == 0)
        break;
      symbols.push(start);
      let a6 = low + Math.floor(range * acc[start] / total);
      let b7 = low + Math.floor(range * acc[start + 1] / total) - 1;
      while (((a6 ^ b7) & HALF) == 0) {
        register = register << 1 & MASK | read_bit();
        a6 = a6 << 1 & MASK;
        b7 = b7 << 1 & MASK | 1;
      }
      while (a6 & ~b7 & QRTR) {
        register = register & HALF | register << 1 & MASK >>> 1 | read_bit();
        a6 = a6 << 1 ^ HALF;
        b7 = (b7 ^ HALF) << 1 | HALF | 1;
      }
      low = a6;
      range = 1 + b7 - a6;
    }
    let offset = symbol_count - 4;
    return symbols.map((x4) => {
      switch (x4 - offset) {
        case 3:
          return offset + 65792 + (bytes3[pos_payload++] << 16 | bytes3[pos_payload++] << 8 | bytes3[pos_payload++]);
        case 2:
          return offset + 256 + (bytes3[pos_payload++] << 8 | bytes3[pos_payload++]);
        case 1:
          return offset + bytes3[pos_payload++];
        default:
          return x4 - 1;
      }
    });
  }
  function read_payload(v6) {
    let pos = 0;
    return () => v6[pos++];
  }
  function read_compressed_payload(s7) {
    return read_payload(decode_arithmetic(unsafe_atob(s7)));
  }
  function unsafe_atob(s7) {
    let lookup = [];
    [..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"].forEach((c9, i7) => lookup[c9.charCodeAt(0)] = i7);
    let n9 = s7.length;
    let ret = new Uint8Array(6 * n9 >> 3);
    for (let i7 = 0, pos = 0, width = 0, carry = 0; i7 < n9; i7++) {
      carry = carry << 6 | lookup[s7.charCodeAt(i7)];
      width += 6;
      if (width >= 8) {
        ret[pos++] = carry >> (width -= 8);
      }
    }
    return ret;
  }
  function signed(i7) {
    return i7 & 1 ? ~i7 >> 1 : i7 >> 1;
  }
  function read_deltas(n9, next) {
    let v6 = Array(n9);
    for (let i7 = 0, x4 = 0; i7 < n9; i7++)
      v6[i7] = x4 += signed(next());
    return v6;
  }
  function read_sorted(next, prev = 0) {
    let ret = [];
    while (true) {
      let x4 = next();
      let n9 = next();
      if (!n9)
        break;
      prev += x4;
      for (let i7 = 0; i7 < n9; i7++) {
        ret.push(prev + i7);
      }
      prev += n9 + 1;
    }
    return ret;
  }
  function read_sorted_arrays(next) {
    return read_array_while(() => {
      let v6 = read_sorted(next);
      if (v6.length)
        return v6;
    });
  }
  function read_mapped(next) {
    let ret = [];
    while (true) {
      let w8 = next();
      if (w8 == 0)
        break;
      ret.push(read_linear_table(w8, next));
    }
    while (true) {
      let w8 = next() - 1;
      if (w8 < 0)
        break;
      ret.push(read_replacement_table(w8, next));
    }
    return ret.flat();
  }
  function read_array_while(next) {
    let v6 = [];
    while (true) {
      let x4 = next(v6.length);
      if (!x4)
        break;
      v6.push(x4);
    }
    return v6;
  }
  function read_transposed(n9, w8, next) {
    let m6 = Array(n9).fill().map(() => []);
    for (let i7 = 0; i7 < w8; i7++) {
      read_deltas(n9, next).forEach((x4, j7) => m6[j7].push(x4));
    }
    return m6;
  }
  function read_linear_table(w8, next) {
    let dx = 1 + next();
    let dy = next();
    let vN = read_array_while(next);
    let m6 = read_transposed(vN.length, 1 + w8, next);
    return m6.flatMap((v6, i7) => {
      let [x4, ...ys2] = v6;
      return Array(vN[i7]).fill().map((_8, j7) => {
        let j_dy = j7 * dy;
        return [x4 + j7 * dx, ys2.map((y11) => y11 + j_dy)];
      });
    });
  }
  function read_replacement_table(w8, next) {
    let n9 = 1 + next();
    let m6 = read_transposed(n9, 1 + w8, next);
    return m6.map((v6) => [v6[0], v6.slice(1)]);
  }
  function hex_cp(cp) {
    return cp.toString(16).toUpperCase().padStart(2, "0");
  }
  function quote_cp(cp) {
    return `{${hex_cp(cp)}}`;
  }
  function explode_cp(s7) {
    let cps = [];
    for (let pos = 0, len = s7.length; pos < len; ) {
      let cp = s7.codePointAt(pos);
      pos += cp < 65536 ? 1 : 2;
      cps.push(cp);
    }
    return cps;
  }
  function str_from_cps(cps) {
    const chunk = 4096;
    let len = cps.length;
    if (len < chunk)
      return String.fromCodePoint(...cps);
    let buf = [];
    for (let i7 = 0; i7 < len; ) {
      buf.push(String.fromCodePoint(...cps.slice(i7, i7 += chunk)));
    }
    return buf.join("");
  }
  function unpack_cc(packed) {
    return packed >> 24 & 255;
  }
  function unpack_cp(packed) {
    return packed & 16777215;
  }
  function is_hangul(cp) {
    return cp >= S0 && cp < S1;
  }
  function compose_pair(a6, b7) {
    if (a6 >= L0 && a6 < L1 && b7 >= V0 && b7 < V1) {
      return S0 + (a6 - L0) * N_COUNT + (b7 - V0) * T_COUNT;
    } else if (is_hangul(a6) && b7 > T0 && b7 < T1 && (a6 - S0) % T_COUNT == 0) {
      return a6 + (b7 - T0);
    } else {
      let recomp = RECOMP.get(a6);
      if (recomp) {
        recomp = recomp.get(b7);
        if (recomp) {
          return recomp;
        }
      }
      return -1;
    }
  }
  function decomposed(cps) {
    let ret = [];
    let buf = [];
    let check_order = false;
    function add4(cp) {
      let cc = SHIFTED_RANK.get(cp);
      if (cc) {
        check_order = true;
        cp |= cc;
      }
      ret.push(cp);
    }
    for (let cp of cps) {
      while (true) {
        if (cp < 128) {
          ret.push(cp);
        } else if (is_hangul(cp)) {
          let s_index = cp - S0;
          let l_index = s_index / N_COUNT | 0;
          let v_index = s_index % N_COUNT / T_COUNT | 0;
          let t_index = s_index % T_COUNT;
          add4(L0 + l_index);
          add4(V0 + v_index);
          if (t_index > 0)
            add4(T0 + t_index);
        } else {
          let mapped = DECOMP.get(cp);
          if (mapped) {
            buf.push(...mapped);
          } else {
            add4(cp);
          }
        }
        if (!buf.length)
          break;
        cp = buf.pop();
      }
    }
    if (check_order && ret.length > 1) {
      let prev_cc = unpack_cc(ret[0]);
      for (let i7 = 1; i7 < ret.length; i7++) {
        let cc = unpack_cc(ret[i7]);
        if (cc == 0 || prev_cc <= cc) {
          prev_cc = cc;
          continue;
        }
        let j7 = i7 - 1;
        while (true) {
          let tmp = ret[j7 + 1];
          ret[j7 + 1] = ret[j7];
          ret[j7] = tmp;
          if (!j7)
            break;
          prev_cc = unpack_cc(ret[--j7]);
          if (prev_cc <= cc)
            break;
        }
        prev_cc = unpack_cc(ret[i7]);
      }
    }
    return ret;
  }
  function composed_from_decomposed(v6) {
    let ret = [];
    let stack = [];
    let prev_cp = -1;
    let prev_cc = 0;
    for (let packed of v6) {
      let cc = unpack_cc(packed);
      let cp = unpack_cp(packed);
      if (prev_cp == -1) {
        if (cc == 0) {
          prev_cp = cp;
        } else {
          ret.push(cp);
        }
      } else if (prev_cc > 0 && prev_cc >= cc) {
        if (cc == 0) {
          ret.push(prev_cp, ...stack);
          stack.length = 0;
          prev_cp = cp;
        } else {
          stack.push(cp);
        }
        prev_cc = cc;
      } else {
        let composed = compose_pair(prev_cp, cp);
        if (composed >= 0) {
          prev_cp = composed;
        } else if (prev_cc == 0 && cc == 0) {
          ret.push(prev_cp);
          prev_cp = cp;
        } else {
          stack.push(cp);
          prev_cc = cc;
        }
      }
    }
    if (prev_cp >= 0) {
      ret.push(prev_cp, ...stack);
    }
    return ret;
  }
  function nfd(cps) {
    return decomposed(cps).map(unpack_cp);
  }
  function nfc(cps) {
    return composed_from_decomposed(decomposed(cps));
  }
  function read_set() {
    return new Set(read_sorted(r$1));
  }
  function read_chunked() {
    return new Set([read_sorted(r$1).map((i7) => CHUNKS[i7]), read_sorted(r$1)].flat(2));
  }
  function read_emoji_trie(cps) {
    let B10 = read_array_while(() => {
      let keys2 = read_sorted(r$1).map((i7) => EMOJI_SORTED[i7]);
      if (keys2.length)
        return read_emoji_trie(keys2);
    }).sort((a6, b7) => b7.Q.size - a6.Q.size);
    let temp = r$1();
    let V9 = temp % 3;
    temp = temp / 3 | 0;
    let F8 = temp & 1;
    temp >>= 1;
    let S12 = temp & 1;
    let C6 = temp & 2;
    return { B: B10, V: V9, F: F8, S: S12, C: C6, Q: new Set(cps) };
  }
  function safe_str_from_cps(cps, quoter = quote_cp) {
    let buf = [];
    if (is_combining_mark(cps[0]))
      buf.push("\u25CC");
    let prev = 0;
    let n9 = cps.length;
    for (let i7 = 0; i7 < n9; i7++) {
      let cp = cps[i7];
      if (should_escape(cp)) {
        buf.push(str_from_cps(cps.slice(prev, i7)));
        buf.push(quoter(cp));
        prev = i7 + 1;
      }
    }
    buf.push(str_from_cps(cps.slice(prev, n9)));
    return buf.join("");
  }
  function quoted_cp(cp) {
    return (should_escape(cp) ? "" : `${bidi_qq(safe_str_from_cps([cp]))} `) + quote_cp(cp);
  }
  function bidi_qq(s7) {
    return `"${s7}"\u200E`;
  }
  function check_label_extension(cps) {
    if (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {
      throw new Error("invalid label extension");
    }
  }
  function check_leading_underscore(cps) {
    const UNDERSCORE2 = 95;
    for (let i7 = cps.lastIndexOf(UNDERSCORE2); i7 > 0; ) {
      if (cps[--i7] !== UNDERSCORE2) {
        throw new Error("underscore allowed only at start");
      }
    }
  }
  function check_fenced(cps) {
    let cp = cps[0];
    let prev = FENCED.get(cp);
    if (prev)
      throw error_placement(`leading ${prev}`);
    let n9 = cps.length;
    let last = -1;
    for (let i7 = 1; i7 < n9; i7++) {
      cp = cps[i7];
      let match = FENCED.get(cp);
      if (match) {
        if (last == i7)
          throw error_placement(`${prev} + ${match}`);
        last = i7 + 1;
        prev = match;
      }
    }
    if (last == n9)
      throw error_placement(`trailing ${prev}`);
  }
  function is_combining_mark(cp) {
    return CM.has(cp);
  }
  function should_escape(cp) {
    return ESCAPE.has(cp);
  }
  function ens_normalize(name2) {
    return flatten(ens_split(name2));
  }
  function ens_split(name2, preserve_emoji) {
    let offset = 0;
    return name2.split(STOP_CH).map((label) => {
      let input = explode_cp(label);
      let info = {
        input,
        offset
        // codepoint, not substring!
      };
      offset += input.length + 1;
      let norm;
      try {
        let tokens = info.tokens = process2(input, nfc);
        let token_count = tokens.length;
        let type;
        if (!token_count) {
          throw new Error(`empty label`);
        } else {
          let chars = tokens[0];
          let emoji = token_count > 1 || chars.is_emoji;
          if (!emoji && chars.every((cp) => cp < 128)) {
            norm = chars;
            check_leading_underscore(norm);
            check_label_extension(norm);
            type = "ASCII";
          } else {
            if (emoji) {
              info.emoji = true;
              chars = tokens.flatMap((x4) => x4.is_emoji ? [] : x4);
            }
            norm = tokens.flatMap((x4) => !preserve_emoji && x4.is_emoji ? filter_fe0f(x4) : x4);
            check_leading_underscore(norm);
            if (!chars.length) {
              type = "Emoji";
            } else {
              if (CM.has(norm[0]))
                throw error_placement("leading combining mark");
              for (let i7 = 1; i7 < token_count; i7++) {
                let cps = tokens[i7];
                if (!cps.is_emoji && CM.has(cps[0])) {
                  throw error_placement(`emoji + combining mark: "${str_from_cps(tokens[i7 - 1])} + ${safe_str_from_cps([cps[0]])}"`);
                }
              }
              check_fenced(norm);
              let unique = [...new Set(chars)];
              let [g7] = determine_group(unique);
              check_group(g7, chars);
              check_whole(g7, unique);
              type = g7.N;
            }
          }
        }
        info.type = type;
      } catch (err) {
        info.error = err;
      }
      info.output = norm;
      return info;
    });
  }
  function check_whole(group, unique) {
    let maker;
    let shared = [];
    for (let cp of unique) {
      let whole = WHOLE_MAP.get(cp);
      if (whole === UNIQUE_PH)
        return;
      if (whole) {
        let set2 = whole.M.get(cp);
        maker = maker ? maker.filter((g7) => set2.has(g7)) : [...set2];
        if (!maker.length)
          return;
      } else {
        shared.push(cp);
      }
    }
    if (maker) {
      for (let g7 of maker) {
        if (shared.every((cp) => g7.V.has(cp))) {
          throw new Error(`whole-script confusable: ${group.N}/${g7.N}`);
        }
      }
    }
  }
  function determine_group(unique) {
    let groups = GROUPS;
    for (let cp of unique) {
      let gs3 = groups.filter((g7) => g7.V.has(cp));
      if (!gs3.length) {
        if (groups === GROUPS) {
          throw error_disallowed(cp);
        } else {
          throw error_group_member(groups[0], cp);
        }
      }
      groups = gs3;
      if (gs3.length == 1)
        break;
    }
    return groups;
  }
  function flatten(split2) {
    return split2.map(({ input, error, output: output2 }) => {
      if (error) {
        let msg = error.message;
        throw new Error(split2.length == 1 ? msg : `Invalid label ${bidi_qq(safe_str_from_cps(input))}: ${msg}`);
      }
      return str_from_cps(output2);
    }).join(STOP_CH);
  }
  function error_disallowed(cp) {
    return new Error(`disallowed character: ${quoted_cp(cp)}`);
  }
  function error_group_member(g7, cp) {
    let quoted = quoted_cp(cp);
    let gg = GROUPS.find((g8) => g8.P.has(cp));
    if (gg) {
      quoted = `${gg.N} ${quoted}`;
    }
    return new Error(`illegal mixture: ${g7.N} + ${quoted}`);
  }
  function error_placement(where) {
    return new Error(`illegal placement: ${where}`);
  }
  function check_group(g7, cps) {
    let { V: V9, M: M7 } = g7;
    for (let cp of cps) {
      if (!V9.has(cp)) {
        throw error_group_member(g7, cp);
      }
    }
    if (M7) {
      let decomposed2 = nfd(cps);
      for (let i7 = 1, e9 = decomposed2.length; i7 < e9; i7++) {
        if (NSM.has(decomposed2[i7])) {
          let j7 = i7 + 1;
          for (let cp; j7 < e9 && NSM.has(cp = decomposed2[j7]); j7++) {
            for (let k6 = i7; k6 < j7; k6++) {
              if (decomposed2[k6] == cp) {
                throw new Error(`non-spacing marks: repeated ${quoted_cp(cp)}`);
              }
            }
          }
          if (j7 - i7 > NSM_MAX) {
            throw new Error(`non-spacing marks: too many ${bidi_qq(safe_str_from_cps(decomposed2.slice(i7 - 1, j7)))} (${j7 - i7}/${NSM_MAX})`);
          }
          i7 = j7;
        }
      }
    }
  }
  function process2(input, nf) {
    let ret = [];
    let chars = [];
    input = input.slice().reverse();
    while (input.length) {
      let emoji = consume_emoji_reversed(input);
      if (emoji) {
        if (chars.length) {
          ret.push(nf(chars));
          chars = [];
        }
        ret.push(emoji);
      } else {
        let cp = input.pop();
        if (VALID.has(cp)) {
          chars.push(cp);
        } else {
          let cps = MAPPED.get(cp);
          if (cps) {
            chars.push(...cps);
          } else if (!IGNORED.has(cp)) {
            throw error_disallowed(cp);
          }
        }
      }
    }
    if (chars.length) {
      ret.push(nf(chars));
    }
    return ret;
  }
  function filter_fe0f(cps) {
    return cps.filter((cp) => cp != FE0F);
  }
  function consume_emoji_reversed(cps, eaten) {
    let node = EMOJI_ROOT;
    let emoji;
    let saved;
    let stack = [];
    let pos = cps.length;
    if (eaten)
      eaten.length = 0;
    while (pos) {
      let cp = cps[--pos];
      node = node.B.find((x4) => x4.Q.has(cp));
      if (!node)
        break;
      if (node.S) {
        saved = cp;
      } else if (node.C) {
        if (cp === saved)
          break;
      }
      stack.push(cp);
      if (node.F) {
        stack.push(FE0F);
        if (pos > 0 && cps[pos - 1] == FE0F)
          pos--;
      }
      if (node.V) {
        emoji = conform_emoji_copy(stack, node);
        if (eaten)
          eaten.push(...cps.slice(pos).reverse());
        cps.length = pos;
      }
    }
    return emoji;
  }
  function conform_emoji_copy(cps, node) {
    let copy = Emoji.from(cps);
    if (node.V == 2)
      copy.splice(1, 1);
    return copy;
  }
  var r$1, FENCED, NSM_MAX, r, SHIFTED_RANK, EXCLUSIONS, DECOMP, RECOMP, S0, L0, V0, T0, L_COUNT, V_COUNT, T_COUNT, N_COUNT, S_COUNT, S1, L1, V1, T1, FE0F, STOP_CH, UNIQUE_PH, HYPHEN, MAPPED, IGNORED, CM, NSM, ESCAPE, NFC_CHECK, CHUNKS, UNRESTRICTED, GROUPS, WHOLE_VALID, WHOLE_MAP, union, multi, VALID, EMOJI_SORTED, EMOJI_ROOT, Emoji;
  var init_dist = __esm({
    "node_modules/@adraffy/ens-normalize/dist/index.js"() {
      r$1 = read_compressed_payload("AEgSbwjEDVYByQKaAQsBOQDpATQAngDUAHsAoABoANQAagCNAEQAhABMAHIAOwA9ACsANgAmAGIAHgAvACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGAAeABMAFwAXAA0ADgAWAA8AFAAVBFsF1QEXE0o3xAXUALIArkABaACmAgPGAK6AMDAwMAE/qAYK7P4HQAblMgVYBVkAPSw5Afa3EgfJwgAPA8meNALGCjACjqIChtk/j2+KAsXMAoPzASDgCgDyrgFCAi6OCkCQAOQA4woWABjVuskNDD6eBBx4AP4COhi+D+wKBirqBgSCaA0cBy4ArABqku+mnIAAXAaUJAbqABwAPAyUFvyp/Mo8INAIvCoDshQ8APcubKQAon4ZABgEJtgXAR4AuhnOBPsKIE04CZgJiR8cVlpM5INDABQADQAWAA9sVQAiAA8ASO8W2T30OVnKluYvChEeX05ZPe0AFAANABYAD2wgXUCYAMPsABwAOgzGFryp/AHauQVcBeMC0KACxLEKTR2kZhR0Gm5M9gC8DmgC4gAMLjSKF8qSAoF8ARMcAL4OaALiAAwuAUlQJpJMCwMt/AUpCthqGK4B2EQAciwSeAIyFiIDKCi6OGwAOuIB9iYAyA7MtgEcZIIAsgYABgCK1EoFHNZsGACoKNIBogAAAAAAKy4DnABoAQoaPu43dQQZGACrAcgCIgDgLBJ0OvRQsTOiKDVJBfsoBVoFWbC5BWo7XkITO1hCmHuUZmCh+QwUA8YIJvJ4JASkTAJUVAJ2HKwoAZCkpjZcA0YYBIRiCgDSBqxAMCQHKgI6XgBsAWIgcgCEHhoAlgFKuAAoahgBsMYDOC4iRFQBcFoGZgJmAPJKGAMqAgYASkIArABeAHQALLYGCPTwGo6AAAAKIgAqALQcSAHSAdwIDDKXeYHpAAsAEgA1AD4AOTR3etTBEGAQXQJNCkxtOxUMAq0PpwvmERYM0irM09kANKoH7ANUB+wDVANUB+wH7ANUB+wDVANUA1QDVBwL8BvUwRBgD0kEbgWPBYwE1wiEJkoRggcpCNNUDnQfHEgDRgD9IyZJHTuUMwwlQ0wNTQQH/TZDbKh9OQNIMaxU9pCjA8wyUDltAh5yEqEAKw90HTW2Tn96SHGhCkxPr7WASWNOaAK/Oqk/+QoiCZRvvHdPBj4QGCeiEPQMMAGyATgN6kvVBO4GOATGH3oZFg/KlZkIoi3aDOom4C6egFcj8iqABepL8TzaC0pRZQ9WC2IJ4DpggUsDHgEKIogK2g02CGoQ8ArGaA3iEUIHNgPSSZcAogb+Cw4dMhWyJg1iqQsGOXQG+BrzC4wmrBMmevkF0BoeBkoBJhr8AMwu5IWtWi5cGU9cBgALIiPEFKVQHQ0iQLR4RRoYBxIlpgKOQ21KhFEzHpAh8zw6DWMuEFF5B/I8AhlMC348m0aoRQsRzz6KPUUiRkwpBDJ8LCwniAnMD4IMtnxvAVYJHgmuDG4TLhEUN8IINgcWKpchJxIIHkaSYJcE9JwD8BPOAwgFPAk+BxADshwqEysVJgUKgSHUAvA20i6wAoxWfQEUBcgPIh/cEE1H3Q7mCJgCYgOAJegAKhUeABQimAhAYABcj9VTAi7ICMRqaSNxA2QU5F4RcAeODlQHpBwwFbwc3nDFXgiGBSigrAlYAXIJlgFcBOAIBjVYjJ0gPmdQi1UYmCBeQTxd+QIuDGIVnES6h3UCiA9oEhgBMgFwBzYM/gJ0EeoRaBCSCOiGATWyM/U6IgRMIYAgDgokA0xsywskJvYM9WYBoBJfAwk0OnfrZ6hgsyEX+gcWMsJBXSHuC49PygyZGr4YP1QrGeEHvAPwGvAn50FUBfwDoAAQOkoz6wS6C2YIiAk8AEYOoBQH1BhnCm6MzQEuiAG0lgNUjoACbIwGNAcIAGQIhAV24gAaAqQIoAACAMwDVAA2AqoHmgAWAII+AToDJCwBHuICjAOQCC7IAZIsAfAmBBjADBIA9DRuRwLDrgKAZ2afBdpVAosCRjIBSiIEAktETgOsbt4A2ABIBhDcRAESqEfIF+BAAdxsKADEAPgAAjIHAj4BygHwagC0AVwLLgmfsLIBSuYmAIAAEmgB1AKGANoAMgB87gFQAEoFVvYF0AJMRgEOLhUoVF4BuAMcATABCgB2BsiKosYEHARqB9ACEBgV3gLvKweyAyLcE8pCwgK921IAMhMKNQqkCqNgWF0wAy5vPU0ACx+lPsQ/SwVOO1A7VTtQO1U7UDtVO1A7VTtQO1UDlLzfvN8KaV9CYegMow3RRMU6RhPYYE5gLxPFLbQUvhXLJVMZOhq5JwIl4VUGDwEt0GYtCCk0che5ADwpZYM+Y4MeLQpIHORTjlT1LRgArkufM6wNqRsSRD0FRHXqYicWCwofAmR+AmI/WEqsWDcdAqH0AmiVAmYGAp+BOBgIAmY4AmYjBGsEfAN/EAN+jzkDOXQUOX86ICACbBoCMjM4BwJtxAJtq+yHMGRCKAFkANsA3gBHAgeVDIoA+wi/AAqyAncsAnafPAJ5SEACeLcaWdhFq0bwAnw8AnrFAn0GAnztR/1IemAhACgSSVVKWBIUSskC0P4C0MlLJAOITAOH40TCkS8C8p5dAAMDq0vLTCoiAMxNSU2sAos8AorVvhgEGkBkArQCjjQCjlk9lH4CjtYCjll1UbFTMgdS0VSCApP4ApMJAOYAGVUbVaxVzQMsGCmSgzLeeGNFODYCl5wC769YHqUAViIClowClnmZAKZZqVoGfkoAOAKWsgKWS1xBXM4CmcgCmWFcx10EFgKcmDm/OpoCnBMCn5gCnrWHABoMLicMAp3uAp6PALI6YTFh7AKe0AKgawGmAp6cHAKeS6JjxWQkIigCJ6wCJnsCoPgCoEnUAqYsAqXLAqf8AHoCp+9oeWiuAABGahlqzgKs4AKsqwKtZAKs/wJXGgJV2QKx3tQDH0tslAKyugoCsuUUbN1tYG1FXAMlygK2WTg8bo0DKUICuFsCuUQSArkndHAzcN4CvRYDLa8DMg4CvoVx/wMzbgK+F3Mfc0wCw8gCwwFzf3RIMkJ03QM8pAM8lwM9vALFeQLGRALGDYYCyGZOAshBAslMAskrAmSaAt3PeHZeeKt5IkvNAxigZv8CYfEZ8JUhewhej164DgLPaALPaSxIUM/wEJwAw6oCz3ABJucDTg9+SAIC3CQC24cC0kwDUlkDU1wA/gNViYCGPMgT6l1CcoLLg4oC2sQC2duEDYRGpzkDhqIALANkC4ZuVvYAUgLfYgLetXB0AuIs7REB8y0kAfSYAfLPhALr8ALpbXYC6vYC6uEA9kQBtgLuhgLrmZanlwAC7jwDhd2YdnDdcZ4C8wAAZgOOE5mQAvcQA5FrA5KEAveVAvnWAvhjmhmaqLg0mxsDnYAC/vcBGAA2nxmfsAMFigOmZwOm1gDOwgMGZ6GFogIGAwxGAQwBHAdqBl62ZAIAuARovA6IHrAKABRyNgAgAzASSgOGfAFgJB4AjOwAHgDmoAScjgi0BhygwgCoBRK86h4+PxZ5BWk4P0EsQiJCtV9yEl+9AJbGBTMAkE0am7o7J2AzErrQDjAYxxiKyfcFWAVZBVgFWQVkBVkFWAVZBVgFWQVYBVkFWAVZRxYI2IZoAwMDCmVe6iwEygOyBjC8vAC8BKi8AOhBKhazBUc+aj5xQkBCt192OF/pAFgSM6wAjP/MbMv9puhGez4nJAUsFyg3Nn5u32vB8hnDLGoBbNdvMRgFYAVrycLJuQjQSlwBAQEKfV5+jL8AND+CAAQW0gbmriQGAIzEDAMCDgDlZh4+JSBLQrJCvUI5JF8oYDcoOSQJwj4KRT9EPnk+gj5xPnICikK9SkM8X8xPUGtOCy1sVTBrDG8gX+E0OxwJaJwKYyQsPR4nQqxCvSzMAsv9X8oPIC8KCQoAACN+nt9rOy5LGMmsya0JZsLMzQphQWAP5hCkEgCTjh5GQiYbqm06zjkKND9EPnFCQBwICx5NSG1cLS5a4rwTCn7uHixCQBxeCUsKDzRVREM4BTtEnC0KghwuQkAb9glUIyQZMTIBBo9i8F8KcmTKYAxgLiRvAERgGjoDHB9gtAcDbBFmT2BOEgIAZOhgFmCWYH5gtGBMYJJpFhgGtg/cVqq8WwtDF6wBvCzOwgMgFgEdBB8BegJtMDGWU4EBiwq5SBsA5SR0jwvLDqdN6wGcAoidUAVBYAD4AD4LATUXWHsMpg0lILuwSABQDTUAFhO4NVUC0wxLZhEcANlPBnYECx9bADIAtwKbKAsWcKwzOaAaAVwBhwn9A9ruEAarBksGugAey1aqWwq7YhOKCy1ADrwBvAEjA0hbKSkpIR8gIi0TJwciDY4AVQJvWJFKlgJvIA9ySAHUdRDPUiEaqrFN6wcSBU1gAPgAPgsBewAHJW0LiAymOTEuyLBXDgwAYL0MAGRKaFAiIhzAADIAtwKbKC08D88CkRh8ULxYyXRzjtilnA72mhU+G+0S2hIHDxwByAk7EJQGESwNNwwAPAC0zwEDAKUA4gCbizAAFQBcG8cvbXcrDsIRAzwlRNTiHR8MG34CfATCC6vxbQA4Oi4Opzkuz6IdB7wKABA7Ls8SGgB9rNsdD7wbSBzOoncfAT4qYB0C7KAJBE3z5R9mDL0M+wg9Cj8ABcELPgJMDbwIvQ09CT0KvS7PoisOvAaYAhwPjBriBBwLvBY8AKELPBC8BRihe90AO2wMPQACpwm9BRzR9QYFB2/LBnwAB7wSXBISvQECAOsCAAB1FVwHFswV/HAXvBg8AC68AuyovAAevAJWISuAAAG8AALkFT0VvCvso7zJqDwEAp8nTAACXADn3hm8CaVcD7/FAPUafAiiBQv/cQDfvKe8GNwavKOMeXMG/KmchAASvAcbDAADlABtvAcAC7ynPAIaPLsIopzLDvwHwak8AOF8L7dtvwNJAAPsABW8AAb8AAm8AGmMABq8AA68Axi8jmoV/AABXAAObAAuTB8ABrwAF7wIIgANSwC6vCcAA7wADpwq7ACyWwAcHAAbvAAB7AqiAAXHCxYV3AAHnABCvAEDAGm8AAt8AB28AAi8CaIABcsAbqAZ1gCSCCIABcsAATwAB9wAHZwIIgAGmwAJfAAbLABtHADmvIEACFwACDwAFLwAaPwJIgAGywDjjAAJPAuiDsX7YAAHPABunUBJAEgACrwFAAM8AAmuAzgABxwAGXwAAgym/AAKHAAKPAAJ/KfsBrwACRwAAwwAEDwBABQ8ABFsAA+MAA3sAA28ABkMBxYcABU8AG6cFrQBvAC7ABM8BABpLAsA4UwAAjwABFMAF3wFHAAG0QAYvB8BfClTADpGALAJBw4McwApK3EBpQYIXwJtJA0ACghwTG1gK4oggRVjLjcDogq1AALZABcC/ARvAXdzSFMVIgNQAhY/AS0GBHRHvnxTe0EAKgAyAvwAVAvcAHyRLQEsAHfmDhIzRwJLAFgGAAJRAQiLzQB5PAQhpgBbANcWAJZpOCCMAM5ssgDQ1RcJw3Z0HBlXHgrSAYmRrCNUVE5JEz3DivoAgB04QSos4RKYUABzASosMSlDGhADMVYE+MbvAExm3QBrAnICQBF7Osh4LzXWBhETIAUVCK6v/xPNACYAAQIbAIYAiQCONgDjALQA1QCdPQC7AKsApgChAOcAnwDTAJwA4AEBAPwAwAB6AFsAywDNAPwA1wDrAIkAogEqAOMA2ADVBAIIKzTT09PTtb/bzM/NQjEWAUsBVS5GAVMBYgFhAVQBRUpCRGcMAUwUBgkEMzcMBwAgDSQmKCs3OTk8PDw9Pg0/HVBQUFBSUlFSKFNUVlVVHFxgYF9hYCNlZ29ucXFxcXFxc3Nzc3Nzc3Nzc3N1dXZ1dFsAPesAQgCTAHEAKwBf8QCHAFAAUAAwAm/oAIT+8fEAXQCM6wCYAEgAWwBd+PipAH4AfgBiAE8AqgAdAK8AfAI5AjwA9QDgAPcA9wDhAPgA4gDiAOEA3wAoAnQBSgE5ATcBTQE3ATcBNwEyATEBMQExARUBURAAKgkBAEwYCxcEFhcPAIcAjwCfAEoAYxkCKgBvAGgAkAMOAyArAxpCP0gqAIoCSADAAlACnQC5Ao8CjwKPAo8CjwKPAoQCjwKPAo8CjwKPAo8CjgKOApECmQKQAo8CjwKNAo0CjQKNAosCjgJuAc0CkAKYAo8CjwKOF3oMAPcGA5gCWgIzGAFNETYC2xILLBQBRzgUTpIBdKU9AWJaAP4DOkgA/wCSKh4ZkGsAKmEAagAvAIoDlcyM8K+FWwa7LA/DEgKe1nUrCwQkWwGzAN5/gYB/gX+Cg4N/hIeFf4aJh4GIg4mDin+Lf4x/jYuOf49/kIORf5J/k3+Uf5WElomXg5h/AIMloQCEBDwEOQQ7BD4EPARCBD8EOgRABEIEQQQ9BD8EQgCkA4gAylIA0AINAPdbAPcBGgD3APUA9QD2APXVhSRmvwD3APUA9QD2APUdAIpbAPcAigEaAPcAigLtAPcAitWFJGa/HQD4WwEaAPcA9wD1APUA9gD1APgA9QD1APYA9dWFJGa/HQCKWwEaAPcAigD3AIoC7QD3AIrVhSRmvx0CRAE3AksBOgJMwgOfAu0Dn9WFJGa/HQCKWwEaA58AigOfAIoC7QOfAIrVhSRmvx0EMQCKBDIAigeOMm4hLQCKAT9vBCQA/gDHWwMAVVv/FDMDAIoDPtkASgMAigMAl2dBtv/TrfLzakaPh3aztmIuZQrR3ER2n5Yo+qNR2jK/aP/V04UK1njIJXLgkab9PjOxyJDVbIN3R/FZLoZVl2kYFQIZ7V6LpRqGDt9OdDohnJKp5yX/HLj0voPpLrneDaN11t5W3sSM4ALscgSw8fyWLVkKa/cNcQmjYOgTLZUgOLi2F05g4TR0RfgZ4PBdntxdV3qvdxQt8DeaMMgjJMgwUxYN3tUNpUNx21AvwADDAIa0+raTWaoBXmShAl5AThpMi282o+WzOKMlxjHj7a+DI6AM6VI9w+xyh3Eyg/1XvPmbqjeg2MGXugHt8wW03DQMRTd5iqqOhjLvyOCcKtViGwAHVLyl86KqvxVX7MxSW8HLq6KCrLpB8SspAOHO9IuOwCh9poLoMEha9CHCxlRAXJNDobducWjqhFHqCkzjTM2V9CHslwq4iU19IxqhIFZMve15lDTiMVZIPdADXGxTqzSTv0dDWyk1ht430yvaYCy9qY0MQ3cC5c1uw4mHcTGkMHTAGC99TkNXFAiLQgw9ZWhwKJjGCe+J5FIaMpYhhyUnEgfrF3zEtzn40DdgCIJUJfZ0mo3eXsDwneJ8AYCr7Vx2eHFnt2H6ZEyAHs9JoQ4Lzh5zBoGOGwAz37NOPuqSNmZf51hBEovtpm2T1wI79OBWDyvCFYkONqAKGVYgIL0F+uxTcMLSPtFbiNDbBPFgip8MGDmLLHbSyGXdCMO6f7teiW9EEmorZ+75KzanZwvUySgjoUQBTfHlOIerJs6Y9wLlgDw18AB1ne0tZRNgGjcrqHbtubSUooEpy4hWpDzTSrmvqw0H9AoXQLolMt9eOM+l9RitBB1OBnrdC1XL4yLFyXqZSgZhv7FnnDEXLUeffb4nVDqYTLY6X7gHVaK4ZZlepja2Oe6OhLDI/Ve5SQTCmJdH3HJeb14cw99XsBQAlDy5s5kil2sGezZA3tFok2IsNja7QuFgM30Hff3NGSsSVFYZLOcTBOvlPx8vLhjJrSI7xrNMA/BOzpBIJrdR1+v+zw4RZ7ry6aq4/tFfvPQxQCPDsXlcRvIZYl+E5g3kJ+zLMZon0yElBvEOQTh6SaAdIO6BwdqJqfvgU+e8Y65FQhdiHkZMVt9/39N2jGd26J6cNjq8cQIyp6RonRPgVn2fl89uRDcQ27GacaN0MPrcNyRlbUWelKfDfyrNVVGBG5sjd3jXzTx06ywyzuWn5jbvEfPPCTbpClkgEu9oPLKICxU5HuDe3jA1XnvU85IYYhaEtOU1YVWYhEFsa4/TQj3rHdsU2da2eVbF8YjSI0m619/8bLMZu3xildwqM7zf1cjn4Whx0PSYXcY5bR7wEQfGC7CTOXwZdmsdTO8q3uGm7Rh/RfCWwpzBHCAaVfjxgibL5vUeL0pH6bzDmI9yCXKC/okkmbc28OJvI87L/bjFzpq0DHepw4kT1Od+fL7cyuFaRgfaUWB2++TCFvz11J0leEtrGkpccfX9z2LY39sph4PBHCjNOOkd0ybUm+ZzS8GkFbqMpq8uiX2yHpa0jllTLfGTDBMYR6FT5FWLLDPMkYxt1Q0eyMvxJWztDjy0m6VvZPvamrFXjHmPpU6WxrZqH6WW//I37RwvqPQhPz8I3RPuXAk1C94ZprQWm9iGM/KgiGDO6SV9sjp+Jmk4TBajMNJ5zzWZ1k1jrteQQBp9C2dOvmbIeeEME8y573Q8TgGe+ZCzutM45gYLBzYm2LNvgq2kebAbMpHRDSyh6dQ27GbsAAdCqQVVXWC1C+zpwBM2Lr4eqtobmmu1vJEDlIQR1iN8CUWpztq50z7FFQBn3SKViX6wSqzVQCoYvAjByjeSa+h1PRnYWvBinTDB9cHt4eqDsPS4jcD3FwXJKT0RQsl8EvslI2SFaz2OtmYLFV8FwgvWroZ3fKmh7btewX9tfL2upXsrsqpLJzpzNGyNlnuZyetg7DIOxQTMBR7dqlrTlZ6FWi1g4j1NSjA2j1Yd7fzTH6k9LxCyUCneAKYCU581bnvKih6KJTeTeCX4Zhme/QIz7w2o+AdSgtLAkdrLS9nfweYEqrMLsrGGSWXtgWamAWp6+x6GM/Z8jNw3BqPNQ39hrzYLECn3tPvh/LqKbRSCiDGauDKBBj/kGbpnM1Bb/my8hv4NWStclkwjfl57y4oNDgw1JAG9VOti3QVVoSziMEsSdfEjaCPIDb7SgpLXykQsM+nbqbt97I0mIlzWv0uqFobLMAq8Rd9pszUBKxFhBPwOjf//gVOz2r7URJ2OnpviCXv9iz3a4X/YLBYbXoYwxBv/Kq0a5s4utQHzoTerJ7PmFW/no/ZAsid/hRIV82tD+Qabh5F1ssIM8Ri3chu0PuPD3sSJRMjDoxLAbwUbroiPAz/V52e8s3DIixxlO7OrvhMj3qfzA0kKxzwicr5wJmZwJxTXgrwYsqhRvpgC2Nfdyd+TYYxJSZgk+gk2g9KyHSlwQVAyPtWWgvVGyVBqsU2LpDlLNosSAtolC1uBKt5pQZLhAxTjeGCWIC/HVpagc5rRwkgpCHKEsjA8d+scp8aiMewwQBhp5dYTV5t/Nvl+HbDMu8F3S0psPyZb1bSnqlHPFUnMQeQqSqwDBT23fJO9gO3aVaa1icrXU0PKwlMM5K+iL3ATcVq2fFWKk0irCTF4LDVDG4gUpkyplq6efcZS+WDR1woApjD18x+2JQR9oOXzuA7uy4b+/91WsJd/tSd1QcAH8PVPXApieA37B7YXPhDPH1azP3PKR+HfHmOoDYLeuKsIi/ssSsdYs62qJo14Hw1P2N/6zpr8F3FTWmJ4ysAVcl84Iv/tl///Z8FaAWbBQbyMNDZjrZ2JwdRjtd1jOeNumSodFtr4/Zf45iRJf/8HSW+KIB/+GlKu8Rv1BPLr/4duoL+kFPRqrstEr41gfJupoJRf4hcYDWX93FOcfEBiIivxtjtV8g7mvOReiamYWKE7vfPbv3v2L9Kwq3cIDFGLyhyfOGuf/9vA5muH6Pjg7B4SUj2ydDXra9fSBI+DrsNHA6l51wfHssJb+11TfNk7B8OleUe3Y+ZmHboMFHdv7FFP2cfISFyeAQR0sk/Xv62HBTdW4HmnGSLFk/cqyWVVFJkdIIa+4hos3JRHcqLoRKM5h2Qtk1RZtzISMtlXTfTqIc77YsCCgQD0r61jtxskCctwJOtjE/pL8wC4LBD4AZFjh2wzzFCrT/PNqW0/DeBbkfMfzVm9yy06WiF+1mTdNNEAytVtohBKg3brWd2VQa+aF+cQ0mW5CvbwOlWCT07liX226PjiVLwFCRs/Ax2/u+ZNPjrNFIWIPf5GjHyUKp60OeXe9F01f7IaPf/SDTvyDAf7LSWWejtiZcsqtWZjrdn6A2MqBwnSeKhrZOlUMmgMionmiCIvXqKZfmhGZ1MwD3uMF4n9KJcfWLA3cL5pq48tm5NDYNh3SS/TKUtmFSlQR89MR4+kxcqJgpGbhm9gXneDELkyqAN5nitmIzTscKeJRXqd64RiaOALR2d295NWwbjHRNG2AU5oR9OS2oJg/5CY6BFPc1JvD2Mxdhp2/MZdI8dLePxiP4KRIp8VXmqfg+jqd/RNG7GNuq1U2SiI4735Bdc0MVFx6mH5UOWEa5HuhYykd6t4M1gYLVS8m1B+9bUqi5DziQq7qT8d94cxB6AB4WqMCOF/zPPtRSZUUaMSsvHOWxGASufywTX8ogy6HgUf9p+Z30wUEosl8qgmwm6o2AV6nO9HKQjRHpN6SUegI5pvR61RLnUJ1lqCtmfcsRQutEizVpAaPXN7xMp5UQ5OSZK6tniCK9CpyMd7LjR6+MxfoMEDPpWdf2p2m5N3KO4QMxf+V7vGdYjemQczQ+m2MGIkFNYDMf0Yop2eSx81sP36WHUczqEhKysp2iJSYAvfgJjinKwToPvRKb+HBi+7cJ96S5ngfLOXaHAFRLkulo4TnXTFO51gX0TCCo4ZUHdbpdgkMEwUZAPjh6M+hA8DzycbtxAgH3uD6i0nN1aTiIuQ4BYCE9dEHHwAmINU+4YEWx4EC3OZwFGfYZMPLScVlb+BAAJeARUh+gdWA3/gRqCrf1jecgqeFf1MdzrrP4SVlGm5mMihSP+zYYksAB7O+SBPwNQqSNMiLnkviY/klwgcRmvqtCqeWeA0gjuir4CMZqmw/ntP6M+l0pdN8/P9xI53aP7x/zavJbbKOz8VzO/nXxIr1tjparMnqd6iWdByHKw4lF4p/u57Yv07WeZPDnRl7wgmDVZZ44fQsjdYO/gmXQ+940PRGst8UMQApFC4OOV22e4N+lVOPyFLAOj4t8R3PFw/FjbSWy0ELuAFReNkee8ORcBOT2NPDcs7OfpUmzvn/F9Czk9o9naMyVYy/j8I5qVFmQDFcptBp65J/+sJA3w/j6y/eqUkKxTsf0CZjtNdRSBEmJ2tmfgmJbqpcsSagk+Ul9qdyV+NnqFBIJZFCB1XwPvWGDBOjVUmpWGHsWA5uDuMgLUNKZ4vlq5qfzY1LnRhCc/mh5/EX+hzuGdDy5aYYx4BAdwTTeZHcZpl3X0YyuxZFWNE6wFNppYs3LcFJePOyfKZ8KYb7dmRyvDOcORLPH0sytC6mH1US3JVj6paYM1GEr+CUmyHRnabHPqLlh6Kl0/BWd3ebziDfvpRQpPoR7N+LkUeYWtQ6Rn5v5+NtNeBPs2+DKDlzEVR5aYbTVPrZekJsZ9UC9qtVcP99thVIt1GREnN8zXP8mBfzS+wKYym8fcW6KqrE702Zco+hFQAEIR7qimo7dd7wO8B7R+QZPTuCWm1UAwblDTyURSbd85P4Pz+wBpQyGPeEpsEvxxIZkKsyfSOUcfE3UqzMFwZKYijb7sOkzpou+tC4bPXey5GI1GUAg9c3vLwIwAhcdPHRsYvpAfzkZHWY20vWxxJO0lvKfj6sG2g/pJ1vd/X2EBZkyEjLN4nUZOpOO7MewyHCrxQK8d5aF7rCeQlFX+XksK6l6z971BPuJqwdjj68ULOj9ZTDdOLopMdOLL0PFSS792SXE/EC9EDnIXZGYhr52aQb+9b2zEdBSnpkxAdBUkwJDqGCpZk/HkRidjdp0zKv/Cm52EenmfeKX6HkLUJgMbTTxxIZkIeL/6xuAaAAHbA7mONVduTHNX/UJj1nJEaI7f3HlUyiqKn7VfBE+bdb4HWln1HPJx001Ulq1tOxFf8WZEARvq5Da1+pE7fPVxLntGACz3nkoLsKcPdUqdCwwiyWkmXTd5+bv3j7HaReRt3ESn783Ew3SWsvkEjKtbocNksbrLmV+GVZn1+Uneo35MT1/4r8fngQX5/ptORfgmWfF6KSB/ssJmUSijXxQqUpzkANEkSkYgYj560OOjJr6uqckFuO15TRNgABEwNDjus1V3q2huLPYERMCLXUNmJJpbMrUQsSO7Qnxta55TvPWL6gWmMOvFknqETzqzFVO8SVkovEdYatypLGmDy9VWfgAc0KyIChiOhbd7UlbAeVLPZyEDp4POXKBwN/KP5pT6Cyqs6yaI00vXMn1ubk9OWT9Q/O2t/C25qlnO/zO0xcBzpMBCAB8vsdsh3U8fnPX1XlPEWfaYJxKVaTUgfCESWl4CCkIyjE6iQ5JFcwU6S4/IH0/Agacp8d5Gzq2+GzPnJ7+sqk40mfFQpKrDbAKwLlr3ONEati2k/ycLMSUu7V/7BBkDlNyXoN9tvqXCbbMc4SSQXgC/DBUY9QjtrCtQ+susEomCq8xcNJNNMWCH31GtlTw2BdCXkJBjT+/QNWlBWwQ5SWCh1LdQ99QVii/DyTxjSR6rmdap3l3L3aiplQpPYlrzNm9er88fXd2+ao+YdUNjtqmxiVxmyYPzJxl67OokDcTezEGqldkGgPbRdXA+fGcuZVkembZByo7J1dMnkGNjwwCny+FNcVcWvWYL9mg8oF7jACVWI3bA64EXpdM8bSIEVIAs5JJH+LHXgnCsgcMGPZyAAVBncvbLiexzg9YozcytjPXVlAbQAC7Tc4S0C8QN4LlAGjj4pQAVWrwkaDoUYGxxvkCWKRRHkdzJB5zpREleBDL1oDKEvAqmkDibVC4kTqF89YO6laUjgtJPebBfzr16tg4t10GmN1sJ5vezk2sUOq8blCn5mPZyT3ltaDcddKupQjqusNM9wtFVD0ABzv17fZDn7GPT1nkCtdcgYejcK1qOcTGtPxnCX1rErEjVWCnEJv5HaOAUjgpiKQjUKkQi64D5g2COgwas8FcgIl0Pw95H9dWxE3QG0VbMNffh6BPlAojLDf4es2/5Xfq7hw5NGcON2g8Qsy2UQm94KddKyy3kdJxWgpNaEc15xcylbLC3vnT26u8qS90qc2MU8LdOJc5VPF5KnSpXIhnj1eJJ/jszjZ01oR6JDFJRoeTPO/wh4IPFbdG9KljuSzeuI92p8JF/bpgDE8wG86/W2EBKgPrmzdLijxssQn8mM44ky/KLGOJcrSwXIpZa/Z3v7W6HCRk7ewds99LTsUW1LbeJytw8Q/BFZVZyfO9BUHOCe2suuEkO8DU4fLX0IQSQ2TdOkKXDtPf3sNV9tYhYFueuPRhfQlEEy+aYM/MCz7diDNmFSswYYlZZPmKr2Q5AxLsSVEqqBtn6hVl1BCFOFExnqnIsmyY/NA8jXnDaNzr7Zv3hu+I1Mf/PJjk0gALN2G8ABzdf9FNvWHvZHhv6xIoDCXf964MxG92vGZtx/LYU5PeZqgly8tT5tGeQGeJzMMsJc5p+a5Rn2PtEhiRzo/5Owjy1n0Lzx3ev8GHQmeWb8vagG6O5Qk5nrZuQTiKODI4UqL0LLAusS2Ve7j1Ivdxquu1BR9Rc4QkOiUPwQXJv6du2E8i5pDhVoQpUhyMWGUT2O2YODIhjAfI71gxep5r5zAY7GBUZpy51hAw0pcCCrhOmU8Wp6ujQTdZQsCjtq6SHX8QAMNiPCIIkoxhHEZPgsBcOlP4aErJZPhF7qvx6gHrn8hEwPwYbx8YmT/n7lbcmTip1v8kgsrIjFTAlvLY4Nuil0KDmgz3svYs0ZJ3O3Is/vSx4xpxF1e2VAtZE8dJxGYEIhCSuPvCjP54l/NSNDnwlKvAW8mG+AQkgp7a87Igh26uKMFGD0PoPHTSvoWxiHuk+su8XkQiHIjeYKl/RdcOHpxhQH3zHCNE3aARm83Bl6zGxU/vMltlVPQhubcqhW4RYkl6uXk5JdP/QpzaKFpw2M8zvysv2qj7xaQECuu2akM0Cssj/uB9+wDR7uA6XOnLNaoczalHoMj33eiiu+DRaFsUmlmUZuh9bjDY4INMNSSAivSh03uJvny4Gj+D+neudoa7iJi7c4VFlZ/J5gUR82308zSNAt/ZroBXDWw0fV3eVPAn3aX0mtJabF6RsUZmL+Ehn+wn51/4QipMjD+6y64t7bjL6bjENan2prQ4h7++hBJ9NXvX8CUocJqMC937IasLzm5K0qwXeFMAimMHkEIQIQI2LrQ9sLBfXuyp66zWvlsh74GPv7Xpabj993pRNNDuFud5oIcn/92isbADXdpRPbjmbCNOrwRbxGZx2XmYNGMiV5kjF4IKyxCBvKier9U4uVoheCdmk83rp5G0PihAm2fAtczI4b9BWqX+nrZTrJX5kSwQddi93NQrXG+Cl3eBGNkM77VBsMpEolhXex1MVvMkZN9fG59GGbciH11FEXaY1MxrArovaSjE/lUUqBg2cZBNmiWbvzCHCPJ4RVGFK2dTbObM1m+gJyEX53fa7u3+TZpm74mNEzWbkVL4vjNwfL9uzRCu1cgbrNx5Yv5dDruNrIOgwIk+UZWwJfdbu/WHul6PMmRflVCIzd7B37Pgm/Up/NuCiQW7RXyafevN3AL6ycciCc4ZPlTRzEu+aURGlUBOJbUEsheX7PPyrrhdUt5JAG12EEEZpY/N3Vhbl5uLAfT0CbC2XmpnryFkxZmBTs5prvEeuf0bn73i3O82WTiQtJWEPLsBXnQmdnKhB06NbbhLtlTZYJMxDMJpFeajSNRDB2v61BMUHqXggUwRJ19m6p5zl51v11q34T74lTXdJURuV6+bg2D6qpfGnLy7KGLuLZngobM4pIouz4+n0/UzFKxDgLM4h+fUwKZozQ9UGrHjcif51Ruonz7oIVZ56xWtZS8z7u5zay6J2LD4gCYh2RXoBRLDKsUlZ80R8kmoxlJiL8aZCy2wCAonnucFxCLT1HKoMhbPKt34D97EXPPh0joO93iJVF1Uruew61Qoy3ZUVNX9uIJDt9AQWKLLo+mSzmTibyLHq0D6hhzpvgUgI6ekyVEL3FD+Fi5R3A8MRHPXspN1VyKkfRlC+OGiNgPC4NREZpFETgVmdXrQ2TxChuS3aY+Ndc7CiYv5+CmzfiqeZrWIQJW/C4RvjbGUoJFf1K6ZdR2xL/bG4kVq1+I4jQWX+26YUijpp+lpN7o5c6ZodXJCF56UkFGsqz44sIg8jrdWvbjRCxi2Bk0iyM3a7ecAV93zB6h1Ei38c0s6+8nrbkopArccGP8vntQe1bFeEh2nJIFOHX/k3/UHb5PtKGpnzbkmnRETMX+9X/QduLZWw/feklW/kH/JnzToJe9Kgu9Hct1UGbH5BPCLo4OOtQnZonW0xnyCcdtKyPQ/sbLiSTYJdSx4sJqWLMnfn6fIqPB3WAgk00J+fCOkomPHqtS67pf0mFmKoItYZUlJu6BihSZ8qve8+/X+LX1MhQXF95AshfUleCtmdn6l6QFXzLg2sgLn1oyVFuZecv7fzsIHzoRlAGp0gwYDOn1S4qabWvB5xUaE+Svw4KmjWtxdnuQbI32dw87D4N95u8qQRJTSQg0wLxOLkxSrPMLEn1UIhNKjAa9VLs3WLaXGrtCIt8bKY2AQP/ZdyRU6zT/E8qP2ltyBE2CCZPgWgEYDoJJO4n92y61ylNaSFXKohJhLjkfvYWm592539sIpmBNLlDo1bExFBfmHJJ0lFEiC/fj8v42OoMC9Mo3whIoWvyHfq6Uacqq55mzFf/EGC+NP/gHjhd6urc6R0hES27VXux7UY8CGKPohplWIZtTrFSaPWslCWy78E22Pw8fvReSUZx/txqLtHrFqg1DY/Eus6Iq1heZdrdcqE0/c971Bz1HW/XNXHsXpUIbI4kHdOfCc6T5zHZzvzQJB0ggMFL6IGPAilU9bj/ASdPk6fNvNtZqPuwEDhMBtBnhCexo6D6VAGIOPvJPPV523Y8R8a9vCqZbswSZKzOT1291BsUbmUWehtbb1fdRX9hiJKXvwr1QX6GjnZMgyMvnwOo2Dr24amr7FqEAbVeJAjRNOceM2EQ1Mna9fInqPJ5mh5X8CzT1aDOv08An0blz0fF5Gq4mS2cwq5glwIOlY5nznE8X4j/UdZ3FJsVIXte1JH0A7iibuPfazStM5O/Vo3KXIpXBeGORV0M9XDXFvsYZUHGvFCUubWzTw248EHE0cpQM2zNg6rjavreq3NHCAWsoZ7wvVy7l5gvtKRmIj1MnvfWEm0yFnGcuOq192350a5WefpfKCcX3Sn+AgHU+qnpstNtddbdVebagJU390lq9ko4aI9rqdaWXYG8tv5O/ZQHSqDRYHC6zfH10l5z++opso7aOSaIczlQ13iAzXvLdEu0V7kwNUZ1c8Y8aq7SeIEe5p902FlNkW8DnwHyueHchbK8vVFJfmr9mz7P8nUSccl1ULaoWMRSI1ls32kvlK0h46h3J25Yd9AzfcJbp9qYF/SEt3H5j69mMdcsNxZcAzT/A89ov3tglTX54y/EwjMfuoDoxPwLJDm5I7q6F9Kp469yNy1zSxz0N4HbRRBj9xFFuogvBspv7DXUNIsGxTINEQfmctb42XImWAODgARNo7dfcTqFKq6aTfivmvunLmzP9f8yLsJvXD3JbcPcDGNriMAcjzeDTNr65t8YB5tsnFDFLa0Uwmd2OvUdkLMX9TsAUYUfooSv47sw5J88j7CpahRjjO3/UhOXjTS39W5YZAel2KTbQd1h7INOw9P23GW7GDAe4agIUFHP48MZr7ubq0efFmmtwYMyk7D0r1oeG/CGOODgb9Ur+JMHxkwzPbtCX2ZnENQuI0RN5SyTIZuoY4XS9Rd/tPe3vNAZGSHM/YYwqs9xkkENx0O+eC2YVW1cwOJ3ckE890nbQeHLKlW15L0P0W2VliyYrfNr0nrIYddoRyGaCtj4OYd2MT7ebApqZOAQIaSHJM4mphhfjNjtnjg6YRyx9qM2FT3xOiYIMqXPFWdzhSgFF8ItocqVV09CmIoO8k6U/oJB7++wSX/YksxfPXHyjSgAGZOj1aKEq9fSvXBqtp2wu8/FxEf5AxapAD06pPGuLVUYLdgEzHR8wqRGYEwiUO9MyYbgswstuLYhwYFpSVKOdzAihZ9LuHtD598EGhINU9xc9xhL+QgTLAstmPIvvm2xyRw/WTUPXkP3ZHu6GyPmj5xFH9/QGpkglKXRVUBgVmLOJx8uZO2AstxQYocZH2JhORlxawj66BAXUEs7K/gPxINIRAFyK3WLuyq9oBTF9wEbnmCot82WjIg7CPNwYK3KrZMrKAz5yFszg4wCVLJVnIL8+OYA0xRDH8cHQjQUiQ2i1mr/be32k/3Xej9sdf3iuGvZHyLFSJvPSqz/wltnxumTJYKZsrWXtx/Rmu39jjV9lFaJttfFn57/No2h/unsJmMHbrnZ8csxkp5HQ4xR1s0HH+t3Iz82a3iQWTUDGq/+l2W3TUYLE8zNdL8Y+5oXaIH/Y2UUcX67cXeN4WvENZjz4+8q7vjhowOI3rSjFhGZ6KzwmU7+5nFV+kGWAZ5z2UWvzq0TK0pk1hPwAN4jbw//1CApRvIaIjhSGhioY6TUmsToek9cF9XjJdHvLPcyyCV3lbR5Jiz/ts46ay2F820VjTXvllElwrGzKcNSyvQlWDXdwrUINXmHorAM3fE19ngLZmgeUaCJLsSITf2VcfAOuWwX7mTPdP8Zb/04KqRniufCpwnDUk7sP0RX6cud/sanFMagnzKInSRVey0YzlVSOtA/AjrofmSH6RYbJQ8b4NDeTkIGc6247+Mnbez/qhJ9GAv9fGNFercPnnrf285Qgs+UqThLRgflcAKFuqWhLzZaR4QqvSwa3xe0LPkqj9xJWub195r7NrrR0e78FR+0mRBNMPsraqZctAUVAJfYKehTDV1MGGQSeDsOK9J3sbUuKRIS/WilX/64CBms9jCZocBlsBSZaIAjWm/SUZ8daWL2a/cJFyUOFqE3Epc2RWbtjNyPwOGpWtzu32kUooUqsJud7IV4E8rstUBXM7tGEtBx99x60g1duhyvxeKJSl8s5E34HTMmADT0836aEdg5Dv9rVyCz8i2REOmiz6wtIVFN0HsjAoN37SrY0bV1Ms8CRUILhvZvvRaDzoVCaSI0u8EPuTe4b7OPowgRGODl22UBBmHSTUY8e4DyL+Bc7bngo+2T8HtNvzyATSL5iJZgFPKpmUyZv54vVL90+/RQGATUmNKnrIvcJMYON9fl83naW5sf6hRkbbTC9RUEE6XADwjgA46wWfUQ+QWZl0J4PVTWAln/YfAz/SV3q3J9+yCYDleruoN5uoc/wT2f4YONGTb6zTGq3V+3JqzmCOjwebKln+fExVLN7sqtqfMnsKVXWbb2Ai5m3D/fCTgX7oKYzTZvj+m28XnDqPbXuP4MyWdmPezcesdrh7rCzA7BWdObiuyDEKjjzBbQ0qnuwjliz+b+j7aPMKlkXyIznV3tGzAfYwIbzGGt098oh4eq3ruDjdgHtjxfFCjHrjjRbHajoz/YOY4raojPFQ910GIlBV7hq47UDgpyajBxQUmD8NctiLV1rTSLAEsQDLTeRKcmPBMVMFF0SPBBhZ5oXoxtD3lMhuAQXmA+57OcciczVW9e9zwSIAHS+FJmvfXMJGF1dMBsIUMaPjvgaVqUc3p32qVCMQYFEiRLzlVSOGMCmv/HJIxAHe3mL/XnoZ1IkWLeRZfgyByjnDbbeRK5KL7bYHSVJZ9UFq+yCiNKeRUaYjgbC3hVUvfJAhy/QNl/JqLKVvGMk9ZcfyGidNeo/VTxK9vUpodzfQI9Z2eAre4nmrkzgxKSnT5IJ1D69oHuUS5hp7pK9IAWuNrAOtOH0mAuwCrY8mXAtVXUeaNK3OXr6PRvmWg4VQqFSy+a1GZfFYgdsJELG8N0kvqmzvwZ02Plf5fH9QTy6br0oY/IDsEA+GBf9pEVWCIuBCjsup3LDSDqI+5+0IKSUFr7A96A2f0FbcU9fqljdqvsd8sG55KcKloHIFZem2Wb6pCLXybnVSB0sjCXzdS8IKvE");
      FENCED = /* @__PURE__ */ new Map([[8217, "apostrophe"], [8260, "fraction slash"], [12539, "middle dot"]]);
      NSM_MAX = 4;
      r = read_compressed_payload("AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g");
      SHIFTED_RANK = new Map(read_sorted_arrays(r).flatMap((v6, i7) => v6.map((x4) => [x4, i7 + 1 << 24])));
      EXCLUSIONS = new Set(read_sorted(r));
      DECOMP = /* @__PURE__ */ new Map();
      RECOMP = /* @__PURE__ */ new Map();
      for (let [cp, cps] of read_mapped(r)) {
        if (!EXCLUSIONS.has(cp) && cps.length == 2) {
          let [a6, b7] = cps;
          let bucket = RECOMP.get(a6);
          if (!bucket) {
            bucket = /* @__PURE__ */ new Map();
            RECOMP.set(a6, bucket);
          }
          bucket.set(b7, cp);
        }
        DECOMP.set(cp, cps.reverse());
      }
      S0 = 44032;
      L0 = 4352;
      V0 = 4449;
      T0 = 4519;
      L_COUNT = 19;
      V_COUNT = 21;
      T_COUNT = 28;
      N_COUNT = V_COUNT * T_COUNT;
      S_COUNT = L_COUNT * N_COUNT;
      S1 = S0 + S_COUNT;
      L1 = L0 + L_COUNT;
      V1 = V0 + V_COUNT;
      T1 = T0 + T_COUNT;
      FE0F = 65039;
      STOP_CH = ".";
      UNIQUE_PH = 1;
      HYPHEN = 45;
      MAPPED = new Map(read_mapped(r$1));
      IGNORED = read_set();
      CM = read_set();
      NSM = new Set(read_sorted(r$1).map(function(i7) {
        return this[i7];
      }, [...CM]));
      ESCAPE = read_set();
      NFC_CHECK = read_set();
      CHUNKS = read_sorted_arrays(r$1);
      UNRESTRICTED = r$1();
      GROUPS = read_array_while((i7) => {
        let N17 = read_array_while(r$1).map((x4) => x4 + 96);
        if (N17.length) {
          let R7 = i7 >= UNRESTRICTED;
          N17[0] -= 32;
          N17 = str_from_cps(N17);
          if (R7)
            N17 = `Restricted[${N17}]`;
          let P7 = read_chunked();
          let Q10 = read_chunked();
          let V9 = [...P7, ...Q10].sort((a6, b7) => a6 - b7);
          let M7 = !r$1();
          return { N: N17, P: P7, M: M7, R: R7, V: new Set(V9) };
        }
      });
      WHOLE_VALID = read_set();
      WHOLE_MAP = /* @__PURE__ */ new Map();
      [...WHOLE_VALID, ...read_set()].sort((a6, b7) => a6 - b7).map((cp, i7, v6) => {
        let d7 = r$1();
        let w8 = v6[i7] = d7 ? v6[i7 - d7] : { V: [], M: /* @__PURE__ */ new Map() };
        w8.V.push(cp);
        if (!WHOLE_VALID.has(cp)) {
          WHOLE_MAP.set(cp, w8);
        }
      });
      for (let { V: V9, M: M7 } of new Set(WHOLE_MAP.values())) {
        let recs = [];
        for (let cp of V9) {
          let gs3 = GROUPS.filter((g7) => g7.V.has(cp));
          let rec = recs.find(({ G: G9 }) => gs3.some((g7) => G9.has(g7)));
          if (!rec) {
            rec = { G: /* @__PURE__ */ new Set(), V: [] };
            recs.push(rec);
          }
          rec.V.push(cp);
          gs3.forEach((g7) => rec.G.add(g7));
        }
        let union2 = recs.flatMap(({ G: G9 }) => [...G9]);
        for (let { G: G9, V: V10 } of recs) {
          let complement = new Set(union2.filter((g7) => !G9.has(g7)));
          for (let cp of V10) {
            M7.set(cp, complement);
          }
        }
      }
      union = /* @__PURE__ */ new Set();
      multi = /* @__PURE__ */ new Set();
      for (let g7 of GROUPS) {
        for (let cp of g7.V) {
          (union.has(cp) ? multi : union).add(cp);
        }
      }
      for (let cp of union) {
        if (!WHOLE_MAP.has(cp) && !multi.has(cp)) {
          WHOLE_MAP.set(cp, UNIQUE_PH);
        }
      }
      VALID = /* @__PURE__ */ new Set([...union, ...nfd(union)]);
      EMOJI_SORTED = read_sorted(r$1);
      EMOJI_ROOT = read_emoji_trie([]);
      Emoji = class extends Array {
        get is_emoji() {
          return true;
        }
      };
    }
  });

  // node_modules/viem/dist/esm/utils/ens/normalize.js
  function normalize(name2) {
    return ens_normalize(name2);
  }
  var init_normalize = __esm({
    "node_modules/viem/dist/esm/utils/ens/normalize.js"() {
      init_dist();
    }
  });

  // node_modules/viem/dist/esm/ens.js
  var ens_exports = {};
  __export(ens_exports, {
    getEnsAddress: () => getEnsAddress,
    getEnsAvatar: () => getEnsAvatar,
    getEnsName: () => getEnsName,
    getEnsResolver: () => getEnsResolver,
    getEnsText: () => getEnsText,
    labelhash: () => labelhash,
    namehash: () => namehash,
    normalize: () => normalize
  });
  var init_ens2 = __esm({
    "node_modules/viem/dist/esm/ens.js"() {
      init_normalize();
      init_getEnsAddress();
      init_getEnsAvatar();
      init_getEnsName();
      init_getEnsResolver();
      init_getEnsText();
      init_labelhash();
      init_namehash();
    }
  });

  // node_modules/@stablelib/int/lib/int.js
  var require_int = __commonJS({
    "node_modules/@stablelib/int/lib/int.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      function imulShim(a6, b7) {
        var ah = a6 >>> 16 & 65535, al = a6 & 65535;
        var bh = b7 >>> 16 & 65535, bl = b7 & 65535;
        return al * bl + (ah * bl + al * bh << 16 >>> 0) | 0;
      }
      exports.mul = Math.imul || imulShim;
      function add4(a6, b7) {
        return a6 + b7 | 0;
      }
      exports.add = add4;
      function sub(a6, b7) {
        return a6 - b7 | 0;
      }
      exports.sub = sub;
      function rotl(x4, n9) {
        return x4 << n9 | x4 >>> 32 - n9;
      }
      exports.rotl = rotl;
      function rotr(x4, n9) {
        return x4 << 32 - n9 | x4 >>> n9;
      }
      exports.rotr = rotr;
      function isIntegerShim(n9) {
        return typeof n9 === "number" && isFinite(n9) && Math.floor(n9) === n9;
      }
      exports.isInteger = Number.isInteger || isIntegerShim;
      exports.MAX_SAFE_INTEGER = 9007199254740991;
      exports.isSafeInteger = function(n9) {
        return exports.isInteger(n9) && (n9 >= -exports.MAX_SAFE_INTEGER && n9 <= exports.MAX_SAFE_INTEGER);
      };
    }
  });

  // node_modules/@stablelib/binary/lib/binary.js
  var require_binary = __commonJS({
    "node_modules/@stablelib/binary/lib/binary.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var int_1 = require_int();
      function readInt16BE(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        return (array[offset + 0] << 8 | array[offset + 1]) << 16 >> 16;
      }
      exports.readInt16BE = readInt16BE;
      function readUint16BE(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        return (array[offset + 0] << 8 | array[offset + 1]) >>> 0;
      }
      exports.readUint16BE = readUint16BE;
      function readInt16LE(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        return (array[offset + 1] << 8 | array[offset]) << 16 >> 16;
      }
      exports.readInt16LE = readInt16LE;
      function readUint16LE(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        return (array[offset + 1] << 8 | array[offset]) >>> 0;
      }
      exports.readUint16LE = readUint16LE;
      function writeUint16BE(value, out, offset) {
        if (out === void 0) {
          out = new Uint8Array(2);
        }
        if (offset === void 0) {
          offset = 0;
        }
        out[offset + 0] = value >>> 8;
        out[offset + 1] = value >>> 0;
        return out;
      }
      exports.writeUint16BE = writeUint16BE;
      exports.writeInt16BE = writeUint16BE;
      function writeUint16LE(value, out, offset) {
        if (out === void 0) {
          out = new Uint8Array(2);
        }
        if (offset === void 0) {
          offset = 0;
        }
        out[offset + 0] = value >>> 0;
        out[offset + 1] = value >>> 8;
        return out;
      }
      exports.writeUint16LE = writeUint16LE;
      exports.writeInt16LE = writeUint16LE;
      function readInt32BE(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        return array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3];
      }
      exports.readInt32BE = readInt32BE;
      function readUint32BE(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        return (array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3]) >>> 0;
      }
      exports.readUint32BE = readUint32BE;
      function readInt32LE(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        return array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset];
      }
      exports.readInt32LE = readInt32LE;
      function readUint32LE(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        return (array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset]) >>> 0;
      }
      exports.readUint32LE = readUint32LE;
      function writeUint32BE(value, out, offset) {
        if (out === void 0) {
          out = new Uint8Array(4);
        }
        if (offset === void 0) {
          offset = 0;
        }
        out[offset + 0] = value >>> 24;
        out[offset + 1] = value >>> 16;
        out[offset + 2] = value >>> 8;
        out[offset + 3] = value >>> 0;
        return out;
      }
      exports.writeUint32BE = writeUint32BE;
      exports.writeInt32BE = writeUint32BE;
      function writeUint32LE(value, out, offset) {
        if (out === void 0) {
          out = new Uint8Array(4);
        }
        if (offset === void 0) {
          offset = 0;
        }
        out[offset + 0] = value >>> 0;
        out[offset + 1] = value >>> 8;
        out[offset + 2] = value >>> 16;
        out[offset + 3] = value >>> 24;
        return out;
      }
      exports.writeUint32LE = writeUint32LE;
      exports.writeInt32LE = writeUint32LE;
      function readInt64BE(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        var hi2 = readInt32BE(array, offset);
        var lo3 = readInt32BE(array, offset + 4);
        return hi2 * 4294967296 + lo3 - (lo3 >> 31) * 4294967296;
      }
      exports.readInt64BE = readInt64BE;
      function readUint64BE(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        var hi2 = readUint32BE(array, offset);
        var lo3 = readUint32BE(array, offset + 4);
        return hi2 * 4294967296 + lo3;
      }
      exports.readUint64BE = readUint64BE;
      function readInt64LE(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        var lo3 = readInt32LE(array, offset);
        var hi2 = readInt32LE(array, offset + 4);
        return hi2 * 4294967296 + lo3 - (lo3 >> 31) * 4294967296;
      }
      exports.readInt64LE = readInt64LE;
      function readUint64LE(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        var lo3 = readUint32LE(array, offset);
        var hi2 = readUint32LE(array, offset + 4);
        return hi2 * 4294967296 + lo3;
      }
      exports.readUint64LE = readUint64LE;
      function writeUint64BE(value, out, offset) {
        if (out === void 0) {
          out = new Uint8Array(8);
        }
        if (offset === void 0) {
          offset = 0;
        }
        writeUint32BE(value / 4294967296 >>> 0, out, offset);
        writeUint32BE(value >>> 0, out, offset + 4);
        return out;
      }
      exports.writeUint64BE = writeUint64BE;
      exports.writeInt64BE = writeUint64BE;
      function writeUint64LE(value, out, offset) {
        if (out === void 0) {
          out = new Uint8Array(8);
        }
        if (offset === void 0) {
          offset = 0;
        }
        writeUint32LE(value >>> 0, out, offset);
        writeUint32LE(value / 4294967296 >>> 0, out, offset + 4);
        return out;
      }
      exports.writeUint64LE = writeUint64LE;
      exports.writeInt64LE = writeUint64LE;
      function readUintBE(bitLength, array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        if (bitLength % 8 !== 0) {
          throw new Error("readUintBE supports only bitLengths divisible by 8");
        }
        if (bitLength / 8 > array.length - offset) {
          throw new Error("readUintBE: array is too short for the given bitLength");
        }
        var result = 0;
        var mul3 = 1;
        for (var i7 = bitLength / 8 + offset - 1; i7 >= offset; i7--) {
          result += array[i7] * mul3;
          mul3 *= 256;
        }
        return result;
      }
      exports.readUintBE = readUintBE;
      function readUintLE(bitLength, array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        if (bitLength % 8 !== 0) {
          throw new Error("readUintLE supports only bitLengths divisible by 8");
        }
        if (bitLength / 8 > array.length - offset) {
          throw new Error("readUintLE: array is too short for the given bitLength");
        }
        var result = 0;
        var mul3 = 1;
        for (var i7 = offset; i7 < offset + bitLength / 8; i7++) {
          result += array[i7] * mul3;
          mul3 *= 256;
        }
        return result;
      }
      exports.readUintLE = readUintLE;
      function writeUintBE(bitLength, value, out, offset) {
        if (out === void 0) {
          out = new Uint8Array(bitLength / 8);
        }
        if (offset === void 0) {
          offset = 0;
        }
        if (bitLength % 8 !== 0) {
          throw new Error("writeUintBE supports only bitLengths divisible by 8");
        }
        if (!int_1.isSafeInteger(value)) {
          throw new Error("writeUintBE value must be an integer");
        }
        var div = 1;
        for (var i7 = bitLength / 8 + offset - 1; i7 >= offset; i7--) {
          out[i7] = value / div & 255;
          div *= 256;
        }
        return out;
      }
      exports.writeUintBE = writeUintBE;
      function writeUintLE(bitLength, value, out, offset) {
        if (out === void 0) {
          out = new Uint8Array(bitLength / 8);
        }
        if (offset === void 0) {
          offset = 0;
        }
        if (bitLength % 8 !== 0) {
          throw new Error("writeUintLE supports only bitLengths divisible by 8");
        }
        if (!int_1.isSafeInteger(value)) {
          throw new Error("writeUintLE value must be an integer");
        }
        var div = 1;
        for (var i7 = offset; i7 < offset + bitLength / 8; i7++) {
          out[i7] = value / div & 255;
          div *= 256;
        }
        return out;
      }
      exports.writeUintLE = writeUintLE;
      function readFloat32BE(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
        return view.getFloat32(offset);
      }
      exports.readFloat32BE = readFloat32BE;
      function readFloat32LE(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
        return view.getFloat32(offset, true);
      }
      exports.readFloat32LE = readFloat32LE;
      function readFloat64BE(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
        return view.getFloat64(offset);
      }
      exports.readFloat64BE = readFloat64BE;
      function readFloat64LE(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
        return view.getFloat64(offset, true);
      }
      exports.readFloat64LE = readFloat64LE;
      function writeFloat32BE(value, out, offset) {
        if (out === void 0) {
          out = new Uint8Array(4);
        }
        if (offset === void 0) {
          offset = 0;
        }
        var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
        view.setFloat32(offset, value);
        return out;
      }
      exports.writeFloat32BE = writeFloat32BE;
      function writeFloat32LE(value, out, offset) {
        if (out === void 0) {
          out = new Uint8Array(4);
        }
        if (offset === void 0) {
          offset = 0;
        }
        var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
        view.setFloat32(offset, value, true);
        return out;
      }
      exports.writeFloat32LE = writeFloat32LE;
      function writeFloat64BE(value, out, offset) {
        if (out === void 0) {
          out = new Uint8Array(8);
        }
        if (offset === void 0) {
          offset = 0;
        }
        var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
        view.setFloat64(offset, value);
        return out;
      }
      exports.writeFloat64BE = writeFloat64BE;
      function writeFloat64LE(value, out, offset) {
        if (out === void 0) {
          out = new Uint8Array(8);
        }
        if (offset === void 0) {
          offset = 0;
        }
        var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
        view.setFloat64(offset, value, true);
        return out;
      }
      exports.writeFloat64LE = writeFloat64LE;
    }
  });

  // node_modules/@stablelib/wipe/lib/wipe.js
  var require_wipe = __commonJS({
    "node_modules/@stablelib/wipe/lib/wipe.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      function wipe(array) {
        for (var i7 = 0; i7 < array.length; i7++) {
          array[i7] = 0;
        }
        return array;
      }
      exports.wipe = wipe;
    }
  });

  // node_modules/@stablelib/chacha/lib/chacha.js
  var require_chacha = __commonJS({
    "node_modules/@stablelib/chacha/lib/chacha.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var binary_1 = require_binary();
      var wipe_1 = require_wipe();
      var ROUNDS = 20;
      function core(out, input, key2) {
        var j0 = 1634760805;
        var j1 = 857760878;
        var j22 = 2036477234;
        var j32 = 1797285236;
        var j42 = key2[3] << 24 | key2[2] << 16 | key2[1] << 8 | key2[0];
        var j52 = key2[7] << 24 | key2[6] << 16 | key2[5] << 8 | key2[4];
        var j62 = key2[11] << 24 | key2[10] << 16 | key2[9] << 8 | key2[8];
        var j7 = key2[15] << 24 | key2[14] << 16 | key2[13] << 8 | key2[12];
        var j8 = key2[19] << 24 | key2[18] << 16 | key2[17] << 8 | key2[16];
        var j9 = key2[23] << 24 | key2[22] << 16 | key2[21] << 8 | key2[20];
        var j10 = key2[27] << 24 | key2[26] << 16 | key2[25] << 8 | key2[24];
        var j11 = key2[31] << 24 | key2[30] << 16 | key2[29] << 8 | key2[28];
        var j12 = input[3] << 24 | input[2] << 16 | input[1] << 8 | input[0];
        var j13 = input[7] << 24 | input[6] << 16 | input[5] << 8 | input[4];
        var j14 = input[11] << 24 | input[10] << 16 | input[9] << 8 | input[8];
        var j15 = input[15] << 24 | input[14] << 16 | input[13] << 8 | input[12];
        var x0 = j0;
        var x1 = j1;
        var x22 = j22;
        var x32 = j32;
        var x4 = j42;
        var x5 = j52;
        var x6 = j62;
        var x7 = j7;
        var x8 = j8;
        var x9 = j9;
        var x10 = j10;
        var x11 = j11;
        var x12 = j12;
        var x13 = j13;
        var x14 = j14;
        var x15 = j15;
        for (var i7 = 0; i7 < ROUNDS; i7 += 2) {
          x0 = x0 + x4 | 0;
          x12 ^= x0;
          x12 = x12 >>> 32 - 16 | x12 << 16;
          x8 = x8 + x12 | 0;
          x4 ^= x8;
          x4 = x4 >>> 32 - 12 | x4 << 12;
          x1 = x1 + x5 | 0;
          x13 ^= x1;
          x13 = x13 >>> 32 - 16 | x13 << 16;
          x9 = x9 + x13 | 0;
          x5 ^= x9;
          x5 = x5 >>> 32 - 12 | x5 << 12;
          x22 = x22 + x6 | 0;
          x14 ^= x22;
          x14 = x14 >>> 32 - 16 | x14 << 16;
          x10 = x10 + x14 | 0;
          x6 ^= x10;
          x6 = x6 >>> 32 - 12 | x6 << 12;
          x32 = x32 + x7 | 0;
          x15 ^= x32;
          x15 = x15 >>> 32 - 16 | x15 << 16;
          x11 = x11 + x15 | 0;
          x7 ^= x11;
          x7 = x7 >>> 32 - 12 | x7 << 12;
          x22 = x22 + x6 | 0;
          x14 ^= x22;
          x14 = x14 >>> 32 - 8 | x14 << 8;
          x10 = x10 + x14 | 0;
          x6 ^= x10;
          x6 = x6 >>> 32 - 7 | x6 << 7;
          x32 = x32 + x7 | 0;
          x15 ^= x32;
          x15 = x15 >>> 32 - 8 | x15 << 8;
          x11 = x11 + x15 | 0;
          x7 ^= x11;
          x7 = x7 >>> 32 - 7 | x7 << 7;
          x1 = x1 + x5 | 0;
          x13 ^= x1;
          x13 = x13 >>> 32 - 8 | x13 << 8;
          x9 = x9 + x13 | 0;
          x5 ^= x9;
          x5 = x5 >>> 32 - 7 | x5 << 7;
          x0 = x0 + x4 | 0;
          x12 ^= x0;
          x12 = x12 >>> 32 - 8 | x12 << 8;
          x8 = x8 + x12 | 0;
          x4 ^= x8;
          x4 = x4 >>> 32 - 7 | x4 << 7;
          x0 = x0 + x5 | 0;
          x15 ^= x0;
          x15 = x15 >>> 32 - 16 | x15 << 16;
          x10 = x10 + x15 | 0;
          x5 ^= x10;
          x5 = x5 >>> 32 - 12 | x5 << 12;
          x1 = x1 + x6 | 0;
          x12 ^= x1;
          x12 = x12 >>> 32 - 16 | x12 << 16;
          x11 = x11 + x12 | 0;
          x6 ^= x11;
          x6 = x6 >>> 32 - 12 | x6 << 12;
          x22 = x22 + x7 | 0;
          x13 ^= x22;
          x13 = x13 >>> 32 - 16 | x13 << 16;
          x8 = x8 + x13 | 0;
          x7 ^= x8;
          x7 = x7 >>> 32 - 12 | x7 << 12;
          x32 = x32 + x4 | 0;
          x14 ^= x32;
          x14 = x14 >>> 32 - 16 | x14 << 16;
          x9 = x9 + x14 | 0;
          x4 ^= x9;
          x4 = x4 >>> 32 - 12 | x4 << 12;
          x22 = x22 + x7 | 0;
          x13 ^= x22;
          x13 = x13 >>> 32 - 8 | x13 << 8;
          x8 = x8 + x13 | 0;
          x7 ^= x8;
          x7 = x7 >>> 32 - 7 | x7 << 7;
          x32 = x32 + x4 | 0;
          x14 ^= x32;
          x14 = x14 >>> 32 - 8 | x14 << 8;
          x9 = x9 + x14 | 0;
          x4 ^= x9;
          x4 = x4 >>> 32 - 7 | x4 << 7;
          x1 = x1 + x6 | 0;
          x12 ^= x1;
          x12 = x12 >>> 32 - 8 | x12 << 8;
          x11 = x11 + x12 | 0;
          x6 ^= x11;
          x6 = x6 >>> 32 - 7 | x6 << 7;
          x0 = x0 + x5 | 0;
          x15 ^= x0;
          x15 = x15 >>> 32 - 8 | x15 << 8;
          x10 = x10 + x15 | 0;
          x5 ^= x10;
          x5 = x5 >>> 32 - 7 | x5 << 7;
        }
        binary_1.writeUint32LE(x0 + j0 | 0, out, 0);
        binary_1.writeUint32LE(x1 + j1 | 0, out, 4);
        binary_1.writeUint32LE(x22 + j22 | 0, out, 8);
        binary_1.writeUint32LE(x32 + j32 | 0, out, 12);
        binary_1.writeUint32LE(x4 + j42 | 0, out, 16);
        binary_1.writeUint32LE(x5 + j52 | 0, out, 20);
        binary_1.writeUint32LE(x6 + j62 | 0, out, 24);
        binary_1.writeUint32LE(x7 + j7 | 0, out, 28);
        binary_1.writeUint32LE(x8 + j8 | 0, out, 32);
        binary_1.writeUint32LE(x9 + j9 | 0, out, 36);
        binary_1.writeUint32LE(x10 + j10 | 0, out, 40);
        binary_1.writeUint32LE(x11 + j11 | 0, out, 44);
        binary_1.writeUint32LE(x12 + j12 | 0, out, 48);
        binary_1.writeUint32LE(x13 + j13 | 0, out, 52);
        binary_1.writeUint32LE(x14 + j14 | 0, out, 56);
        binary_1.writeUint32LE(x15 + j15 | 0, out, 60);
      }
      function streamXOR(key2, nonce, src2, dst, nonceInplaceCounterLength) {
        if (nonceInplaceCounterLength === void 0) {
          nonceInplaceCounterLength = 0;
        }
        if (key2.length !== 32) {
          throw new Error("ChaCha: key size must be 32 bytes");
        }
        if (dst.length < src2.length) {
          throw new Error("ChaCha: destination is shorter than source");
        }
        var nc;
        var counterLength;
        if (nonceInplaceCounterLength === 0) {
          if (nonce.length !== 8 && nonce.length !== 12) {
            throw new Error("ChaCha nonce must be 8 or 12 bytes");
          }
          nc = new Uint8Array(16);
          counterLength = nc.length - nonce.length;
          nc.set(nonce, counterLength);
        } else {
          if (nonce.length !== 16) {
            throw new Error("ChaCha nonce with counter must be 16 bytes");
          }
          nc = nonce;
          counterLength = nonceInplaceCounterLength;
        }
        var block2 = new Uint8Array(64);
        for (var i7 = 0; i7 < src2.length; i7 += 64) {
          core(block2, nc, key2);
          for (var j7 = i7; j7 < i7 + 64 && j7 < src2.length; j7++) {
            dst[j7] = src2[j7] ^ block2[j7 - i7];
          }
          incrementCounter(nc, 0, counterLength);
        }
        wipe_1.wipe(block2);
        if (nonceInplaceCounterLength === 0) {
          wipe_1.wipe(nc);
        }
        return dst;
      }
      exports.streamXOR = streamXOR;
      function stream(key2, nonce, dst, nonceInplaceCounterLength) {
        if (nonceInplaceCounterLength === void 0) {
          nonceInplaceCounterLength = 0;
        }
        wipe_1.wipe(dst);
        return streamXOR(key2, nonce, dst, dst, nonceInplaceCounterLength);
      }
      exports.stream = stream;
      function incrementCounter(counter, pos, len) {
        var carry = 1;
        while (len--) {
          carry = carry + (counter[pos] & 255) | 0;
          counter[pos] = carry & 255;
          carry >>>= 8;
          pos++;
        }
        if (carry > 0) {
          throw new Error("ChaCha: counter overflow");
        }
      }
    }
  });

  // node_modules/@stablelib/constant-time/lib/constant-time.js
  var require_constant_time = __commonJS({
    "node_modules/@stablelib/constant-time/lib/constant-time.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      function select(subject, resultIfOne, resultIfZero) {
        return ~(subject - 1) & resultIfOne | subject - 1 & resultIfZero;
      }
      exports.select = select;
      function lessOrEqual(a6, b7) {
        return (a6 | 0) - (b7 | 0) - 1 >>> 31 & 1;
      }
      exports.lessOrEqual = lessOrEqual;
      function compare2(a6, b7) {
        if (a6.length !== b7.length) {
          return 0;
        }
        var result = 0;
        for (var i7 = 0; i7 < a6.length; i7++) {
          result |= a6[i7] ^ b7[i7];
        }
        return 1 & result - 1 >>> 8;
      }
      exports.compare = compare2;
      function equal(a6, b7) {
        if (a6.length === 0 || b7.length === 0) {
          return false;
        }
        return compare2(a6, b7) !== 0;
      }
      exports.equal = equal;
    }
  });

  // node_modules/@stablelib/poly1305/lib/poly1305.js
  var require_poly1305 = __commonJS({
    "node_modules/@stablelib/poly1305/lib/poly1305.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var constant_time_1 = require_constant_time();
      var wipe_1 = require_wipe();
      exports.DIGEST_LENGTH = 16;
      var Poly1305 = (
        /** @class */
        function() {
          function Poly13052(key2) {
            this.digestLength = exports.DIGEST_LENGTH;
            this._buffer = new Uint8Array(16);
            this._r = new Uint16Array(10);
            this._h = new Uint16Array(10);
            this._pad = new Uint16Array(8);
            this._leftover = 0;
            this._fin = 0;
            this._finished = false;
            var t0 = key2[0] | key2[1] << 8;
            this._r[0] = t0 & 8191;
            var t1 = key2[2] | key2[3] << 8;
            this._r[1] = (t0 >>> 13 | t1 << 3) & 8191;
            var t22 = key2[4] | key2[5] << 8;
            this._r[2] = (t1 >>> 10 | t22 << 6) & 7939;
            var t32 = key2[6] | key2[7] << 8;
            this._r[3] = (t22 >>> 7 | t32 << 9) & 8191;
            var t42 = key2[8] | key2[9] << 8;
            this._r[4] = (t32 >>> 4 | t42 << 12) & 255;
            this._r[5] = t42 >>> 1 & 8190;
            var t52 = key2[10] | key2[11] << 8;
            this._r[6] = (t42 >>> 14 | t52 << 2) & 8191;
            var t6 = key2[12] | key2[13] << 8;
            this._r[7] = (t52 >>> 11 | t6 << 5) & 8065;
            var t7 = key2[14] | key2[15] << 8;
            this._r[8] = (t6 >>> 8 | t7 << 8) & 8191;
            this._r[9] = t7 >>> 5 & 127;
            this._pad[0] = key2[16] | key2[17] << 8;
            this._pad[1] = key2[18] | key2[19] << 8;
            this._pad[2] = key2[20] | key2[21] << 8;
            this._pad[3] = key2[22] | key2[23] << 8;
            this._pad[4] = key2[24] | key2[25] << 8;
            this._pad[5] = key2[26] | key2[27] << 8;
            this._pad[6] = key2[28] | key2[29] << 8;
            this._pad[7] = key2[30] | key2[31] << 8;
          }
          Poly13052.prototype._blocks = function(m6, mpos, bytes3) {
            var hibit = this._fin ? 0 : 1 << 11;
            var h0 = this._h[0], h1 = this._h[1], h22 = this._h[2], h32 = this._h[3], h42 = this._h[4], h52 = this._h[5], h62 = this._h[6], h72 = this._h[7], h82 = this._h[8], h92 = this._h[9];
            var r0 = this._r[0], r1 = this._r[1], r22 = this._r[2], r32 = this._r[3], r42 = this._r[4], r52 = this._r[5], r62 = this._r[6], r72 = this._r[7], r8 = this._r[8], r9 = this._r[9];
            while (bytes3 >= 16) {
              var t0 = m6[mpos + 0] | m6[mpos + 1] << 8;
              h0 += t0 & 8191;
              var t1 = m6[mpos + 2] | m6[mpos + 3] << 8;
              h1 += (t0 >>> 13 | t1 << 3) & 8191;
              var t22 = m6[mpos + 4] | m6[mpos + 5] << 8;
              h22 += (t1 >>> 10 | t22 << 6) & 8191;
              var t32 = m6[mpos + 6] | m6[mpos + 7] << 8;
              h32 += (t22 >>> 7 | t32 << 9) & 8191;
              var t42 = m6[mpos + 8] | m6[mpos + 9] << 8;
              h42 += (t32 >>> 4 | t42 << 12) & 8191;
              h52 += t42 >>> 1 & 8191;
              var t52 = m6[mpos + 10] | m6[mpos + 11] << 8;
              h62 += (t42 >>> 14 | t52 << 2) & 8191;
              var t6 = m6[mpos + 12] | m6[mpos + 13] << 8;
              h72 += (t52 >>> 11 | t6 << 5) & 8191;
              var t7 = m6[mpos + 14] | m6[mpos + 15] << 8;
              h82 += (t6 >>> 8 | t7 << 8) & 8191;
              h92 += t7 >>> 5 | hibit;
              var c9 = 0;
              var d0 = c9;
              d0 += h0 * r0;
              d0 += h1 * (5 * r9);
              d0 += h22 * (5 * r8);
              d0 += h32 * (5 * r72);
              d0 += h42 * (5 * r62);
              c9 = d0 >>> 13;
              d0 &= 8191;
              d0 += h52 * (5 * r52);
              d0 += h62 * (5 * r42);
              d0 += h72 * (5 * r32);
              d0 += h82 * (5 * r22);
              d0 += h92 * (5 * r1);
              c9 += d0 >>> 13;
              d0 &= 8191;
              var d1 = c9;
              d1 += h0 * r1;
              d1 += h1 * r0;
              d1 += h22 * (5 * r9);
              d1 += h32 * (5 * r8);
              d1 += h42 * (5 * r72);
              c9 = d1 >>> 13;
              d1 &= 8191;
              d1 += h52 * (5 * r62);
              d1 += h62 * (5 * r52);
              d1 += h72 * (5 * r42);
              d1 += h82 * (5 * r32);
              d1 += h92 * (5 * r22);
              c9 += d1 >>> 13;
              d1 &= 8191;
              var d22 = c9;
              d22 += h0 * r22;
              d22 += h1 * r1;
              d22 += h22 * r0;
              d22 += h32 * (5 * r9);
              d22 += h42 * (5 * r8);
              c9 = d22 >>> 13;
              d22 &= 8191;
              d22 += h52 * (5 * r72);
              d22 += h62 * (5 * r62);
              d22 += h72 * (5 * r52);
              d22 += h82 * (5 * r42);
              d22 += h92 * (5 * r32);
              c9 += d22 >>> 13;
              d22 &= 8191;
              var d32 = c9;
              d32 += h0 * r32;
              d32 += h1 * r22;
              d32 += h22 * r1;
              d32 += h32 * r0;
              d32 += h42 * (5 * r9);
              c9 = d32 >>> 13;
              d32 &= 8191;
              d32 += h52 * (5 * r8);
              d32 += h62 * (5 * r72);
              d32 += h72 * (5 * r62);
              d32 += h82 * (5 * r52);
              d32 += h92 * (5 * r42);
              c9 += d32 >>> 13;
              d32 &= 8191;
              var d42 = c9;
              d42 += h0 * r42;
              d42 += h1 * r32;
              d42 += h22 * r22;
              d42 += h32 * r1;
              d42 += h42 * r0;
              c9 = d42 >>> 13;
              d42 &= 8191;
              d42 += h52 * (5 * r9);
              d42 += h62 * (5 * r8);
              d42 += h72 * (5 * r72);
              d42 += h82 * (5 * r62);
              d42 += h92 * (5 * r52);
              c9 += d42 >>> 13;
              d42 &= 8191;
              var d52 = c9;
              d52 += h0 * r52;
              d52 += h1 * r42;
              d52 += h22 * r32;
              d52 += h32 * r22;
              d52 += h42 * r1;
              c9 = d52 >>> 13;
              d52 &= 8191;
              d52 += h52 * r0;
              d52 += h62 * (5 * r9);
              d52 += h72 * (5 * r8);
              d52 += h82 * (5 * r72);
              d52 += h92 * (5 * r62);
              c9 += d52 >>> 13;
              d52 &= 8191;
              var d62 = c9;
              d62 += h0 * r62;
              d62 += h1 * r52;
              d62 += h22 * r42;
              d62 += h32 * r32;
              d62 += h42 * r22;
              c9 = d62 >>> 13;
              d62 &= 8191;
              d62 += h52 * r1;
              d62 += h62 * r0;
              d62 += h72 * (5 * r9);
              d62 += h82 * (5 * r8);
              d62 += h92 * (5 * r72);
              c9 += d62 >>> 13;
              d62 &= 8191;
              var d7 = c9;
              d7 += h0 * r72;
              d7 += h1 * r62;
              d7 += h22 * r52;
              d7 += h32 * r42;
              d7 += h42 * r32;
              c9 = d7 >>> 13;
              d7 &= 8191;
              d7 += h52 * r22;
              d7 += h62 * r1;
              d7 += h72 * r0;
              d7 += h82 * (5 * r9);
              d7 += h92 * (5 * r8);
              c9 += d7 >>> 13;
              d7 &= 8191;
              var d8 = c9;
              d8 += h0 * r8;
              d8 += h1 * r72;
              d8 += h22 * r62;
              d8 += h32 * r52;
              d8 += h42 * r42;
              c9 = d8 >>> 13;
              d8 &= 8191;
              d8 += h52 * r32;
              d8 += h62 * r22;
              d8 += h72 * r1;
              d8 += h82 * r0;
              d8 += h92 * (5 * r9);
              c9 += d8 >>> 13;
              d8 &= 8191;
              var d9 = c9;
              d9 += h0 * r9;
              d9 += h1 * r8;
              d9 += h22 * r72;
              d9 += h32 * r62;
              d9 += h42 * r52;
              c9 = d9 >>> 13;
              d9 &= 8191;
              d9 += h52 * r42;
              d9 += h62 * r32;
              d9 += h72 * r22;
              d9 += h82 * r1;
              d9 += h92 * r0;
              c9 += d9 >>> 13;
              d9 &= 8191;
              c9 = (c9 << 2) + c9 | 0;
              c9 = c9 + d0 | 0;
              d0 = c9 & 8191;
              c9 = c9 >>> 13;
              d1 += c9;
              h0 = d0;
              h1 = d1;
              h22 = d22;
              h32 = d32;
              h42 = d42;
              h52 = d52;
              h62 = d62;
              h72 = d7;
              h82 = d8;
              h92 = d9;
              mpos += 16;
              bytes3 -= 16;
            }
            this._h[0] = h0;
            this._h[1] = h1;
            this._h[2] = h22;
            this._h[3] = h32;
            this._h[4] = h42;
            this._h[5] = h52;
            this._h[6] = h62;
            this._h[7] = h72;
            this._h[8] = h82;
            this._h[9] = h92;
          };
          Poly13052.prototype.finish = function(mac, macpos) {
            if (macpos === void 0) {
              macpos = 0;
            }
            var g7 = new Uint16Array(10);
            var c9;
            var mask;
            var f7;
            var i7;
            if (this._leftover) {
              i7 = this._leftover;
              this._buffer[i7++] = 1;
              for (; i7 < 16; i7++) {
                this._buffer[i7] = 0;
              }
              this._fin = 1;
              this._blocks(this._buffer, 0, 16);
            }
            c9 = this._h[1] >>> 13;
            this._h[1] &= 8191;
            for (i7 = 2; i7 < 10; i7++) {
              this._h[i7] += c9;
              c9 = this._h[i7] >>> 13;
              this._h[i7] &= 8191;
            }
            this._h[0] += c9 * 5;
            c9 = this._h[0] >>> 13;
            this._h[0] &= 8191;
            this._h[1] += c9;
            c9 = this._h[1] >>> 13;
            this._h[1] &= 8191;
            this._h[2] += c9;
            g7[0] = this._h[0] + 5;
            c9 = g7[0] >>> 13;
            g7[0] &= 8191;
            for (i7 = 1; i7 < 10; i7++) {
              g7[i7] = this._h[i7] + c9;
              c9 = g7[i7] >>> 13;
              g7[i7] &= 8191;
            }
            g7[9] -= 1 << 13;
            mask = (c9 ^ 1) - 1;
            for (i7 = 0; i7 < 10; i7++) {
              g7[i7] &= mask;
            }
            mask = ~mask;
            for (i7 = 0; i7 < 10; i7++) {
              this._h[i7] = this._h[i7] & mask | g7[i7];
            }
            this._h[0] = (this._h[0] | this._h[1] << 13) & 65535;
            this._h[1] = (this._h[1] >>> 3 | this._h[2] << 10) & 65535;
            this._h[2] = (this._h[2] >>> 6 | this._h[3] << 7) & 65535;
            this._h[3] = (this._h[3] >>> 9 | this._h[4] << 4) & 65535;
            this._h[4] = (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14) & 65535;
            this._h[5] = (this._h[6] >>> 2 | this._h[7] << 11) & 65535;
            this._h[6] = (this._h[7] >>> 5 | this._h[8] << 8) & 65535;
            this._h[7] = (this._h[8] >>> 8 | this._h[9] << 5) & 65535;
            f7 = this._h[0] + this._pad[0];
            this._h[0] = f7 & 65535;
            for (i7 = 1; i7 < 8; i7++) {
              f7 = (this._h[i7] + this._pad[i7] | 0) + (f7 >>> 16) | 0;
              this._h[i7] = f7 & 65535;
            }
            mac[macpos + 0] = this._h[0] >>> 0;
            mac[macpos + 1] = this._h[0] >>> 8;
            mac[macpos + 2] = this._h[1] >>> 0;
            mac[macpos + 3] = this._h[1] >>> 8;
            mac[macpos + 4] = this._h[2] >>> 0;
            mac[macpos + 5] = this._h[2] >>> 8;
            mac[macpos + 6] = this._h[3] >>> 0;
            mac[macpos + 7] = this._h[3] >>> 8;
            mac[macpos + 8] = this._h[4] >>> 0;
            mac[macpos + 9] = this._h[4] >>> 8;
            mac[macpos + 10] = this._h[5] >>> 0;
            mac[macpos + 11] = this._h[5] >>> 8;
            mac[macpos + 12] = this._h[6] >>> 0;
            mac[macpos + 13] = this._h[6] >>> 8;
            mac[macpos + 14] = this._h[7] >>> 0;
            mac[macpos + 15] = this._h[7] >>> 8;
            this._finished = true;
            return this;
          };
          Poly13052.prototype.update = function(m6) {
            var mpos = 0;
            var bytes3 = m6.length;
            var want;
            if (this._leftover) {
              want = 16 - this._leftover;
              if (want > bytes3) {
                want = bytes3;
              }
              for (var i7 = 0; i7 < want; i7++) {
                this._buffer[this._leftover + i7] = m6[mpos + i7];
              }
              bytes3 -= want;
              mpos += want;
              this._leftover += want;
              if (this._leftover < 16) {
                return this;
              }
              this._blocks(this._buffer, 0, 16);
              this._leftover = 0;
            }
            if (bytes3 >= 16) {
              want = bytes3 - bytes3 % 16;
              this._blocks(m6, mpos, want);
              mpos += want;
              bytes3 -= want;
            }
            if (bytes3) {
              for (var i7 = 0; i7 < bytes3; i7++) {
                this._buffer[this._leftover + i7] = m6[mpos + i7];
              }
              this._leftover += bytes3;
            }
            return this;
          };
          Poly13052.prototype.digest = function() {
            if (this._finished) {
              throw new Error("Poly1305 was finished");
            }
            var mac = new Uint8Array(16);
            this.finish(mac);
            return mac;
          };
          Poly13052.prototype.clean = function() {
            wipe_1.wipe(this._buffer);
            wipe_1.wipe(this._r);
            wipe_1.wipe(this._h);
            wipe_1.wipe(this._pad);
            this._leftover = 0;
            this._fin = 0;
            this._finished = true;
            return this;
          };
          return Poly13052;
        }()
      );
      exports.Poly1305 = Poly1305;
      function oneTimeAuth(key2, data2) {
        var h10 = new Poly1305(key2);
        h10.update(data2);
        var digest2 = h10.digest();
        h10.clean();
        return digest2;
      }
      exports.oneTimeAuth = oneTimeAuth;
      function equal(a6, b7) {
        if (a6.length !== exports.DIGEST_LENGTH || b7.length !== exports.DIGEST_LENGTH) {
          return false;
        }
        return constant_time_1.equal(a6, b7);
      }
      exports.equal = equal;
    }
  });

  // node_modules/@stablelib/chacha20poly1305/lib/chacha20poly1305.js
  var require_chacha20poly1305 = __commonJS({
    "node_modules/@stablelib/chacha20poly1305/lib/chacha20poly1305.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var chacha_1 = require_chacha();
      var poly1305_1 = require_poly1305();
      var wipe_1 = require_wipe();
      var binary_1 = require_binary();
      var constant_time_1 = require_constant_time();
      exports.KEY_LENGTH = 32;
      exports.NONCE_LENGTH = 12;
      exports.TAG_LENGTH = 16;
      var ZEROS = new Uint8Array(16);
      var ChaCha20Poly1305 = (
        /** @class */
        function() {
          function ChaCha20Poly13052(key2) {
            this.nonceLength = exports.NONCE_LENGTH;
            this.tagLength = exports.TAG_LENGTH;
            if (key2.length !== exports.KEY_LENGTH) {
              throw new Error("ChaCha20Poly1305 needs 32-byte key");
            }
            this._key = new Uint8Array(key2);
          }
          ChaCha20Poly13052.prototype.seal = function(nonce, plaintext, associatedData, dst) {
            if (nonce.length > 16) {
              throw new Error("ChaCha20Poly1305: incorrect nonce length");
            }
            var counter = new Uint8Array(16);
            counter.set(nonce, counter.length - nonce.length);
            var authKey = new Uint8Array(32);
            chacha_1.stream(this._key, counter, authKey, 4);
            var resultLength = plaintext.length + this.tagLength;
            var result;
            if (dst) {
              if (dst.length !== resultLength) {
                throw new Error("ChaCha20Poly1305: incorrect destination length");
              }
              result = dst;
            } else {
              result = new Uint8Array(resultLength);
            }
            chacha_1.streamXOR(this._key, counter, plaintext, result, 4);
            this._authenticate(result.subarray(result.length - this.tagLength, result.length), authKey, result.subarray(0, result.length - this.tagLength), associatedData);
            wipe_1.wipe(counter);
            return result;
          };
          ChaCha20Poly13052.prototype.open = function(nonce, sealed, associatedData, dst) {
            if (nonce.length > 16) {
              throw new Error("ChaCha20Poly1305: incorrect nonce length");
            }
            if (sealed.length < this.tagLength) {
              return null;
            }
            var counter = new Uint8Array(16);
            counter.set(nonce, counter.length - nonce.length);
            var authKey = new Uint8Array(32);
            chacha_1.stream(this._key, counter, authKey, 4);
            var calculatedTag = new Uint8Array(this.tagLength);
            this._authenticate(calculatedTag, authKey, sealed.subarray(0, sealed.length - this.tagLength), associatedData);
            if (!constant_time_1.equal(calculatedTag, sealed.subarray(sealed.length - this.tagLength, sealed.length))) {
              return null;
            }
            var resultLength = sealed.length - this.tagLength;
            var result;
            if (dst) {
              if (dst.length !== resultLength) {
                throw new Error("ChaCha20Poly1305: incorrect destination length");
              }
              result = dst;
            } else {
              result = new Uint8Array(resultLength);
            }
            chacha_1.streamXOR(this._key, counter, sealed.subarray(0, sealed.length - this.tagLength), result, 4);
            wipe_1.wipe(counter);
            return result;
          };
          ChaCha20Poly13052.prototype.clean = function() {
            wipe_1.wipe(this._key);
            return this;
          };
          ChaCha20Poly13052.prototype._authenticate = function(tagOut, authKey, ciphertext, associatedData) {
            var h10 = new poly1305_1.Poly1305(authKey);
            if (associatedData) {
              h10.update(associatedData);
              if (associatedData.length % 16 > 0) {
                h10.update(ZEROS.subarray(associatedData.length % 16));
              }
            }
            h10.update(ciphertext);
            if (ciphertext.length % 16 > 0) {
              h10.update(ZEROS.subarray(ciphertext.length % 16));
            }
            var length2 = new Uint8Array(8);
            if (associatedData) {
              binary_1.writeUint64LE(associatedData.length, length2);
            }
            h10.update(length2);
            binary_1.writeUint64LE(ciphertext.length, length2);
            h10.update(length2);
            var tag = h10.digest();
            for (var i7 = 0; i7 < tag.length; i7++) {
              tagOut[i7] = tag[i7];
            }
            h10.clean();
            wipe_1.wipe(tag);
            wipe_1.wipe(length2);
          };
          return ChaCha20Poly13052;
        }()
      );
      exports.ChaCha20Poly1305 = ChaCha20Poly1305;
    }
  });

  // node_modules/@stablelib/hash/lib/hash.js
  var require_hash = __commonJS({
    "node_modules/@stablelib/hash/lib/hash.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      function isSerializableHash(h10) {
        return typeof h10.saveState !== "undefined" && typeof h10.restoreState !== "undefined" && typeof h10.cleanSavedState !== "undefined";
      }
      exports.isSerializableHash = isSerializableHash;
    }
  });

  // node_modules/@stablelib/hmac/lib/hmac.js
  var require_hmac = __commonJS({
    "node_modules/@stablelib/hmac/lib/hmac.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var hash_1 = require_hash();
      var constant_time_1 = require_constant_time();
      var wipe_1 = require_wipe();
      var HMAC = (
        /** @class */
        function() {
          function HMAC2(hash5, key2) {
            this._finished = false;
            this._inner = new hash5();
            this._outer = new hash5();
            this.blockSize = this._outer.blockSize;
            this.digestLength = this._outer.digestLength;
            var pad2 = new Uint8Array(this.blockSize);
            if (key2.length > this.blockSize) {
              this._inner.update(key2).finish(pad2).clean();
            } else {
              pad2.set(key2);
            }
            for (var i7 = 0; i7 < pad2.length; i7++) {
              pad2[i7] ^= 54;
            }
            this._inner.update(pad2);
            for (var i7 = 0; i7 < pad2.length; i7++) {
              pad2[i7] ^= 54 ^ 92;
            }
            this._outer.update(pad2);
            if (hash_1.isSerializableHash(this._inner) && hash_1.isSerializableHash(this._outer)) {
              this._innerKeyedState = this._inner.saveState();
              this._outerKeyedState = this._outer.saveState();
            }
            wipe_1.wipe(pad2);
          }
          HMAC2.prototype.reset = function() {
            if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {
              throw new Error("hmac: can't reset() because hash doesn't implement restoreState()");
            }
            this._inner.restoreState(this._innerKeyedState);
            this._outer.restoreState(this._outerKeyedState);
            this._finished = false;
            return this;
          };
          HMAC2.prototype.clean = function() {
            if (hash_1.isSerializableHash(this._inner)) {
              this._inner.cleanSavedState(this._innerKeyedState);
            }
            if (hash_1.isSerializableHash(this._outer)) {
              this._outer.cleanSavedState(this._outerKeyedState);
            }
            this._inner.clean();
            this._outer.clean();
          };
          HMAC2.prototype.update = function(data2) {
            this._inner.update(data2);
            return this;
          };
          HMAC2.prototype.finish = function(out) {
            if (this._finished) {
              this._outer.finish(out);
              return this;
            }
            this._inner.finish(out);
            this._outer.update(out.subarray(0, this.digestLength)).finish(out);
            this._finished = true;
            return this;
          };
          HMAC2.prototype.digest = function() {
            var out = new Uint8Array(this.digestLength);
            this.finish(out);
            return out;
          };
          HMAC2.prototype.saveState = function() {
            if (!hash_1.isSerializableHash(this._inner)) {
              throw new Error("hmac: can't saveState() because hash doesn't implement it");
            }
            return this._inner.saveState();
          };
          HMAC2.prototype.restoreState = function(savedState) {
            if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {
              throw new Error("hmac: can't restoreState() because hash doesn't implement it");
            }
            this._inner.restoreState(savedState);
            this._outer.restoreState(this._outerKeyedState);
            this._finished = false;
            return this;
          };
          HMAC2.prototype.cleanSavedState = function(savedState) {
            if (!hash_1.isSerializableHash(this._inner)) {
              throw new Error("hmac: can't cleanSavedState() because hash doesn't implement it");
            }
            this._inner.cleanSavedState(savedState);
          };
          return HMAC2;
        }()
      );
      exports.HMAC = HMAC;
      function hmac2(hash5, key2, data2) {
        var h10 = new HMAC(hash5, key2);
        h10.update(data2);
        var digest2 = h10.digest();
        h10.clean();
        return digest2;
      }
      exports.hmac = hmac2;
      exports.equal = constant_time_1.equal;
    }
  });

  // node_modules/@stablelib/hkdf/lib/hkdf.js
  var require_hkdf = __commonJS({
    "node_modules/@stablelib/hkdf/lib/hkdf.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var hmac_1 = require_hmac();
      var wipe_1 = require_wipe();
      var HKDF = (
        /** @class */
        function() {
          function HKDF2(hash5, key2, salt, info) {
            if (salt === void 0) {
              salt = new Uint8Array(0);
            }
            this._counter = new Uint8Array(1);
            this._hash = hash5;
            this._info = info;
            var okm = hmac_1.hmac(this._hash, salt, key2);
            this._hmac = new hmac_1.HMAC(hash5, okm);
            this._buffer = new Uint8Array(this._hmac.digestLength);
            this._bufpos = this._buffer.length;
          }
          HKDF2.prototype._fillBuffer = function() {
            this._counter[0]++;
            var ctr = this._counter[0];
            if (ctr === 0) {
              throw new Error("hkdf: cannot expand more");
            }
            this._hmac.reset();
            if (ctr > 1) {
              this._hmac.update(this._buffer);
            }
            if (this._info) {
              this._hmac.update(this._info);
            }
            this._hmac.update(this._counter);
            this._hmac.finish(this._buffer);
            this._bufpos = 0;
          };
          HKDF2.prototype.expand = function(length2) {
            var out = new Uint8Array(length2);
            for (var i7 = 0; i7 < out.length; i7++) {
              if (this._bufpos === this._buffer.length) {
                this._fillBuffer();
              }
              out[i7] = this._buffer[this._bufpos++];
            }
            return out;
          };
          HKDF2.prototype.clean = function() {
            this._hmac.clean();
            wipe_1.wipe(this._buffer);
            wipe_1.wipe(this._counter);
            this._bufpos = 0;
          };
          return HKDF2;
        }()
      );
      exports.HKDF = HKDF;
    }
  });

  // node_modules/@stablelib/random/lib/source/browser.js
  var require_browser = __commonJS({
    "node_modules/@stablelib/random/lib/source/browser.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BrowserRandomSource = void 0;
      var QUOTA = 65536;
      var BrowserRandomSource = class {
        constructor() {
          this.isAvailable = false;
          this.isInstantiated = false;
          const browserCrypto = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
          if (browserCrypto && browserCrypto.getRandomValues !== void 0) {
            this._crypto = browserCrypto;
            this.isAvailable = true;
            this.isInstantiated = true;
          }
        }
        randomBytes(length2) {
          if (!this.isAvailable || !this._crypto) {
            throw new Error("Browser random byte generator is not available.");
          }
          const out = new Uint8Array(length2);
          for (let i7 = 0; i7 < out.length; i7 += QUOTA) {
            this._crypto.getRandomValues(out.subarray(i7, i7 + Math.min(out.length - i7, QUOTA)));
          }
          return out;
        }
      };
      exports.BrowserRandomSource = BrowserRandomSource;
    }
  });

  // (disabled):crypto
  var require_crypto = __commonJS({
    "(disabled):crypto"() {
    }
  });

  // node_modules/@stablelib/random/lib/source/node.js
  var require_node = __commonJS({
    "node_modules/@stablelib/random/lib/source/node.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.NodeRandomSource = void 0;
      var wipe_1 = require_wipe();
      var NodeRandomSource = class {
        constructor() {
          this.isAvailable = false;
          this.isInstantiated = false;
          if (typeof __require !== "undefined") {
            const nodeCrypto = require_crypto();
            if (nodeCrypto && nodeCrypto.randomBytes) {
              this._crypto = nodeCrypto;
              this.isAvailable = true;
              this.isInstantiated = true;
            }
          }
        }
        randomBytes(length2) {
          if (!this.isAvailable || !this._crypto) {
            throw new Error("Node.js random byte generator is not available.");
          }
          let buffer2 = this._crypto.randomBytes(length2);
          if (buffer2.length !== length2) {
            throw new Error("NodeRandomSource: got fewer bytes than requested");
          }
          const out = new Uint8Array(length2);
          for (let i7 = 0; i7 < out.length; i7++) {
            out[i7] = buffer2[i7];
          }
          (0, wipe_1.wipe)(buffer2);
          return out;
        }
      };
      exports.NodeRandomSource = NodeRandomSource;
    }
  });

  // node_modules/@stablelib/random/lib/source/system.js
  var require_system = __commonJS({
    "node_modules/@stablelib/random/lib/source/system.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SystemRandomSource = void 0;
      var browser_1 = require_browser();
      var node_1 = require_node();
      var SystemRandomSource = class {
        constructor() {
          this.isAvailable = false;
          this.name = "";
          this._source = new browser_1.BrowserRandomSource();
          if (this._source.isAvailable) {
            this.isAvailable = true;
            this.name = "Browser";
            return;
          }
          this._source = new node_1.NodeRandomSource();
          if (this._source.isAvailable) {
            this.isAvailable = true;
            this.name = "Node";
            return;
          }
        }
        randomBytes(length2) {
          if (!this.isAvailable) {
            throw new Error("System random byte generator is not available.");
          }
          return this._source.randomBytes(length2);
        }
      };
      exports.SystemRandomSource = SystemRandomSource;
    }
  });

  // node_modules/@stablelib/random/lib/random.js
  var require_random = __commonJS({
    "node_modules/@stablelib/random/lib/random.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.randomStringForEntropy = exports.randomString = exports.randomUint32 = exports.randomBytes = exports.defaultRandomSource = void 0;
      var system_1 = require_system();
      var binary_1 = require_binary();
      var wipe_1 = require_wipe();
      exports.defaultRandomSource = new system_1.SystemRandomSource();
      function randomBytes3(length2, prng = exports.defaultRandomSource) {
        return prng.randomBytes(length2);
      }
      exports.randomBytes = randomBytes3;
      function randomUint32(prng = exports.defaultRandomSource) {
        const buf = randomBytes3(4, prng);
        const result = (0, binary_1.readUint32LE)(buf);
        (0, wipe_1.wipe)(buf);
        return result;
      }
      exports.randomUint32 = randomUint32;
      var ALPHANUMERIC = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
      function randomString(length2, charset = ALPHANUMERIC, prng = exports.defaultRandomSource) {
        if (charset.length < 2) {
          throw new Error("randomString charset is too short");
        }
        if (charset.length > 256) {
          throw new Error("randomString charset is too long");
        }
        let out = "";
        const charsLen = charset.length;
        const maxByte = 256 - 256 % charsLen;
        while (length2 > 0) {
          const buf = randomBytes3(Math.ceil(length2 * 256 / maxByte), prng);
          for (let i7 = 0; i7 < buf.length && length2 > 0; i7++) {
            const randomByte = buf[i7];
            if (randomByte < maxByte) {
              out += charset.charAt(randomByte % charsLen);
              length2--;
            }
          }
          (0, wipe_1.wipe)(buf);
        }
        return out;
      }
      exports.randomString = randomString;
      function randomStringForEntropy(bits, charset = ALPHANUMERIC, prng = exports.defaultRandomSource) {
        const length2 = Math.ceil(bits / (Math.log(charset.length) / Math.LN2));
        return randomString(length2, charset, prng);
      }
      exports.randomStringForEntropy = randomStringForEntropy;
    }
  });

  // node_modules/@stablelib/sha256/lib/sha256.js
  var require_sha256 = __commonJS({
    "node_modules/@stablelib/sha256/lib/sha256.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var binary_1 = require_binary();
      var wipe_1 = require_wipe();
      exports.DIGEST_LENGTH = 32;
      exports.BLOCK_SIZE = 64;
      var SHA256 = (
        /** @class */
        function() {
          function SHA2562() {
            this.digestLength = exports.DIGEST_LENGTH;
            this.blockSize = exports.BLOCK_SIZE;
            this._state = new Int32Array(8);
            this._temp = new Int32Array(64);
            this._buffer = new Uint8Array(128);
            this._bufferLength = 0;
            this._bytesHashed = 0;
            this._finished = false;
            this.reset();
          }
          SHA2562.prototype._initState = function() {
            this._state[0] = 1779033703;
            this._state[1] = 3144134277;
            this._state[2] = 1013904242;
            this._state[3] = 2773480762;
            this._state[4] = 1359893119;
            this._state[5] = 2600822924;
            this._state[6] = 528734635;
            this._state[7] = 1541459225;
          };
          SHA2562.prototype.reset = function() {
            this._initState();
            this._bufferLength = 0;
            this._bytesHashed = 0;
            this._finished = false;
            return this;
          };
          SHA2562.prototype.clean = function() {
            wipe_1.wipe(this._buffer);
            wipe_1.wipe(this._temp);
            this.reset();
          };
          SHA2562.prototype.update = function(data2, dataLength) {
            if (dataLength === void 0) {
              dataLength = data2.length;
            }
            if (this._finished) {
              throw new Error("SHA256: can't update because hash was finished.");
            }
            var dataPos = 0;
            this._bytesHashed += dataLength;
            if (this._bufferLength > 0) {
              while (this._bufferLength < this.blockSize && dataLength > 0) {
                this._buffer[this._bufferLength++] = data2[dataPos++];
                dataLength--;
              }
              if (this._bufferLength === this.blockSize) {
                hashBlocks(this._temp, this._state, this._buffer, 0, this.blockSize);
                this._bufferLength = 0;
              }
            }
            if (dataLength >= this.blockSize) {
              dataPos = hashBlocks(this._temp, this._state, data2, dataPos, dataLength);
              dataLength %= this.blockSize;
            }
            while (dataLength > 0) {
              this._buffer[this._bufferLength++] = data2[dataPos++];
              dataLength--;
            }
            return this;
          };
          SHA2562.prototype.finish = function(out) {
            if (!this._finished) {
              var bytesHashed = this._bytesHashed;
              var left = this._bufferLength;
              var bitLenHi = bytesHashed / 536870912 | 0;
              var bitLenLo = bytesHashed << 3;
              var padLength = bytesHashed % 64 < 56 ? 64 : 128;
              this._buffer[left] = 128;
              for (var i7 = left + 1; i7 < padLength - 8; i7++) {
                this._buffer[i7] = 0;
              }
              binary_1.writeUint32BE(bitLenHi, this._buffer, padLength - 8);
              binary_1.writeUint32BE(bitLenLo, this._buffer, padLength - 4);
              hashBlocks(this._temp, this._state, this._buffer, 0, padLength);
              this._finished = true;
            }
            for (var i7 = 0; i7 < this.digestLength / 4; i7++) {
              binary_1.writeUint32BE(this._state[i7], out, i7 * 4);
            }
            return this;
          };
          SHA2562.prototype.digest = function() {
            var out = new Uint8Array(this.digestLength);
            this.finish(out);
            return out;
          };
          SHA2562.prototype.saveState = function() {
            if (this._finished) {
              throw new Error("SHA256: cannot save finished state");
            }
            return {
              state: new Int32Array(this._state),
              buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
              bufferLength: this._bufferLength,
              bytesHashed: this._bytesHashed
            };
          };
          SHA2562.prototype.restoreState = function(savedState) {
            this._state.set(savedState.state);
            this._bufferLength = savedState.bufferLength;
            if (savedState.buffer) {
              this._buffer.set(savedState.buffer);
            }
            this._bytesHashed = savedState.bytesHashed;
            this._finished = false;
            return this;
          };
          SHA2562.prototype.cleanSavedState = function(savedState) {
            wipe_1.wipe(savedState.state);
            if (savedState.buffer) {
              wipe_1.wipe(savedState.buffer);
            }
            savedState.bufferLength = 0;
            savedState.bytesHashed = 0;
          };
          return SHA2562;
        }()
      );
      exports.SHA256 = SHA256;
      var K8 = new Int32Array([
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ]);
      function hashBlocks(w8, v6, p8, pos, len) {
        while (len >= 64) {
          var a6 = v6[0];
          var b7 = v6[1];
          var c9 = v6[2];
          var d7 = v6[3];
          var e9 = v6[4];
          var f7 = v6[5];
          var g7 = v6[6];
          var h10 = v6[7];
          for (var i7 = 0; i7 < 16; i7++) {
            var j7 = pos + i7 * 4;
            w8[i7] = binary_1.readUint32BE(p8, j7);
          }
          for (var i7 = 16; i7 < 64; i7++) {
            var u7 = w8[i7 - 2];
            var t1 = (u7 >>> 17 | u7 << 32 - 17) ^ (u7 >>> 19 | u7 << 32 - 19) ^ u7 >>> 10;
            u7 = w8[i7 - 15];
            var t22 = (u7 >>> 7 | u7 << 32 - 7) ^ (u7 >>> 18 | u7 << 32 - 18) ^ u7 >>> 3;
            w8[i7] = (t1 + w8[i7 - 7] | 0) + (t22 + w8[i7 - 16] | 0);
          }
          for (var i7 = 0; i7 < 64; i7++) {
            var t1 = (((e9 >>> 6 | e9 << 32 - 6) ^ (e9 >>> 11 | e9 << 32 - 11) ^ (e9 >>> 25 | e9 << 32 - 25)) + (e9 & f7 ^ ~e9 & g7) | 0) + (h10 + (K8[i7] + w8[i7] | 0) | 0) | 0;
            var t22 = ((a6 >>> 2 | a6 << 32 - 2) ^ (a6 >>> 13 | a6 << 32 - 13) ^ (a6 >>> 22 | a6 << 32 - 22)) + (a6 & b7 ^ a6 & c9 ^ b7 & c9) | 0;
            h10 = g7;
            g7 = f7;
            f7 = e9;
            e9 = d7 + t1 | 0;
            d7 = c9;
            c9 = b7;
            b7 = a6;
            a6 = t1 + t22 | 0;
          }
          v6[0] += a6;
          v6[1] += b7;
          v6[2] += c9;
          v6[3] += d7;
          v6[4] += e9;
          v6[5] += f7;
          v6[6] += g7;
          v6[7] += h10;
          pos += 64;
          len -= 64;
        }
        return pos;
      }
      function hash5(data2) {
        var h10 = new SHA256();
        h10.update(data2);
        var digest2 = h10.digest();
        h10.clean();
        return digest2;
      }
      exports.hash = hash5;
    }
  });

  // node_modules/@stablelib/x25519/lib/x25519.js
  var require_x25519 = __commonJS({
    "node_modules/@stablelib/x25519/lib/x25519.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.sharedKey = exports.generateKeyPair = exports.generateKeyPairFromSeed = exports.scalarMultBase = exports.scalarMult = exports.SHARED_KEY_LENGTH = exports.SECRET_KEY_LENGTH = exports.PUBLIC_KEY_LENGTH = void 0;
      var random_1 = require_random();
      var wipe_1 = require_wipe();
      exports.PUBLIC_KEY_LENGTH = 32;
      exports.SECRET_KEY_LENGTH = 32;
      exports.SHARED_KEY_LENGTH = 32;
      function gf(init2) {
        const r8 = new Float64Array(16);
        if (init2) {
          for (let i7 = 0; i7 < init2.length; i7++) {
            r8[i7] = init2[i7];
          }
        }
        return r8;
      }
      var _9 = new Uint8Array(32);
      _9[0] = 9;
      var _121665 = gf([56129, 1]);
      function car25519(o9) {
        let c9 = 1;
        for (let i7 = 0; i7 < 16; i7++) {
          let v6 = o9[i7] + c9 + 65535;
          c9 = Math.floor(v6 / 65536);
          o9[i7] = v6 - c9 * 65536;
        }
        o9[0] += c9 - 1 + 37 * (c9 - 1);
      }
      function sel25519(p8, q8, b7) {
        const c9 = ~(b7 - 1);
        for (let i7 = 0; i7 < 16; i7++) {
          const t6 = c9 & (p8[i7] ^ q8[i7]);
          p8[i7] ^= t6;
          q8[i7] ^= t6;
        }
      }
      function pack25519(o9, n9) {
        const m6 = gf();
        const t6 = gf();
        for (let i7 = 0; i7 < 16; i7++) {
          t6[i7] = n9[i7];
        }
        car25519(t6);
        car25519(t6);
        car25519(t6);
        for (let j7 = 0; j7 < 2; j7++) {
          m6[0] = t6[0] - 65517;
          for (let i7 = 1; i7 < 15; i7++) {
            m6[i7] = t6[i7] - 65535 - (m6[i7 - 1] >> 16 & 1);
            m6[i7 - 1] &= 65535;
          }
          m6[15] = t6[15] - 32767 - (m6[14] >> 16 & 1);
          const b7 = m6[15] >> 16 & 1;
          m6[14] &= 65535;
          sel25519(t6, m6, 1 - b7);
        }
        for (let i7 = 0; i7 < 16; i7++) {
          o9[2 * i7] = t6[i7] & 255;
          o9[2 * i7 + 1] = t6[i7] >> 8;
        }
      }
      function unpack25519(o9, n9) {
        for (let i7 = 0; i7 < 16; i7++) {
          o9[i7] = n9[2 * i7] + (n9[2 * i7 + 1] << 8);
        }
        o9[15] &= 32767;
      }
      function add4(o9, a6, b7) {
        for (let i7 = 0; i7 < 16; i7++) {
          o9[i7] = a6[i7] + b7[i7];
        }
      }
      function sub(o9, a6, b7) {
        for (let i7 = 0; i7 < 16; i7++) {
          o9[i7] = a6[i7] - b7[i7];
        }
      }
      function mul3(o9, a6, b7) {
        let v6, c9, t0 = 0, t1 = 0, t22 = 0, t32 = 0, t42 = 0, t52 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t222 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b7[0], b1 = b7[1], b22 = b7[2], b32 = b7[3], b42 = b7[4], b52 = b7[5], b62 = b7[6], b72 = b7[7], b8 = b7[8], b9 = b7[9], b10 = b7[10], b11 = b7[11], b12 = b7[12], b13 = b7[13], b14 = b7[14], b15 = b7[15];
        v6 = a6[0];
        t0 += v6 * b0;
        t1 += v6 * b1;
        t22 += v6 * b22;
        t32 += v6 * b32;
        t42 += v6 * b42;
        t52 += v6 * b52;
        t6 += v6 * b62;
        t7 += v6 * b72;
        t8 += v6 * b8;
        t9 += v6 * b9;
        t10 += v6 * b10;
        t11 += v6 * b11;
        t12 += v6 * b12;
        t13 += v6 * b13;
        t14 += v6 * b14;
        t15 += v6 * b15;
        v6 = a6[1];
        t1 += v6 * b0;
        t22 += v6 * b1;
        t32 += v6 * b22;
        t42 += v6 * b32;
        t52 += v6 * b42;
        t6 += v6 * b52;
        t7 += v6 * b62;
        t8 += v6 * b72;
        t9 += v6 * b8;
        t10 += v6 * b9;
        t11 += v6 * b10;
        t12 += v6 * b11;
        t13 += v6 * b12;
        t14 += v6 * b13;
        t15 += v6 * b14;
        t16 += v6 * b15;
        v6 = a6[2];
        t22 += v6 * b0;
        t32 += v6 * b1;
        t42 += v6 * b22;
        t52 += v6 * b32;
        t6 += v6 * b42;
        t7 += v6 * b52;
        t8 += v6 * b62;
        t9 += v6 * b72;
        t10 += v6 * b8;
        t11 += v6 * b9;
        t12 += v6 * b10;
        t13 += v6 * b11;
        t14 += v6 * b12;
        t15 += v6 * b13;
        t16 += v6 * b14;
        t17 += v6 * b15;
        v6 = a6[3];
        t32 += v6 * b0;
        t42 += v6 * b1;
        t52 += v6 * b22;
        t6 += v6 * b32;
        t7 += v6 * b42;
        t8 += v6 * b52;
        t9 += v6 * b62;
        t10 += v6 * b72;
        t11 += v6 * b8;
        t12 += v6 * b9;
        t13 += v6 * b10;
        t14 += v6 * b11;
        t15 += v6 * b12;
        t16 += v6 * b13;
        t17 += v6 * b14;
        t18 += v6 * b15;
        v6 = a6[4];
        t42 += v6 * b0;
        t52 += v6 * b1;
        t6 += v6 * b22;
        t7 += v6 * b32;
        t8 += v6 * b42;
        t9 += v6 * b52;
        t10 += v6 * b62;
        t11 += v6 * b72;
        t12 += v6 * b8;
        t13 += v6 * b9;
        t14 += v6 * b10;
        t15 += v6 * b11;
        t16 += v6 * b12;
        t17 += v6 * b13;
        t18 += v6 * b14;
        t19 += v6 * b15;
        v6 = a6[5];
        t52 += v6 * b0;
        t6 += v6 * b1;
        t7 += v6 * b22;
        t8 += v6 * b32;
        t9 += v6 * b42;
        t10 += v6 * b52;
        t11 += v6 * b62;
        t12 += v6 * b72;
        t13 += v6 * b8;
        t14 += v6 * b9;
        t15 += v6 * b10;
        t16 += v6 * b11;
        t17 += v6 * b12;
        t18 += v6 * b13;
        t19 += v6 * b14;
        t20 += v6 * b15;
        v6 = a6[6];
        t6 += v6 * b0;
        t7 += v6 * b1;
        t8 += v6 * b22;
        t9 += v6 * b32;
        t10 += v6 * b42;
        t11 += v6 * b52;
        t12 += v6 * b62;
        t13 += v6 * b72;
        t14 += v6 * b8;
        t15 += v6 * b9;
        t16 += v6 * b10;
        t17 += v6 * b11;
        t18 += v6 * b12;
        t19 += v6 * b13;
        t20 += v6 * b14;
        t21 += v6 * b15;
        v6 = a6[7];
        t7 += v6 * b0;
        t8 += v6 * b1;
        t9 += v6 * b22;
        t10 += v6 * b32;
        t11 += v6 * b42;
        t12 += v6 * b52;
        t13 += v6 * b62;
        t14 += v6 * b72;
        t15 += v6 * b8;
        t16 += v6 * b9;
        t17 += v6 * b10;
        t18 += v6 * b11;
        t19 += v6 * b12;
        t20 += v6 * b13;
        t21 += v6 * b14;
        t222 += v6 * b15;
        v6 = a6[8];
        t8 += v6 * b0;
        t9 += v6 * b1;
        t10 += v6 * b22;
        t11 += v6 * b32;
        t12 += v6 * b42;
        t13 += v6 * b52;
        t14 += v6 * b62;
        t15 += v6 * b72;
        t16 += v6 * b8;
        t17 += v6 * b9;
        t18 += v6 * b10;
        t19 += v6 * b11;
        t20 += v6 * b12;
        t21 += v6 * b13;
        t222 += v6 * b14;
        t23 += v6 * b15;
        v6 = a6[9];
        t9 += v6 * b0;
        t10 += v6 * b1;
        t11 += v6 * b22;
        t12 += v6 * b32;
        t13 += v6 * b42;
        t14 += v6 * b52;
        t15 += v6 * b62;
        t16 += v6 * b72;
        t17 += v6 * b8;
        t18 += v6 * b9;
        t19 += v6 * b10;
        t20 += v6 * b11;
        t21 += v6 * b12;
        t222 += v6 * b13;
        t23 += v6 * b14;
        t24 += v6 * b15;
        v6 = a6[10];
        t10 += v6 * b0;
        t11 += v6 * b1;
        t12 += v6 * b22;
        t13 += v6 * b32;
        t14 += v6 * b42;
        t15 += v6 * b52;
        t16 += v6 * b62;
        t17 += v6 * b72;
        t18 += v6 * b8;
        t19 += v6 * b9;
        t20 += v6 * b10;
        t21 += v6 * b11;
        t222 += v6 * b12;
        t23 += v6 * b13;
        t24 += v6 * b14;
        t25 += v6 * b15;
        v6 = a6[11];
        t11 += v6 * b0;
        t12 += v6 * b1;
        t13 += v6 * b22;
        t14 += v6 * b32;
        t15 += v6 * b42;
        t16 += v6 * b52;
        t17 += v6 * b62;
        t18 += v6 * b72;
        t19 += v6 * b8;
        t20 += v6 * b9;
        t21 += v6 * b10;
        t222 += v6 * b11;
        t23 += v6 * b12;
        t24 += v6 * b13;
        t25 += v6 * b14;
        t26 += v6 * b15;
        v6 = a6[12];
        t12 += v6 * b0;
        t13 += v6 * b1;
        t14 += v6 * b22;
        t15 += v6 * b32;
        t16 += v6 * b42;
        t17 += v6 * b52;
        t18 += v6 * b62;
        t19 += v6 * b72;
        t20 += v6 * b8;
        t21 += v6 * b9;
        t222 += v6 * b10;
        t23 += v6 * b11;
        t24 += v6 * b12;
        t25 += v6 * b13;
        t26 += v6 * b14;
        t27 += v6 * b15;
        v6 = a6[13];
        t13 += v6 * b0;
        t14 += v6 * b1;
        t15 += v6 * b22;
        t16 += v6 * b32;
        t17 += v6 * b42;
        t18 += v6 * b52;
        t19 += v6 * b62;
        t20 += v6 * b72;
        t21 += v6 * b8;
        t222 += v6 * b9;
        t23 += v6 * b10;
        t24 += v6 * b11;
        t25 += v6 * b12;
        t26 += v6 * b13;
        t27 += v6 * b14;
        t28 += v6 * b15;
        v6 = a6[14];
        t14 += v6 * b0;
        t15 += v6 * b1;
        t16 += v6 * b22;
        t17 += v6 * b32;
        t18 += v6 * b42;
        t19 += v6 * b52;
        t20 += v6 * b62;
        t21 += v6 * b72;
        t222 += v6 * b8;
        t23 += v6 * b9;
        t24 += v6 * b10;
        t25 += v6 * b11;
        t26 += v6 * b12;
        t27 += v6 * b13;
        t28 += v6 * b14;
        t29 += v6 * b15;
        v6 = a6[15];
        t15 += v6 * b0;
        t16 += v6 * b1;
        t17 += v6 * b22;
        t18 += v6 * b32;
        t19 += v6 * b42;
        t20 += v6 * b52;
        t21 += v6 * b62;
        t222 += v6 * b72;
        t23 += v6 * b8;
        t24 += v6 * b9;
        t25 += v6 * b10;
        t26 += v6 * b11;
        t27 += v6 * b12;
        t28 += v6 * b13;
        t29 += v6 * b14;
        t30 += v6 * b15;
        t0 += 38 * t16;
        t1 += 38 * t17;
        t22 += 38 * t18;
        t32 += 38 * t19;
        t42 += 38 * t20;
        t52 += 38 * t21;
        t6 += 38 * t222;
        t7 += 38 * t23;
        t8 += 38 * t24;
        t9 += 38 * t25;
        t10 += 38 * t26;
        t11 += 38 * t27;
        t12 += 38 * t28;
        t13 += 38 * t29;
        t14 += 38 * t30;
        c9 = 1;
        v6 = t0 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t0 = v6 - c9 * 65536;
        v6 = t1 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t1 = v6 - c9 * 65536;
        v6 = t22 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t22 = v6 - c9 * 65536;
        v6 = t32 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t32 = v6 - c9 * 65536;
        v6 = t42 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t42 = v6 - c9 * 65536;
        v6 = t52 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t52 = v6 - c9 * 65536;
        v6 = t6 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t6 = v6 - c9 * 65536;
        v6 = t7 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t7 = v6 - c9 * 65536;
        v6 = t8 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t8 = v6 - c9 * 65536;
        v6 = t9 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t9 = v6 - c9 * 65536;
        v6 = t10 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t10 = v6 - c9 * 65536;
        v6 = t11 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t11 = v6 - c9 * 65536;
        v6 = t12 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t12 = v6 - c9 * 65536;
        v6 = t13 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t13 = v6 - c9 * 65536;
        v6 = t14 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t14 = v6 - c9 * 65536;
        v6 = t15 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t15 = v6 - c9 * 65536;
        t0 += c9 - 1 + 37 * (c9 - 1);
        c9 = 1;
        v6 = t0 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t0 = v6 - c9 * 65536;
        v6 = t1 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t1 = v6 - c9 * 65536;
        v6 = t22 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t22 = v6 - c9 * 65536;
        v6 = t32 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t32 = v6 - c9 * 65536;
        v6 = t42 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t42 = v6 - c9 * 65536;
        v6 = t52 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t52 = v6 - c9 * 65536;
        v6 = t6 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t6 = v6 - c9 * 65536;
        v6 = t7 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t7 = v6 - c9 * 65536;
        v6 = t8 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t8 = v6 - c9 * 65536;
        v6 = t9 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t9 = v6 - c9 * 65536;
        v6 = t10 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t10 = v6 - c9 * 65536;
        v6 = t11 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t11 = v6 - c9 * 65536;
        v6 = t12 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t12 = v6 - c9 * 65536;
        v6 = t13 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t13 = v6 - c9 * 65536;
        v6 = t14 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t14 = v6 - c9 * 65536;
        v6 = t15 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t15 = v6 - c9 * 65536;
        t0 += c9 - 1 + 37 * (c9 - 1);
        o9[0] = t0;
        o9[1] = t1;
        o9[2] = t22;
        o9[3] = t32;
        o9[4] = t42;
        o9[5] = t52;
        o9[6] = t6;
        o9[7] = t7;
        o9[8] = t8;
        o9[9] = t9;
        o9[10] = t10;
        o9[11] = t11;
        o9[12] = t12;
        o9[13] = t13;
        o9[14] = t14;
        o9[15] = t15;
      }
      function square(o9, a6) {
        mul3(o9, a6, a6);
      }
      function inv25519(o9, inp) {
        const c9 = gf();
        for (let i7 = 0; i7 < 16; i7++) {
          c9[i7] = inp[i7];
        }
        for (let i7 = 253; i7 >= 0; i7--) {
          square(c9, c9);
          if (i7 !== 2 && i7 !== 4) {
            mul3(c9, c9, inp);
          }
        }
        for (let i7 = 0; i7 < 16; i7++) {
          o9[i7] = c9[i7];
        }
      }
      function scalarMult(n9, p8) {
        const z7 = new Uint8Array(32);
        const x4 = new Float64Array(80);
        const a6 = gf(), b7 = gf(), c9 = gf(), d7 = gf(), e9 = gf(), f7 = gf();
        for (let i7 = 0; i7 < 31; i7++) {
          z7[i7] = n9[i7];
        }
        z7[31] = n9[31] & 127 | 64;
        z7[0] &= 248;
        unpack25519(x4, p8);
        for (let i7 = 0; i7 < 16; i7++) {
          b7[i7] = x4[i7];
        }
        a6[0] = d7[0] = 1;
        for (let i7 = 254; i7 >= 0; --i7) {
          const r8 = z7[i7 >>> 3] >>> (i7 & 7) & 1;
          sel25519(a6, b7, r8);
          sel25519(c9, d7, r8);
          add4(e9, a6, c9);
          sub(a6, a6, c9);
          add4(c9, b7, d7);
          sub(b7, b7, d7);
          square(d7, e9);
          square(f7, a6);
          mul3(a6, c9, a6);
          mul3(c9, b7, e9);
          add4(e9, a6, c9);
          sub(a6, a6, c9);
          square(b7, a6);
          sub(c9, d7, f7);
          mul3(a6, c9, _121665);
          add4(a6, a6, d7);
          mul3(c9, c9, a6);
          mul3(a6, d7, f7);
          mul3(d7, b7, x4);
          square(b7, e9);
          sel25519(a6, b7, r8);
          sel25519(c9, d7, r8);
        }
        for (let i7 = 0; i7 < 16; i7++) {
          x4[i7 + 16] = a6[i7];
          x4[i7 + 32] = c9[i7];
          x4[i7 + 48] = b7[i7];
          x4[i7 + 64] = d7[i7];
        }
        const x32 = x4.subarray(32);
        const x16 = x4.subarray(16);
        inv25519(x32, x32);
        mul3(x16, x16, x32);
        const q8 = new Uint8Array(32);
        pack25519(q8, x16);
        return q8;
      }
      exports.scalarMult = scalarMult;
      function scalarMultBase(n9) {
        return scalarMult(n9, _9);
      }
      exports.scalarMultBase = scalarMultBase;
      function generateKeyPairFromSeed2(seed) {
        if (seed.length !== exports.SECRET_KEY_LENGTH) {
          throw new Error(`x25519: seed must be ${exports.SECRET_KEY_LENGTH} bytes`);
        }
        const secretKey = new Uint8Array(seed);
        const publicKey = scalarMultBase(secretKey);
        return {
          publicKey,
          secretKey
        };
      }
      exports.generateKeyPairFromSeed = generateKeyPairFromSeed2;
      function generateKeyPair4(prng) {
        const seed = (0, random_1.randomBytes)(32, prng);
        const result = generateKeyPairFromSeed2(seed);
        (0, wipe_1.wipe)(seed);
        return result;
      }
      exports.generateKeyPair = generateKeyPair4;
      function sharedKey3(mySecretKey, theirPublicKey, rejectZero = false) {
        if (mySecretKey.length !== exports.PUBLIC_KEY_LENGTH) {
          throw new Error("X25519: incorrect secret key length");
        }
        if (theirPublicKey.length !== exports.PUBLIC_KEY_LENGTH) {
          throw new Error("X25519: incorrect public key length");
        }
        const result = scalarMult(mySecretKey, theirPublicKey);
        if (rejectZero) {
          let zeros2 = 0;
          for (let i7 = 0; i7 < result.length; i7++) {
            zeros2 |= result[i7];
          }
          if (zeros2 === 0) {
            throw new Error("X25519: invalid shared key");
          }
        }
        return result;
      }
      exports.sharedKey = sharedKey3;
    }
  });

  // node_modules/uint8arrays/esm/src/compare.js
  var init_compare = __esm({
    "node_modules/uint8arrays/esm/src/compare.js"() {
    }
  });

  // node_modules/uint8arrays/esm/src/util/as-uint8array.js
  function asUint8Array(buf) {
    if (globalThis.Buffer != null) {
      return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
    }
    return buf;
  }
  var init_as_uint8array = __esm({
    "node_modules/uint8arrays/esm/src/util/as-uint8array.js"() {
    }
  });

  // node_modules/uint8arrays/esm/src/alloc.js
  function allocUnsafe(size3 = 0) {
    if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
      return asUint8Array(globalThis.Buffer.allocUnsafe(size3));
    }
    return new Uint8Array(size3);
  }
  var init_alloc = __esm({
    "node_modules/uint8arrays/esm/src/alloc.js"() {
      init_as_uint8array();
    }
  });

  // node_modules/uint8arrays/esm/src/concat.js
  function concat2(arrays, length2) {
    if (!length2) {
      length2 = arrays.reduce((acc, curr) => acc + curr.length, 0);
    }
    const output2 = allocUnsafe(length2);
    let offset = 0;
    for (const arr of arrays) {
      output2.set(arr, offset);
      offset += arr.length;
    }
    return asUint8Array(output2);
  }
  var init_concat2 = __esm({
    "node_modules/uint8arrays/esm/src/concat.js"() {
      init_alloc();
      init_as_uint8array();
    }
  });

  // node_modules/uint8arrays/esm/src/equals.js
  var init_equals = __esm({
    "node_modules/uint8arrays/esm/src/equals.js"() {
    }
  });

  // node_modules/multiformats/esm/vendor/base-x.js
  function base(ALPHABET2, name2) {
    if (ALPHABET2.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j7 = 0; j7 < BASE_MAP.length; j7++) {
      BASE_MAP[j7] = 255;
    }
    for (var i7 = 0; i7 < ALPHABET2.length; i7++) {
      var x4 = ALPHABET2.charAt(i7);
      var xc = x4.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x4 + " is ambiguous");
      }
      BASE_MAP[xc] = i7;
    }
    var BASE = ALPHABET2.length;
    var LEADER = ALPHABET2.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode10(source) {
      if (source instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source)) {
        source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
      } else if (Array.isArray(source)) {
        source = Uint8Array.from(source);
      }
      if (!(source instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length2 = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size3 = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size3);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i8 = 0;
        for (var it1 = size3 - 1; (carry !== 0 || i8 < length2) && it1 !== -1; it1--, i8++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length2 = i8;
        pbegin++;
      }
      var it22 = size3 - length2;
      while (it22 !== size3 && b58[it22] === 0) {
        it22++;
      }
      var str = LEADER.repeat(zeroes);
      for (; it22 < size3; ++it22) {
        str += ALPHABET2.charAt(b58[it22]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return new Uint8Array();
      }
      var psz = 0;
      if (source[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length2 = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size3 = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size3);
      while (source[psz]) {
        var carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i8 = 0;
        for (var it3 = size3 - 1; (carry !== 0 || i8 < length2) && it3 !== -1; it3--, i8++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length2 = i8;
        psz++;
      }
      if (source[psz] === " ") {
        return;
      }
      var it4 = size3 - length2;
      while (it4 !== size3 && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size3 - it4));
      var j8 = zeroes;
      while (it4 !== size3) {
        vch[j8++] = b256[it4++];
      }
      return vch;
    }
    function decode8(string2) {
      var buffer2 = decodeUnsafe(string2);
      if (buffer2) {
        return buffer2;
      }
      throw new Error(`Non-${name2} character`);
    }
    return {
      encode: encode10,
      decodeUnsafe,
      decode: decode8
    };
  }
  var src, _brrp__multiformats_scope_baseX, base_x_default;
  var init_base_x = __esm({
    "node_modules/multiformats/esm/vendor/base-x.js"() {
      src = base;
      _brrp__multiformats_scope_baseX = src;
      base_x_default = _brrp__multiformats_scope_baseX;
    }
  });

  // node_modules/multiformats/esm/src/bytes.js
  var empty, equals, coerce, fromString, toString;
  var init_bytes = __esm({
    "node_modules/multiformats/esm/src/bytes.js"() {
      empty = new Uint8Array(0);
      equals = (aa2, bb) => {
        if (aa2 === bb)
          return true;
        if (aa2.byteLength !== bb.byteLength) {
          return false;
        }
        for (let ii2 = 0; ii2 < aa2.byteLength; ii2++) {
          if (aa2[ii2] !== bb[ii2]) {
            return false;
          }
        }
        return true;
      };
      coerce = (o9) => {
        if (o9 instanceof Uint8Array && o9.constructor.name === "Uint8Array")
          return o9;
        if (o9 instanceof ArrayBuffer)
          return new Uint8Array(o9);
        if (ArrayBuffer.isView(o9)) {
          return new Uint8Array(o9.buffer, o9.byteOffset, o9.byteLength);
        }
        throw new Error("Unknown type, must be binary type");
      };
      fromString = (str) => new TextEncoder().encode(str);
      toString = (b7) => new TextDecoder().decode(b7);
    }
  });

  // node_modules/multiformats/esm/src/bases/base.js
  var Encoder, Decoder, ComposedDecoder, or, Codec, from, baseX, decode, encode, rfc4648;
  var init_base2 = __esm({
    "node_modules/multiformats/esm/src/bases/base.js"() {
      init_base_x();
      init_bytes();
      Encoder = class {
        constructor(name2, prefix, baseEncode) {
          this.name = name2;
          this.prefix = prefix;
          this.baseEncode = baseEncode;
        }
        encode(bytes3) {
          if (bytes3 instanceof Uint8Array) {
            return `${this.prefix}${this.baseEncode(bytes3)}`;
          } else {
            throw Error("Unknown type, must be binary type");
          }
        }
      };
      Decoder = class {
        constructor(name2, prefix, baseDecode) {
          this.name = name2;
          this.prefix = prefix;
          if (prefix.codePointAt(0) === void 0) {
            throw new Error("Invalid prefix character");
          }
          this.prefixCodePoint = prefix.codePointAt(0);
          this.baseDecode = baseDecode;
        }
        decode(text) {
          if (typeof text === "string") {
            if (text.codePointAt(0) !== this.prefixCodePoint) {
              throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
            }
            return this.baseDecode(text.slice(this.prefix.length));
          } else {
            throw Error("Can only multibase decode strings");
          }
        }
        or(decoder) {
          return or(this, decoder);
        }
      };
      ComposedDecoder = class {
        constructor(decoders) {
          this.decoders = decoders;
        }
        or(decoder) {
          return or(this, decoder);
        }
        decode(input) {
          const prefix = input[0];
          const decoder = this.decoders[prefix];
          if (decoder) {
            return decoder.decode(input);
          } else {
            throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
          }
        }
      };
      or = (left, right) => new ComposedDecoder({
        ...left.decoders || { [left.prefix]: left },
        ...right.decoders || { [right.prefix]: right }
      });
      Codec = class {
        constructor(name2, prefix, baseEncode, baseDecode) {
          this.name = name2;
          this.prefix = prefix;
          this.baseEncode = baseEncode;
          this.baseDecode = baseDecode;
          this.encoder = new Encoder(name2, prefix, baseEncode);
          this.decoder = new Decoder(name2, prefix, baseDecode);
        }
        encode(input) {
          return this.encoder.encode(input);
        }
        decode(input) {
          return this.decoder.decode(input);
        }
      };
      from = ({ name: name2, prefix, encode: encode10, decode: decode8 }) => new Codec(name2, prefix, encode10, decode8);
      baseX = ({ prefix, name: name2, alphabet: alphabet2 }) => {
        const { encode: encode10, decode: decode8 } = base_x_default(alphabet2, name2);
        return from({
          prefix,
          name: name2,
          encode: encode10,
          decode: (text) => coerce(decode8(text))
        });
      };
      decode = (string2, alphabet2, bitsPerChar, name2) => {
        const codes = {};
        for (let i7 = 0; i7 < alphabet2.length; ++i7) {
          codes[alphabet2[i7]] = i7;
        }
        let end = string2.length;
        while (string2[end - 1] === "=") {
          --end;
        }
        const out = new Uint8Array(end * bitsPerChar / 8 | 0);
        let bits = 0;
        let buffer2 = 0;
        let written = 0;
        for (let i7 = 0; i7 < end; ++i7) {
          const value = codes[string2[i7]];
          if (value === void 0) {
            throw new SyntaxError(`Non-${name2} character`);
          }
          buffer2 = buffer2 << bitsPerChar | value;
          bits += bitsPerChar;
          if (bits >= 8) {
            bits -= 8;
            out[written++] = 255 & buffer2 >> bits;
          }
        }
        if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
          throw new SyntaxError("Unexpected end of data");
        }
        return out;
      };
      encode = (data2, alphabet2, bitsPerChar) => {
        const pad2 = alphabet2[alphabet2.length - 1] === "=";
        const mask = (1 << bitsPerChar) - 1;
        let out = "";
        let bits = 0;
        let buffer2 = 0;
        for (let i7 = 0; i7 < data2.length; ++i7) {
          buffer2 = buffer2 << 8 | data2[i7];
          bits += 8;
          while (bits > bitsPerChar) {
            bits -= bitsPerChar;
            out += alphabet2[mask & buffer2 >> bits];
          }
        }
        if (bits) {
          out += alphabet2[mask & buffer2 << bitsPerChar - bits];
        }
        if (pad2) {
          while (out.length * bitsPerChar & 7) {
            out += "=";
          }
        }
        return out;
      };
      rfc4648 = ({ name: name2, prefix, bitsPerChar, alphabet: alphabet2 }) => {
        return from({
          prefix,
          name: name2,
          encode(input) {
            return encode(input, alphabet2, bitsPerChar);
          },
          decode(input) {
            return decode(input, alphabet2, bitsPerChar, name2);
          }
        });
      };
    }
  });

  // node_modules/multiformats/esm/src/bases/identity.js
  var identity_exports = {};
  __export(identity_exports, {
    identity: () => identity
  });
  var identity;
  var init_identity = __esm({
    "node_modules/multiformats/esm/src/bases/identity.js"() {
      init_base2();
      init_bytes();
      identity = from({
        prefix: "\0",
        name: "identity",
        encode: (buf) => toString(buf),
        decode: (str) => fromString(str)
      });
    }
  });

  // node_modules/multiformats/esm/src/bases/base2.js
  var base2_exports = {};
  __export(base2_exports, {
    base2: () => base2
  });
  var base2;
  var init_base22 = __esm({
    "node_modules/multiformats/esm/src/bases/base2.js"() {
      init_base2();
      base2 = rfc4648({
        prefix: "0",
        name: "base2",
        alphabet: "01",
        bitsPerChar: 1
      });
    }
  });

  // node_modules/multiformats/esm/src/bases/base8.js
  var base8_exports = {};
  __export(base8_exports, {
    base8: () => base8
  });
  var base8;
  var init_base8 = __esm({
    "node_modules/multiformats/esm/src/bases/base8.js"() {
      init_base2();
      base8 = rfc4648({
        prefix: "7",
        name: "base8",
        alphabet: "01234567",
        bitsPerChar: 3
      });
    }
  });

  // node_modules/multiformats/esm/src/bases/base10.js
  var base10_exports = {};
  __export(base10_exports, {
    base10: () => base10
  });
  var base10;
  var init_base10 = __esm({
    "node_modules/multiformats/esm/src/bases/base10.js"() {
      init_base2();
      base10 = baseX({
        prefix: "9",
        name: "base10",
        alphabet: "0123456789"
      });
    }
  });

  // node_modules/multiformats/esm/src/bases/base16.js
  var base16_exports = {};
  __export(base16_exports, {
    base16: () => base16,
    base16upper: () => base16upper
  });
  var base16, base16upper;
  var init_base16 = __esm({
    "node_modules/multiformats/esm/src/bases/base16.js"() {
      init_base2();
      base16 = rfc4648({
        prefix: "f",
        name: "base16",
        alphabet: "0123456789abcdef",
        bitsPerChar: 4
      });
      base16upper = rfc4648({
        prefix: "F",
        name: "base16upper",
        alphabet: "0123456789ABCDEF",
        bitsPerChar: 4
      });
    }
  });

  // node_modules/multiformats/esm/src/bases/base32.js
  var base32_exports = {};
  __export(base32_exports, {
    base32: () => base32,
    base32hex: () => base32hex,
    base32hexpad: () => base32hexpad,
    base32hexpadupper: () => base32hexpadupper,
    base32hexupper: () => base32hexupper,
    base32pad: () => base32pad,
    base32padupper: () => base32padupper,
    base32upper: () => base32upper,
    base32z: () => base32z
  });
  var base32, base32upper, base32pad, base32padupper, base32hex, base32hexupper, base32hexpad, base32hexpadupper, base32z;
  var init_base32 = __esm({
    "node_modules/multiformats/esm/src/bases/base32.js"() {
      init_base2();
      base32 = rfc4648({
        prefix: "b",
        name: "base32",
        alphabet: "abcdefghijklmnopqrstuvwxyz234567",
        bitsPerChar: 5
      });
      base32upper = rfc4648({
        prefix: "B",
        name: "base32upper",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
        bitsPerChar: 5
      });
      base32pad = rfc4648({
        prefix: "c",
        name: "base32pad",
        alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
        bitsPerChar: 5
      });
      base32padupper = rfc4648({
        prefix: "C",
        name: "base32padupper",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
        bitsPerChar: 5
      });
      base32hex = rfc4648({
        prefix: "v",
        name: "base32hex",
        alphabet: "0123456789abcdefghijklmnopqrstuv",
        bitsPerChar: 5
      });
      base32hexupper = rfc4648({
        prefix: "V",
        name: "base32hexupper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
        bitsPerChar: 5
      });
      base32hexpad = rfc4648({
        prefix: "t",
        name: "base32hexpad",
        alphabet: "0123456789abcdefghijklmnopqrstuv=",
        bitsPerChar: 5
      });
      base32hexpadupper = rfc4648({
        prefix: "T",
        name: "base32hexpadupper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
        bitsPerChar: 5
      });
      base32z = rfc4648({
        prefix: "h",
        name: "base32z",
        alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
        bitsPerChar: 5
      });
    }
  });

  // node_modules/multiformats/esm/src/bases/base36.js
  var base36_exports = {};
  __export(base36_exports, {
    base36: () => base36,
    base36upper: () => base36upper
  });
  var base36, base36upper;
  var init_base36 = __esm({
    "node_modules/multiformats/esm/src/bases/base36.js"() {
      init_base2();
      base36 = baseX({
        prefix: "k",
        name: "base36",
        alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
      });
      base36upper = baseX({
        prefix: "K",
        name: "base36upper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
      });
    }
  });

  // node_modules/multiformats/esm/src/bases/base58.js
  var base58_exports = {};
  __export(base58_exports, {
    base58btc: () => base58btc,
    base58flickr: () => base58flickr
  });
  var base58btc, base58flickr;
  var init_base58 = __esm({
    "node_modules/multiformats/esm/src/bases/base58.js"() {
      init_base2();
      base58btc = baseX({
        name: "base58btc",
        prefix: "z",
        alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
      });
      base58flickr = baseX({
        name: "base58flickr",
        prefix: "Z",
        alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
      });
    }
  });

  // node_modules/multiformats/esm/src/bases/base64.js
  var base64_exports = {};
  __export(base64_exports, {
    base64: () => base64,
    base64pad: () => base64pad,
    base64url: () => base64url,
    base64urlpad: () => base64urlpad
  });
  var base64, base64pad, base64url, base64urlpad;
  var init_base64 = __esm({
    "node_modules/multiformats/esm/src/bases/base64.js"() {
      init_base2();
      base64 = rfc4648({
        prefix: "m",
        name: "base64",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
        bitsPerChar: 6
      });
      base64pad = rfc4648({
        prefix: "M",
        name: "base64pad",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
        bitsPerChar: 6
      });
      base64url = rfc4648({
        prefix: "u",
        name: "base64url",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
        bitsPerChar: 6
      });
      base64urlpad = rfc4648({
        prefix: "U",
        name: "base64urlpad",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
        bitsPerChar: 6
      });
    }
  });

  // node_modules/multiformats/esm/src/bases/base256emoji.js
  var base256emoji_exports = {};
  __export(base256emoji_exports, {
    base256emoji: () => base256emoji
  });
  function encode2(data2) {
    return data2.reduce((p8, c9) => {
      p8 += alphabetBytesToChars[c9];
      return p8;
    }, "");
  }
  function decode2(str) {
    const byts = [];
    for (const char of str) {
      const byt = alphabetCharsToBytes[char.codePointAt(0)];
      if (byt === void 0) {
        throw new Error(`Non-base256emoji character: ${char}`);
      }
      byts.push(byt);
    }
    return new Uint8Array(byts);
  }
  var alphabet, alphabetBytesToChars, alphabetCharsToBytes, base256emoji;
  var init_base256emoji = __esm({
    "node_modules/multiformats/esm/src/bases/base256emoji.js"() {
      init_base2();
      alphabet = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
      alphabetBytesToChars = alphabet.reduce((p8, c9, i7) => {
        p8[i7] = c9;
        return p8;
      }, []);
      alphabetCharsToBytes = alphabet.reduce((p8, c9, i7) => {
        p8[c9.codePointAt(0)] = i7;
        return p8;
      }, []);
      base256emoji = from({
        prefix: "\u{1F680}",
        name: "base256emoji",
        encode: encode2,
        decode: decode2
      });
    }
  });

  // node_modules/multiformats/esm/vendor/varint.js
  function encode3(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT) {
      out[offset++] = num & 255 | MSB;
      num /= 128;
    }
    while (num & MSBALL) {
      out[offset++] = num & 255 | MSB;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode3.bytes = offset - oldOffset + 1;
    return out;
  }
  function read(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b7, l9 = buf.length;
    do {
      if (counter >= l9) {
        read.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b7 = buf[counter++];
      res += shift < 28 ? (b7 & REST$1) << shift : (b7 & REST$1) * Math.pow(2, shift);
      shift += 7;
    } while (b7 >= MSB$1);
    read.bytes = counter - offset;
    return res;
  }
  var encode_1, MSB, REST, MSBALL, INT, decode3, MSB$1, REST$1, N1, N2, N3, N4, N5, N6, N7, N8, N9, length, varint, _brrp_varint, varint_default;
  var init_varint = __esm({
    "node_modules/multiformats/esm/vendor/varint.js"() {
      encode_1 = encode3;
      MSB = 128;
      REST = 127;
      MSBALL = ~REST;
      INT = Math.pow(2, 31);
      decode3 = read;
      MSB$1 = 128;
      REST$1 = 127;
      N1 = Math.pow(2, 7);
      N2 = Math.pow(2, 14);
      N3 = Math.pow(2, 21);
      N4 = Math.pow(2, 28);
      N5 = Math.pow(2, 35);
      N6 = Math.pow(2, 42);
      N7 = Math.pow(2, 49);
      N8 = Math.pow(2, 56);
      N9 = Math.pow(2, 63);
      length = function(value) {
        return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
      };
      varint = {
        encode: encode_1,
        decode: decode3,
        encodingLength: length
      };
      _brrp_varint = varint;
      varint_default = _brrp_varint;
    }
  });

  // node_modules/multiformats/esm/src/varint.js
  var decode4, encodeTo, encodingLength;
  var init_varint2 = __esm({
    "node_modules/multiformats/esm/src/varint.js"() {
      init_varint();
      decode4 = (data2, offset = 0) => {
        const code2 = varint_default.decode(data2, offset);
        return [
          code2,
          varint_default.decode.bytes
        ];
      };
      encodeTo = (int, target, offset = 0) => {
        varint_default.encode(int, target, offset);
        return target;
      };
      encodingLength = (int) => {
        return varint_default.encodingLength(int);
      };
    }
  });

  // node_modules/multiformats/esm/src/hashes/digest.js
  var create, decode5, equals2, Digest;
  var init_digest = __esm({
    "node_modules/multiformats/esm/src/hashes/digest.js"() {
      init_bytes();
      init_varint2();
      create = (code2, digest2) => {
        const size3 = digest2.byteLength;
        const sizeOffset = encodingLength(code2);
        const digestOffset = sizeOffset + encodingLength(size3);
        const bytes3 = new Uint8Array(digestOffset + size3);
        encodeTo(code2, bytes3, 0);
        encodeTo(size3, bytes3, sizeOffset);
        bytes3.set(digest2, digestOffset);
        return new Digest(code2, size3, digest2, bytes3);
      };
      decode5 = (multihash) => {
        const bytes3 = coerce(multihash);
        const [code2, sizeOffset] = decode4(bytes3);
        const [size3, digestOffset] = decode4(bytes3.subarray(sizeOffset));
        const digest2 = bytes3.subarray(sizeOffset + digestOffset);
        if (digest2.byteLength !== size3) {
          throw new Error("Incorrect length");
        }
        return new Digest(code2, size3, digest2, bytes3);
      };
      equals2 = (a6, b7) => {
        if (a6 === b7) {
          return true;
        } else {
          return a6.code === b7.code && a6.size === b7.size && equals(a6.bytes, b7.bytes);
        }
      };
      Digest = class {
        constructor(code2, size3, digest2, bytes3) {
          this.code = code2;
          this.size = size3;
          this.digest = digest2;
          this.bytes = bytes3;
        }
      };
    }
  });

  // node_modules/multiformats/esm/src/hashes/hasher.js
  var from2, Hasher;
  var init_hasher = __esm({
    "node_modules/multiformats/esm/src/hashes/hasher.js"() {
      init_digest();
      from2 = ({ name: name2, code: code2, encode: encode10 }) => new Hasher(name2, code2, encode10);
      Hasher = class {
        constructor(name2, code2, encode10) {
          this.name = name2;
          this.code = code2;
          this.encode = encode10;
        }
        digest(input) {
          if (input instanceof Uint8Array) {
            const result = this.encode(input);
            return result instanceof Uint8Array ? create(this.code, result) : result.then((digest2) => create(this.code, digest2));
          } else {
            throw Error("Unknown type, must be binary type");
          }
        }
      };
    }
  });

  // node_modules/multiformats/esm/src/hashes/sha2-browser.js
  var sha2_browser_exports = {};
  __export(sha2_browser_exports, {
    sha256: () => sha256,
    sha512: () => sha512
  });
  var sha, sha256, sha512;
  var init_sha2_browser = __esm({
    "node_modules/multiformats/esm/src/hashes/sha2-browser.js"() {
      init_hasher();
      sha = (name2) => async (data2) => new Uint8Array(await crypto.subtle.digest(name2, data2));
      sha256 = from2({
        name: "sha2-256",
        code: 18,
        encode: sha("SHA-256")
      });
      sha512 = from2({
        name: "sha2-512",
        code: 19,
        encode: sha("SHA-512")
      });
    }
  });

  // node_modules/multiformats/esm/src/hashes/identity.js
  var identity_exports2 = {};
  __export(identity_exports2, {
    identity: () => identity2
  });
  var code, name, encode4, digest, identity2;
  var init_identity2 = __esm({
    "node_modules/multiformats/esm/src/hashes/identity.js"() {
      init_bytes();
      init_digest();
      code = 0;
      name = "identity";
      encode4 = coerce;
      digest = (input) => create(code, encode4(input));
      identity2 = {
        code,
        name,
        encode: encode4,
        digest
      };
    }
  });

  // node_modules/multiformats/esm/src/codecs/raw.js
  var init_raw = __esm({
    "node_modules/multiformats/esm/src/codecs/raw.js"() {
      init_bytes();
    }
  });

  // node_modules/multiformats/esm/src/codecs/json.js
  var textEncoder, textDecoder;
  var init_json = __esm({
    "node_modules/multiformats/esm/src/codecs/json.js"() {
      textEncoder = new TextEncoder();
      textDecoder = new TextDecoder();
    }
  });

  // node_modules/multiformats/esm/src/cid.js
  var CID, parseCIDtoBytes, toStringV0, toStringV1, DAG_PB_CODE, SHA_256_CODE, encodeCID, cidSymbol, readonly, hidden, version3, deprecate, IS_CID_DEPRECATION;
  var init_cid = __esm({
    "node_modules/multiformats/esm/src/cid.js"() {
      init_varint2();
      init_digest();
      init_base58();
      init_base32();
      init_bytes();
      CID = class {
        constructor(version30, code2, multihash, bytes3) {
          this.code = code2;
          this.version = version30;
          this.multihash = multihash;
          this.bytes = bytes3;
          this.byteOffset = bytes3.byteOffset;
          this.byteLength = bytes3.byteLength;
          this.asCID = this;
          this._baseCache = /* @__PURE__ */ new Map();
          Object.defineProperties(this, {
            byteOffset: hidden,
            byteLength: hidden,
            code: readonly,
            version: readonly,
            multihash: readonly,
            bytes: readonly,
            _baseCache: hidden,
            asCID: hidden
          });
        }
        toV0() {
          switch (this.version) {
            case 0: {
              return this;
            }
            default: {
              const { code: code2, multihash } = this;
              if (code2 !== DAG_PB_CODE) {
                throw new Error("Cannot convert a non dag-pb CID to CIDv0");
              }
              if (multihash.code !== SHA_256_CODE) {
                throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
              }
              return CID.createV0(multihash);
            }
          }
        }
        toV1() {
          switch (this.version) {
            case 0: {
              const { code: code2, digest: digest2 } = this.multihash;
              const multihash = create(code2, digest2);
              return CID.createV1(this.code, multihash);
            }
            case 1: {
              return this;
            }
            default: {
              throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
            }
          }
        }
        equals(other) {
          return other && this.code === other.code && this.version === other.version && equals2(this.multihash, other.multihash);
        }
        toString(base4) {
          const { bytes: bytes3, version: version30, _baseCache } = this;
          switch (version30) {
            case 0:
              return toStringV0(bytes3, _baseCache, base4 || base58btc.encoder);
            default:
              return toStringV1(bytes3, _baseCache, base4 || base32.encoder);
          }
        }
        toJSON() {
          return {
            code: this.code,
            version: this.version,
            hash: this.multihash.bytes
          };
        }
        get [Symbol.toStringTag]() {
          return "CID";
        }
        [Symbol.for("nodejs.util.inspect.custom")]() {
          return "CID(" + this.toString() + ")";
        }
        static isCID(value) {
          deprecate(/^0\.0/, IS_CID_DEPRECATION);
          return !!(value && (value[cidSymbol] || value.asCID === value));
        }
        get toBaseEncodedString() {
          throw new Error("Deprecated, use .toString()");
        }
        get codec() {
          throw new Error('"codec" property is deprecated, use integer "code" property instead');
        }
        get buffer() {
          throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
        }
        get multibaseName() {
          throw new Error('"multibaseName" property is deprecated');
        }
        get prefix() {
          throw new Error('"prefix" property is deprecated');
        }
        static asCID(value) {
          if (value instanceof CID) {
            return value;
          } else if (value != null && value.asCID === value) {
            const { version: version30, code: code2, multihash, bytes: bytes3 } = value;
            return new CID(version30, code2, multihash, bytes3 || encodeCID(version30, code2, multihash.bytes));
          } else if (value != null && value[cidSymbol] === true) {
            const { version: version30, multihash, code: code2 } = value;
            const digest2 = decode5(multihash);
            return CID.create(version30, code2, digest2);
          } else {
            return null;
          }
        }
        static create(version30, code2, digest2) {
          if (typeof code2 !== "number") {
            throw new Error("String codecs are no longer supported");
          }
          switch (version30) {
            case 0: {
              if (code2 !== DAG_PB_CODE) {
                throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
              } else {
                return new CID(version30, code2, digest2, digest2.bytes);
              }
            }
            case 1: {
              const bytes3 = encodeCID(version30, code2, digest2.bytes);
              return new CID(version30, code2, digest2, bytes3);
            }
            default: {
              throw new Error("Invalid version");
            }
          }
        }
        static createV0(digest2) {
          return CID.create(0, DAG_PB_CODE, digest2);
        }
        static createV1(code2, digest2) {
          return CID.create(1, code2, digest2);
        }
        static decode(bytes3) {
          const [cid, remainder] = CID.decodeFirst(bytes3);
          if (remainder.length) {
            throw new Error("Incorrect length");
          }
          return cid;
        }
        static decodeFirst(bytes3) {
          const specs = CID.inspectBytes(bytes3);
          const prefixSize = specs.size - specs.multihashSize;
          const multihashBytes = coerce(bytes3.subarray(prefixSize, prefixSize + specs.multihashSize));
          if (multihashBytes.byteLength !== specs.multihashSize) {
            throw new Error("Incorrect length");
          }
          const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
          const digest2 = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
          const cid = specs.version === 0 ? CID.createV0(digest2) : CID.createV1(specs.codec, digest2);
          return [
            cid,
            bytes3.subarray(specs.size)
          ];
        }
        static inspectBytes(initialBytes) {
          let offset = 0;
          const next = () => {
            const [i7, length2] = decode4(initialBytes.subarray(offset));
            offset += length2;
            return i7;
          };
          let version30 = next();
          let codec = DAG_PB_CODE;
          if (version30 === 18) {
            version30 = 0;
            offset = 0;
          } else if (version30 === 1) {
            codec = next();
          }
          if (version30 !== 0 && version30 !== 1) {
            throw new RangeError(`Invalid CID version ${version30}`);
          }
          const prefixSize = offset;
          const multihashCode = next();
          const digestSize = next();
          const size3 = offset + digestSize;
          const multihashSize = size3 - prefixSize;
          return {
            version: version30,
            codec,
            multihashCode,
            digestSize,
            multihashSize,
            size: size3
          };
        }
        static parse(source, base4) {
          const [prefix, bytes3] = parseCIDtoBytes(source, base4);
          const cid = CID.decode(bytes3);
          cid._baseCache.set(prefix, source);
          return cid;
        }
      };
      parseCIDtoBytes = (source, base4) => {
        switch (source[0]) {
          case "Q": {
            const decoder = base4 || base58btc;
            return [
              base58btc.prefix,
              decoder.decode(`${base58btc.prefix}${source}`)
            ];
          }
          case base58btc.prefix: {
            const decoder = base4 || base58btc;
            return [
              base58btc.prefix,
              decoder.decode(source)
            ];
          }
          case base32.prefix: {
            const decoder = base4 || base32;
            return [
              base32.prefix,
              decoder.decode(source)
            ];
          }
          default: {
            if (base4 == null) {
              throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
            }
            return [
              source[0],
              base4.decode(source)
            ];
          }
        }
      };
      toStringV0 = (bytes3, cache, base4) => {
        const { prefix } = base4;
        if (prefix !== base58btc.prefix) {
          throw Error(`Cannot string encode V0 in ${base4.name} encoding`);
        }
        const cid = cache.get(prefix);
        if (cid == null) {
          const cid2 = base4.encode(bytes3).slice(1);
          cache.set(prefix, cid2);
          return cid2;
        } else {
          return cid;
        }
      };
      toStringV1 = (bytes3, cache, base4) => {
        const { prefix } = base4;
        const cid = cache.get(prefix);
        if (cid == null) {
          const cid2 = base4.encode(bytes3);
          cache.set(prefix, cid2);
          return cid2;
        } else {
          return cid;
        }
      };
      DAG_PB_CODE = 112;
      SHA_256_CODE = 18;
      encodeCID = (version30, code2, multihash) => {
        const codeOffset = encodingLength(version30);
        const hashOffset = codeOffset + encodingLength(code2);
        const bytes3 = new Uint8Array(hashOffset + multihash.byteLength);
        encodeTo(version30, bytes3, 0);
        encodeTo(code2, bytes3, codeOffset);
        bytes3.set(multihash, hashOffset);
        return bytes3;
      };
      cidSymbol = Symbol.for("@ipld/js-cid/CID");
      readonly = {
        writable: false,
        configurable: false,
        enumerable: true
      };
      hidden = {
        writable: false,
        enumerable: false,
        configurable: false
      };
      version3 = "0.0.0-dev";
      deprecate = (range, message) => {
        if (range.test(version3)) {
          console.warn(message);
        } else {
          throw new Error(message);
        }
      };
      IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;
    }
  });

  // node_modules/multiformats/esm/src/index.js
  var init_src = __esm({
    "node_modules/multiformats/esm/src/index.js"() {
      init_cid();
      init_varint2();
      init_bytes();
      init_hasher();
      init_digest();
    }
  });

  // node_modules/multiformats/esm/src/basics.js
  var bases, hashes;
  var init_basics = __esm({
    "node_modules/multiformats/esm/src/basics.js"() {
      init_identity();
      init_base22();
      init_base8();
      init_base10();
      init_base16();
      init_base32();
      init_base36();
      init_base58();
      init_base64();
      init_base256emoji();
      init_sha2_browser();
      init_identity2();
      init_raw();
      init_json();
      init_src();
      bases = {
        ...identity_exports,
        ...base2_exports,
        ...base8_exports,
        ...base10_exports,
        ...base16_exports,
        ...base32_exports,
        ...base36_exports,
        ...base58_exports,
        ...base64_exports,
        ...base256emoji_exports
      };
      hashes = {
        ...sha2_browser_exports,
        ...identity_exports2
      };
    }
  });

  // node_modules/uint8arrays/esm/src/util/bases.js
  function createCodec(name2, prefix, encode10, decode8) {
    return {
      name: name2,
      prefix,
      encoder: {
        name: name2,
        prefix,
        encode: encode10
      },
      decoder: { decode: decode8 }
    };
  }
  var string, ascii, BASES, bases_default;
  var init_bases = __esm({
    "node_modules/uint8arrays/esm/src/util/bases.js"() {
      init_basics();
      init_alloc();
      string = createCodec("utf8", "u", (buf) => {
        const decoder = new TextDecoder("utf8");
        return "u" + decoder.decode(buf);
      }, (str) => {
        const encoder3 = new TextEncoder();
        return encoder3.encode(str.substring(1));
      });
      ascii = createCodec("ascii", "a", (buf) => {
        let string2 = "a";
        for (let i7 = 0; i7 < buf.length; i7++) {
          string2 += String.fromCharCode(buf[i7]);
        }
        return string2;
      }, (str) => {
        str = str.substring(1);
        const buf = allocUnsafe(str.length);
        for (let i7 = 0; i7 < str.length; i7++) {
          buf[i7] = str.charCodeAt(i7);
        }
        return buf;
      });
      BASES = {
        utf8: string,
        "utf-8": string,
        hex: bases.base16,
        latin1: ascii,
        ascii,
        binary: ascii,
        ...bases
      };
      bases_default = BASES;
    }
  });

  // node_modules/uint8arrays/esm/src/from-string.js
  function fromString2(string2, encoding = "utf8") {
    const base4 = bases_default[encoding];
    if (!base4) {
      throw new Error(`Unsupported encoding "${encoding}"`);
    }
    if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
      return asUint8Array(globalThis.Buffer.from(string2, "utf-8"));
    }
    return base4.decoder.decode(`${base4.prefix}${string2}`);
  }
  var init_from_string = __esm({
    "node_modules/uint8arrays/esm/src/from-string.js"() {
      init_bases();
      init_as_uint8array();
    }
  });

  // node_modules/uint8arrays/esm/src/to-string.js
  function toString2(array, encoding = "utf8") {
    const base4 = bases_default[encoding];
    if (!base4) {
      throw new Error(`Unsupported encoding "${encoding}"`);
    }
    if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
      return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
    }
    return base4.encoder.encode(array).substring(1);
  }
  var init_to_string = __esm({
    "node_modules/uint8arrays/esm/src/to-string.js"() {
      init_bases();
    }
  });

  // node_modules/uint8arrays/esm/src/xor.js
  var init_xor = __esm({
    "node_modules/uint8arrays/esm/src/xor.js"() {
      init_alloc();
      init_as_uint8array();
    }
  });

  // node_modules/uint8arrays/esm/src/index.js
  var init_src2 = __esm({
    "node_modules/uint8arrays/esm/src/index.js"() {
      init_compare();
      init_concat2();
      init_equals();
      init_from_string();
      init_to_string();
      init_xor();
    }
  });

  // node_modules/detect-browser/es/index.js
  function detect(userAgent) {
    if (!!userAgent) {
      return parseUserAgent(userAgent);
    }
    if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
      return new ReactNativeInfo();
    }
    if (typeof navigator !== "undefined") {
      return parseUserAgent(navigator.userAgent);
    }
    return getNodeVersion();
  }
  function matchUserAgent(ua2) {
    return ua2 !== "" && userAgentRules.reduce(function(matched, _a2) {
      var browser = _a2[0], regex = _a2[1];
      if (matched) {
        return matched;
      }
      var uaMatch = regex.exec(ua2);
      return !!uaMatch && [browser, uaMatch];
    }, false);
  }
  function parseUserAgent(ua2) {
    var matchedRule = matchUserAgent(ua2);
    if (!matchedRule) {
      return null;
    }
    var name2 = matchedRule[0], match = matchedRule[1];
    if (name2 === "searchbot") {
      return new BotInfo();
    }
    var versionParts = match[1] && match[1].split(".").join("_").split("_").slice(0, 3);
    if (versionParts) {
      if (versionParts.length < REQUIRED_VERSION_PARTS) {
        versionParts = __spreadArray(__spreadArray([], versionParts, true), createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length), true);
      }
    } else {
      versionParts = [];
    }
    var version30 = versionParts.join(".");
    var os3 = detectOS(ua2);
    var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua2);
    if (searchBotMatch && searchBotMatch[1]) {
      return new SearchBotDeviceInfo(name2, version30, os3, searchBotMatch[1]);
    }
    return new BrowserInfo(name2, version30, os3);
  }
  function detectOS(ua2) {
    for (var ii2 = 0, count = operatingSystemRules.length; ii2 < count; ii2++) {
      var _a2 = operatingSystemRules[ii2], os3 = _a2[0], regex = _a2[1];
      var match = regex.exec(ua2);
      if (match) {
        return os3;
      }
    }
    return null;
  }
  function getNodeVersion() {
    var isNode2 = typeof process !== "undefined" && process.version;
    return isNode2 ? new NodeInfo(process.version.slice(1)) : null;
  }
  function createVersionParts(count) {
    var output2 = [];
    for (var ii2 = 0; ii2 < count; ii2++) {
      output2.push("0");
    }
    return output2;
  }
  var __spreadArray, BrowserInfo, NodeInfo, SearchBotDeviceInfo, BotInfo, ReactNativeInfo, SEARCHBOX_UA_REGEX, SEARCHBOT_OS_REGEX, REQUIRED_VERSION_PARTS, userAgentRules, operatingSystemRules;
  var init_es = __esm({
    "node_modules/detect-browser/es/index.js"() {
      __spreadArray = function(to3, from3, pack3) {
        if (pack3 || arguments.length === 2)
          for (var i7 = 0, l9 = from3.length, ar4; i7 < l9; i7++) {
            if (ar4 || !(i7 in from3)) {
              if (!ar4)
                ar4 = Array.prototype.slice.call(from3, 0, i7);
              ar4[i7] = from3[i7];
            }
          }
        return to3.concat(ar4 || Array.prototype.slice.call(from3));
      };
      BrowserInfo = /** @class */
      function() {
        function BrowserInfo2(name2, version30, os3) {
          this.name = name2;
          this.version = version30;
          this.os = os3;
          this.type = "browser";
        }
        return BrowserInfo2;
      }();
      NodeInfo = /** @class */
      function() {
        function NodeInfo2(version30) {
          this.version = version30;
          this.type = "node";
          this.name = "node";
          this.os = process.platform;
        }
        return NodeInfo2;
      }();
      SearchBotDeviceInfo = /** @class */
      function() {
        function SearchBotDeviceInfo2(name2, version30, os3, bot) {
          this.name = name2;
          this.version = version30;
          this.os = os3;
          this.bot = bot;
          this.type = "bot-device";
        }
        return SearchBotDeviceInfo2;
      }();
      BotInfo = /** @class */
      function() {
        function BotInfo2() {
          this.type = "bot";
          this.bot = true;
          this.name = "bot";
          this.version = null;
          this.os = null;
        }
        return BotInfo2;
      }();
      ReactNativeInfo = /** @class */
      function() {
        function ReactNativeInfo2() {
          this.type = "react-native";
          this.name = "react-native";
          this.version = null;
          this.os = null;
        }
        return ReactNativeInfo2;
      }();
      SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
      SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
      REQUIRED_VERSION_PARTS = 3;
      userAgentRules = [
        ["aol", /AOLShield\/([0-9\._]+)/],
        ["edge", /Edge\/([0-9\._]+)/],
        ["edge-ios", /EdgiOS\/([0-9\._]+)/],
        ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
        ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
        ["samsung", /SamsungBrowser\/([0-9\.]+)/],
        ["silk", /\bSilk\/([0-9._-]+)\b/],
        ["miui", /MiuiBrowser\/([0-9\.]+)$/],
        ["beaker", /BeakerBrowser\/([0-9\.]+)/],
        ["edge-chromium", /EdgA?\/([0-9\.]+)/],
        [
          "chromium-webview",
          /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
        ],
        ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
        ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
        ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
        ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
        ["fxios", /FxiOS\/([0-9\.]+)/],
        ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
        ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
        ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
        ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
        ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
        ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
        ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
        ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
        ["ie", /MSIE\s(7\.0)/],
        ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
        ["android", /Android\s([0-9\.]+)/],
        ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
        ["safari", /Version\/([0-9\._]+).*Safari/],
        ["facebook", /FB[AS]V\/([0-9\.]+)/],
        ["instagram", /Instagram\s([0-9\.]+)/],
        ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
        ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
        ["curl", /^curl\/([0-9\.]+)$/],
        ["searchbot", SEARCHBOX_UA_REGEX]
      ];
      operatingSystemRules = [
        ["iOS", /iP(hone|od|ad)/],
        ["Android OS", /Android/],
        ["BlackBerry OS", /BlackBerry|BB10/],
        ["Windows Mobile", /IEMobile/],
        ["Amazon OS", /Kindle/],
        ["Windows 3.11", /Win16/],
        ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
        ["Windows 98", /(Windows 98)|(Win98)/],
        ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
        ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
        ["Windows Server 2003", /(Windows NT 5.2)/],
        ["Windows Vista", /(Windows NT 6.0)/],
        ["Windows 7", /(Windows NT 6.1)/],
        ["Windows 8", /(Windows NT 6.2)/],
        ["Windows 8.1", /(Windows NT 6.3)/],
        ["Windows 10", /(Windows NT 10.0)/],
        ["Windows ME", /Windows ME/],
        ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
        ["Open BSD", /OpenBSD/],
        ["Sun OS", /SunOS/],
        ["Chrome OS", /CrOS/],
        ["Linux", /(Linux)|(X11)/],
        ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
        ["QNX", /QNX/],
        ["BeOS", /BeOS/],
        ["OS/2", /OS\/2/]
      ];
    }
  });

  // node_modules/tslib/tslib.es6.js
  var tslib_es6_exports = {};
  __export(tslib_es6_exports, {
    __assign: () => __assign,
    __asyncDelegator: () => __asyncDelegator,
    __asyncGenerator: () => __asyncGenerator,
    __asyncValues: () => __asyncValues,
    __await: () => __await,
    __awaiter: () => __awaiter,
    __classPrivateFieldGet: () => __classPrivateFieldGet2,
    __classPrivateFieldSet: () => __classPrivateFieldSet,
    __createBinding: () => __createBinding,
    __decorate: () => __decorate,
    __exportStar: () => __exportStar,
    __extends: () => __extends,
    __generator: () => __generator,
    __importDefault: () => __importDefault,
    __importStar: () => __importStar,
    __makeTemplateObject: () => __makeTemplateObject,
    __metadata: () => __metadata,
    __param: () => __param,
    __read: () => __read,
    __rest: () => __rest,
    __spread: () => __spread,
    __spreadArrays: () => __spreadArrays,
    __values: () => __values
  });
  function __extends(d7, b7) {
    extendStatics(d7, b7);
    function __() {
      this.constructor = d7;
    }
    d7.prototype = b7 === null ? Object.create(b7) : (__.prototype = b7.prototype, new __());
  }
  function __rest(s7, e9) {
    var t6 = {};
    for (var p8 in s7)
      if (Object.prototype.hasOwnProperty.call(s7, p8) && e9.indexOf(p8) < 0)
        t6[p8] = s7[p8];
    if (s7 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i7 = 0, p8 = Object.getOwnPropertySymbols(s7); i7 < p8.length; i7++) {
        if (e9.indexOf(p8[i7]) < 0 && Object.prototype.propertyIsEnumerable.call(s7, p8[i7]))
          t6[p8[i7]] = s7[p8[i7]];
      }
    return t6;
  }
  function __decorate(decorators, target, key2, desc) {
    var c9 = arguments.length, r8 = c9 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d7;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
      r8 = Reflect.decorate(decorators, target, key2, desc);
    else
      for (var i7 = decorators.length - 1; i7 >= 0; i7--)
        if (d7 = decorators[i7])
          r8 = (c9 < 3 ? d7(r8) : c9 > 3 ? d7(target, key2, r8) : d7(target, key2)) || r8;
    return c9 > 3 && r8 && Object.defineProperty(target, key2, r8), r8;
  }
  function __param(paramIndex, decorator) {
    return function(target, key2) {
      decorator(target, key2, paramIndex);
    };
  }
  function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
      return Reflect.metadata(metadataKey, metadataValue);
  }
  function __awaiter(thisArg, _arguments, P7, generator) {
    function adopt(value) {
      return value instanceof P7 ? value : new P7(function(resolve) {
        resolve(value);
      });
    }
    return new (P7 || (P7 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e9) {
          reject(e9);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e9) {
          reject(e9);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }
  function __generator(thisArg, body) {
    var _8 = { label: 0, sent: function() {
      if (t6[0] & 1)
        throw t6[1];
      return t6[1];
    }, trys: [], ops: [] }, f7, y11, t6, g7;
    return g7 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g7[Symbol.iterator] = function() {
      return this;
    }), g7;
    function verb(n9) {
      return function(v6) {
        return step([n9, v6]);
      };
    }
    function step(op) {
      if (f7)
        throw new TypeError("Generator is already executing.");
      while (_8)
        try {
          if (f7 = 1, y11 && (t6 = op[0] & 2 ? y11["return"] : op[0] ? y11["throw"] || ((t6 = y11["return"]) && t6.call(y11), 0) : y11.next) && !(t6 = t6.call(y11, op[1])).done)
            return t6;
          if (y11 = 0, t6)
            op = [op[0] & 2, t6.value];
          switch (op[0]) {
            case 0:
            case 1:
              t6 = op;
              break;
            case 4:
              _8.label++;
              return { value: op[1], done: false };
            case 5:
              _8.label++;
              y11 = op[1];
              op = [0];
              continue;
            case 7:
              op = _8.ops.pop();
              _8.trys.pop();
              continue;
            default:
              if (!(t6 = _8.trys, t6 = t6.length > 0 && t6[t6.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _8 = 0;
                continue;
              }
              if (op[0] === 3 && (!t6 || op[1] > t6[0] && op[1] < t6[3])) {
                _8.label = op[1];
                break;
              }
              if (op[0] === 6 && _8.label < t6[1]) {
                _8.label = t6[1];
                t6 = op;
                break;
              }
              if (t6 && _8.label < t6[2]) {
                _8.label = t6[2];
                _8.ops.push(op);
                break;
              }
              if (t6[2])
                _8.ops.pop();
              _8.trys.pop();
              continue;
          }
          op = body.call(thisArg, _8);
        } catch (e9) {
          op = [6, e9];
          y11 = 0;
        } finally {
          f7 = t6 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  }
  function __createBinding(o9, m6, k6, k22) {
    if (k22 === void 0)
      k22 = k6;
    o9[k22] = m6[k6];
  }
  function __exportStar(m6, exports) {
    for (var p8 in m6)
      if (p8 !== "default" && !exports.hasOwnProperty(p8))
        exports[p8] = m6[p8];
  }
  function __values(o9) {
    var s7 = typeof Symbol === "function" && Symbol.iterator, m6 = s7 && o9[s7], i7 = 0;
    if (m6)
      return m6.call(o9);
    if (o9 && typeof o9.length === "number")
      return {
        next: function() {
          if (o9 && i7 >= o9.length)
            o9 = void 0;
          return { value: o9 && o9[i7++], done: !o9 };
        }
      };
    throw new TypeError(s7 ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __read(o9, n9) {
    var m6 = typeof Symbol === "function" && o9[Symbol.iterator];
    if (!m6)
      return o9;
    var i7 = m6.call(o9), r8, ar4 = [], e9;
    try {
      while ((n9 === void 0 || n9-- > 0) && !(r8 = i7.next()).done)
        ar4.push(r8.value);
    } catch (error) {
      e9 = { error };
    } finally {
      try {
        if (r8 && !r8.done && (m6 = i7["return"]))
          m6.call(i7);
      } finally {
        if (e9)
          throw e9.error;
      }
    }
    return ar4;
  }
  function __spread() {
    for (var ar4 = [], i7 = 0; i7 < arguments.length; i7++)
      ar4 = ar4.concat(__read(arguments[i7]));
    return ar4;
  }
  function __spreadArrays() {
    for (var s7 = 0, i7 = 0, il = arguments.length; i7 < il; i7++)
      s7 += arguments[i7].length;
    for (var r8 = Array(s7), k6 = 0, i7 = 0; i7 < il; i7++)
      for (var a6 = arguments[i7], j7 = 0, jl = a6.length; j7 < jl; j7++, k6++)
        r8[k6] = a6[j7];
    return r8;
  }
  function __await(v6) {
    return this instanceof __await ? (this.v = v6, this) : new __await(v6);
  }
  function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var g7 = generator.apply(thisArg, _arguments || []), i7, q8 = [];
    return i7 = {}, verb("next"), verb("throw"), verb("return"), i7[Symbol.asyncIterator] = function() {
      return this;
    }, i7;
    function verb(n9) {
      if (g7[n9])
        i7[n9] = function(v6) {
          return new Promise(function(a6, b7) {
            q8.push([n9, v6, a6, b7]) > 1 || resume(n9, v6);
          });
        };
    }
    function resume(n9, v6) {
      try {
        step(g7[n9](v6));
      } catch (e9) {
        settle2(q8[0][3], e9);
      }
    }
    function step(r8) {
      r8.value instanceof __await ? Promise.resolve(r8.value.v).then(fulfill, reject) : settle2(q8[0][2], r8);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle2(f7, v6) {
      if (f7(v6), q8.shift(), q8.length)
        resume(q8[0][0], q8[0][1]);
    }
  }
  function __asyncDelegator(o9) {
    var i7, p8;
    return i7 = {}, verb("next"), verb("throw", function(e9) {
      throw e9;
    }), verb("return"), i7[Symbol.iterator] = function() {
      return this;
    }, i7;
    function verb(n9, f7) {
      i7[n9] = o9[n9] ? function(v6) {
        return (p8 = !p8) ? { value: __await(o9[n9](v6)), done: n9 === "return" } : f7 ? f7(v6) : v6;
      } : f7;
    }
  }
  function __asyncValues(o9) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m6 = o9[Symbol.asyncIterator], i7;
    return m6 ? m6.call(o9) : (o9 = typeof __values === "function" ? __values(o9) : o9[Symbol.iterator](), i7 = {}, verb("next"), verb("throw"), verb("return"), i7[Symbol.asyncIterator] = function() {
      return this;
    }, i7);
    function verb(n9) {
      i7[n9] = o9[n9] && function(v6) {
        return new Promise(function(resolve, reject) {
          v6 = o9[n9](v6), settle2(resolve, reject, v6.done, v6.value);
        });
      };
    }
    function settle2(resolve, reject, d7, v6) {
      Promise.resolve(v6).then(function(v7) {
        resolve({ value: v7, done: d7 });
      }, reject);
    }
  }
  function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) {
      Object.defineProperty(cooked, "raw", { value: raw });
    } else {
      cooked.raw = raw;
    }
    return cooked;
  }
  function __importStar(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k6 in mod)
        if (Object.hasOwnProperty.call(mod, k6))
          result[k6] = mod[k6];
    }
    result.default = mod;
    return result;
  }
  function __importDefault(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  }
  function __classPrivateFieldGet2(receiver, privateMap) {
    if (!privateMap.has(receiver)) {
      throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
  }
  function __classPrivateFieldSet(receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
      throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
  }
  var extendStatics, __assign;
  var init_tslib_es6 = __esm({
    "node_modules/tslib/tslib.es6.js"() {
      extendStatics = function(d7, b7) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d8, b8) {
          d8.__proto__ = b8;
        } || function(d8, b8) {
          for (var p8 in b8)
            if (b8.hasOwnProperty(p8))
              d8[p8] = b8[p8];
        };
        return extendStatics(d7, b7);
      };
      __assign = function() {
        __assign = Object.assign || function __assign2(t6) {
          for (var s7, i7 = 1, n9 = arguments.length; i7 < n9; i7++) {
            s7 = arguments[i7];
            for (var p8 in s7)
              if (Object.prototype.hasOwnProperty.call(s7, p8))
                t6[p8] = s7[p8];
          }
          return t6;
        };
        return __assign.apply(this, arguments);
      };
    }
  });

  // node_modules/@walletconnect/time/dist/cjs/utils/delay.js
  var require_delay = __commonJS({
    "node_modules/@walletconnect/time/dist/cjs/utils/delay.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.delay = void 0;
      function delay(timeout) {
        return new Promise((resolve) => {
          setTimeout(() => {
            resolve(true);
          }, timeout);
        });
      }
      exports.delay = delay;
    }
  });

  // node_modules/@walletconnect/time/dist/cjs/constants/misc.js
  var require_misc = __commonJS({
    "node_modules/@walletconnect/time/dist/cjs/constants/misc.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ONE_THOUSAND = exports.ONE_HUNDRED = void 0;
      exports.ONE_HUNDRED = 100;
      exports.ONE_THOUSAND = 1e3;
    }
  });

  // node_modules/@walletconnect/time/dist/cjs/constants/time.js
  var require_time = __commonJS({
    "node_modules/@walletconnect/time/dist/cjs/constants/time.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ONE_YEAR = exports.FOUR_WEEKS = exports.THREE_WEEKS = exports.TWO_WEEKS = exports.ONE_WEEK = exports.THIRTY_DAYS = exports.SEVEN_DAYS = exports.FIVE_DAYS = exports.THREE_DAYS = exports.ONE_DAY = exports.TWENTY_FOUR_HOURS = exports.TWELVE_HOURS = exports.SIX_HOURS = exports.THREE_HOURS = exports.ONE_HOUR = exports.SIXTY_MINUTES = exports.THIRTY_MINUTES = exports.TEN_MINUTES = exports.FIVE_MINUTES = exports.ONE_MINUTE = exports.SIXTY_SECONDS = exports.THIRTY_SECONDS = exports.TEN_SECONDS = exports.FIVE_SECONDS = exports.ONE_SECOND = void 0;
      exports.ONE_SECOND = 1;
      exports.FIVE_SECONDS = 5;
      exports.TEN_SECONDS = 10;
      exports.THIRTY_SECONDS = 30;
      exports.SIXTY_SECONDS = 60;
      exports.ONE_MINUTE = exports.SIXTY_SECONDS;
      exports.FIVE_MINUTES = exports.ONE_MINUTE * 5;
      exports.TEN_MINUTES = exports.ONE_MINUTE * 10;
      exports.THIRTY_MINUTES = exports.ONE_MINUTE * 30;
      exports.SIXTY_MINUTES = exports.ONE_MINUTE * 60;
      exports.ONE_HOUR = exports.SIXTY_MINUTES;
      exports.THREE_HOURS = exports.ONE_HOUR * 3;
      exports.SIX_HOURS = exports.ONE_HOUR * 6;
      exports.TWELVE_HOURS = exports.ONE_HOUR * 12;
      exports.TWENTY_FOUR_HOURS = exports.ONE_HOUR * 24;
      exports.ONE_DAY = exports.TWENTY_FOUR_HOURS;
      exports.THREE_DAYS = exports.ONE_DAY * 3;
      exports.FIVE_DAYS = exports.ONE_DAY * 5;
      exports.SEVEN_DAYS = exports.ONE_DAY * 7;
      exports.THIRTY_DAYS = exports.ONE_DAY * 30;
      exports.ONE_WEEK = exports.SEVEN_DAYS;
      exports.TWO_WEEKS = exports.ONE_WEEK * 2;
      exports.THREE_WEEKS = exports.ONE_WEEK * 3;
      exports.FOUR_WEEKS = exports.ONE_WEEK * 4;
      exports.ONE_YEAR = exports.ONE_DAY * 365;
    }
  });

  // node_modules/@walletconnect/time/dist/cjs/constants/index.js
  var require_constants = __commonJS({
    "node_modules/@walletconnect/time/dist/cjs/constants/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      tslib_1.__exportStar(require_misc(), exports);
      tslib_1.__exportStar(require_time(), exports);
    }
  });

  // node_modules/@walletconnect/time/dist/cjs/utils/convert.js
  var require_convert = __commonJS({
    "node_modules/@walletconnect/time/dist/cjs/utils/convert.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.fromMiliseconds = exports.toMiliseconds = void 0;
      var constants_1 = require_constants();
      function toMiliseconds(seconds) {
        return seconds * constants_1.ONE_THOUSAND;
      }
      exports.toMiliseconds = toMiliseconds;
      function fromMiliseconds2(miliseconds) {
        return Math.floor(miliseconds / constants_1.ONE_THOUSAND);
      }
      exports.fromMiliseconds = fromMiliseconds2;
    }
  });

  // node_modules/@walletconnect/time/dist/cjs/utils/index.js
  var require_utils = __commonJS({
    "node_modules/@walletconnect/time/dist/cjs/utils/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      tslib_1.__exportStar(require_delay(), exports);
      tslib_1.__exportStar(require_convert(), exports);
    }
  });

  // node_modules/@walletconnect/time/dist/cjs/watch.js
  var require_watch = __commonJS({
    "node_modules/@walletconnect/time/dist/cjs/watch.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Watch = void 0;
      var Watch = class {
        constructor() {
          this.timestamps = /* @__PURE__ */ new Map();
        }
        start(label) {
          if (this.timestamps.has(label)) {
            throw new Error(`Watch already started for label: ${label}`);
          }
          this.timestamps.set(label, { started: Date.now() });
        }
        stop(label) {
          const timestamp = this.get(label);
          if (typeof timestamp.elapsed !== "undefined") {
            throw new Error(`Watch already stopped for label: ${label}`);
          }
          const elapsed = Date.now() - timestamp.started;
          this.timestamps.set(label, { started: timestamp.started, elapsed });
        }
        get(label) {
          const timestamp = this.timestamps.get(label);
          if (typeof timestamp === "undefined") {
            throw new Error(`No timestamp found for label: ${label}`);
          }
          return timestamp;
        }
        elapsed(label) {
          const timestamp = this.get(label);
          const elapsed = timestamp.elapsed || Date.now() - timestamp.started;
          return elapsed;
        }
      };
      exports.Watch = Watch;
      exports.default = Watch;
    }
  });

  // node_modules/@walletconnect/time/dist/cjs/types/watch.js
  var require_watch2 = __commonJS({
    "node_modules/@walletconnect/time/dist/cjs/types/watch.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.IWatch = void 0;
      var IWatch = class {
      };
      exports.IWatch = IWatch;
    }
  });

  // node_modules/@walletconnect/time/dist/cjs/types/index.js
  var require_types = __commonJS({
    "node_modules/@walletconnect/time/dist/cjs/types/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      tslib_1.__exportStar(require_watch2(), exports);
    }
  });

  // node_modules/@walletconnect/time/dist/cjs/index.js
  var require_cjs = __commonJS({
    "node_modules/@walletconnect/time/dist/cjs/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      tslib_1.__exportStar(require_utils(), exports);
      tslib_1.__exportStar(require_watch(), exports);
      tslib_1.__exportStar(require_types(), exports);
      tslib_1.__exportStar(require_constants(), exports);
    }
  });

  // node_modules/@walletconnect/window-getters/dist/cjs/index.js
  var require_cjs2 = __commonJS({
    "node_modules/@walletconnect/window-getters/dist/cjs/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getLocalStorage = exports.getLocalStorageOrThrow = exports.getCrypto = exports.getCryptoOrThrow = exports.getLocation = exports.getLocationOrThrow = exports.getNavigator = exports.getNavigatorOrThrow = exports.getDocument = exports.getDocumentOrThrow = exports.getFromWindowOrThrow = exports.getFromWindow = void 0;
      function getFromWindow(name2) {
        let res = void 0;
        if (typeof window !== "undefined" && typeof window[name2] !== "undefined") {
          res = window[name2];
        }
        return res;
      }
      exports.getFromWindow = getFromWindow;
      function getFromWindowOrThrow(name2) {
        const res = getFromWindow(name2);
        if (!res) {
          throw new Error(`${name2} is not defined in Window`);
        }
        return res;
      }
      exports.getFromWindowOrThrow = getFromWindowOrThrow;
      function getDocumentOrThrow() {
        return getFromWindowOrThrow("document");
      }
      exports.getDocumentOrThrow = getDocumentOrThrow;
      function getDocument() {
        return getFromWindow("document");
      }
      exports.getDocument = getDocument;
      function getNavigatorOrThrow() {
        return getFromWindowOrThrow("navigator");
      }
      exports.getNavigatorOrThrow = getNavigatorOrThrow;
      function getNavigator() {
        return getFromWindow("navigator");
      }
      exports.getNavigator = getNavigator;
      function getLocationOrThrow() {
        return getFromWindowOrThrow("location");
      }
      exports.getLocationOrThrow = getLocationOrThrow;
      function getLocation() {
        return getFromWindow("location");
      }
      exports.getLocation = getLocation;
      function getCryptoOrThrow() {
        return getFromWindowOrThrow("crypto");
      }
      exports.getCryptoOrThrow = getCryptoOrThrow;
      function getCrypto() {
        return getFromWindow("crypto");
      }
      exports.getCrypto = getCrypto;
      function getLocalStorageOrThrow() {
        return getFromWindowOrThrow("localStorage");
      }
      exports.getLocalStorageOrThrow = getLocalStorageOrThrow;
      function getLocalStorage() {
        return getFromWindow("localStorage");
      }
      exports.getLocalStorage = getLocalStorage;
    }
  });

  // node_modules/@walletconnect/window-metadata/dist/cjs/index.js
  var require_cjs3 = __commonJS({
    "node_modules/@walletconnect/window-metadata/dist/cjs/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getWindowMetadata = void 0;
      var window_getters_1 = require_cjs2();
      function getWindowMetadata() {
        let doc;
        let loc;
        try {
          doc = window_getters_1.getDocumentOrThrow();
          loc = window_getters_1.getLocationOrThrow();
        } catch (e9) {
          return null;
        }
        function getIcons() {
          const links = doc.getElementsByTagName("link");
          const icons2 = [];
          for (let i7 = 0; i7 < links.length; i7++) {
            const link = links[i7];
            const rel = link.getAttribute("rel");
            if (rel) {
              if (rel.toLowerCase().indexOf("icon") > -1) {
                const href = link.getAttribute("href");
                if (href) {
                  if (href.toLowerCase().indexOf("https:") === -1 && href.toLowerCase().indexOf("http:") === -1 && href.indexOf("//") !== 0) {
                    let absoluteHref = loc.protocol + "//" + loc.host;
                    if (href.indexOf("/") === 0) {
                      absoluteHref += href;
                    } else {
                      const path = loc.pathname.split("/");
                      path.pop();
                      const finalPath = path.join("/");
                      absoluteHref += finalPath + "/" + href;
                    }
                    icons2.push(absoluteHref);
                  } else if (href.indexOf("//") === 0) {
                    const absoluteUrl = loc.protocol + href;
                    icons2.push(absoluteUrl);
                  } else {
                    icons2.push(href);
                  }
                }
              }
            }
          }
          return icons2;
        }
        function getWindowMetadataOfAny(...args) {
          const metaTags = doc.getElementsByTagName("meta");
          for (let i7 = 0; i7 < metaTags.length; i7++) {
            const tag = metaTags[i7];
            const attributes = ["itemprop", "property", "name"].map((target) => tag.getAttribute(target)).filter((attr) => {
              if (attr) {
                return args.includes(attr);
              }
              return false;
            });
            if (attributes.length && attributes) {
              const content = tag.getAttribute("content");
              if (content) {
                return content;
              }
            }
          }
          return "";
        }
        function getName() {
          let name3 = getWindowMetadataOfAny("name", "og:site_name", "og:title", "twitter:title");
          if (!name3) {
            name3 = doc.title;
          }
          return name3;
        }
        function getDescription() {
          const description2 = getWindowMetadataOfAny("description", "og:description", "twitter:description", "keywords");
          return description2;
        }
        const name2 = getName();
        const description = getDescription();
        const url = loc.origin;
        const icons = getIcons();
        const meta = {
          description,
          url,
          icons,
          name: name2
        };
        return meta;
      }
      exports.getWindowMetadata = getWindowMetadata;
    }
  });

  // node_modules/strict-uri-encode/index.js
  var require_strict_uri_encode = __commonJS({
    "node_modules/strict-uri-encode/index.js"(exports, module) {
      "use strict";
      module.exports = (str) => encodeURIComponent(str).replace(/[!'()*]/g, (x4) => `%${x4.charCodeAt(0).toString(16).toUpperCase()}`);
    }
  });

  // node_modules/decode-uri-component/index.js
  var require_decode_uri_component = __commonJS({
    "node_modules/decode-uri-component/index.js"(exports, module) {
      "use strict";
      var token = "%[a-f0-9]{2}";
      var singleMatcher = new RegExp("(" + token + ")|([^%]+?)", "gi");
      var multiMatcher = new RegExp("(" + token + ")+", "gi");
      function decodeComponents(components, split2) {
        try {
          return [decodeURIComponent(components.join(""))];
        } catch (err) {
        }
        if (components.length === 1) {
          return components;
        }
        split2 = split2 || 1;
        var left = components.slice(0, split2);
        var right = components.slice(split2);
        return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
      }
      function decode8(input) {
        try {
          return decodeURIComponent(input);
        } catch (err) {
          var tokens = input.match(singleMatcher) || [];
          for (var i7 = 1; i7 < tokens.length; i7++) {
            input = decodeComponents(tokens, i7).join("");
            tokens = input.match(singleMatcher) || [];
          }
          return input;
        }
      }
      function customDecodeURIComponent(input) {
        var replaceMap = {
          "%FE%FF": "\uFFFD\uFFFD",
          "%FF%FE": "\uFFFD\uFFFD"
        };
        var match = multiMatcher.exec(input);
        while (match) {
          try {
            replaceMap[match[0]] = decodeURIComponent(match[0]);
          } catch (err) {
            var result = decode8(match[0]);
            if (result !== match[0]) {
              replaceMap[match[0]] = result;
            }
          }
          match = multiMatcher.exec(input);
        }
        replaceMap["%C2"] = "\uFFFD";
        var entries = Object.keys(replaceMap);
        for (var i7 = 0; i7 < entries.length; i7++) {
          var key2 = entries[i7];
          input = input.replace(new RegExp(key2, "g"), replaceMap[key2]);
        }
        return input;
      }
      module.exports = function(encodedURI) {
        if (typeof encodedURI !== "string") {
          throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
        }
        try {
          encodedURI = encodedURI.replace(/\+/g, " ");
          return decodeURIComponent(encodedURI);
        } catch (err) {
          return customDecodeURIComponent(encodedURI);
        }
      };
    }
  });

  // node_modules/split-on-first/index.js
  var require_split_on_first = __commonJS({
    "node_modules/split-on-first/index.js"(exports, module) {
      "use strict";
      module.exports = (string2, separator) => {
        if (!(typeof string2 === "string" && typeof separator === "string")) {
          throw new TypeError("Expected the arguments to be of type `string`");
        }
        if (separator === "") {
          return [string2];
        }
        const separatorIndex = string2.indexOf(separator);
        if (separatorIndex === -1) {
          return [string2];
        }
        return [
          string2.slice(0, separatorIndex),
          string2.slice(separatorIndex + separator.length)
        ];
      };
    }
  });

  // node_modules/filter-obj/index.js
  var require_filter_obj = __commonJS({
    "node_modules/filter-obj/index.js"(exports, module) {
      "use strict";
      module.exports = function(obj, predicate) {
        var ret = {};
        var keys2 = Object.keys(obj);
        var isArr = Array.isArray(predicate);
        for (var i7 = 0; i7 < keys2.length; i7++) {
          var key2 = keys2[i7];
          var val = obj[key2];
          if (isArr ? predicate.indexOf(key2) !== -1 : predicate(key2, val, obj)) {
            ret[key2] = val;
          }
        }
        return ret;
      };
    }
  });

  // node_modules/@wagmi/connectors/node_modules/query-string/index.js
  var require_query_string = __commonJS({
    "node_modules/@wagmi/connectors/node_modules/query-string/index.js"(exports) {
      "use strict";
      var strictUriEncode = require_strict_uri_encode();
      var decodeComponent = require_decode_uri_component();
      var splitOnFirst = require_split_on_first();
      var filterObject = require_filter_obj();
      var isNullOrUndefined = (value) => value === null || value === void 0;
      var encodeFragmentIdentifier = Symbol("encodeFragmentIdentifier");
      function encoderForArrayFormat(options2) {
        switch (options2.arrayFormat) {
          case "index":
            return (key2) => (result, value) => {
              const index2 = result.length;
              if (value === void 0 || options2.skipNull && value === null || options2.skipEmptyString && value === "") {
                return result;
              }
              if (value === null) {
                return [...result, [encode10(key2, options2), "[", index2, "]"].join("")];
              }
              return [
                ...result,
                [encode10(key2, options2), "[", encode10(index2, options2), "]=", encode10(value, options2)].join("")
              ];
            };
          case "bracket":
            return (key2) => (result, value) => {
              if (value === void 0 || options2.skipNull && value === null || options2.skipEmptyString && value === "") {
                return result;
              }
              if (value === null) {
                return [...result, [encode10(key2, options2), "[]"].join("")];
              }
              return [...result, [encode10(key2, options2), "[]=", encode10(value, options2)].join("")];
            };
          case "colon-list-separator":
            return (key2) => (result, value) => {
              if (value === void 0 || options2.skipNull && value === null || options2.skipEmptyString && value === "") {
                return result;
              }
              if (value === null) {
                return [...result, [encode10(key2, options2), ":list="].join("")];
              }
              return [...result, [encode10(key2, options2), ":list=", encode10(value, options2)].join("")];
            };
          case "comma":
          case "separator":
          case "bracket-separator": {
            const keyValueSep = options2.arrayFormat === "bracket-separator" ? "[]=" : "=";
            return (key2) => (result, value) => {
              if (value === void 0 || options2.skipNull && value === null || options2.skipEmptyString && value === "") {
                return result;
              }
              value = value === null ? "" : value;
              if (result.length === 0) {
                return [[encode10(key2, options2), keyValueSep, encode10(value, options2)].join("")];
              }
              return [[result, encode10(value, options2)].join(options2.arrayFormatSeparator)];
            };
          }
          default:
            return (key2) => (result, value) => {
              if (value === void 0 || options2.skipNull && value === null || options2.skipEmptyString && value === "") {
                return result;
              }
              if (value === null) {
                return [...result, encode10(key2, options2)];
              }
              return [...result, [encode10(key2, options2), "=", encode10(value, options2)].join("")];
            };
        }
      }
      function parserForArrayFormat(options2) {
        let result;
        switch (options2.arrayFormat) {
          case "index":
            return (key2, value, accumulator) => {
              result = /\[(\d*)\]$/.exec(key2);
              key2 = key2.replace(/\[\d*\]$/, "");
              if (!result) {
                accumulator[key2] = value;
                return;
              }
              if (accumulator[key2] === void 0) {
                accumulator[key2] = {};
              }
              accumulator[key2][result[1]] = value;
            };
          case "bracket":
            return (key2, value, accumulator) => {
              result = /(\[\])$/.exec(key2);
              key2 = key2.replace(/\[\]$/, "");
              if (!result) {
                accumulator[key2] = value;
                return;
              }
              if (accumulator[key2] === void 0) {
                accumulator[key2] = [value];
                return;
              }
              accumulator[key2] = [].concat(accumulator[key2], value);
            };
          case "colon-list-separator":
            return (key2, value, accumulator) => {
              result = /(:list)$/.exec(key2);
              key2 = key2.replace(/:list$/, "");
              if (!result) {
                accumulator[key2] = value;
                return;
              }
              if (accumulator[key2] === void 0) {
                accumulator[key2] = [value];
                return;
              }
              accumulator[key2] = [].concat(accumulator[key2], value);
            };
          case "comma":
          case "separator":
            return (key2, value, accumulator) => {
              const isArray2 = typeof value === "string" && value.includes(options2.arrayFormatSeparator);
              const isEncodedArray = typeof value === "string" && !isArray2 && decode8(value, options2).includes(options2.arrayFormatSeparator);
              value = isEncodedArray ? decode8(value, options2) : value;
              const newValue = isArray2 || isEncodedArray ? value.split(options2.arrayFormatSeparator).map((item) => decode8(item, options2)) : value === null ? value : decode8(value, options2);
              accumulator[key2] = newValue;
            };
          case "bracket-separator":
            return (key2, value, accumulator) => {
              const isArray2 = /(\[\])$/.test(key2);
              key2 = key2.replace(/\[\]$/, "");
              if (!isArray2) {
                accumulator[key2] = value ? decode8(value, options2) : value;
                return;
              }
              const arrayValue = value === null ? [] : value.split(options2.arrayFormatSeparator).map((item) => decode8(item, options2));
              if (accumulator[key2] === void 0) {
                accumulator[key2] = arrayValue;
                return;
              }
              accumulator[key2] = [].concat(accumulator[key2], arrayValue);
            };
          default:
            return (key2, value, accumulator) => {
              if (accumulator[key2] === void 0) {
                accumulator[key2] = value;
                return;
              }
              accumulator[key2] = [].concat(accumulator[key2], value);
            };
        }
      }
      function validateArrayFormatSeparator(value) {
        if (typeof value !== "string" || value.length !== 1) {
          throw new TypeError("arrayFormatSeparator must be single character string");
        }
      }
      function encode10(value, options2) {
        if (options2.encode) {
          return options2.strict ? strictUriEncode(value) : encodeURIComponent(value);
        }
        return value;
      }
      function decode8(value, options2) {
        if (options2.decode) {
          return decodeComponent(value);
        }
        return value;
      }
      function keysSorter(input) {
        if (Array.isArray(input)) {
          return input.sort();
        }
        if (typeof input === "object") {
          return keysSorter(Object.keys(input)).sort((a6, b7) => Number(a6) - Number(b7)).map((key2) => input[key2]);
        }
        return input;
      }
      function removeHash(input) {
        const hashStart = input.indexOf("#");
        if (hashStart !== -1) {
          input = input.slice(0, hashStart);
        }
        return input;
      }
      function getHash(url) {
        let hash5 = "";
        const hashStart = url.indexOf("#");
        if (hashStart !== -1) {
          hash5 = url.slice(hashStart);
        }
        return hash5;
      }
      function extract2(input) {
        input = removeHash(input);
        const queryStart = input.indexOf("?");
        if (queryStart === -1) {
          return "";
        }
        return input.slice(queryStart + 1);
      }
      function parseValue(value, options2) {
        if (options2.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
          value = Number(value);
        } else if (options2.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
          value = value.toLowerCase() === "true";
        }
        return value;
      }
      function parse4(query, options2) {
        options2 = Object.assign({
          decode: true,
          sort: true,
          arrayFormat: "none",
          arrayFormatSeparator: ",",
          parseNumbers: false,
          parseBooleans: false
        }, options2);
        validateArrayFormatSeparator(options2.arrayFormatSeparator);
        const formatter = parserForArrayFormat(options2);
        const ret = /* @__PURE__ */ Object.create(null);
        if (typeof query !== "string") {
          return ret;
        }
        query = query.trim().replace(/^[?#&]/, "");
        if (!query) {
          return ret;
        }
        for (const param of query.split("&")) {
          if (param === "") {
            continue;
          }
          let [key2, value] = splitOnFirst(options2.decode ? param.replace(/\+/g, " ") : param, "=");
          value = value === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(options2.arrayFormat) ? value : decode8(value, options2);
          formatter(decode8(key2, options2), value, ret);
        }
        for (const key2 of Object.keys(ret)) {
          const value = ret[key2];
          if (typeof value === "object" && value !== null) {
            for (const k6 of Object.keys(value)) {
              value[k6] = parseValue(value[k6], options2);
            }
          } else {
            ret[key2] = parseValue(value, options2);
          }
        }
        if (options2.sort === false) {
          return ret;
        }
        return (options2.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options2.sort)).reduce((result, key2) => {
          const value = ret[key2];
          if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
            result[key2] = keysSorter(value);
          } else {
            result[key2] = value;
          }
          return result;
        }, /* @__PURE__ */ Object.create(null));
      }
      exports.extract = extract2;
      exports.parse = parse4;
      exports.stringify = (object, options2) => {
        if (!object) {
          return "";
        }
        options2 = Object.assign({
          encode: true,
          strict: true,
          arrayFormat: "none",
          arrayFormatSeparator: ","
        }, options2);
        validateArrayFormatSeparator(options2.arrayFormatSeparator);
        const shouldFilter = (key2) => options2.skipNull && isNullOrUndefined(object[key2]) || options2.skipEmptyString && object[key2] === "";
        const formatter = encoderForArrayFormat(options2);
        const objectCopy = {};
        for (const key2 of Object.keys(object)) {
          if (!shouldFilter(key2)) {
            objectCopy[key2] = object[key2];
          }
        }
        const keys2 = Object.keys(objectCopy);
        if (options2.sort !== false) {
          keys2.sort(options2.sort);
        }
        return keys2.map((key2) => {
          const value = object[key2];
          if (value === void 0) {
            return "";
          }
          if (value === null) {
            return encode10(key2, options2);
          }
          if (Array.isArray(value)) {
            if (value.length === 0 && options2.arrayFormat === "bracket-separator") {
              return encode10(key2, options2) + "[]";
            }
            return value.reduce(formatter(key2), []).join("&");
          }
          return encode10(key2, options2) + "=" + encode10(value, options2);
        }).filter((x4) => x4.length > 0).join("&");
      };
      exports.parseUrl = (url, options2) => {
        options2 = Object.assign({
          decode: true
        }, options2);
        const [url_, hash5] = splitOnFirst(url, "#");
        return Object.assign(
          {
            url: url_.split("?")[0] || "",
            query: parse4(extract2(url), options2)
          },
          options2 && options2.parseFragmentIdentifier && hash5 ? { fragmentIdentifier: decode8(hash5, options2) } : {}
        );
      };
      exports.stringifyUrl = (object, options2) => {
        options2 = Object.assign({
          encode: true,
          strict: true,
          [encodeFragmentIdentifier]: true
        }, options2);
        const url = removeHash(object.url).split("?")[0] || "";
        const queryFromUrl = exports.extract(object.url);
        const parsedQueryFromUrl = exports.parse(queryFromUrl, { sort: false });
        const query = Object.assign(parsedQueryFromUrl, object.query);
        let queryString = exports.stringify(query, options2);
        if (queryString) {
          queryString = `?${queryString}`;
        }
        let hash5 = getHash(object.url);
        if (object.fragmentIdentifier) {
          hash5 = `#${options2[encodeFragmentIdentifier] ? encode10(object.fragmentIdentifier, options2) : object.fragmentIdentifier}`;
        }
        return `${url}${queryString}${hash5}`;
      };
      exports.pick = (input, filter2, options2) => {
        options2 = Object.assign({
          parseFragmentIdentifier: true,
          [encodeFragmentIdentifier]: false
        }, options2);
        const { url, query, fragmentIdentifier } = exports.parseUrl(input, options2);
        return exports.stringifyUrl({
          url,
          query: filterObject(query, filter2),
          fragmentIdentifier
        }, options2);
      };
      exports.exclude = (input, filter2, options2) => {
        const exclusionFilter = Array.isArray(filter2) ? (key2) => !filter2.includes(key2) : (key2, value) => !filter2(key2, value);
        return exports.pick(input, exclusionFilter, options2);
      };
    }
  });

  // node_modules/@walletconnect/relay-api/dist/esm/types.js
  var init_types = __esm({
    "node_modules/@walletconnect/relay-api/dist/esm/types.js"() {
    }
  });

  // node_modules/@walletconnect/relay-api/dist/esm/misc.js
  var init_misc = __esm({
    "node_modules/@walletconnect/relay-api/dist/esm/misc.js"() {
    }
  });

  // node_modules/@walletconnect/relay-api/dist/esm/validators.js
  var init_validators = __esm({
    "node_modules/@walletconnect/relay-api/dist/esm/validators.js"() {
      init_misc();
    }
  });

  // node_modules/@walletconnect/relay-api/dist/esm/parsers.js
  var init_parsers = __esm({
    "node_modules/@walletconnect/relay-api/dist/esm/parsers.js"() {
      init_misc();
      init_validators();
    }
  });

  // node_modules/@walletconnect/relay-api/dist/esm/jsonrpc.js
  var RELAY_JSONRPC;
  var init_jsonrpc = __esm({
    "node_modules/@walletconnect/relay-api/dist/esm/jsonrpc.js"() {
      RELAY_JSONRPC = {
        waku: {
          publish: "waku_publish",
          batchPublish: "waku_batchPublish",
          subscribe: "waku_subscribe",
          batchSubscribe: "waku_batchSubscribe",
          subscription: "waku_subscription",
          unsubscribe: "waku_unsubscribe",
          batchUnsubscribe: "waku_batchUnsubscribe"
        },
        irn: {
          publish: "irn_publish",
          batchPublish: "irn_batchPublish",
          subscribe: "irn_subscribe",
          batchSubscribe: "irn_batchSubscribe",
          subscription: "irn_subscription",
          unsubscribe: "irn_unsubscribe",
          batchUnsubscribe: "irn_batchUnsubscribe"
        },
        iridium: {
          publish: "iridium_publish",
          batchPublish: "iridium_batchPublish",
          subscribe: "iridium_subscribe",
          batchSubscribe: "iridium_batchSubscribe",
          subscription: "iridium_subscription",
          unsubscribe: "iridium_unsubscribe",
          batchUnsubscribe: "iridium_batchUnsubscribe"
        }
      };
    }
  });

  // node_modules/@walletconnect/relay-api/dist/esm/index.js
  var init_esm = __esm({
    "node_modules/@walletconnect/relay-api/dist/esm/index.js"() {
      init_types();
      init_parsers();
      init_jsonrpc();
      init_validators();
    }
  });

  // node_modules/events/events.js
  var require_events = __commonJS({
    "node_modules/events/events.js"(exports, module) {
      "use strict";
      var R7 = typeof Reflect === "object" ? Reflect : null;
      var ReflectApply = R7 && typeof R7.apply === "function" ? R7.apply : function ReflectApply2(target, receiver, args) {
        return Function.prototype.apply.call(target, receiver, args);
      };
      var ReflectOwnKeys;
      if (R7 && typeof R7.ownKeys === "function") {
        ReflectOwnKeys = R7.ownKeys;
      } else if (Object.getOwnPropertySymbols) {
        ReflectOwnKeys = function ReflectOwnKeys2(target) {
          return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
        };
      } else {
        ReflectOwnKeys = function ReflectOwnKeys2(target) {
          return Object.getOwnPropertyNames(target);
        };
      }
      function ProcessEmitWarning(warning2) {
        if (console && console.warn)
          console.warn(warning2);
      }
      var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
        return value !== value;
      };
      function EventEmitter4() {
        EventEmitter4.init.call(this);
      }
      module.exports = EventEmitter4;
      module.exports.once = once;
      EventEmitter4.EventEmitter = EventEmitter4;
      EventEmitter4.prototype._events = void 0;
      EventEmitter4.prototype._eventsCount = 0;
      EventEmitter4.prototype._maxListeners = void 0;
      var defaultMaxListeners = 10;
      function checkListener(listener) {
        if (typeof listener !== "function") {
          throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
        }
      }
      Object.defineProperty(EventEmitter4, "defaultMaxListeners", {
        enumerable: true,
        get: function() {
          return defaultMaxListeners;
        },
        set: function(arg) {
          if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
            throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
          }
          defaultMaxListeners = arg;
        }
      });
      EventEmitter4.init = function() {
        if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        }
        this._maxListeners = this._maxListeners || void 0;
      };
      EventEmitter4.prototype.setMaxListeners = function setMaxListeners(n9) {
        if (typeof n9 !== "number" || n9 < 0 || NumberIsNaN(n9)) {
          throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n9 + ".");
        }
        this._maxListeners = n9;
        return this;
      };
      function _getMaxListeners(that) {
        if (that._maxListeners === void 0)
          return EventEmitter4.defaultMaxListeners;
        return that._maxListeners;
      }
      EventEmitter4.prototype.getMaxListeners = function getMaxListeners() {
        return _getMaxListeners(this);
      };
      EventEmitter4.prototype.emit = function emit(type) {
        var args = [];
        for (var i7 = 1; i7 < arguments.length; i7++)
          args.push(arguments[i7]);
        var doError = type === "error";
        var events = this._events;
        if (events !== void 0)
          doError = doError && events.error === void 0;
        else if (!doError)
          return false;
        if (doError) {
          var er5;
          if (args.length > 0)
            er5 = args[0];
          if (er5 instanceof Error) {
            throw er5;
          }
          var err = new Error("Unhandled error." + (er5 ? " (" + er5.message + ")" : ""));
          err.context = er5;
          throw err;
        }
        var handler = events[type];
        if (handler === void 0)
          return false;
        if (typeof handler === "function") {
          ReflectApply(handler, this, args);
        } else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i7 = 0; i7 < len; ++i7)
            ReflectApply(listeners[i7], this, args);
        }
        return true;
      };
      function _addListener(target, type, listener, prepend) {
        var m6;
        var events;
        var existing;
        checkListener(listener);
        events = target._events;
        if (events === void 0) {
          events = target._events = /* @__PURE__ */ Object.create(null);
          target._eventsCount = 0;
        } else {
          if (events.newListener !== void 0) {
            target.emit(
              "newListener",
              type,
              listener.listener ? listener.listener : listener
            );
            events = target._events;
          }
          existing = events[type];
        }
        if (existing === void 0) {
          existing = events[type] = listener;
          ++target._eventsCount;
        } else {
          if (typeof existing === "function") {
            existing = events[type] = prepend ? [listener, existing] : [existing, listener];
          } else if (prepend) {
            existing.unshift(listener);
          } else {
            existing.push(listener);
          }
          m6 = _getMaxListeners(target);
          if (m6 > 0 && existing.length > m6 && !existing.warned) {
            existing.warned = true;
            var w8 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            w8.name = "MaxListenersExceededWarning";
            w8.emitter = target;
            w8.type = type;
            w8.count = existing.length;
            ProcessEmitWarning(w8);
          }
        }
        return target;
      }
      EventEmitter4.prototype.addListener = function addListener(type, listener) {
        return _addListener(this, type, listener, false);
      };
      EventEmitter4.prototype.on = EventEmitter4.prototype.addListener;
      EventEmitter4.prototype.prependListener = function prependListener(type, listener) {
        return _addListener(this, type, listener, true);
      };
      function onceWrapper() {
        if (!this.fired) {
          this.target.removeListener(this.type, this.wrapFn);
          this.fired = true;
          if (arguments.length === 0)
            return this.listener.call(this.target);
          return this.listener.apply(this.target, arguments);
        }
      }
      function _onceWrap(target, type, listener) {
        var state = { fired: false, wrapFn: void 0, target, type, listener };
        var wrapped = onceWrapper.bind(state);
        wrapped.listener = listener;
        state.wrapFn = wrapped;
        return wrapped;
      }
      EventEmitter4.prototype.once = function once2(type, listener) {
        checkListener(listener);
        this.on(type, _onceWrap(this, type, listener));
        return this;
      };
      EventEmitter4.prototype.prependOnceListener = function prependOnceListener(type, listener) {
        checkListener(listener);
        this.prependListener(type, _onceWrap(this, type, listener));
        return this;
      };
      EventEmitter4.prototype.removeListener = function removeListener(type, listener) {
        var list, events, position, i7, originalListener;
        checkListener(listener);
        events = this._events;
        if (events === void 0)
          return this;
        list = events[type];
        if (list === void 0)
          return this;
        if (list === listener || list.listener === listener) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else {
            delete events[type];
            if (events.removeListener)
              this.emit("removeListener", type, list.listener || listener);
          }
        } else if (typeof list !== "function") {
          position = -1;
          for (i7 = list.length - 1; i7 >= 0; i7--) {
            if (list[i7] === listener || list[i7].listener === listener) {
              originalListener = list[i7].listener;
              position = i7;
              break;
            }
          }
          if (position < 0)
            return this;
          if (position === 0)
            list.shift();
          else {
            spliceOne(list, position);
          }
          if (list.length === 1)
            events[type] = list[0];
          if (events.removeListener !== void 0)
            this.emit("removeListener", type, originalListener || listener);
        }
        return this;
      };
      EventEmitter4.prototype.off = EventEmitter4.prototype.removeListener;
      EventEmitter4.prototype.removeAllListeners = function removeAllListeners(type) {
        var listeners, events, i7;
        events = this._events;
        if (events === void 0)
          return this;
        if (events.removeListener === void 0) {
          if (arguments.length === 0) {
            this._events = /* @__PURE__ */ Object.create(null);
            this._eventsCount = 0;
          } else if (events[type] !== void 0) {
            if (--this._eventsCount === 0)
              this._events = /* @__PURE__ */ Object.create(null);
            else
              delete events[type];
          }
          return this;
        }
        if (arguments.length === 0) {
          var keys2 = Object.keys(events);
          var key2;
          for (i7 = 0; i7 < keys2.length; ++i7) {
            key2 = keys2[i7];
            if (key2 === "removeListener")
              continue;
            this.removeAllListeners(key2);
          }
          this.removeAllListeners("removeListener");
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
          return this;
        }
        listeners = events[type];
        if (typeof listeners === "function") {
          this.removeListener(type, listeners);
        } else if (listeners !== void 0) {
          for (i7 = listeners.length - 1; i7 >= 0; i7--) {
            this.removeListener(type, listeners[i7]);
          }
        }
        return this;
      };
      function _listeners(target, type, unwrap) {
        var events = target._events;
        if (events === void 0)
          return [];
        var evlistener = events[type];
        if (evlistener === void 0)
          return [];
        if (typeof evlistener === "function")
          return unwrap ? [evlistener.listener || evlistener] : [evlistener];
        return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
      }
      EventEmitter4.prototype.listeners = function listeners(type) {
        return _listeners(this, type, true);
      };
      EventEmitter4.prototype.rawListeners = function rawListeners(type) {
        return _listeners(this, type, false);
      };
      EventEmitter4.listenerCount = function(emitter, type) {
        if (typeof emitter.listenerCount === "function") {
          return emitter.listenerCount(type);
        } else {
          return listenerCount.call(emitter, type);
        }
      };
      EventEmitter4.prototype.listenerCount = listenerCount;
      function listenerCount(type) {
        var events = this._events;
        if (events !== void 0) {
          var evlistener = events[type];
          if (typeof evlistener === "function") {
            return 1;
          } else if (evlistener !== void 0) {
            return evlistener.length;
          }
        }
        return 0;
      }
      EventEmitter4.prototype.eventNames = function eventNames() {
        return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
      };
      function arrayClone(arr, n9) {
        var copy = new Array(n9);
        for (var i7 = 0; i7 < n9; ++i7)
          copy[i7] = arr[i7];
        return copy;
      }
      function spliceOne(list, index2) {
        for (; index2 + 1 < list.length; index2++)
          list[index2] = list[index2 + 1];
        list.pop();
      }
      function unwrapListeners(arr) {
        var ret = new Array(arr.length);
        for (var i7 = 0; i7 < ret.length; ++i7) {
          ret[i7] = arr[i7].listener || arr[i7];
        }
        return ret;
      }
      function once(emitter, name2) {
        return new Promise(function(resolve, reject) {
          function errorListener(err) {
            emitter.removeListener(name2, resolver);
            reject(err);
          }
          function resolver() {
            if (typeof emitter.removeListener === "function") {
              emitter.removeListener("error", errorListener);
            }
            resolve([].slice.call(arguments));
          }
          ;
          eventTargetAgnosticAddListener(emitter, name2, resolver, { once: true });
          if (name2 !== "error") {
            addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
          }
        });
      }
      function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
        if (typeof emitter.on === "function") {
          eventTargetAgnosticAddListener(emitter, "error", handler, flags);
        }
      }
      function eventTargetAgnosticAddListener(emitter, name2, listener, flags) {
        if (typeof emitter.on === "function") {
          if (flags.once) {
            emitter.once(name2, listener);
          } else {
            emitter.on(name2, listener);
          }
        } else if (typeof emitter.addEventListener === "function") {
          emitter.addEventListener(name2, function wrapListener(arg) {
            if (flags.once) {
              emitter.removeEventListener(name2, wrapListener);
            }
            listener(arg);
          });
        } else {
          throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
        }
      }
    }
  });

  // node_modules/@walletconnect/utils/node_modules/query-string/index.js
  var require_query_string2 = __commonJS({
    "node_modules/@walletconnect/utils/node_modules/query-string/index.js"(exports) {
      "use strict";
      var strictUriEncode = require_strict_uri_encode();
      var decodeComponent = require_decode_uri_component();
      var splitOnFirst = require_split_on_first();
      var filterObject = require_filter_obj();
      var isNullOrUndefined = (value) => value === null || value === void 0;
      var encodeFragmentIdentifier = Symbol("encodeFragmentIdentifier");
      function encoderForArrayFormat(options2) {
        switch (options2.arrayFormat) {
          case "index":
            return (key2) => (result, value) => {
              const index2 = result.length;
              if (value === void 0 || options2.skipNull && value === null || options2.skipEmptyString && value === "") {
                return result;
              }
              if (value === null) {
                return [...result, [encode10(key2, options2), "[", index2, "]"].join("")];
              }
              return [
                ...result,
                [encode10(key2, options2), "[", encode10(index2, options2), "]=", encode10(value, options2)].join("")
              ];
            };
          case "bracket":
            return (key2) => (result, value) => {
              if (value === void 0 || options2.skipNull && value === null || options2.skipEmptyString && value === "") {
                return result;
              }
              if (value === null) {
                return [...result, [encode10(key2, options2), "[]"].join("")];
              }
              return [...result, [encode10(key2, options2), "[]=", encode10(value, options2)].join("")];
            };
          case "colon-list-separator":
            return (key2) => (result, value) => {
              if (value === void 0 || options2.skipNull && value === null || options2.skipEmptyString && value === "") {
                return result;
              }
              if (value === null) {
                return [...result, [encode10(key2, options2), ":list="].join("")];
              }
              return [...result, [encode10(key2, options2), ":list=", encode10(value, options2)].join("")];
            };
          case "comma":
          case "separator":
          case "bracket-separator": {
            const keyValueSep = options2.arrayFormat === "bracket-separator" ? "[]=" : "=";
            return (key2) => (result, value) => {
              if (value === void 0 || options2.skipNull && value === null || options2.skipEmptyString && value === "") {
                return result;
              }
              value = value === null ? "" : value;
              if (result.length === 0) {
                return [[encode10(key2, options2), keyValueSep, encode10(value, options2)].join("")];
              }
              return [[result, encode10(value, options2)].join(options2.arrayFormatSeparator)];
            };
          }
          default:
            return (key2) => (result, value) => {
              if (value === void 0 || options2.skipNull && value === null || options2.skipEmptyString && value === "") {
                return result;
              }
              if (value === null) {
                return [...result, encode10(key2, options2)];
              }
              return [...result, [encode10(key2, options2), "=", encode10(value, options2)].join("")];
            };
        }
      }
      function parserForArrayFormat(options2) {
        let result;
        switch (options2.arrayFormat) {
          case "index":
            return (key2, value, accumulator) => {
              result = /\[(\d*)\]$/.exec(key2);
              key2 = key2.replace(/\[\d*\]$/, "");
              if (!result) {
                accumulator[key2] = value;
                return;
              }
              if (accumulator[key2] === void 0) {
                accumulator[key2] = {};
              }
              accumulator[key2][result[1]] = value;
            };
          case "bracket":
            return (key2, value, accumulator) => {
              result = /(\[\])$/.exec(key2);
              key2 = key2.replace(/\[\]$/, "");
              if (!result) {
                accumulator[key2] = value;
                return;
              }
              if (accumulator[key2] === void 0) {
                accumulator[key2] = [value];
                return;
              }
              accumulator[key2] = [].concat(accumulator[key2], value);
            };
          case "colon-list-separator":
            return (key2, value, accumulator) => {
              result = /(:list)$/.exec(key2);
              key2 = key2.replace(/:list$/, "");
              if (!result) {
                accumulator[key2] = value;
                return;
              }
              if (accumulator[key2] === void 0) {
                accumulator[key2] = [value];
                return;
              }
              accumulator[key2] = [].concat(accumulator[key2], value);
            };
          case "comma":
          case "separator":
            return (key2, value, accumulator) => {
              const isArray2 = typeof value === "string" && value.includes(options2.arrayFormatSeparator);
              const isEncodedArray = typeof value === "string" && !isArray2 && decode8(value, options2).includes(options2.arrayFormatSeparator);
              value = isEncodedArray ? decode8(value, options2) : value;
              const newValue = isArray2 || isEncodedArray ? value.split(options2.arrayFormatSeparator).map((item) => decode8(item, options2)) : value === null ? value : decode8(value, options2);
              accumulator[key2] = newValue;
            };
          case "bracket-separator":
            return (key2, value, accumulator) => {
              const isArray2 = /(\[\])$/.test(key2);
              key2 = key2.replace(/\[\]$/, "");
              if (!isArray2) {
                accumulator[key2] = value ? decode8(value, options2) : value;
                return;
              }
              const arrayValue = value === null ? [] : value.split(options2.arrayFormatSeparator).map((item) => decode8(item, options2));
              if (accumulator[key2] === void 0) {
                accumulator[key2] = arrayValue;
                return;
              }
              accumulator[key2] = [].concat(accumulator[key2], arrayValue);
            };
          default:
            return (key2, value, accumulator) => {
              if (accumulator[key2] === void 0) {
                accumulator[key2] = value;
                return;
              }
              accumulator[key2] = [].concat(accumulator[key2], value);
            };
        }
      }
      function validateArrayFormatSeparator(value) {
        if (typeof value !== "string" || value.length !== 1) {
          throw new TypeError("arrayFormatSeparator must be single character string");
        }
      }
      function encode10(value, options2) {
        if (options2.encode) {
          return options2.strict ? strictUriEncode(value) : encodeURIComponent(value);
        }
        return value;
      }
      function decode8(value, options2) {
        if (options2.decode) {
          return decodeComponent(value);
        }
        return value;
      }
      function keysSorter(input) {
        if (Array.isArray(input)) {
          return input.sort();
        }
        if (typeof input === "object") {
          return keysSorter(Object.keys(input)).sort((a6, b7) => Number(a6) - Number(b7)).map((key2) => input[key2]);
        }
        return input;
      }
      function removeHash(input) {
        const hashStart = input.indexOf("#");
        if (hashStart !== -1) {
          input = input.slice(0, hashStart);
        }
        return input;
      }
      function getHash(url) {
        let hash5 = "";
        const hashStart = url.indexOf("#");
        if (hashStart !== -1) {
          hash5 = url.slice(hashStart);
        }
        return hash5;
      }
      function extract2(input) {
        input = removeHash(input);
        const queryStart = input.indexOf("?");
        if (queryStart === -1) {
          return "";
        }
        return input.slice(queryStart + 1);
      }
      function parseValue(value, options2) {
        if (options2.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
          value = Number(value);
        } else if (options2.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
          value = value.toLowerCase() === "true";
        }
        return value;
      }
      function parse4(query, options2) {
        options2 = Object.assign({
          decode: true,
          sort: true,
          arrayFormat: "none",
          arrayFormatSeparator: ",",
          parseNumbers: false,
          parseBooleans: false
        }, options2);
        validateArrayFormatSeparator(options2.arrayFormatSeparator);
        const formatter = parserForArrayFormat(options2);
        const ret = /* @__PURE__ */ Object.create(null);
        if (typeof query !== "string") {
          return ret;
        }
        query = query.trim().replace(/^[?#&]/, "");
        if (!query) {
          return ret;
        }
        for (const param of query.split("&")) {
          if (param === "") {
            continue;
          }
          let [key2, value] = splitOnFirst(options2.decode ? param.replace(/\+/g, " ") : param, "=");
          value = value === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(options2.arrayFormat) ? value : decode8(value, options2);
          formatter(decode8(key2, options2), value, ret);
        }
        for (const key2 of Object.keys(ret)) {
          const value = ret[key2];
          if (typeof value === "object" && value !== null) {
            for (const k6 of Object.keys(value)) {
              value[k6] = parseValue(value[k6], options2);
            }
          } else {
            ret[key2] = parseValue(value, options2);
          }
        }
        if (options2.sort === false) {
          return ret;
        }
        return (options2.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options2.sort)).reduce((result, key2) => {
          const value = ret[key2];
          if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
            result[key2] = keysSorter(value);
          } else {
            result[key2] = value;
          }
          return result;
        }, /* @__PURE__ */ Object.create(null));
      }
      exports.extract = extract2;
      exports.parse = parse4;
      exports.stringify = (object, options2) => {
        if (!object) {
          return "";
        }
        options2 = Object.assign({
          encode: true,
          strict: true,
          arrayFormat: "none",
          arrayFormatSeparator: ","
        }, options2);
        validateArrayFormatSeparator(options2.arrayFormatSeparator);
        const shouldFilter = (key2) => options2.skipNull && isNullOrUndefined(object[key2]) || options2.skipEmptyString && object[key2] === "";
        const formatter = encoderForArrayFormat(options2);
        const objectCopy = {};
        for (const key2 of Object.keys(object)) {
          if (!shouldFilter(key2)) {
            objectCopy[key2] = object[key2];
          }
        }
        const keys2 = Object.keys(objectCopy);
        if (options2.sort !== false) {
          keys2.sort(options2.sort);
        }
        return keys2.map((key2) => {
          const value = object[key2];
          if (value === void 0) {
            return "";
          }
          if (value === null) {
            return encode10(key2, options2);
          }
          if (Array.isArray(value)) {
            if (value.length === 0 && options2.arrayFormat === "bracket-separator") {
              return encode10(key2, options2) + "[]";
            }
            return value.reduce(formatter(key2), []).join("&");
          }
          return encode10(key2, options2) + "=" + encode10(value, options2);
        }).filter((x4) => x4.length > 0).join("&");
      };
      exports.parseUrl = (url, options2) => {
        options2 = Object.assign({
          decode: true
        }, options2);
        const [url_, hash5] = splitOnFirst(url, "#");
        return Object.assign(
          {
            url: url_.split("?")[0] || "",
            query: parse4(extract2(url), options2)
          },
          options2 && options2.parseFragmentIdentifier && hash5 ? { fragmentIdentifier: decode8(hash5, options2) } : {}
        );
      };
      exports.stringifyUrl = (object, options2) => {
        options2 = Object.assign({
          encode: true,
          strict: true,
          [encodeFragmentIdentifier]: true
        }, options2);
        const url = removeHash(object.url).split("?")[0] || "";
        const queryFromUrl = exports.extract(object.url);
        const parsedQueryFromUrl = exports.parse(queryFromUrl, { sort: false });
        const query = Object.assign(parsedQueryFromUrl, object.query);
        let queryString = exports.stringify(query, options2);
        if (queryString) {
          queryString = `?${queryString}`;
        }
        let hash5 = getHash(object.url);
        if (object.fragmentIdentifier) {
          hash5 = `#${options2[encodeFragmentIdentifier] ? encode10(object.fragmentIdentifier, options2) : object.fragmentIdentifier}`;
        }
        return `${url}${queryString}${hash5}`;
      };
      exports.pick = (input, filter2, options2) => {
        options2 = Object.assign({
          parseFragmentIdentifier: true,
          [encodeFragmentIdentifier]: false
        }, options2);
        const { url, query, fragmentIdentifier } = exports.parseUrl(input, options2);
        return exports.stringifyUrl({
          url,
          query: filterObject(query, filter2),
          fragmentIdentifier
        }, options2);
      };
      exports.exclude = (input, filter2, options2) => {
        const exclusionFilter = Array.isArray(filter2) ? (key2) => !filter2.includes(key2) : (key2, value) => !filter2(key2, value);
        return exports.pick(input, exclusionFilter, options2);
      };
    }
  });

  // node_modules/@walletconnect/utils/dist/index.es.js
  function ge(e9) {
    const [n9, t6] = e9.split(K);
    return { namespace: n9, reference: t6 };
  }
  function Un(e9, n9 = []) {
    const t6 = [];
    return Object.keys(e9).forEach((r8) => {
      if (n9.length && !n9.includes(r8))
        return;
      const o9 = e9[r8];
      t6.push(...o9.accounts);
    }), t6;
  }
  function L(e9, n9) {
    return e9.includes(":") ? [e9] : n9.chains || [];
  }
  function kn() {
    const e9 = fe2.generateKeyPair();
    return { privateKey: toString2(e9.secretKey, p), publicKey: toString2(e9.publicKey, p) };
  }
  function Vn() {
    const e9 = (0, import_random2.randomBytes)(X);
    return toString2(e9, p);
  }
  function Mn(e9, n9) {
    const t6 = fe2.sharedKey(fromString2(e9, p), fromString2(n9, p), true), r8 = new import_hkdf2.HKDF(import_sha2562.SHA256, t6).expand(X);
    return toString2(r8, p);
  }
  function Kn(e9) {
    const n9 = (0, import_sha2562.hash)(fromString2(e9, p));
    return toString2(n9, p);
  }
  function Ln(e9) {
    const n9 = (0, import_sha2562.hash)(fromString2(e9, H));
    return toString2(n9, p);
  }
  function Pe(e9) {
    return fromString2(`${e9}`, J);
  }
  function $(e9) {
    return Number(toString2(e9, J));
  }
  function xn(e9) {
    const n9 = Pe(typeof e9.type < "u" ? e9.type : Q);
    if ($(n9) === _ && typeof e9.senderPublicKey > "u")
      throw new Error("Missing sender public key for type 1 envelope");
    const t6 = typeof e9.senderPublicKey < "u" ? fromString2(e9.senderPublicKey, p) : void 0, r8 = typeof e9.iv < "u" ? fromString2(e9.iv, p) : (0, import_random2.randomBytes)(Z), o9 = new import_chacha20poly13052.ChaCha20Poly1305(fromString2(e9.symKey, p)).seal(r8, fromString2(e9.message, H));
    return Re({ type: n9, sealed: o9, iv: r8, senderPublicKey: t6 });
  }
  function Fn(e9) {
    const n9 = new import_chacha20poly13052.ChaCha20Poly1305(fromString2(e9.symKey, p)), { sealed: t6, iv: r8 } = ee(e9.encoded), o9 = n9.open(r8, t6);
    if (o9 === null)
      throw new Error("Failed to decrypt");
    return toString2(o9, H);
  }
  function Re(e9) {
    if ($(e9.type) === _) {
      if (typeof e9.senderPublicKey > "u")
        throw new Error("Missing sender public key for type 1 envelope");
      return toString2(concat2([e9.type, e9.senderPublicKey, e9.iv, e9.sealed]), F);
    }
    return toString2(concat2([e9.type, e9.iv, e9.sealed]), F);
  }
  function ee(e9) {
    const n9 = fromString2(e9, F), t6 = n9.slice(Dn, Ie), r8 = Ie;
    if ($(t6) === _) {
      const d7 = r8 + X, l9 = d7 + Z, c9 = n9.slice(r8, d7), u7 = n9.slice(d7, l9), a6 = n9.slice(l9);
      return { type: t6, sealed: a6, iv: u7, senderPublicKey: c9 };
    }
    const o9 = r8 + Z, s7 = n9.slice(r8, o9), i7 = n9.slice(o9);
    return { type: t6, sealed: i7, iv: s7 };
  }
  function Hn(e9, n9) {
    const t6 = ee(e9);
    return Te({ type: $(t6.type), senderPublicKey: typeof t6.senderPublicKey < "u" ? toString2(t6.senderPublicKey, p) : void 0, receiverPublicKey: n9?.receiverPublicKey });
  }
  function Te(e9) {
    const n9 = e9?.type || Q;
    if (n9 === _) {
      if (typeof e9?.senderPublicKey > "u")
        throw new Error("missing sender public key");
      if (typeof e9?.receiverPublicKey > "u")
        throw new Error("missing receiver public key");
    }
    return { type: n9, senderPublicKey: e9?.senderPublicKey, receiverPublicKey: e9?.receiverPublicKey };
  }
  function qn(e9) {
    return e9.type === _ && typeof e9.senderPublicKey == "string" && typeof e9.receiverPublicKey == "string";
  }
  function te() {
    return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
  }
  function C() {
    return !(0, import_window_getters2.getDocument)() && !!(0, import_window_getters2.getNavigator)() && navigator.product === Ce;
  }
  function D() {
    return !te() && !!(0, import_window_getters2.getNavigator)();
  }
  function T() {
    return C() ? m.reactNative : te() ? m.node : D() ? m.browser : m.unknown;
  }
  function Jn() {
    var e9;
    try {
      return C() && typeof global < "u" && typeof (global == null ? void 0 : global.Application) < "u" ? (e9 = global.Application) == null ? void 0 : e9.applicationId : void 0;
    } catch {
      return;
    }
  }
  function De(e9, n9) {
    let t6 = M.parse(e9);
    return t6 = _e(_e({}, t6), n9), e9 = M.stringify(t6), e9;
  }
  function Qn() {
    return (0, import_window_metadata2.getWindowMetadata)() || { name: "", description: "", url: "", icons: [""] };
  }
  function ke() {
    if (T() === m.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
      const { OS: t6, Version: r8 } = global.Platform;
      return [t6, r8].join("-");
    }
    const e9 = detect();
    if (e9 === null)
      return "unknown";
    const n9 = e9.os ? e9.os.replace(" ", "").toLowerCase() : "unknown";
    return e9.type === "browser" ? [n9, e9.name, e9.version].join("-") : [n9, e9.version].join("-");
  }
  function Ve() {
    var e9;
    const n9 = T();
    return n9 === m.browser ? [n9, ((e9 = (0, import_window_getters2.getLocation)()) == null ? void 0 : e9.host) || "unknown"].join(":") : n9;
  }
  function Me(e9, n9, t6) {
    const r8 = ke(), o9 = Ve();
    return [[e9, n9].join("-"), [$e, t6].join("-"), r8, o9].join("/");
  }
  function Xn({ protocol: e9, version: n9, relayUrl: t6, sdkVersion: r8, auth: o9, projectId: s7, useOnCloseEvent: i7, bundleId: d7 }) {
    const l9 = t6.split("?"), c9 = Me(e9, n9, r8), u7 = { auth: o9, ua: c9, projectId: s7, useOnCloseEvent: i7 || void 0, origin: d7 || void 0 }, a6 = De(l9[1] || "", u7);
    return l9[0] + "?" + a6;
  }
  function O(e9, n9) {
    return e9.filter((t6) => n9.includes(t6)).length === e9.length;
  }
  function rt(e9) {
    return Object.fromEntries(e9.entries());
  }
  function ot(e9) {
    return new Map(Object.entries(e9));
  }
  function at(e9 = import_time2.FIVE_MINUTES, n9) {
    const t6 = (0, import_time2.toMiliseconds)(e9 || import_time2.FIVE_MINUTES);
    let r8, o9, s7;
    return { resolve: (i7) => {
      s7 && r8 && (clearTimeout(s7), r8(i7));
    }, reject: (i7) => {
      s7 && o9 && (clearTimeout(s7), o9(i7));
    }, done: () => new Promise((i7, d7) => {
      s7 = setTimeout(() => {
        d7(new Error(n9));
      }, t6), r8 = i7, o9 = d7;
    }) };
  }
  function ut(e9, n9, t6) {
    return new Promise(async (r8, o9) => {
      const s7 = setTimeout(() => o9(new Error(t6)), n9);
      try {
        const i7 = await e9;
        r8(i7);
      } catch (i7) {
        o9(i7);
      }
      clearTimeout(s7);
    });
  }
  function re(e9, n9) {
    if (typeof n9 == "string" && n9.startsWith(`${e9}:`))
      return n9;
    if (e9.toLowerCase() === "topic") {
      if (typeof n9 != "string")
        throw new Error('Value must be "string" for expirer target type: topic');
      return `topic:${n9}`;
    } else if (e9.toLowerCase() === "id") {
      if (typeof n9 != "number")
        throw new Error('Value must be "number" for expirer target type: id');
      return `id:${n9}`;
    }
    throw new Error(`Unknown expirer target type: ${e9}`);
  }
  function lt(e9) {
    return re("topic", e9);
  }
  function dt(e9) {
    return re("id", e9);
  }
  function ft(e9) {
    const [n9, t6] = e9.split(":"), r8 = { id: void 0, topic: void 0 };
    if (n9 === "topic" && typeof t6 == "string")
      r8.topic = t6;
    else if (n9 === "id" && Number.isInteger(Number(t6)))
      r8.id = Number(t6);
    else
      throw new Error(`Invalid target, expected id:number or topic:string, got ${n9}:${t6}`);
    return r8;
  }
  function pt(e9, n9) {
    return (0, import_time2.fromMiliseconds)((n9 || Date.now()) + (0, import_time2.toMiliseconds)(e9));
  }
  function mt(e9) {
    return Date.now() >= (0, import_time2.toMiliseconds)(e9);
  }
  function yt(e9, n9) {
    return `${e9}${n9 ? `:${n9}` : ""}`;
  }
  function S2(e9 = [], n9 = []) {
    return [.../* @__PURE__ */ new Set([...e9, ...n9])];
  }
  async function ht({ id: e9, topic: n9, wcDeepLink: t6 }) {
    try {
      if (!t6)
        return;
      const r8 = typeof t6 == "string" ? JSON.parse(t6) : t6;
      let o9 = r8?.href;
      if (typeof o9 != "string")
        return;
      o9.endsWith("/") && (o9 = o9.slice(0, -1));
      const s7 = `${o9}/wc?requestId=${e9}&sessionTopic=${n9}`, i7 = T();
      i7 === m.browser ? s7.startsWith("https://") ? window.open(s7, "_blank", "noreferrer noopener") : window.open(s7, "_self", "noreferrer noopener") : i7 === m.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(s7);
    } catch (r8) {
      console.error(r8);
    }
  }
  async function gt(e9, n9) {
    try {
      return await e9.getItem(n9) || (D() ? localStorage.getItem(n9) : void 0);
    } catch (t6) {
      console.error(t6);
    }
  }
  function vt(e9) {
    return e9?.relay || { protocol: Fe };
  }
  function Et(e9) {
    const n9 = RELAY_JSONRPC[e9];
    if (typeof n9 > "u")
      throw new Error(`Relay Protocol not supported: ${e9}`);
    return n9;
  }
  function Be(e9, n9 = "-") {
    const t6 = {}, r8 = "relay" + n9;
    return Object.keys(e9).forEach((o9) => {
      if (o9.startsWith(r8)) {
        const s7 = o9.replace(r8, ""), i7 = e9[o9];
        t6[s7] = i7;
      }
    }), t6;
  }
  function wt2(e9) {
    e9 = e9.includes("wc://") ? e9.replace("wc://", "") : e9, e9 = e9.includes("wc:") ? e9.replace("wc:", "") : e9;
    const n9 = e9.indexOf(":"), t6 = e9.indexOf("?") !== -1 ? e9.indexOf("?") : void 0, r8 = e9.substring(0, n9), o9 = e9.substring(n9 + 1, t6).split("@"), s7 = typeof t6 < "u" ? e9.substring(t6) : "", i7 = M.parse(s7);
    return { protocol: r8, topic: Ge(o9[0]), version: parseInt(o9[1], 10), symKey: i7.symKey, relay: Be(i7) };
  }
  function Ge(e9) {
    return e9.startsWith("//") ? e9.substring(2) : e9;
  }
  function We(e9, n9 = "-") {
    const t6 = "relay", r8 = {};
    return Object.keys(e9).forEach((o9) => {
      const s7 = t6 + n9 + o9;
      e9[o9] && (r8[s7] = e9[o9]);
    }), r8;
  }
  function It2(e9) {
    return `${e9.protocol}:${e9.topic}@${e9.version}?` + M.stringify(St2({ symKey: e9.symKey }, We(e9.relay)));
  }
  function A(e9) {
    const n9 = [];
    return e9.forEach((t6) => {
      const [r8, o9] = t6.split(":");
      n9.push(`${r8}:${o9}`);
    }), n9;
  }
  function Je(e9) {
    const n9 = [];
    return Object.values(e9).forEach((t6) => {
      n9.push(...A(t6.accounts));
    }), n9;
  }
  function Qe(e9, n9) {
    const t6 = [];
    return Object.values(e9).forEach((r8) => {
      A(r8.accounts).includes(n9) && t6.push(...r8.methods);
    }), t6;
  }
  function Ze(e9, n9) {
    const t6 = [];
    return Object.values(e9).forEach((r8) => {
      A(r8.accounts).includes(n9) && t6.push(...r8.events);
    }), t6;
  }
  function jt(e9, n9) {
    const t6 = un(e9, n9);
    if (t6)
      throw new Error(t6.message);
    const r8 = {};
    for (const [o9, s7] of Object.entries(e9))
      r8[o9] = { methods: s7.methods, events: s7.events, chains: s7.accounts.map((i7) => `${i7.split(":")[0]}:${i7.split(":")[1]}`) };
    return r8;
  }
  function oe2(e9) {
    return e9.includes(":");
  }
  function Xe2(e9) {
    return oe2(e9) ? e9.split(":")[0] : e9;
  }
  function N(e9, n9) {
    const { message: t6, code: r8 } = nn[e9];
    return { message: n9 ? `${t6} ${n9}` : t6, code: r8 };
  }
  function U(e9, n9) {
    const { message: t6, code: r8 } = en[e9];
    return { message: n9 ? `${t6} ${n9}` : t6, code: r8 };
  }
  function k(e9, n9) {
    return Array.isArray(e9) ? typeof n9 < "u" && e9.length ? e9.every(n9) : true : false;
  }
  function B2(e9) {
    return Object.getPrototypeOf(e9) === Object.prototype && Object.keys(e9).length;
  }
  function w(e9) {
    return typeof e9 > "u";
  }
  function h(e9, n9) {
    return n9 && w(e9) ? true : typeof e9 == "string" && !!e9.trim().length;
  }
  function G(e9, n9) {
    return n9 && w(e9) ? true : typeof e9 == "number" && !isNaN(e9);
  }
  function Dt(e9, n9) {
    const { requiredNamespaces: t6 } = n9, r8 = Object.keys(e9.namespaces), o9 = Object.keys(t6);
    let s7 = true;
    return O(o9, r8) ? (r8.forEach((i7) => {
      const { accounts: d7, methods: l9, events: c9 } = e9.namespaces[i7], u7 = A(d7), a6 = t6[i7];
      (!O(L(i7, a6), u7) || !O(a6.methods, l9) || !O(a6.events, c9)) && (s7 = false);
    }), s7) : false;
  }
  function V2(e9) {
    return h(e9, false) && e9.includes(":") ? e9.split(":").length === 2 : false;
  }
  function tn(e9) {
    if (h(e9, false) && e9.includes(":")) {
      const n9 = e9.split(":");
      if (n9.length === 3) {
        const t6 = n9[0] + ":" + n9[1];
        return !!n9[2] && V2(t6);
      }
    }
    return false;
  }
  function kt(e9) {
    if (h(e9, false))
      try {
        return typeof new URL(e9) < "u";
      } catch {
        return false;
      }
    return false;
  }
  function Vt(e9) {
    var n9;
    return (n9 = e9?.proposer) == null ? void 0 : n9.publicKey;
  }
  function Mt(e9) {
    return e9?.topic;
  }
  function Kt(e9, n9) {
    let t6 = null;
    return h(e9?.publicKey, false) || (t6 = N("MISSING_OR_INVALID", `${n9} controller public key should be a string`)), t6;
  }
  function ie(e9) {
    let n9 = true;
    return k(e9) ? e9.length && (n9 = e9.every((t6) => h(t6, false))) : n9 = false, n9;
  }
  function rn(e9, n9, t6) {
    let r8 = null;
    return k(n9) && n9.length ? n9.forEach((o9) => {
      r8 || V2(o9) || (r8 = U("UNSUPPORTED_CHAINS", `${t6}, chain ${o9} should be a string and conform to "namespace:chainId" format`));
    }) : V2(e9) || (r8 = U("UNSUPPORTED_CHAINS", `${t6}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), r8;
  }
  function on(e9, n9, t6) {
    let r8 = null;
    return Object.entries(e9).forEach(([o9, s7]) => {
      if (r8)
        return;
      const i7 = rn(o9, L(o9, s7), `${n9} ${t6}`);
      i7 && (r8 = i7);
    }), r8;
  }
  function sn(e9, n9) {
    let t6 = null;
    return k(e9) ? e9.forEach((r8) => {
      t6 || tn(r8) || (t6 = U("UNSUPPORTED_ACCOUNTS", `${n9}, account ${r8} should be a string and conform to "namespace:chainId:address" format`));
    }) : t6 = U("UNSUPPORTED_ACCOUNTS", `${n9}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), t6;
  }
  function cn(e9, n9) {
    let t6 = null;
    return Object.values(e9).forEach((r8) => {
      if (t6)
        return;
      const o9 = sn(r8?.accounts, `${n9} namespace`);
      o9 && (t6 = o9);
    }), t6;
  }
  function an(e9, n9) {
    let t6 = null;
    return ie(e9?.methods) ? ie(e9?.events) || (t6 = U("UNSUPPORTED_EVENTS", `${n9}, events should be an array of strings or empty array for no events`)) : t6 = U("UNSUPPORTED_METHODS", `${n9}, methods should be an array of strings or empty array for no methods`), t6;
  }
  function ce(e9, n9) {
    let t6 = null;
    return Object.values(e9).forEach((r8) => {
      if (t6)
        return;
      const o9 = an(r8, `${n9}, namespace`);
      o9 && (t6 = o9);
    }), t6;
  }
  function Lt(e9, n9, t6) {
    let r8 = null;
    if (e9 && B2(e9)) {
      const o9 = ce(e9, n9);
      o9 && (r8 = o9);
      const s7 = on(e9, n9, t6);
      s7 && (r8 = s7);
    } else
      r8 = N("MISSING_OR_INVALID", `${n9}, ${t6} should be an object with data`);
    return r8;
  }
  function un(e9, n9) {
    let t6 = null;
    if (e9 && B2(e9)) {
      const r8 = ce(e9, n9);
      r8 && (t6 = r8);
      const o9 = cn(e9, n9);
      o9 && (t6 = o9);
    } else
      t6 = N("MISSING_OR_INVALID", `${n9}, namespaces should be an object with data`);
    return t6;
  }
  function ln(e9) {
    return h(e9.protocol, true);
  }
  function xt(e9, n9) {
    let t6 = false;
    return n9 && !e9 ? t6 = true : e9 && k(e9) && e9.length && e9.forEach((r8) => {
      t6 = ln(r8);
    }), t6;
  }
  function Ft(e9) {
    return typeof e9 == "number";
  }
  function Ht(e9) {
    return typeof e9 < "u" && typeof e9 !== null;
  }
  function qt(e9) {
    return !(!e9 || typeof e9 != "object" || !e9.code || !G(e9.code, false) || !e9.message || !h(e9.message, false));
  }
  function Bt(e9) {
    return !(w(e9) || !h(e9.method, false));
  }
  function Gt(e9) {
    return !(w(e9) || w(e9.result) && w(e9.error) || !G(e9.id, false) || !h(e9.jsonrpc, false));
  }
  function Wt(e9) {
    return !(w(e9) || !h(e9.name, false));
  }
  function zt(e9, n9) {
    return !(!V2(n9) || !Je(e9).includes(n9));
  }
  function Yt(e9, n9, t6) {
    return h(t6, false) ? Qe(e9, n9).includes(t6) : false;
  }
  function Jt(e9, n9, t6) {
    return h(t6, false) ? Ze(e9, n9).includes(t6) : false;
  }
  function dn(e9, n9, t6) {
    let r8 = null;
    const o9 = Qt(e9), s7 = Zt(n9), i7 = Object.keys(o9), d7 = Object.keys(s7), l9 = fn(Object.keys(e9)), c9 = fn(Object.keys(n9)), u7 = l9.filter((a6) => !c9.includes(a6));
    return u7.length && (r8 = N("NON_CONFORMING_NAMESPACES", `${t6} namespaces keys don't satisfy requiredNamespaces.
      Required: ${u7.toString()}
      Received: ${Object.keys(n9).toString()}`)), O(i7, d7) || (r8 = N("NON_CONFORMING_NAMESPACES", `${t6} namespaces chains don't satisfy required namespaces.
      Required: ${i7.toString()}
      Approved: ${d7.toString()}`)), Object.keys(n9).forEach((a6) => {
      if (!a6.includes(":") || r8)
        return;
      const b7 = A(n9[a6].accounts);
      b7.includes(a6) || (r8 = N("NON_CONFORMING_NAMESPACES", `${t6} namespaces accounts don't satisfy namespace accounts for ${a6}
        Required: ${a6}
        Approved: ${b7.toString()}`));
    }), i7.forEach((a6) => {
      r8 || (O(o9[a6].methods, s7[a6].methods) ? O(o9[a6].events, s7[a6].events) || (r8 = N("NON_CONFORMING_NAMESPACES", `${t6} namespaces events don't satisfy namespace events for ${a6}`)) : r8 = N("NON_CONFORMING_NAMESPACES", `${t6} namespaces methods don't satisfy namespace methods for ${a6}`));
    }), r8;
  }
  function Qt(e9) {
    const n9 = {};
    return Object.keys(e9).forEach((t6) => {
      var r8;
      t6.includes(":") ? n9[t6] = e9[t6] : (r8 = e9[t6].chains) == null || r8.forEach((o9) => {
        n9[o9] = { methods: e9[t6].methods, events: e9[t6].events };
      });
    }), n9;
  }
  function fn(e9) {
    return [...new Set(e9.map((n9) => n9.includes(":") ? n9.split(":")[0] : n9))];
  }
  function Zt(e9) {
    const n9 = {};
    return Object.keys(e9).forEach((t6) => {
      if (t6.includes(":"))
        n9[t6] = e9[t6];
      else {
        const r8 = A(e9[t6].accounts);
        r8?.forEach((o9) => {
          n9[o9] = { accounts: e9[t6].accounts.filter((s7) => s7.includes(`${o9}:`)), methods: e9[t6].methods, events: e9[t6].events };
        });
      }
    }), n9;
  }
  function Xt(e9, n9) {
    return G(e9, false) && e9 <= n9.max && e9 >= n9.min;
  }
  function er() {
    const e9 = T();
    return new Promise((n9) => {
      switch (e9) {
        case m.browser:
          n9(pn());
          break;
        case m.reactNative:
          n9(mn());
          break;
        case m.node:
          n9(yn());
          break;
        default:
          n9(true);
      }
    });
  }
  function pn() {
    return D() && navigator?.onLine;
  }
  async function mn() {
    if (C() && typeof global < "u" && global != null && global.NetInfo) {
      const e9 = await (global == null ? void 0 : global.NetInfo.fetch());
      return e9?.isConnected;
    }
    return true;
  }
  function yn() {
    return true;
  }
  function nr(e9) {
    switch (T()) {
      case m.browser:
        hn(e9);
        break;
      case m.reactNative:
        gn(e9);
        break;
      case m.node:
        break;
    }
  }
  function hn(e9) {
    !C() && D() && (window.addEventListener("online", () => e9(true)), window.addEventListener("offline", () => e9(false)));
  }
  function gn(e9) {
    C() && typeof global < "u" && global != null && global.NetInfo && global?.NetInfo.addEventListener((n9) => e9(n9?.isConnected));
  }
  var import_chacha20poly13052, import_hkdf2, import_random2, import_sha2562, fe2, import_time2, import_window_getters2, import_window_metadata2, M, K, J, p, F, H, Q, _, Dn, Ie, Z, X, Bn, Ae, Gn, Wn, Ue, _e, Ce, m, $e, Fe, bt, He, Nt, Ot2, qe, St2, en, nn, ae, tr;
  var init_index_es = __esm({
    "node_modules/@walletconnect/utils/dist/index.es.js"() {
      import_chacha20poly13052 = __toESM(require_chacha20poly1305());
      import_hkdf2 = __toESM(require_hkdf());
      import_random2 = __toESM(require_random());
      import_sha2562 = __toESM(require_sha256());
      fe2 = __toESM(require_x25519());
      init_src2();
      init_es();
      import_time2 = __toESM(require_cjs());
      import_window_getters2 = __toESM(require_cjs2());
      import_window_metadata2 = __toESM(require_cjs3());
      M = __toESM(require_query_string2());
      init_esm();
      K = ":";
      J = "base10";
      p = "base16";
      F = "base64pad";
      H = "utf8";
      Q = 0;
      _ = 1;
      Dn = 0;
      Ie = 1;
      Z = 12;
      X = 32;
      Bn = Object.defineProperty;
      Ae = Object.getOwnPropertySymbols;
      Gn = Object.prototype.hasOwnProperty;
      Wn = Object.prototype.propertyIsEnumerable;
      Ue = (e9, n9, t6) => n9 in e9 ? Bn(e9, n9, { enumerable: true, configurable: true, writable: true, value: t6 }) : e9[n9] = t6;
      _e = (e9, n9) => {
        for (var t6 in n9 || (n9 = {}))
          Gn.call(n9, t6) && Ue(e9, t6, n9[t6]);
        if (Ae)
          for (var t6 of Ae(n9))
            Wn.call(n9, t6) && Ue(e9, t6, n9[t6]);
        return e9;
      };
      Ce = "ReactNative";
      m = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" };
      $e = "js";
      Fe = "irn";
      bt = Object.defineProperty;
      He = Object.getOwnPropertySymbols;
      Nt = Object.prototype.hasOwnProperty;
      Ot2 = Object.prototype.propertyIsEnumerable;
      qe = (e9, n9, t6) => n9 in e9 ? bt(e9, n9, { enumerable: true, configurable: true, writable: true, value: t6 }) : e9[n9] = t6;
      St2 = (e9, n9) => {
        for (var t6 in n9 || (n9 = {}))
          Nt.call(n9, t6) && qe(e9, t6, n9[t6]);
        if (He)
          for (var t6 of He(n9))
            Ot2.call(n9, t6) && qe(e9, t6, n9[t6]);
        return e9;
      };
      en = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } };
      nn = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
      ae = {};
      tr = class {
        static get(n9) {
          return ae[n9];
        }
        static set(n9, t6) {
          ae[n9] = t6;
        }
        static delete(n9) {
          delete ae[n9];
        }
      };
    }
  });

  // node_modules/destr/dist/index.mjs
  function jsonParseTransform(key2, value) {
    if (key2 === "__proto__" || key2 === "constructor" && value && typeof value === "object" && "prototype" in value) {
      warnKeyDropped(key2);
      return;
    }
    return value;
  }
  function warnKeyDropped(key2) {
    console.warn(`[destr] Dropping "${key2}" key to prevent prototype pollution.`);
  }
  function destr(value, options2 = {}) {
    if (typeof value !== "string") {
      return value;
    }
    const _value = value.trim();
    if (
      // eslint-disable-next-line unicorn/prefer-at
      value[0] === '"' && value.at(-1) === '"' && !value.includes("\\")
    ) {
      return _value.slice(1, -1);
    }
    if (_value.length <= 9) {
      const _lval = _value.toLowerCase();
      if (_lval === "true") {
        return true;
      }
      if (_lval === "false") {
        return false;
      }
      if (_lval === "undefined") {
        return void 0;
      }
      if (_lval === "null") {
        return null;
      }
      if (_lval === "nan") {
        return Number.NaN;
      }
      if (_lval === "infinity") {
        return Number.POSITIVE_INFINITY;
      }
      if (_lval === "-infinity") {
        return Number.NEGATIVE_INFINITY;
      }
    }
    if (!JsonSigRx.test(value)) {
      if (options2.strict) {
        throw new SyntaxError("[destr] Invalid JSON");
      }
      return value;
    }
    try {
      if (suspectProtoRx.test(value) || suspectConstructorRx.test(value)) {
        if (options2.strict) {
          throw new Error("[destr] Possible prototype pollution");
        }
        return JSON.parse(value, jsonParseTransform);
      }
      return JSON.parse(value);
    } catch (error) {
      if (options2.strict) {
        throw error;
      }
      return value;
    }
  }
  var suspectProtoRx, suspectConstructorRx, JsonSigRx;
  var init_dist2 = __esm({
    "node_modules/destr/dist/index.mjs"() {
      suspectProtoRx = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/;
      suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
      JsonSigRx = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
    }
  });

  // node_modules/unstorage/dist/shared/unstorage.8581f561.mjs
  function wrapToPromise(value) {
    if (!value || typeof value.then !== "function") {
      return Promise.resolve(value);
    }
    return value;
  }
  function asyncCall(function_, ...arguments_) {
    try {
      return wrapToPromise(function_(...arguments_));
    } catch (error) {
      return Promise.reject(error);
    }
  }
  function isPrimitive(value) {
    const type = typeof value;
    return value === null || type !== "object" && type !== "function";
  }
  function isPureObject(value) {
    const proto = Object.getPrototypeOf(value);
    return !proto || proto.isPrototypeOf(Object);
  }
  function stringify4(value) {
    if (isPrimitive(value)) {
      return String(value);
    }
    if (isPureObject(value) || Array.isArray(value)) {
      return JSON.stringify(value);
    }
    if (typeof value.toJSON === "function") {
      return stringify4(value.toJSON());
    }
    throw new Error("[unstorage] Cannot stringify value!");
  }
  function checkBufferSupport() {
    if (typeof Buffer === void 0) {
      throw new TypeError("[unstorage] Buffer is not supported!");
    }
  }
  function serializeRaw(value) {
    if (typeof value === "string") {
      return value;
    }
    checkBufferSupport();
    const base642 = Buffer.from(value).toString("base64");
    return BASE64_PREFIX + base642;
  }
  function deserializeRaw(value) {
    if (typeof value !== "string") {
      return value;
    }
    if (!value.startsWith(BASE64_PREFIX)) {
      return value;
    }
    checkBufferSupport();
    return Buffer.from(value.slice(BASE64_PREFIX.length), "base64");
  }
  function normalizeKey(key2) {
    if (!key2) {
      return "";
    }
    return key2.split("?")[0].replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "");
  }
  function joinKeys(...keys2) {
    return normalizeKey(keys2.join(":"));
  }
  function normalizeBaseKey(base4) {
    base4 = normalizeKey(base4);
    return base4 ? base4 + ":" : "";
  }
  var BASE64_PREFIX;
  var init_unstorage_8581f561 = __esm({
    "node_modules/unstorage/dist/shared/unstorage.8581f561.mjs"() {
      BASE64_PREFIX = "base64:";
    }
  });

  // node_modules/unstorage/dist/index.mjs
  function defineDriver(factory) {
    return factory;
  }
  function createStorage2(options2 = {}) {
    const context = {
      mounts: { "": options2.driver || memory() },
      mountpoints: [""],
      watching: false,
      watchListeners: [],
      unwatch: {}
    };
    const getMount = (key2) => {
      for (const base4 of context.mountpoints) {
        if (key2.startsWith(base4)) {
          return {
            base: base4,
            relativeKey: key2.slice(base4.length),
            driver: context.mounts[base4]
          };
        }
      }
      return {
        base: "",
        relativeKey: key2,
        driver: context.mounts[""]
      };
    };
    const getMounts = (base4, includeParent) => {
      return context.mountpoints.filter(
        (mountpoint) => mountpoint.startsWith(base4) || includeParent && base4.startsWith(mountpoint)
      ).map((mountpoint) => ({
        relativeBase: base4.length > mountpoint.length ? base4.slice(mountpoint.length) : void 0,
        mountpoint,
        driver: context.mounts[mountpoint]
      }));
    };
    const onChange = (event, key2) => {
      if (!context.watching) {
        return;
      }
      key2 = normalizeKey(key2);
      for (const listener of context.watchListeners) {
        listener(event, key2);
      }
    };
    const startWatch = async () => {
      if (context.watching) {
        return;
      }
      context.watching = true;
      for (const mountpoint in context.mounts) {
        context.unwatch[mountpoint] = await watch(
          context.mounts[mountpoint],
          onChange,
          mountpoint
        );
      }
    };
    const stopWatch = async () => {
      if (!context.watching) {
        return;
      }
      for (const mountpoint in context.unwatch) {
        await context.unwatch[mountpoint]();
      }
      context.unwatch = {};
      context.watching = false;
    };
    const runBatch = (items, commonOptions, cb) => {
      const batches = /* @__PURE__ */ new Map();
      const getBatch = (mount) => {
        let batch = batches.get(mount.base);
        if (!batch) {
          batch = {
            driver: mount.driver,
            base: mount.base,
            items: []
          };
          batches.set(mount.base, batch);
        }
        return batch;
      };
      for (const item of items) {
        const isStringItem = typeof item === "string";
        const key2 = normalizeKey(isStringItem ? item : item.key);
        const value = isStringItem ? void 0 : item.value;
        const options22 = isStringItem || !item.options ? commonOptions : { ...commonOptions, ...item.options };
        const mount = getMount(key2);
        getBatch(mount).items.push({
          key: key2,
          value,
          relativeKey: mount.relativeKey,
          options: options22
        });
      }
      return Promise.all([...batches.values()].map((batch) => cb(batch))).then(
        (r8) => r8.flat()
      );
    };
    const storage = {
      // Item
      hasItem(key2, opts = {}) {
        key2 = normalizeKey(key2);
        const { relativeKey, driver } = getMount(key2);
        return asyncCall(driver.hasItem, relativeKey, opts);
      },
      getItem(key2, opts = {}) {
        key2 = normalizeKey(key2);
        const { relativeKey, driver } = getMount(key2);
        return asyncCall(driver.getItem, relativeKey, opts).then(
          (value) => destr(value)
        );
      },
      getItems(items, commonOptions) {
        return runBatch(items, commonOptions, (batch) => {
          if (batch.driver.getItems) {
            return asyncCall(
              batch.driver.getItems,
              batch.items.map((item) => ({
                key: item.relativeKey,
                options: item.options
              })),
              commonOptions
            ).then(
              (r8) => r8.map((item) => ({
                key: joinKeys(batch.base, item.key),
                value: destr(item.value)
              }))
            );
          }
          return Promise.all(
            batch.items.map((item) => {
              return asyncCall(
                batch.driver.getItem,
                item.relativeKey,
                item.options
              ).then((value) => ({
                key: item.key,
                value: destr(value)
              }));
            })
          );
        });
      },
      getItemRaw(key2, opts = {}) {
        key2 = normalizeKey(key2);
        const { relativeKey, driver } = getMount(key2);
        if (driver.getItemRaw) {
          return asyncCall(driver.getItemRaw, relativeKey, opts);
        }
        return asyncCall(driver.getItem, relativeKey, opts).then(
          (value) => deserializeRaw(value)
        );
      },
      async setItem(key2, value, opts = {}) {
        if (value === void 0) {
          return storage.removeItem(key2);
        }
        key2 = normalizeKey(key2);
        const { relativeKey, driver } = getMount(key2);
        if (!driver.setItem) {
          return;
        }
        await asyncCall(driver.setItem, relativeKey, stringify4(value), opts);
        if (!driver.watch) {
          onChange("update", key2);
        }
      },
      async setItems(items, commonOptions) {
        await runBatch(items, commonOptions, async (batch) => {
          if (batch.driver.setItems) {
            await asyncCall(
              batch.driver.setItems,
              batch.items.map((item) => ({
                key: item.relativeKey,
                value: stringify4(item.value),
                options: item.options
              })),
              commonOptions
            );
          }
          if (!batch.driver.setItem) {
            return;
          }
          await Promise.all(
            batch.items.map((item) => {
              return asyncCall(
                batch.driver.setItem,
                item.relativeKey,
                stringify4(item.value),
                item.options
              );
            })
          );
        });
      },
      async setItemRaw(key2, value, opts = {}) {
        if (value === void 0) {
          return storage.removeItem(key2, opts);
        }
        key2 = normalizeKey(key2);
        const { relativeKey, driver } = getMount(key2);
        if (driver.setItemRaw) {
          await asyncCall(driver.setItemRaw, relativeKey, value, opts);
        } else if (driver.setItem) {
          await asyncCall(driver.setItem, relativeKey, serializeRaw(value), opts);
        } else {
          return;
        }
        if (!driver.watch) {
          onChange("update", key2);
        }
      },
      async removeItem(key2, opts = {}) {
        if (typeof opts === "boolean") {
          opts = { removeMeta: opts };
        }
        key2 = normalizeKey(key2);
        const { relativeKey, driver } = getMount(key2);
        if (!driver.removeItem) {
          return;
        }
        await asyncCall(driver.removeItem, relativeKey, opts);
        if (opts.removeMeta || opts.removeMata) {
          await asyncCall(driver.removeItem, relativeKey + "$", opts);
        }
        if (!driver.watch) {
          onChange("remove", key2);
        }
      },
      // Meta
      async getMeta(key2, opts = {}) {
        if (typeof opts === "boolean") {
          opts = { nativeOnly: opts };
        }
        key2 = normalizeKey(key2);
        const { relativeKey, driver } = getMount(key2);
        const meta = /* @__PURE__ */ Object.create(null);
        if (driver.getMeta) {
          Object.assign(meta, await asyncCall(driver.getMeta, relativeKey, opts));
        }
        if (!opts.nativeOnly) {
          const value = await asyncCall(
            driver.getItem,
            relativeKey + "$",
            opts
          ).then((value_) => destr(value_));
          if (value && typeof value === "object") {
            if (typeof value.atime === "string") {
              value.atime = new Date(value.atime);
            }
            if (typeof value.mtime === "string") {
              value.mtime = new Date(value.mtime);
            }
            Object.assign(meta, value);
          }
        }
        return meta;
      },
      setMeta(key2, value, opts = {}) {
        return this.setItem(key2 + "$", value, opts);
      },
      removeMeta(key2, opts = {}) {
        return this.removeItem(key2 + "$", opts);
      },
      // Keys
      async getKeys(base4, opts = {}) {
        base4 = normalizeBaseKey(base4);
        const mounts = getMounts(base4, true);
        let maskedMounts = [];
        const allKeys = [];
        for (const mount of mounts) {
          const rawKeys = await asyncCall(
            mount.driver.getKeys,
            mount.relativeBase,
            opts
          );
          const keys2 = rawKeys.map((key2) => mount.mountpoint + normalizeKey(key2)).filter((key2) => !maskedMounts.some((p8) => key2.startsWith(p8)));
          allKeys.push(...keys2);
          maskedMounts = [
            mount.mountpoint,
            ...maskedMounts.filter((p8) => !p8.startsWith(mount.mountpoint))
          ];
        }
        return base4 ? allKeys.filter((key2) => key2.startsWith(base4) && !key2.endsWith("$")) : allKeys.filter((key2) => !key2.endsWith("$"));
      },
      // Utils
      async clear(base4, opts = {}) {
        base4 = normalizeBaseKey(base4);
        await Promise.all(
          getMounts(base4, false).map(async (m6) => {
            if (m6.driver.clear) {
              return asyncCall(m6.driver.clear, m6.relativeBase, opts);
            }
            if (m6.driver.removeItem) {
              const keys2 = await m6.driver.getKeys(m6.relativeBase || "", opts);
              return Promise.all(
                keys2.map((key2) => m6.driver.removeItem(key2, opts))
              );
            }
          })
        );
      },
      async dispose() {
        await Promise.all(
          Object.values(context.mounts).map((driver) => dispose(driver))
        );
      },
      async watch(callback) {
        await startWatch();
        context.watchListeners.push(callback);
        return async () => {
          context.watchListeners = context.watchListeners.filter(
            (listener) => listener !== callback
          );
          if (context.watchListeners.length === 0) {
            await stopWatch();
          }
        };
      },
      async unwatch() {
        context.watchListeners = [];
        await stopWatch();
      },
      // Mount
      mount(base4, driver) {
        base4 = normalizeBaseKey(base4);
        if (base4 && context.mounts[base4]) {
          throw new Error(`already mounted at ${base4}`);
        }
        if (base4) {
          context.mountpoints.push(base4);
          context.mountpoints.sort((a6, b7) => b7.length - a6.length);
        }
        context.mounts[base4] = driver;
        if (context.watching) {
          Promise.resolve(watch(driver, onChange, base4)).then((unwatcher) => {
            context.unwatch[base4] = unwatcher;
          }).catch(console.error);
        }
        return storage;
      },
      async unmount(base4, _dispose = true) {
        base4 = normalizeBaseKey(base4);
        if (!base4 || !context.mounts[base4]) {
          return;
        }
        if (context.watching && base4 in context.unwatch) {
          context.unwatch[base4]();
          delete context.unwatch[base4];
        }
        if (_dispose) {
          await dispose(context.mounts[base4]);
        }
        context.mountpoints = context.mountpoints.filter((key2) => key2 !== base4);
        delete context.mounts[base4];
      },
      getMount(key2 = "") {
        key2 = normalizeKey(key2) + ":";
        const m6 = getMount(key2);
        return {
          driver: m6.driver,
          base: m6.base
        };
      },
      getMounts(base4 = "", opts = {}) {
        base4 = normalizeKey(base4);
        const mounts = getMounts(base4, opts.parents);
        return mounts.map((m6) => ({
          driver: m6.driver,
          base: m6.mountpoint
        }));
      }
    };
    return storage;
  }
  function watch(driver, onChange, base4) {
    return driver.watch ? driver.watch((event, key2) => onChange(event, base4 + key2)) : () => {
    };
  }
  async function dispose(driver) {
    if (typeof driver.dispose === "function") {
      await asyncCall(driver.dispose);
    }
  }
  var DRIVER_NAME, memory;
  var init_dist3 = __esm({
    "node_modules/unstorage/dist/index.mjs"() {
      init_dist2();
      init_unstorage_8581f561();
      DRIVER_NAME = "memory";
      memory = defineDriver(() => {
        const data2 = /* @__PURE__ */ new Map();
        return {
          name: DRIVER_NAME,
          options: {},
          hasItem(key2) {
            return data2.has(key2);
          },
          getItem(key2) {
            return data2.get(key2) ?? null;
          },
          getItemRaw(key2) {
            return data2.get(key2) ?? null;
          },
          setItem(key2, value) {
            data2.set(key2, value);
          },
          setItemRaw(key2, value) {
            data2.set(key2, value);
          },
          removeItem(key2) {
            data2.delete(key2);
          },
          getKeys() {
            return Array.from(data2.keys());
          },
          clear() {
            data2.clear();
          },
          dispose() {
            data2.clear();
          }
        };
      });
    }
  });

  // node_modules/idb-keyval/dist/index.js
  function promisifyRequest(request) {
    return new Promise((resolve, reject) => {
      request.oncomplete = request.onsuccess = () => resolve(request.result);
      request.onabort = request.onerror = () => reject(request.error);
    });
  }
  function createStore2(dbName, storeName) {
    const request = indexedDB.open(dbName);
    request.onupgradeneeded = () => request.result.createObjectStore(storeName);
    const dbp = promisifyRequest(request);
    return (txMode, callback) => dbp.then((db) => callback(db.transaction(storeName, txMode).objectStore(storeName)));
  }
  function defaultGetStore() {
    if (!defaultGetStoreFunc) {
      defaultGetStoreFunc = createStore2("keyval-store", "keyval");
    }
    return defaultGetStoreFunc;
  }
  function get(key2, customStore = defaultGetStore()) {
    return customStore("readonly", (store) => promisifyRequest(store.get(key2)));
  }
  function set(key2, value, customStore = defaultGetStore()) {
    return customStore("readwrite", (store) => {
      store.put(value, key2);
      return promisifyRequest(store.transaction);
    });
  }
  function del(key2, customStore = defaultGetStore()) {
    return customStore("readwrite", (store) => {
      store.delete(key2);
      return promisifyRequest(store.transaction);
    });
  }
  function clear(customStore = defaultGetStore()) {
    return customStore("readwrite", (store) => {
      store.clear();
      return promisifyRequest(store.transaction);
    });
  }
  function eachCursor(store, callback) {
    store.openCursor().onsuccess = function() {
      if (!this.result)
        return;
      callback(this.result);
      this.result.continue();
    };
    return promisifyRequest(store.transaction);
  }
  function keys(customStore = defaultGetStore()) {
    return customStore("readonly", (store) => {
      if (store.getAllKeys) {
        return promisifyRequest(store.getAllKeys());
      }
      const items = [];
      return eachCursor(store, (cursor) => items.push(cursor.key)).then(() => items);
    });
  }
  var defaultGetStoreFunc;
  var init_dist4 = __esm({
    "node_modules/idb-keyval/dist/index.js"() {
    }
  });

  // node_modules/@walletconnect/safe-json/dist/esm/index.js
  function safeJsonParse(value) {
    if (typeof value !== "string") {
      throw new Error(`Cannot safe json parse value of type ${typeof value}`);
    }
    try {
      return JSONParse(value);
    } catch (_a2) {
      return value;
    }
  }
  function safeJsonStringify(value) {
    return typeof value === "string" ? value : JSONStringify(value) || "";
  }
  var JSONStringify, JSONParse;
  var init_esm2 = __esm({
    "node_modules/@walletconnect/safe-json/dist/esm/index.js"() {
      JSONStringify = (data2) => JSON.stringify(data2, (_8, value) => typeof value === "bigint" ? value.toString() + "n" : value);
      JSONParse = (json) => {
        const numbersBiggerThanMaxInt = /([\[:])?(\d{17,}|(?:[9](?:[1-9]07199254740991|0[1-9]7199254740991|00[8-9]199254740991|007[2-9]99254740991|007199[3-9]54740991|0071992[6-9]4740991|00719925[5-9]740991|007199254[8-9]40991|0071992547[5-9]0991|00719925474[1-9]991|00719925474099[2-9])))([,\}\]])/g;
        const serializedData = json.replace(numbersBiggerThanMaxInt, '$1"$2n"$3');
        return JSON.parse(serializedData, (_8, value) => {
          const isCustomFormatBigInt = typeof value === "string" && value.match(/^\d+n$/);
          if (isCustomFormatBigInt)
            return BigInt(value.substring(0, value.length - 1));
          return value;
        });
      };
    }
  });

  // node_modules/@walletconnect/keyvaluestorage/dist/index.es.js
  function k2(i7) {
    var t6;
    return [i7[0], safeJsonParse((t6 = i7[1]) != null ? t6 : "")];
  }
  var x, z, D2, E, _2, l, c, K2, N10, y, O2, j, h2;
  var init_index_es2 = __esm({
    "node_modules/@walletconnect/keyvaluestorage/dist/index.es.js"() {
      init_dist3();
      init_dist4();
      init_esm2();
      x = "idb-keyval";
      z = (i7 = {}) => {
        const t6 = i7.base && i7.base.length > 0 ? `${i7.base}:` : "", e9 = (s7) => t6 + s7;
        let n9;
        return i7.dbName && i7.storeName && (n9 = createStore2(i7.dbName, i7.storeName)), { name: x, options: i7, async hasItem(s7) {
          return !(typeof await get(e9(s7), n9) > "u");
        }, async getItem(s7) {
          return await get(e9(s7), n9) ?? null;
        }, setItem(s7, a6) {
          return set(e9(s7), a6, n9);
        }, removeItem(s7) {
          return del(e9(s7), n9);
        }, getKeys() {
          return keys(n9);
        }, clear() {
          return clear(n9);
        } };
      };
      D2 = "WALLET_CONNECT_V2_INDEXED_DB";
      E = "keyvaluestorage";
      _2 = class {
        constructor() {
          this.indexedDb = createStorage2({ driver: z({ dbName: D2, storeName: E }) });
        }
        async getKeys() {
          return this.indexedDb.getKeys();
        }
        async getEntries() {
          return (await this.indexedDb.getItems(await this.indexedDb.getKeys())).map((t6) => [t6.key, t6.value]);
        }
        async getItem(t6) {
          const e9 = await this.indexedDb.getItem(t6);
          if (e9 !== null)
            return e9;
        }
        async setItem(t6, e9) {
          await this.indexedDb.setItem(t6, safeJsonStringify(e9));
        }
        async removeItem(t6) {
          await this.indexedDb.removeItem(t6);
        }
      };
      l = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
      c = { exports: {} };
      (function() {
        let i7;
        function t6() {
        }
        i7 = t6, i7.prototype.getItem = function(e9) {
          return this.hasOwnProperty(e9) ? String(this[e9]) : null;
        }, i7.prototype.setItem = function(e9, n9) {
          this[e9] = String(n9);
        }, i7.prototype.removeItem = function(e9) {
          delete this[e9];
        }, i7.prototype.clear = function() {
          const e9 = this;
          Object.keys(e9).forEach(function(n9) {
            e9[n9] = void 0, delete e9[n9];
          });
        }, i7.prototype.key = function(e9) {
          return e9 = e9 || 0, Object.keys(this)[e9];
        }, i7.prototype.__defineGetter__("length", function() {
          return Object.keys(this).length;
        }), typeof l < "u" && l.localStorage ? c.exports = l.localStorage : typeof window < "u" && window.localStorage ? c.exports = window.localStorage : c.exports = new t6();
      })();
      K2 = class {
        constructor() {
          this.localStorage = c.exports;
        }
        async getKeys() {
          return Object.keys(this.localStorage);
        }
        async getEntries() {
          return Object.entries(this.localStorage).map(k2);
        }
        async getItem(t6) {
          const e9 = this.localStorage.getItem(t6);
          if (e9 !== null)
            return safeJsonParse(e9);
        }
        async setItem(t6, e9) {
          this.localStorage.setItem(t6, safeJsonStringify(e9));
        }
        async removeItem(t6) {
          this.localStorage.removeItem(t6);
        }
      };
      N10 = "wc_storage_version";
      y = 1;
      O2 = async (i7, t6, e9) => {
        const n9 = N10, s7 = await t6.getItem(n9);
        if (s7 && s7 >= y) {
          e9(t6);
          return;
        }
        const a6 = await i7.getKeys();
        if (!a6.length) {
          e9(t6);
          return;
        }
        const m6 = [];
        for (; a6.length; ) {
          const r8 = a6.shift();
          if (!r8)
            continue;
          const o9 = r8.toLowerCase();
          if (o9.includes("wc@") || o9.includes("walletconnect") || o9.includes("wc_") || o9.includes("wallet_connect")) {
            const f7 = await i7.getItem(r8);
            await t6.setItem(r8, f7), m6.push(r8);
          }
        }
        await t6.setItem(n9, y), e9(t6), j(i7, m6);
      };
      j = async (i7, t6) => {
        t6.length && t6.forEach(async (e9) => {
          await i7.removeItem(e9);
        });
      };
      h2 = class {
        constructor() {
          this.initialized = false, this.setInitialized = (e9) => {
            this.storage = e9, this.initialized = true;
          };
          const t6 = new K2();
          this.storage = t6;
          try {
            const e9 = new _2();
            O2(t6, e9, this.setInitialized);
          } catch {
            this.initialized = true;
          }
        }
        async getKeys() {
          return await this.initialize(), this.storage.getKeys();
        }
        async getEntries() {
          return await this.initialize(), this.storage.getEntries();
        }
        async getItem(t6) {
          return await this.initialize(), this.storage.getItem(t6);
        }
        async setItem(t6, e9) {
          return await this.initialize(), this.storage.setItem(t6, e9);
        }
        async removeItem(t6) {
          return await this.initialize(), this.storage.removeItem(t6);
        }
        async initialize() {
          this.initialized || await new Promise((t6) => {
            const e9 = setInterval(() => {
              this.initialized && (clearInterval(e9), t6());
            }, 20);
          });
        }
      };
    }
  });

  // node_modules/@walletconnect/events/dist/esm/events.js
  var IEvents;
  var init_events = __esm({
    "node_modules/@walletconnect/events/dist/esm/events.js"() {
      IEvents = class {
      };
    }
  });

  // node_modules/@walletconnect/events/dist/esm/index.js
  var esm_exports = {};
  __export(esm_exports, {
    IEvents: () => IEvents
  });
  var init_esm3 = __esm({
    "node_modules/@walletconnect/events/dist/esm/index.js"() {
      init_events();
    }
  });

  // node_modules/@walletconnect/heartbeat/dist/cjs/types/heartbeat.js
  var require_heartbeat = __commonJS({
    "node_modules/@walletconnect/heartbeat/dist/cjs/types/heartbeat.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.IHeartBeat = void 0;
      var events_1 = (init_esm3(), __toCommonJS(esm_exports));
      var IHeartBeat = class extends events_1.IEvents {
        constructor(opts) {
          super();
        }
      };
      exports.IHeartBeat = IHeartBeat;
    }
  });

  // node_modules/@walletconnect/heartbeat/dist/cjs/types/index.js
  var require_types2 = __commonJS({
    "node_modules/@walletconnect/heartbeat/dist/cjs/types/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      tslib_1.__exportStar(require_heartbeat(), exports);
    }
  });

  // node_modules/@walletconnect/heartbeat/dist/cjs/constants/heartbeat.js
  var require_heartbeat2 = __commonJS({
    "node_modules/@walletconnect/heartbeat/dist/cjs/constants/heartbeat.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.HEARTBEAT_EVENTS = exports.HEARTBEAT_INTERVAL = void 0;
      var time_1 = require_cjs();
      exports.HEARTBEAT_INTERVAL = time_1.FIVE_SECONDS;
      exports.HEARTBEAT_EVENTS = {
        pulse: "heartbeat_pulse"
      };
    }
  });

  // node_modules/@walletconnect/heartbeat/dist/cjs/constants/index.js
  var require_constants2 = __commonJS({
    "node_modules/@walletconnect/heartbeat/dist/cjs/constants/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      tslib_1.__exportStar(require_heartbeat2(), exports);
    }
  });

  // node_modules/@walletconnect/heartbeat/dist/cjs/heartbeat.js
  var require_heartbeat3 = __commonJS({
    "node_modules/@walletconnect/heartbeat/dist/cjs/heartbeat.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.HeartBeat = void 0;
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var events_1 = require_events();
      var time_1 = require_cjs();
      var types_1 = require_types2();
      var constants_1 = require_constants2();
      var HeartBeat = class extends types_1.IHeartBeat {
        constructor(opts) {
          super(opts);
          this.events = new events_1.EventEmitter();
          this.interval = constants_1.HEARTBEAT_INTERVAL;
          this.interval = (opts === null || opts === void 0 ? void 0 : opts.interval) || constants_1.HEARTBEAT_INTERVAL;
        }
        static init(opts) {
          return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const heartbeat = new HeartBeat(opts);
            yield heartbeat.init();
            return heartbeat;
          });
        }
        init() {
          return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.initialize();
          });
        }
        stop() {
          clearInterval(this.intervalRef);
        }
        on(event, listener) {
          this.events.on(event, listener);
        }
        once(event, listener) {
          this.events.once(event, listener);
        }
        off(event, listener) {
          this.events.off(event, listener);
        }
        removeListener(event, listener) {
          this.events.removeListener(event, listener);
        }
        initialize() {
          return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.intervalRef = setInterval(() => this.pulse(), time_1.toMiliseconds(this.interval));
          });
        }
        pulse() {
          this.events.emit(constants_1.HEARTBEAT_EVENTS.pulse);
        }
      };
      exports.HeartBeat = HeartBeat;
    }
  });

  // node_modules/@walletconnect/heartbeat/dist/cjs/index.js
  var require_cjs4 = __commonJS({
    "node_modules/@walletconnect/heartbeat/dist/cjs/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      tslib_1.__exportStar(require_heartbeat3(), exports);
      tslib_1.__exportStar(require_types2(), exports);
      tslib_1.__exportStar(require_constants2(), exports);
    }
  });

  // node_modules/quick-format-unescaped/index.js
  var require_quick_format_unescaped = __commonJS({
    "node_modules/quick-format-unescaped/index.js"(exports, module) {
      "use strict";
      function tryStringify(o9) {
        try {
          return JSON.stringify(o9);
        } catch (e9) {
          return '"[Circular]"';
        }
      }
      module.exports = format2;
      function format2(f7, args, opts) {
        var ss2 = opts && opts.stringify || tryStringify;
        var offset = 1;
        if (typeof f7 === "object" && f7 !== null) {
          var len = args.length + offset;
          if (len === 1)
            return f7;
          var objects = new Array(len);
          objects[0] = ss2(f7);
          for (var index2 = 1; index2 < len; index2++) {
            objects[index2] = ss2(args[index2]);
          }
          return objects.join(" ");
        }
        if (typeof f7 !== "string") {
          return f7;
        }
        var argLen = args.length;
        if (argLen === 0)
          return f7;
        var str = "";
        var a6 = 1 - offset;
        var lastPos = -1;
        var flen = f7 && f7.length || 0;
        for (var i7 = 0; i7 < flen; ) {
          if (f7.charCodeAt(i7) === 37 && i7 + 1 < flen) {
            lastPos = lastPos > -1 ? lastPos : 0;
            switch (f7.charCodeAt(i7 + 1)) {
              case 100:
              case 102:
                if (a6 >= argLen)
                  break;
                if (args[a6] == null)
                  break;
                if (lastPos < i7)
                  str += f7.slice(lastPos, i7);
                str += Number(args[a6]);
                lastPos = i7 + 2;
                i7++;
                break;
              case 105:
                if (a6 >= argLen)
                  break;
                if (args[a6] == null)
                  break;
                if (lastPos < i7)
                  str += f7.slice(lastPos, i7);
                str += Math.floor(Number(args[a6]));
                lastPos = i7 + 2;
                i7++;
                break;
              case 79:
              case 111:
              case 106:
                if (a6 >= argLen)
                  break;
                if (args[a6] === void 0)
                  break;
                if (lastPos < i7)
                  str += f7.slice(lastPos, i7);
                var type = typeof args[a6];
                if (type === "string") {
                  str += "'" + args[a6] + "'";
                  lastPos = i7 + 2;
                  i7++;
                  break;
                }
                if (type === "function") {
                  str += args[a6].name || "<anonymous>";
                  lastPos = i7 + 2;
                  i7++;
                  break;
                }
                str += ss2(args[a6]);
                lastPos = i7 + 2;
                i7++;
                break;
              case 115:
                if (a6 >= argLen)
                  break;
                if (lastPos < i7)
                  str += f7.slice(lastPos, i7);
                str += String(args[a6]);
                lastPos = i7 + 2;
                i7++;
                break;
              case 37:
                if (lastPos < i7)
                  str += f7.slice(lastPos, i7);
                str += "%";
                lastPos = i7 + 2;
                i7++;
                a6--;
                break;
            }
            ++a6;
          }
          ++i7;
        }
        if (lastPos === -1)
          return f7;
        else if (lastPos < flen) {
          str += f7.slice(lastPos);
        }
        return str;
      }
    }
  });

  // node_modules/pino/browser.js
  var require_browser2 = __commonJS({
    "node_modules/pino/browser.js"(exports, module) {
      "use strict";
      var format2 = require_quick_format_unescaped();
      module.exports = pino;
      var _console = pfGlobalThisOrFallback().console || {};
      var stdSerializers = {
        mapHttpRequest: mock,
        mapHttpResponse: mock,
        wrapRequestSerializer: passthrough,
        wrapResponseSerializer: passthrough,
        wrapErrorSerializer: passthrough,
        req: mock,
        res: mock,
        err: asErrValue
      };
      function shouldSerialize(serialize4, serializers) {
        if (Array.isArray(serialize4)) {
          const hasToFilter = serialize4.filter(function(k6) {
            return k6 !== "!stdSerializers.err";
          });
          return hasToFilter;
        } else if (serialize4 === true) {
          return Object.keys(serializers);
        }
        return false;
      }
      function pino(opts) {
        opts = opts || {};
        opts.browser = opts.browser || {};
        const transmit2 = opts.browser.transmit;
        if (transmit2 && typeof transmit2.send !== "function") {
          throw Error("pino: transmit option must have a send function");
        }
        const proto = opts.browser.write || _console;
        if (opts.browser.write)
          opts.browser.asObject = true;
        const serializers = opts.serializers || {};
        const serialize4 = shouldSerialize(opts.browser.serialize, serializers);
        let stdErrSerialize = opts.browser.serialize;
        if (Array.isArray(opts.browser.serialize) && opts.browser.serialize.indexOf("!stdSerializers.err") > -1)
          stdErrSerialize = false;
        const levels = ["error", "fatal", "warn", "info", "debug", "trace"];
        if (typeof proto === "function") {
          proto.error = proto.fatal = proto.warn = proto.info = proto.debug = proto.trace = proto;
        }
        if (opts.enabled === false)
          opts.level = "silent";
        const level = opts.level || "info";
        const logger47 = Object.create(proto);
        if (!logger47.log)
          logger47.log = noop6;
        Object.defineProperty(logger47, "levelVal", {
          get: getLevelVal
        });
        Object.defineProperty(logger47, "level", {
          get: getLevel,
          set: setLevel
        });
        const setOpts = {
          transmit: transmit2,
          serialize: serialize4,
          asObject: opts.browser.asObject,
          levels,
          timestamp: getTimeFunction(opts)
        };
        logger47.levels = pino.levels;
        logger47.level = level;
        logger47.setMaxListeners = logger47.getMaxListeners = logger47.emit = logger47.addListener = logger47.on = logger47.prependListener = logger47.once = logger47.prependOnceListener = logger47.removeListener = logger47.removeAllListeners = logger47.listeners = logger47.listenerCount = logger47.eventNames = logger47.write = logger47.flush = noop6;
        logger47.serializers = serializers;
        logger47._serialize = serialize4;
        logger47._stdErrSerialize = stdErrSerialize;
        logger47.child = child;
        if (transmit2)
          logger47._logEvent = createLogEventShape();
        function getLevelVal() {
          return this.level === "silent" ? Infinity : this.levels.values[this.level];
        }
        function getLevel() {
          return this._level;
        }
        function setLevel(level2) {
          if (level2 !== "silent" && !this.levels.values[level2]) {
            throw Error("unknown level " + level2);
          }
          this._level = level2;
          set2(setOpts, logger47, "error", "log");
          set2(setOpts, logger47, "fatal", "error");
          set2(setOpts, logger47, "warn", "error");
          set2(setOpts, logger47, "info", "log");
          set2(setOpts, logger47, "debug", "log");
          set2(setOpts, logger47, "trace", "log");
        }
        function child(bindings, childOptions) {
          if (!bindings) {
            throw new Error("missing bindings for child Pino");
          }
          childOptions = childOptions || {};
          if (serialize4 && bindings.serializers) {
            childOptions.serializers = bindings.serializers;
          }
          const childOptionsSerializers = childOptions.serializers;
          if (serialize4 && childOptionsSerializers) {
            var childSerializers = Object.assign({}, serializers, childOptionsSerializers);
            var childSerialize = opts.browser.serialize === true ? Object.keys(childSerializers) : serialize4;
            delete bindings.serializers;
            applySerializers([bindings], childSerialize, childSerializers, this._stdErrSerialize);
          }
          function Child(parent) {
            this._childLevel = (parent._childLevel | 0) + 1;
            this.error = bind2(parent, bindings, "error");
            this.fatal = bind2(parent, bindings, "fatal");
            this.warn = bind2(parent, bindings, "warn");
            this.info = bind2(parent, bindings, "info");
            this.debug = bind2(parent, bindings, "debug");
            this.trace = bind2(parent, bindings, "trace");
            if (childSerializers) {
              this.serializers = childSerializers;
              this._serialize = childSerialize;
            }
            if (transmit2) {
              this._logEvent = createLogEventShape(
                [].concat(parent._logEvent.bindings, bindings)
              );
            }
          }
          Child.prototype = this;
          return new Child(this);
        }
        return logger47;
      }
      pino.levels = {
        values: {
          fatal: 60,
          error: 50,
          warn: 40,
          info: 30,
          debug: 20,
          trace: 10
        },
        labels: {
          10: "trace",
          20: "debug",
          30: "info",
          40: "warn",
          50: "error",
          60: "fatal"
        }
      };
      pino.stdSerializers = stdSerializers;
      pino.stdTimeFunctions = Object.assign({}, { nullTime, epochTime, unixTime, isoTime });
      function set2(opts, logger47, level, fallback2) {
        const proto = Object.getPrototypeOf(logger47);
        logger47[level] = logger47.levelVal > logger47.levels.values[level] ? noop6 : proto[level] ? proto[level] : _console[level] || _console[fallback2] || noop6;
        wrap2(opts, logger47, level);
      }
      function wrap2(opts, logger47, level) {
        if (!opts.transmit && logger47[level] === noop6)
          return;
        logger47[level] = function(write) {
          return function LOG() {
            const ts2 = opts.timestamp();
            const args = new Array(arguments.length);
            const proto = Object.getPrototypeOf && Object.getPrototypeOf(this) === _console ? _console : this;
            for (var i7 = 0; i7 < args.length; i7++)
              args[i7] = arguments[i7];
            if (opts.serialize && !opts.asObject) {
              applySerializers(args, this._serialize, this.serializers, this._stdErrSerialize);
            }
            if (opts.asObject)
              write.call(proto, asObject(this, level, args, ts2));
            else
              write.apply(proto, args);
            if (opts.transmit) {
              const transmitLevel = opts.transmit.level || logger47.level;
              const transmitValue = pino.levels.values[transmitLevel];
              const methodValue = pino.levels.values[level];
              if (methodValue < transmitValue)
                return;
              transmit(this, {
                ts: ts2,
                methodLevel: level,
                methodValue,
                transmitLevel,
                transmitValue: pino.levels.values[opts.transmit.level || logger47.level],
                send: opts.transmit.send,
                val: logger47.levelVal
              }, args);
            }
          };
        }(logger47[level]);
      }
      function asObject(logger47, level, args, ts2) {
        if (logger47._serialize)
          applySerializers(args, logger47._serialize, logger47.serializers, logger47._stdErrSerialize);
        const argsCloned = args.slice();
        let msg = argsCloned[0];
        const o9 = {};
        if (ts2) {
          o9.time = ts2;
        }
        o9.level = pino.levels.values[level];
        let lvl = (logger47._childLevel | 0) + 1;
        if (lvl < 1)
          lvl = 1;
        if (msg !== null && typeof msg === "object") {
          while (lvl-- && typeof argsCloned[0] === "object") {
            Object.assign(o9, argsCloned.shift());
          }
          msg = argsCloned.length ? format2(argsCloned.shift(), argsCloned) : void 0;
        } else if (typeof msg === "string")
          msg = format2(argsCloned.shift(), argsCloned);
        if (msg !== void 0)
          o9.msg = msg;
        return o9;
      }
      function applySerializers(args, serialize4, serializers, stdErrSerialize) {
        for (const i7 in args) {
          if (stdErrSerialize && args[i7] instanceof Error) {
            args[i7] = pino.stdSerializers.err(args[i7]);
          } else if (typeof args[i7] === "object" && !Array.isArray(args[i7])) {
            for (const k6 in args[i7]) {
              if (serialize4 && serialize4.indexOf(k6) > -1 && k6 in serializers) {
                args[i7][k6] = serializers[k6](args[i7][k6]);
              }
            }
          }
        }
      }
      function bind2(parent, bindings, level) {
        return function() {
          const args = new Array(1 + arguments.length);
          args[0] = bindings;
          for (var i7 = 1; i7 < args.length; i7++) {
            args[i7] = arguments[i7 - 1];
          }
          return parent[level].apply(this, args);
        };
      }
      function transmit(logger47, opts, args) {
        const send = opts.send;
        const ts2 = opts.ts;
        const methodLevel = opts.methodLevel;
        const methodValue = opts.methodValue;
        const val = opts.val;
        const bindings = logger47._logEvent.bindings;
        applySerializers(
          args,
          logger47._serialize || Object.keys(logger47.serializers),
          logger47.serializers,
          logger47._stdErrSerialize === void 0 ? true : logger47._stdErrSerialize
        );
        logger47._logEvent.ts = ts2;
        logger47._logEvent.messages = args.filter(function(arg) {
          return bindings.indexOf(arg) === -1;
        });
        logger47._logEvent.level.label = methodLevel;
        logger47._logEvent.level.value = methodValue;
        send(methodLevel, logger47._logEvent, val);
        logger47._logEvent = createLogEventShape(bindings);
      }
      function createLogEventShape(bindings) {
        return {
          ts: 0,
          messages: [],
          bindings: bindings || [],
          level: { label: "", value: 0 }
        };
      }
      function asErrValue(err) {
        const obj = {
          type: err.constructor.name,
          msg: err.message,
          stack: err.stack
        };
        for (const key2 in err) {
          if (obj[key2] === void 0) {
            obj[key2] = err[key2];
          }
        }
        return obj;
      }
      function getTimeFunction(opts) {
        if (typeof opts.timestamp === "function") {
          return opts.timestamp;
        }
        if (opts.timestamp === false) {
          return nullTime;
        }
        return epochTime;
      }
      function mock() {
        return {};
      }
      function passthrough(a6) {
        return a6;
      }
      function noop6() {
      }
      function nullTime() {
        return false;
      }
      function epochTime() {
        return Date.now();
      }
      function unixTime() {
        return Math.round(Date.now() / 1e3);
      }
      function isoTime() {
        return new Date(Date.now()).toISOString();
      }
      function pfGlobalThisOrFallback() {
        function defd(o9) {
          return typeof o9 !== "undefined" && o9;
        }
        try {
          if (typeof globalThis !== "undefined")
            return globalThis;
          Object.defineProperty(Object.prototype, "globalThis", {
            get: function() {
              delete Object.prototype.globalThis;
              return this.globalThis = this;
            },
            configurable: true
          });
          return globalThis;
        } catch (e9) {
          return defd(self) || defd(window) || defd(this) || {};
        }
      }
    }
  });

  // node_modules/@walletconnect/logger/dist/cjs/constants.js
  var require_constants3 = __commonJS({
    "node_modules/@walletconnect/logger/dist/cjs/constants.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.PINO_CUSTOM_CONTEXT_KEY = exports.PINO_LOGGER_DEFAULTS = void 0;
      exports.PINO_LOGGER_DEFAULTS = {
        level: "info"
      };
      exports.PINO_CUSTOM_CONTEXT_KEY = "custom_context";
    }
  });

  // node_modules/@walletconnect/logger/dist/cjs/utils.js
  var require_utils2 = __commonJS({
    "node_modules/@walletconnect/logger/dist/cjs/utils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.generateChildLogger = exports.formatChildLoggerContext = exports.getLoggerContext = exports.setBrowserLoggerContext = exports.getBrowserLoggerContext = exports.getDefaultLoggerOptions = void 0;
      var constants_1 = require_constants3();
      function getDefaultLoggerOptions(opts) {
        return Object.assign(Object.assign({}, opts), { level: (opts === null || opts === void 0 ? void 0 : opts.level) || constants_1.PINO_LOGGER_DEFAULTS.level });
      }
      exports.getDefaultLoggerOptions = getDefaultLoggerOptions;
      function getBrowserLoggerContext(logger47, customContextKey = constants_1.PINO_CUSTOM_CONTEXT_KEY) {
        return logger47[customContextKey] || "";
      }
      exports.getBrowserLoggerContext = getBrowserLoggerContext;
      function setBrowserLoggerContext(logger47, context, customContextKey = constants_1.PINO_CUSTOM_CONTEXT_KEY) {
        logger47[customContextKey] = context;
        return logger47;
      }
      exports.setBrowserLoggerContext = setBrowserLoggerContext;
      function getLoggerContext(logger47, customContextKey = constants_1.PINO_CUSTOM_CONTEXT_KEY) {
        let context = "";
        if (typeof logger47.bindings === "undefined") {
          context = getBrowserLoggerContext(logger47, customContextKey);
        } else {
          context = logger47.bindings().context || "";
        }
        return context;
      }
      exports.getLoggerContext = getLoggerContext;
      function formatChildLoggerContext(logger47, childContext, customContextKey = constants_1.PINO_CUSTOM_CONTEXT_KEY) {
        const parentContext = getLoggerContext(logger47, customContextKey);
        const context = parentContext.trim() ? `${parentContext}/${childContext}` : childContext;
        return context;
      }
      exports.formatChildLoggerContext = formatChildLoggerContext;
      function generateChildLogger(logger47, childContext, customContextKey = constants_1.PINO_CUSTOM_CONTEXT_KEY) {
        const context = formatChildLoggerContext(logger47, childContext, customContextKey);
        const child = logger47.child({ context });
        return setBrowserLoggerContext(child, context, customContextKey);
      }
      exports.generateChildLogger = generateChildLogger;
    }
  });

  // node_modules/@walletconnect/logger/dist/cjs/index.js
  var require_cjs5 = __commonJS({
    "node_modules/@walletconnect/logger/dist/cjs/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.pino = void 0;
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      var pino_1 = tslib_1.__importDefault(require_browser2());
      Object.defineProperty(exports, "pino", { enumerable: true, get: function() {
        return pino_1.default;
      } });
      tslib_1.__exportStar(require_constants3(), exports);
      tslib_1.__exportStar(require_utils2(), exports);
    }
  });

  // node_modules/@walletconnect/types/dist/index.es.js
  var import_events2, n, h3, a, u, g, p2, d, E2, y2, b, S3;
  var init_index_es3 = __esm({
    "node_modules/@walletconnect/types/dist/index.es.js"() {
      init_esm3();
      import_events2 = __toESM(require_events());
      n = class extends IEvents {
        constructor(s7) {
          super(), this.opts = s7, this.protocol = "wc", this.version = 2;
        }
      };
      h3 = class extends IEvents {
        constructor(s7, t6) {
          super(), this.core = s7, this.logger = t6, this.records = /* @__PURE__ */ new Map();
        }
      };
      a = class {
        constructor(s7, t6) {
          this.logger = s7, this.core = t6;
        }
      };
      u = class extends IEvents {
        constructor(s7, t6) {
          super(), this.relayer = s7, this.logger = t6;
        }
      };
      g = class extends IEvents {
        constructor(s7) {
          super();
        }
      };
      p2 = class {
        constructor(s7, t6, o9, w8) {
          this.core = s7, this.logger = t6, this.name = o9;
        }
      };
      d = class extends IEvents {
        constructor(s7, t6) {
          super(), this.relayer = s7, this.logger = t6;
        }
      };
      E2 = class extends IEvents {
        constructor(s7, t6) {
          super(), this.core = s7, this.logger = t6;
        }
      };
      y2 = class {
        constructor(s7, t6) {
          this.projectId = s7, this.logger = t6;
        }
      };
      b = class {
        constructor(s7) {
          this.opts = s7, this.protocol = "wc", this.version = 2;
        }
      };
      S3 = class {
        constructor(s7) {
          this.client = s7;
        }
      };
    }
  });

  // node_modules/@stablelib/sha512/lib/sha512.js
  var require_sha512 = __commonJS({
    "node_modules/@stablelib/sha512/lib/sha512.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var binary_1 = require_binary();
      var wipe_1 = require_wipe();
      exports.DIGEST_LENGTH = 64;
      exports.BLOCK_SIZE = 128;
      var SHA512 = (
        /** @class */
        function() {
          function SHA5122() {
            this.digestLength = exports.DIGEST_LENGTH;
            this.blockSize = exports.BLOCK_SIZE;
            this._stateHi = new Int32Array(8);
            this._stateLo = new Int32Array(8);
            this._tempHi = new Int32Array(16);
            this._tempLo = new Int32Array(16);
            this._buffer = new Uint8Array(256);
            this._bufferLength = 0;
            this._bytesHashed = 0;
            this._finished = false;
            this.reset();
          }
          SHA5122.prototype._initState = function() {
            this._stateHi[0] = 1779033703;
            this._stateHi[1] = 3144134277;
            this._stateHi[2] = 1013904242;
            this._stateHi[3] = 2773480762;
            this._stateHi[4] = 1359893119;
            this._stateHi[5] = 2600822924;
            this._stateHi[6] = 528734635;
            this._stateHi[7] = 1541459225;
            this._stateLo[0] = 4089235720;
            this._stateLo[1] = 2227873595;
            this._stateLo[2] = 4271175723;
            this._stateLo[3] = 1595750129;
            this._stateLo[4] = 2917565137;
            this._stateLo[5] = 725511199;
            this._stateLo[6] = 4215389547;
            this._stateLo[7] = 327033209;
          };
          SHA5122.prototype.reset = function() {
            this._initState();
            this._bufferLength = 0;
            this._bytesHashed = 0;
            this._finished = false;
            return this;
          };
          SHA5122.prototype.clean = function() {
            wipe_1.wipe(this._buffer);
            wipe_1.wipe(this._tempHi);
            wipe_1.wipe(this._tempLo);
            this.reset();
          };
          SHA5122.prototype.update = function(data2, dataLength) {
            if (dataLength === void 0) {
              dataLength = data2.length;
            }
            if (this._finished) {
              throw new Error("SHA512: can't update because hash was finished.");
            }
            var dataPos = 0;
            this._bytesHashed += dataLength;
            if (this._bufferLength > 0) {
              while (this._bufferLength < exports.BLOCK_SIZE && dataLength > 0) {
                this._buffer[this._bufferLength++] = data2[dataPos++];
                dataLength--;
              }
              if (this._bufferLength === this.blockSize) {
                hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, this.blockSize);
                this._bufferLength = 0;
              }
            }
            if (dataLength >= this.blockSize) {
              dataPos = hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, data2, dataPos, dataLength);
              dataLength %= this.blockSize;
            }
            while (dataLength > 0) {
              this._buffer[this._bufferLength++] = data2[dataPos++];
              dataLength--;
            }
            return this;
          };
          SHA5122.prototype.finish = function(out) {
            if (!this._finished) {
              var bytesHashed = this._bytesHashed;
              var left = this._bufferLength;
              var bitLenHi = bytesHashed / 536870912 | 0;
              var bitLenLo = bytesHashed << 3;
              var padLength = bytesHashed % 128 < 112 ? 128 : 256;
              this._buffer[left] = 128;
              for (var i7 = left + 1; i7 < padLength - 8; i7++) {
                this._buffer[i7] = 0;
              }
              binary_1.writeUint32BE(bitLenHi, this._buffer, padLength - 8);
              binary_1.writeUint32BE(bitLenLo, this._buffer, padLength - 4);
              hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, padLength);
              this._finished = true;
            }
            for (var i7 = 0; i7 < this.digestLength / 8; i7++) {
              binary_1.writeUint32BE(this._stateHi[i7], out, i7 * 8);
              binary_1.writeUint32BE(this._stateLo[i7], out, i7 * 8 + 4);
            }
            return this;
          };
          SHA5122.prototype.digest = function() {
            var out = new Uint8Array(this.digestLength);
            this.finish(out);
            return out;
          };
          SHA5122.prototype.saveState = function() {
            if (this._finished) {
              throw new Error("SHA256: cannot save finished state");
            }
            return {
              stateHi: new Int32Array(this._stateHi),
              stateLo: new Int32Array(this._stateLo),
              buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
              bufferLength: this._bufferLength,
              bytesHashed: this._bytesHashed
            };
          };
          SHA5122.prototype.restoreState = function(savedState) {
            this._stateHi.set(savedState.stateHi);
            this._stateLo.set(savedState.stateLo);
            this._bufferLength = savedState.bufferLength;
            if (savedState.buffer) {
              this._buffer.set(savedState.buffer);
            }
            this._bytesHashed = savedState.bytesHashed;
            this._finished = false;
            return this;
          };
          SHA5122.prototype.cleanSavedState = function(savedState) {
            wipe_1.wipe(savedState.stateHi);
            wipe_1.wipe(savedState.stateLo);
            if (savedState.buffer) {
              wipe_1.wipe(savedState.buffer);
            }
            savedState.bufferLength = 0;
            savedState.bytesHashed = 0;
          };
          return SHA5122;
        }()
      );
      exports.SHA512 = SHA512;
      var K8 = new Int32Array([
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ]);
      function hashBlocks(wh, wl, hh, hl, m6, pos, len) {
        var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
        var h10, l9;
        var th, tl;
        var a6, b7, c9, d7;
        while (len >= 128) {
          for (var i7 = 0; i7 < 16; i7++) {
            var j7 = 8 * i7 + pos;
            wh[i7] = binary_1.readUint32BE(m6, j7);
            wl[i7] = binary_1.readUint32BE(m6, j7 + 4);
          }
          for (var i7 = 0; i7 < 80; i7++) {
            var bh0 = ah0;
            var bh1 = ah1;
            var bh2 = ah2;
            var bh3 = ah3;
            var bh4 = ah4;
            var bh5 = ah5;
            var bh6 = ah6;
            var bh7 = ah7;
            var bl0 = al0;
            var bl1 = al1;
            var bl2 = al2;
            var bl3 = al3;
            var bl4 = al4;
            var bl5 = al5;
            var bl6 = al6;
            var bl7 = al7;
            h10 = ah7;
            l9 = al7;
            a6 = l9 & 65535;
            b7 = l9 >>> 16;
            c9 = h10 & 65535;
            d7 = h10 >>> 16;
            h10 = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
            l9 = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
            a6 += l9 & 65535;
            b7 += l9 >>> 16;
            c9 += h10 & 65535;
            d7 += h10 >>> 16;
            h10 = ah4 & ah5 ^ ~ah4 & ah6;
            l9 = al4 & al5 ^ ~al4 & al6;
            a6 += l9 & 65535;
            b7 += l9 >>> 16;
            c9 += h10 & 65535;
            d7 += h10 >>> 16;
            h10 = K8[i7 * 2];
            l9 = K8[i7 * 2 + 1];
            a6 += l9 & 65535;
            b7 += l9 >>> 16;
            c9 += h10 & 65535;
            d7 += h10 >>> 16;
            h10 = wh[i7 % 16];
            l9 = wl[i7 % 16];
            a6 += l9 & 65535;
            b7 += l9 >>> 16;
            c9 += h10 & 65535;
            d7 += h10 >>> 16;
            b7 += a6 >>> 16;
            c9 += b7 >>> 16;
            d7 += c9 >>> 16;
            th = c9 & 65535 | d7 << 16;
            tl = a6 & 65535 | b7 << 16;
            h10 = th;
            l9 = tl;
            a6 = l9 & 65535;
            b7 = l9 >>> 16;
            c9 = h10 & 65535;
            d7 = h10 >>> 16;
            h10 = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
            l9 = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
            a6 += l9 & 65535;
            b7 += l9 >>> 16;
            c9 += h10 & 65535;
            d7 += h10 >>> 16;
            h10 = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
            l9 = al0 & al1 ^ al0 & al2 ^ al1 & al2;
            a6 += l9 & 65535;
            b7 += l9 >>> 16;
            c9 += h10 & 65535;
            d7 += h10 >>> 16;
            b7 += a6 >>> 16;
            c9 += b7 >>> 16;
            d7 += c9 >>> 16;
            bh7 = c9 & 65535 | d7 << 16;
            bl7 = a6 & 65535 | b7 << 16;
            h10 = bh3;
            l9 = bl3;
            a6 = l9 & 65535;
            b7 = l9 >>> 16;
            c9 = h10 & 65535;
            d7 = h10 >>> 16;
            h10 = th;
            l9 = tl;
            a6 += l9 & 65535;
            b7 += l9 >>> 16;
            c9 += h10 & 65535;
            d7 += h10 >>> 16;
            b7 += a6 >>> 16;
            c9 += b7 >>> 16;
            d7 += c9 >>> 16;
            bh3 = c9 & 65535 | d7 << 16;
            bl3 = a6 & 65535 | b7 << 16;
            ah1 = bh0;
            ah2 = bh1;
            ah3 = bh2;
            ah4 = bh3;
            ah5 = bh4;
            ah6 = bh5;
            ah7 = bh6;
            ah0 = bh7;
            al1 = bl0;
            al2 = bl1;
            al3 = bl2;
            al4 = bl3;
            al5 = bl4;
            al6 = bl5;
            al7 = bl6;
            al0 = bl7;
            if (i7 % 16 === 15) {
              for (var j7 = 0; j7 < 16; j7++) {
                h10 = wh[j7];
                l9 = wl[j7];
                a6 = l9 & 65535;
                b7 = l9 >>> 16;
                c9 = h10 & 65535;
                d7 = h10 >>> 16;
                h10 = wh[(j7 + 9) % 16];
                l9 = wl[(j7 + 9) % 16];
                a6 += l9 & 65535;
                b7 += l9 >>> 16;
                c9 += h10 & 65535;
                d7 += h10 >>> 16;
                th = wh[(j7 + 1) % 16];
                tl = wl[(j7 + 1) % 16];
                h10 = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
                l9 = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
                a6 += l9 & 65535;
                b7 += l9 >>> 16;
                c9 += h10 & 65535;
                d7 += h10 >>> 16;
                th = wh[(j7 + 14) % 16];
                tl = wl[(j7 + 14) % 16];
                h10 = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
                l9 = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
                a6 += l9 & 65535;
                b7 += l9 >>> 16;
                c9 += h10 & 65535;
                d7 += h10 >>> 16;
                b7 += a6 >>> 16;
                c9 += b7 >>> 16;
                d7 += c9 >>> 16;
                wh[j7] = c9 & 65535 | d7 << 16;
                wl[j7] = a6 & 65535 | b7 << 16;
              }
            }
          }
          h10 = ah0;
          l9 = al0;
          a6 = l9 & 65535;
          b7 = l9 >>> 16;
          c9 = h10 & 65535;
          d7 = h10 >>> 16;
          h10 = hh[0];
          l9 = hl[0];
          a6 += l9 & 65535;
          b7 += l9 >>> 16;
          c9 += h10 & 65535;
          d7 += h10 >>> 16;
          b7 += a6 >>> 16;
          c9 += b7 >>> 16;
          d7 += c9 >>> 16;
          hh[0] = ah0 = c9 & 65535 | d7 << 16;
          hl[0] = al0 = a6 & 65535 | b7 << 16;
          h10 = ah1;
          l9 = al1;
          a6 = l9 & 65535;
          b7 = l9 >>> 16;
          c9 = h10 & 65535;
          d7 = h10 >>> 16;
          h10 = hh[1];
          l9 = hl[1];
          a6 += l9 & 65535;
          b7 += l9 >>> 16;
          c9 += h10 & 65535;
          d7 += h10 >>> 16;
          b7 += a6 >>> 16;
          c9 += b7 >>> 16;
          d7 += c9 >>> 16;
          hh[1] = ah1 = c9 & 65535 | d7 << 16;
          hl[1] = al1 = a6 & 65535 | b7 << 16;
          h10 = ah2;
          l9 = al2;
          a6 = l9 & 65535;
          b7 = l9 >>> 16;
          c9 = h10 & 65535;
          d7 = h10 >>> 16;
          h10 = hh[2];
          l9 = hl[2];
          a6 += l9 & 65535;
          b7 += l9 >>> 16;
          c9 += h10 & 65535;
          d7 += h10 >>> 16;
          b7 += a6 >>> 16;
          c9 += b7 >>> 16;
          d7 += c9 >>> 16;
          hh[2] = ah2 = c9 & 65535 | d7 << 16;
          hl[2] = al2 = a6 & 65535 | b7 << 16;
          h10 = ah3;
          l9 = al3;
          a6 = l9 & 65535;
          b7 = l9 >>> 16;
          c9 = h10 & 65535;
          d7 = h10 >>> 16;
          h10 = hh[3];
          l9 = hl[3];
          a6 += l9 & 65535;
          b7 += l9 >>> 16;
          c9 += h10 & 65535;
          d7 += h10 >>> 16;
          b7 += a6 >>> 16;
          c9 += b7 >>> 16;
          d7 += c9 >>> 16;
          hh[3] = ah3 = c9 & 65535 | d7 << 16;
          hl[3] = al3 = a6 & 65535 | b7 << 16;
          h10 = ah4;
          l9 = al4;
          a6 = l9 & 65535;
          b7 = l9 >>> 16;
          c9 = h10 & 65535;
          d7 = h10 >>> 16;
          h10 = hh[4];
          l9 = hl[4];
          a6 += l9 & 65535;
          b7 += l9 >>> 16;
          c9 += h10 & 65535;
          d7 += h10 >>> 16;
          b7 += a6 >>> 16;
          c9 += b7 >>> 16;
          d7 += c9 >>> 16;
          hh[4] = ah4 = c9 & 65535 | d7 << 16;
          hl[4] = al4 = a6 & 65535 | b7 << 16;
          h10 = ah5;
          l9 = al5;
          a6 = l9 & 65535;
          b7 = l9 >>> 16;
          c9 = h10 & 65535;
          d7 = h10 >>> 16;
          h10 = hh[5];
          l9 = hl[5];
          a6 += l9 & 65535;
          b7 += l9 >>> 16;
          c9 += h10 & 65535;
          d7 += h10 >>> 16;
          b7 += a6 >>> 16;
          c9 += b7 >>> 16;
          d7 += c9 >>> 16;
          hh[5] = ah5 = c9 & 65535 | d7 << 16;
          hl[5] = al5 = a6 & 65535 | b7 << 16;
          h10 = ah6;
          l9 = al6;
          a6 = l9 & 65535;
          b7 = l9 >>> 16;
          c9 = h10 & 65535;
          d7 = h10 >>> 16;
          h10 = hh[6];
          l9 = hl[6];
          a6 += l9 & 65535;
          b7 += l9 >>> 16;
          c9 += h10 & 65535;
          d7 += h10 >>> 16;
          b7 += a6 >>> 16;
          c9 += b7 >>> 16;
          d7 += c9 >>> 16;
          hh[6] = ah6 = c9 & 65535 | d7 << 16;
          hl[6] = al6 = a6 & 65535 | b7 << 16;
          h10 = ah7;
          l9 = al7;
          a6 = l9 & 65535;
          b7 = l9 >>> 16;
          c9 = h10 & 65535;
          d7 = h10 >>> 16;
          h10 = hh[7];
          l9 = hl[7];
          a6 += l9 & 65535;
          b7 += l9 >>> 16;
          c9 += h10 & 65535;
          d7 += h10 >>> 16;
          b7 += a6 >>> 16;
          c9 += b7 >>> 16;
          d7 += c9 >>> 16;
          hh[7] = ah7 = c9 & 65535 | d7 << 16;
          hl[7] = al7 = a6 & 65535 | b7 << 16;
          pos += 128;
          len -= 128;
        }
        return pos;
      }
      function hash5(data2) {
        var h10 = new SHA512();
        h10.update(data2);
        var digest2 = h10.digest();
        h10.clean();
        return digest2;
      }
      exports.hash = hash5;
    }
  });

  // node_modules/@stablelib/ed25519/lib/ed25519.js
  var require_ed25519 = __commonJS({
    "node_modules/@stablelib/ed25519/lib/ed25519.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.convertSecretKeyToX25519 = exports.convertPublicKeyToX25519 = exports.verify = exports.sign = exports.extractPublicKeyFromSecretKey = exports.generateKeyPair = exports.generateKeyPairFromSeed = exports.SEED_LENGTH = exports.SECRET_KEY_LENGTH = exports.PUBLIC_KEY_LENGTH = exports.SIGNATURE_LENGTH = void 0;
      var random_1 = require_random();
      var sha512_1 = require_sha512();
      var wipe_1 = require_wipe();
      exports.SIGNATURE_LENGTH = 64;
      exports.PUBLIC_KEY_LENGTH = 32;
      exports.SECRET_KEY_LENGTH = 64;
      exports.SEED_LENGTH = 32;
      function gf(init2) {
        const r8 = new Float64Array(16);
        if (init2) {
          for (let i7 = 0; i7 < init2.length; i7++) {
            r8[i7] = init2[i7];
          }
        }
        return r8;
      }
      var _9 = new Uint8Array(32);
      _9[0] = 9;
      var gf0 = gf();
      var gf1 = gf([1]);
      var D10 = gf([
        30883,
        4953,
        19914,
        30187,
        55467,
        16705,
        2637,
        112,
        59544,
        30585,
        16505,
        36039,
        65139,
        11119,
        27886,
        20995
      ]);
      var D22 = gf([
        61785,
        9906,
        39828,
        60374,
        45398,
        33411,
        5274,
        224,
        53552,
        61171,
        33010,
        6542,
        64743,
        22239,
        55772,
        9222
      ]);
      var X8 = gf([
        54554,
        36645,
        11616,
        51542,
        42930,
        38181,
        51040,
        26924,
        56412,
        64982,
        57905,
        49316,
        21502,
        52590,
        14035,
        8553
      ]);
      var Y6 = gf([
        26200,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214
      ]);
      var I5 = gf([
        41136,
        18958,
        6951,
        50414,
        58488,
        44335,
        6150,
        12099,
        55207,
        15867,
        153,
        11085,
        57099,
        20417,
        9344,
        11139
      ]);
      function set25519(r8, a6) {
        for (let i7 = 0; i7 < 16; i7++) {
          r8[i7] = a6[i7] | 0;
        }
      }
      function car25519(o9) {
        let c9 = 1;
        for (let i7 = 0; i7 < 16; i7++) {
          let v6 = o9[i7] + c9 + 65535;
          c9 = Math.floor(v6 / 65536);
          o9[i7] = v6 - c9 * 65536;
        }
        o9[0] += c9 - 1 + 37 * (c9 - 1);
      }
      function sel25519(p8, q8, b7) {
        const c9 = ~(b7 - 1);
        for (let i7 = 0; i7 < 16; i7++) {
          const t6 = c9 & (p8[i7] ^ q8[i7]);
          p8[i7] ^= t6;
          q8[i7] ^= t6;
        }
      }
      function pack25519(o9, n9) {
        const m6 = gf();
        const t6 = gf();
        for (let i7 = 0; i7 < 16; i7++) {
          t6[i7] = n9[i7];
        }
        car25519(t6);
        car25519(t6);
        car25519(t6);
        for (let j7 = 0; j7 < 2; j7++) {
          m6[0] = t6[0] - 65517;
          for (let i7 = 1; i7 < 15; i7++) {
            m6[i7] = t6[i7] - 65535 - (m6[i7 - 1] >> 16 & 1);
            m6[i7 - 1] &= 65535;
          }
          m6[15] = t6[15] - 32767 - (m6[14] >> 16 & 1);
          const b7 = m6[15] >> 16 & 1;
          m6[14] &= 65535;
          sel25519(t6, m6, 1 - b7);
        }
        for (let i7 = 0; i7 < 16; i7++) {
          o9[2 * i7] = t6[i7] & 255;
          o9[2 * i7 + 1] = t6[i7] >> 8;
        }
      }
      function verify32(x4, y11) {
        let d7 = 0;
        for (let i7 = 0; i7 < 32; i7++) {
          d7 |= x4[i7] ^ y11[i7];
        }
        return (1 & d7 - 1 >>> 8) - 1;
      }
      function neq25519(a6, b7) {
        const c9 = new Uint8Array(32);
        const d7 = new Uint8Array(32);
        pack25519(c9, a6);
        pack25519(d7, b7);
        return verify32(c9, d7);
      }
      function par25519(a6) {
        const d7 = new Uint8Array(32);
        pack25519(d7, a6);
        return d7[0] & 1;
      }
      function unpack25519(o9, n9) {
        for (let i7 = 0; i7 < 16; i7++) {
          o9[i7] = n9[2 * i7] + (n9[2 * i7 + 1] << 8);
        }
        o9[15] &= 32767;
      }
      function add4(o9, a6, b7) {
        for (let i7 = 0; i7 < 16; i7++) {
          o9[i7] = a6[i7] + b7[i7];
        }
      }
      function sub(o9, a6, b7) {
        for (let i7 = 0; i7 < 16; i7++) {
          o9[i7] = a6[i7] - b7[i7];
        }
      }
      function mul3(o9, a6, b7) {
        let v6, c9, t0 = 0, t1 = 0, t22 = 0, t32 = 0, t42 = 0, t52 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t222 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b7[0], b1 = b7[1], b22 = b7[2], b32 = b7[3], b42 = b7[4], b52 = b7[5], b62 = b7[6], b72 = b7[7], b8 = b7[8], b9 = b7[9], b10 = b7[10], b11 = b7[11], b12 = b7[12], b13 = b7[13], b14 = b7[14], b15 = b7[15];
        v6 = a6[0];
        t0 += v6 * b0;
        t1 += v6 * b1;
        t22 += v6 * b22;
        t32 += v6 * b32;
        t42 += v6 * b42;
        t52 += v6 * b52;
        t6 += v6 * b62;
        t7 += v6 * b72;
        t8 += v6 * b8;
        t9 += v6 * b9;
        t10 += v6 * b10;
        t11 += v6 * b11;
        t12 += v6 * b12;
        t13 += v6 * b13;
        t14 += v6 * b14;
        t15 += v6 * b15;
        v6 = a6[1];
        t1 += v6 * b0;
        t22 += v6 * b1;
        t32 += v6 * b22;
        t42 += v6 * b32;
        t52 += v6 * b42;
        t6 += v6 * b52;
        t7 += v6 * b62;
        t8 += v6 * b72;
        t9 += v6 * b8;
        t10 += v6 * b9;
        t11 += v6 * b10;
        t12 += v6 * b11;
        t13 += v6 * b12;
        t14 += v6 * b13;
        t15 += v6 * b14;
        t16 += v6 * b15;
        v6 = a6[2];
        t22 += v6 * b0;
        t32 += v6 * b1;
        t42 += v6 * b22;
        t52 += v6 * b32;
        t6 += v6 * b42;
        t7 += v6 * b52;
        t8 += v6 * b62;
        t9 += v6 * b72;
        t10 += v6 * b8;
        t11 += v6 * b9;
        t12 += v6 * b10;
        t13 += v6 * b11;
        t14 += v6 * b12;
        t15 += v6 * b13;
        t16 += v6 * b14;
        t17 += v6 * b15;
        v6 = a6[3];
        t32 += v6 * b0;
        t42 += v6 * b1;
        t52 += v6 * b22;
        t6 += v6 * b32;
        t7 += v6 * b42;
        t8 += v6 * b52;
        t9 += v6 * b62;
        t10 += v6 * b72;
        t11 += v6 * b8;
        t12 += v6 * b9;
        t13 += v6 * b10;
        t14 += v6 * b11;
        t15 += v6 * b12;
        t16 += v6 * b13;
        t17 += v6 * b14;
        t18 += v6 * b15;
        v6 = a6[4];
        t42 += v6 * b0;
        t52 += v6 * b1;
        t6 += v6 * b22;
        t7 += v6 * b32;
        t8 += v6 * b42;
        t9 += v6 * b52;
        t10 += v6 * b62;
        t11 += v6 * b72;
        t12 += v6 * b8;
        t13 += v6 * b9;
        t14 += v6 * b10;
        t15 += v6 * b11;
        t16 += v6 * b12;
        t17 += v6 * b13;
        t18 += v6 * b14;
        t19 += v6 * b15;
        v6 = a6[5];
        t52 += v6 * b0;
        t6 += v6 * b1;
        t7 += v6 * b22;
        t8 += v6 * b32;
        t9 += v6 * b42;
        t10 += v6 * b52;
        t11 += v6 * b62;
        t12 += v6 * b72;
        t13 += v6 * b8;
        t14 += v6 * b9;
        t15 += v6 * b10;
        t16 += v6 * b11;
        t17 += v6 * b12;
        t18 += v6 * b13;
        t19 += v6 * b14;
        t20 += v6 * b15;
        v6 = a6[6];
        t6 += v6 * b0;
        t7 += v6 * b1;
        t8 += v6 * b22;
        t9 += v6 * b32;
        t10 += v6 * b42;
        t11 += v6 * b52;
        t12 += v6 * b62;
        t13 += v6 * b72;
        t14 += v6 * b8;
        t15 += v6 * b9;
        t16 += v6 * b10;
        t17 += v6 * b11;
        t18 += v6 * b12;
        t19 += v6 * b13;
        t20 += v6 * b14;
        t21 += v6 * b15;
        v6 = a6[7];
        t7 += v6 * b0;
        t8 += v6 * b1;
        t9 += v6 * b22;
        t10 += v6 * b32;
        t11 += v6 * b42;
        t12 += v6 * b52;
        t13 += v6 * b62;
        t14 += v6 * b72;
        t15 += v6 * b8;
        t16 += v6 * b9;
        t17 += v6 * b10;
        t18 += v6 * b11;
        t19 += v6 * b12;
        t20 += v6 * b13;
        t21 += v6 * b14;
        t222 += v6 * b15;
        v6 = a6[8];
        t8 += v6 * b0;
        t9 += v6 * b1;
        t10 += v6 * b22;
        t11 += v6 * b32;
        t12 += v6 * b42;
        t13 += v6 * b52;
        t14 += v6 * b62;
        t15 += v6 * b72;
        t16 += v6 * b8;
        t17 += v6 * b9;
        t18 += v6 * b10;
        t19 += v6 * b11;
        t20 += v6 * b12;
        t21 += v6 * b13;
        t222 += v6 * b14;
        t23 += v6 * b15;
        v6 = a6[9];
        t9 += v6 * b0;
        t10 += v6 * b1;
        t11 += v6 * b22;
        t12 += v6 * b32;
        t13 += v6 * b42;
        t14 += v6 * b52;
        t15 += v6 * b62;
        t16 += v6 * b72;
        t17 += v6 * b8;
        t18 += v6 * b9;
        t19 += v6 * b10;
        t20 += v6 * b11;
        t21 += v6 * b12;
        t222 += v6 * b13;
        t23 += v6 * b14;
        t24 += v6 * b15;
        v6 = a6[10];
        t10 += v6 * b0;
        t11 += v6 * b1;
        t12 += v6 * b22;
        t13 += v6 * b32;
        t14 += v6 * b42;
        t15 += v6 * b52;
        t16 += v6 * b62;
        t17 += v6 * b72;
        t18 += v6 * b8;
        t19 += v6 * b9;
        t20 += v6 * b10;
        t21 += v6 * b11;
        t222 += v6 * b12;
        t23 += v6 * b13;
        t24 += v6 * b14;
        t25 += v6 * b15;
        v6 = a6[11];
        t11 += v6 * b0;
        t12 += v6 * b1;
        t13 += v6 * b22;
        t14 += v6 * b32;
        t15 += v6 * b42;
        t16 += v6 * b52;
        t17 += v6 * b62;
        t18 += v6 * b72;
        t19 += v6 * b8;
        t20 += v6 * b9;
        t21 += v6 * b10;
        t222 += v6 * b11;
        t23 += v6 * b12;
        t24 += v6 * b13;
        t25 += v6 * b14;
        t26 += v6 * b15;
        v6 = a6[12];
        t12 += v6 * b0;
        t13 += v6 * b1;
        t14 += v6 * b22;
        t15 += v6 * b32;
        t16 += v6 * b42;
        t17 += v6 * b52;
        t18 += v6 * b62;
        t19 += v6 * b72;
        t20 += v6 * b8;
        t21 += v6 * b9;
        t222 += v6 * b10;
        t23 += v6 * b11;
        t24 += v6 * b12;
        t25 += v6 * b13;
        t26 += v6 * b14;
        t27 += v6 * b15;
        v6 = a6[13];
        t13 += v6 * b0;
        t14 += v6 * b1;
        t15 += v6 * b22;
        t16 += v6 * b32;
        t17 += v6 * b42;
        t18 += v6 * b52;
        t19 += v6 * b62;
        t20 += v6 * b72;
        t21 += v6 * b8;
        t222 += v6 * b9;
        t23 += v6 * b10;
        t24 += v6 * b11;
        t25 += v6 * b12;
        t26 += v6 * b13;
        t27 += v6 * b14;
        t28 += v6 * b15;
        v6 = a6[14];
        t14 += v6 * b0;
        t15 += v6 * b1;
        t16 += v6 * b22;
        t17 += v6 * b32;
        t18 += v6 * b42;
        t19 += v6 * b52;
        t20 += v6 * b62;
        t21 += v6 * b72;
        t222 += v6 * b8;
        t23 += v6 * b9;
        t24 += v6 * b10;
        t25 += v6 * b11;
        t26 += v6 * b12;
        t27 += v6 * b13;
        t28 += v6 * b14;
        t29 += v6 * b15;
        v6 = a6[15];
        t15 += v6 * b0;
        t16 += v6 * b1;
        t17 += v6 * b22;
        t18 += v6 * b32;
        t19 += v6 * b42;
        t20 += v6 * b52;
        t21 += v6 * b62;
        t222 += v6 * b72;
        t23 += v6 * b8;
        t24 += v6 * b9;
        t25 += v6 * b10;
        t26 += v6 * b11;
        t27 += v6 * b12;
        t28 += v6 * b13;
        t29 += v6 * b14;
        t30 += v6 * b15;
        t0 += 38 * t16;
        t1 += 38 * t17;
        t22 += 38 * t18;
        t32 += 38 * t19;
        t42 += 38 * t20;
        t52 += 38 * t21;
        t6 += 38 * t222;
        t7 += 38 * t23;
        t8 += 38 * t24;
        t9 += 38 * t25;
        t10 += 38 * t26;
        t11 += 38 * t27;
        t12 += 38 * t28;
        t13 += 38 * t29;
        t14 += 38 * t30;
        c9 = 1;
        v6 = t0 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t0 = v6 - c9 * 65536;
        v6 = t1 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t1 = v6 - c9 * 65536;
        v6 = t22 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t22 = v6 - c9 * 65536;
        v6 = t32 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t32 = v6 - c9 * 65536;
        v6 = t42 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t42 = v6 - c9 * 65536;
        v6 = t52 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t52 = v6 - c9 * 65536;
        v6 = t6 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t6 = v6 - c9 * 65536;
        v6 = t7 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t7 = v6 - c9 * 65536;
        v6 = t8 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t8 = v6 - c9 * 65536;
        v6 = t9 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t9 = v6 - c9 * 65536;
        v6 = t10 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t10 = v6 - c9 * 65536;
        v6 = t11 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t11 = v6 - c9 * 65536;
        v6 = t12 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t12 = v6 - c9 * 65536;
        v6 = t13 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t13 = v6 - c9 * 65536;
        v6 = t14 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t14 = v6 - c9 * 65536;
        v6 = t15 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t15 = v6 - c9 * 65536;
        t0 += c9 - 1 + 37 * (c9 - 1);
        c9 = 1;
        v6 = t0 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t0 = v6 - c9 * 65536;
        v6 = t1 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t1 = v6 - c9 * 65536;
        v6 = t22 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t22 = v6 - c9 * 65536;
        v6 = t32 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t32 = v6 - c9 * 65536;
        v6 = t42 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t42 = v6 - c9 * 65536;
        v6 = t52 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t52 = v6 - c9 * 65536;
        v6 = t6 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t6 = v6 - c9 * 65536;
        v6 = t7 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t7 = v6 - c9 * 65536;
        v6 = t8 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t8 = v6 - c9 * 65536;
        v6 = t9 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t9 = v6 - c9 * 65536;
        v6 = t10 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t10 = v6 - c9 * 65536;
        v6 = t11 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t11 = v6 - c9 * 65536;
        v6 = t12 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t12 = v6 - c9 * 65536;
        v6 = t13 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t13 = v6 - c9 * 65536;
        v6 = t14 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t14 = v6 - c9 * 65536;
        v6 = t15 + c9 + 65535;
        c9 = Math.floor(v6 / 65536);
        t15 = v6 - c9 * 65536;
        t0 += c9 - 1 + 37 * (c9 - 1);
        o9[0] = t0;
        o9[1] = t1;
        o9[2] = t22;
        o9[3] = t32;
        o9[4] = t42;
        o9[5] = t52;
        o9[6] = t6;
        o9[7] = t7;
        o9[8] = t8;
        o9[9] = t9;
        o9[10] = t10;
        o9[11] = t11;
        o9[12] = t12;
        o9[13] = t13;
        o9[14] = t14;
        o9[15] = t15;
      }
      function square(o9, a6) {
        mul3(o9, a6, a6);
      }
      function inv25519(o9, i7) {
        const c9 = gf();
        let a6;
        for (a6 = 0; a6 < 16; a6++) {
          c9[a6] = i7[a6];
        }
        for (a6 = 253; a6 >= 0; a6--) {
          square(c9, c9);
          if (a6 !== 2 && a6 !== 4) {
            mul3(c9, c9, i7);
          }
        }
        for (a6 = 0; a6 < 16; a6++) {
          o9[a6] = c9[a6];
        }
      }
      function pow2523(o9, i7) {
        const c9 = gf();
        let a6;
        for (a6 = 0; a6 < 16; a6++) {
          c9[a6] = i7[a6];
        }
        for (a6 = 250; a6 >= 0; a6--) {
          square(c9, c9);
          if (a6 !== 1) {
            mul3(c9, c9, i7);
          }
        }
        for (a6 = 0; a6 < 16; a6++) {
          o9[a6] = c9[a6];
        }
      }
      function edadd(p8, q8) {
        const a6 = gf(), b7 = gf(), c9 = gf(), d7 = gf(), e9 = gf(), f7 = gf(), g7 = gf(), h10 = gf(), t6 = gf();
        sub(a6, p8[1], p8[0]);
        sub(t6, q8[1], q8[0]);
        mul3(a6, a6, t6);
        add4(b7, p8[0], p8[1]);
        add4(t6, q8[0], q8[1]);
        mul3(b7, b7, t6);
        mul3(c9, p8[3], q8[3]);
        mul3(c9, c9, D22);
        mul3(d7, p8[2], q8[2]);
        add4(d7, d7, d7);
        sub(e9, b7, a6);
        sub(f7, d7, c9);
        add4(g7, d7, c9);
        add4(h10, b7, a6);
        mul3(p8[0], e9, f7);
        mul3(p8[1], h10, g7);
        mul3(p8[2], g7, f7);
        mul3(p8[3], e9, h10);
      }
      function cswap(p8, q8, b7) {
        for (let i7 = 0; i7 < 4; i7++) {
          sel25519(p8[i7], q8[i7], b7);
        }
      }
      function pack3(r8, p8) {
        const tx = gf(), ty = gf(), zi = gf();
        inv25519(zi, p8[2]);
        mul3(tx, p8[0], zi);
        mul3(ty, p8[1], zi);
        pack25519(r8, ty);
        r8[31] ^= par25519(tx) << 7;
      }
      function scalarmult(p8, q8, s7) {
        set25519(p8[0], gf0);
        set25519(p8[1], gf1);
        set25519(p8[2], gf1);
        set25519(p8[3], gf0);
        for (let i7 = 255; i7 >= 0; --i7) {
          const b7 = s7[i7 / 8 | 0] >> (i7 & 7) & 1;
          cswap(p8, q8, b7);
          edadd(q8, p8);
          edadd(p8, p8);
          cswap(p8, q8, b7);
        }
      }
      function scalarbase(p8, s7) {
        const q8 = [gf(), gf(), gf(), gf()];
        set25519(q8[0], X8);
        set25519(q8[1], Y6);
        set25519(q8[2], gf1);
        mul3(q8[3], X8, Y6);
        scalarmult(p8, q8, s7);
      }
      function generateKeyPairFromSeed2(seed) {
        if (seed.length !== exports.SEED_LENGTH) {
          throw new Error(`ed25519: seed must be ${exports.SEED_LENGTH} bytes`);
        }
        const d7 = (0, sha512_1.hash)(seed);
        d7[0] &= 248;
        d7[31] &= 127;
        d7[31] |= 64;
        const publicKey = new Uint8Array(32);
        const p8 = [gf(), gf(), gf(), gf()];
        scalarbase(p8, d7);
        pack3(publicKey, p8);
        const secretKey = new Uint8Array(64);
        secretKey.set(seed);
        secretKey.set(publicKey, 32);
        return {
          publicKey,
          secretKey
        };
      }
      exports.generateKeyPairFromSeed = generateKeyPairFromSeed2;
      function generateKeyPair4(prng) {
        const seed = (0, random_1.randomBytes)(32, prng);
        const result = generateKeyPairFromSeed2(seed);
        (0, wipe_1.wipe)(seed);
        return result;
      }
      exports.generateKeyPair = generateKeyPair4;
      function extractPublicKeyFromSecretKey(secretKey) {
        if (secretKey.length !== exports.SECRET_KEY_LENGTH) {
          throw new Error(`ed25519: secret key must be ${exports.SECRET_KEY_LENGTH} bytes`);
        }
        return new Uint8Array(secretKey.subarray(32));
      }
      exports.extractPublicKeyFromSecretKey = extractPublicKeyFromSecretKey;
      var L9 = new Float64Array([
        237,
        211,
        245,
        92,
        26,
        99,
        18,
        88,
        214,
        156,
        247,
        162,
        222,
        249,
        222,
        20,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        16
      ]);
      function modL(r8, x4) {
        let carry;
        let i7;
        let j7;
        let k6;
        for (i7 = 63; i7 >= 32; --i7) {
          carry = 0;
          for (j7 = i7 - 32, k6 = i7 - 12; j7 < k6; ++j7) {
            x4[j7] += carry - 16 * x4[i7] * L9[j7 - (i7 - 32)];
            carry = Math.floor((x4[j7] + 128) / 256);
            x4[j7] -= carry * 256;
          }
          x4[j7] += carry;
          x4[i7] = 0;
        }
        carry = 0;
        for (j7 = 0; j7 < 32; j7++) {
          x4[j7] += carry - (x4[31] >> 4) * L9[j7];
          carry = x4[j7] >> 8;
          x4[j7] &= 255;
        }
        for (j7 = 0; j7 < 32; j7++) {
          x4[j7] -= carry * L9[j7];
        }
        for (i7 = 0; i7 < 32; i7++) {
          x4[i7 + 1] += x4[i7] >> 8;
          r8[i7] = x4[i7] & 255;
        }
      }
      function reduce(r8) {
        const x4 = new Float64Array(64);
        for (let i7 = 0; i7 < 64; i7++) {
          x4[i7] = r8[i7];
        }
        for (let i7 = 0; i7 < 64; i7++) {
          r8[i7] = 0;
        }
        modL(r8, x4);
      }
      function sign4(secretKey, message) {
        const x4 = new Float64Array(64);
        const p8 = [gf(), gf(), gf(), gf()];
        const d7 = (0, sha512_1.hash)(secretKey.subarray(0, 32));
        d7[0] &= 248;
        d7[31] &= 127;
        d7[31] |= 64;
        const signature2 = new Uint8Array(64);
        signature2.set(d7.subarray(32), 32);
        const hs3 = new sha512_1.SHA512();
        hs3.update(signature2.subarray(32));
        hs3.update(message);
        const r8 = hs3.digest();
        hs3.clean();
        reduce(r8);
        scalarbase(p8, r8);
        pack3(signature2, p8);
        hs3.reset();
        hs3.update(signature2.subarray(0, 32));
        hs3.update(secretKey.subarray(32));
        hs3.update(message);
        const h10 = hs3.digest();
        reduce(h10);
        for (let i7 = 0; i7 < 32; i7++) {
          x4[i7] = r8[i7];
        }
        for (let i7 = 0; i7 < 32; i7++) {
          for (let j7 = 0; j7 < 32; j7++) {
            x4[i7 + j7] += h10[i7] * d7[j7];
          }
        }
        modL(signature2.subarray(32), x4);
        return signature2;
      }
      exports.sign = sign4;
      function unpackneg(r8, p8) {
        const t6 = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        set25519(r8[2], gf1);
        unpack25519(r8[1], p8);
        square(num, r8[1]);
        mul3(den, num, D10);
        sub(num, num, r8[2]);
        add4(den, r8[2], den);
        square(den2, den);
        square(den4, den2);
        mul3(den6, den4, den2);
        mul3(t6, den6, num);
        mul3(t6, t6, den);
        pow2523(t6, t6);
        mul3(t6, t6, num);
        mul3(t6, t6, den);
        mul3(t6, t6, den);
        mul3(r8[0], t6, den);
        square(chk, r8[0]);
        mul3(chk, chk, den);
        if (neq25519(chk, num)) {
          mul3(r8[0], r8[0], I5);
        }
        square(chk, r8[0]);
        mul3(chk, chk, den);
        if (neq25519(chk, num)) {
          return -1;
        }
        if (par25519(r8[0]) === p8[31] >> 7) {
          sub(r8[0], gf0, r8[0]);
        }
        mul3(r8[3], r8[0], r8[1]);
        return 0;
      }
      function verify4(publicKey, message, signature2) {
        const t6 = new Uint8Array(32);
        const p8 = [gf(), gf(), gf(), gf()];
        const q8 = [gf(), gf(), gf(), gf()];
        if (signature2.length !== exports.SIGNATURE_LENGTH) {
          throw new Error(`ed25519: signature must be ${exports.SIGNATURE_LENGTH} bytes`);
        }
        if (unpackneg(q8, publicKey)) {
          return false;
        }
        const hs3 = new sha512_1.SHA512();
        hs3.update(signature2.subarray(0, 32));
        hs3.update(publicKey);
        hs3.update(message);
        const h10 = hs3.digest();
        reduce(h10);
        scalarmult(p8, q8, h10);
        scalarbase(q8, signature2.subarray(32));
        edadd(p8, q8);
        pack3(t6, p8);
        if (verify32(signature2, t6)) {
          return false;
        }
        return true;
      }
      exports.verify = verify4;
      function convertPublicKeyToX25519(publicKey) {
        let q8 = [gf(), gf(), gf(), gf()];
        if (unpackneg(q8, publicKey)) {
          throw new Error("Ed25519: invalid public key");
        }
        let a6 = gf();
        let b7 = gf();
        let y11 = q8[1];
        add4(a6, gf1, y11);
        sub(b7, gf1, y11);
        inv25519(b7, b7);
        mul3(a6, a6, b7);
        let z7 = new Uint8Array(32);
        pack25519(z7, a6);
        return z7;
      }
      exports.convertPublicKeyToX25519 = convertPublicKeyToX25519;
      function convertSecretKeyToX25519(secretKey) {
        const d7 = (0, sha512_1.hash)(secretKey.subarray(0, 32));
        d7[0] &= 248;
        d7[31] &= 127;
        d7[31] |= 64;
        const o9 = new Uint8Array(d7.subarray(0, 32));
        (0, wipe_1.wipe)(d7);
        return o9;
      }
      exports.convertSecretKeyToX25519 = convertSecretKeyToX25519;
    }
  });

  // node_modules/@walletconnect/relay-auth/dist/esm/constants.js
  var JWT_IRIDIUM_ALG, JWT_IRIDIUM_TYP, JWT_DELIMITER, JWT_ENCODING, JSON_ENCODING, DATA_ENCODING, DID_DELIMITER, DID_PREFIX, DID_METHOD, MULTICODEC_ED25519_ENCODING, MULTICODEC_ED25519_BASE, MULTICODEC_ED25519_HEADER, KEY_PAIR_SEED_LENGTH;
  var init_constants = __esm({
    "node_modules/@walletconnect/relay-auth/dist/esm/constants.js"() {
      JWT_IRIDIUM_ALG = "EdDSA";
      JWT_IRIDIUM_TYP = "JWT";
      JWT_DELIMITER = ".";
      JWT_ENCODING = "base64url";
      JSON_ENCODING = "utf8";
      DATA_ENCODING = "utf8";
      DID_DELIMITER = ":";
      DID_PREFIX = "did";
      DID_METHOD = "key";
      MULTICODEC_ED25519_ENCODING = "base58btc";
      MULTICODEC_ED25519_BASE = "z";
      MULTICODEC_ED25519_HEADER = "K36";
      KEY_PAIR_SEED_LENGTH = 32;
    }
  });

  // node_modules/@walletconnect/relay-auth/dist/esm/utils.js
  function encodeJSON(val) {
    return toString2(fromString2(safeJsonStringify(val), JSON_ENCODING), JWT_ENCODING);
  }
  function encodeIss(publicKey) {
    const header = fromString2(MULTICODEC_ED25519_HEADER, MULTICODEC_ED25519_ENCODING);
    const multicodec = MULTICODEC_ED25519_BASE + toString2(concat2([header, publicKey]), MULTICODEC_ED25519_ENCODING);
    return [DID_PREFIX, DID_METHOD, multicodec].join(DID_DELIMITER);
  }
  function encodeSig(bytes3) {
    return toString2(bytes3, JWT_ENCODING);
  }
  function encodeData2(params) {
    return fromString2([encodeJSON(params.header), encodeJSON(params.payload)].join(JWT_DELIMITER), DATA_ENCODING);
  }
  function encodeJWT(params) {
    return [
      encodeJSON(params.header),
      encodeJSON(params.payload),
      encodeSig(params.signature)
    ].join(JWT_DELIMITER);
  }
  var init_utils5 = __esm({
    "node_modules/@walletconnect/relay-auth/dist/esm/utils.js"() {
      init_concat2();
      init_to_string();
      init_from_string();
      init_esm2();
      init_constants();
    }
  });

  // node_modules/@walletconnect/relay-auth/dist/esm/api.js
  function generateKeyPair3(seed = (0, import_random3.randomBytes)(KEY_PAIR_SEED_LENGTH)) {
    return ed25519.generateKeyPairFromSeed(seed);
  }
  async function signJWT(sub, aud, ttl, keyPair2, iat = (0, import_time3.fromMiliseconds)(Date.now())) {
    const header = { alg: JWT_IRIDIUM_ALG, typ: JWT_IRIDIUM_TYP };
    const iss = encodeIss(keyPair2.publicKey);
    const exp = iat + ttl;
    const payload = { iss, sub, aud, iat, exp };
    const data2 = encodeData2({ header, payload });
    const signature2 = ed25519.sign(keyPair2.secretKey, data2);
    return encodeJWT({ header, payload, signature: signature2 });
  }
  var ed25519, import_random3, import_time3;
  var init_api = __esm({
    "node_modules/@walletconnect/relay-auth/dist/esm/api.js"() {
      ed25519 = __toESM(require_ed25519());
      import_random3 = __toESM(require_random());
      import_time3 = __toESM(require_cjs());
      init_constants();
      init_utils5();
    }
  });

  // node_modules/@walletconnect/relay-auth/dist/esm/types.js
  var init_types2 = __esm({
    "node_modules/@walletconnect/relay-auth/dist/esm/types.js"() {
    }
  });

  // node_modules/@walletconnect/relay-auth/dist/esm/index.js
  var init_esm4 = __esm({
    "node_modules/@walletconnect/relay-auth/dist/esm/index.js"() {
      init_api();
      init_constants();
      init_types2();
      init_utils5();
    }
  });

  // node_modules/@walletconnect/jsonrpc-utils/dist/esm/constants.js
  var PARSE_ERROR, INVALID_REQUEST, METHOD_NOT_FOUND, INVALID_PARAMS, INTERNAL_ERROR, SERVER_ERROR, RESERVED_ERROR_CODES, SERVER_ERROR_CODE_RANGE, STANDARD_ERROR_MAP, DEFAULT_ERROR;
  var init_constants2 = __esm({
    "node_modules/@walletconnect/jsonrpc-utils/dist/esm/constants.js"() {
      PARSE_ERROR = "PARSE_ERROR";
      INVALID_REQUEST = "INVALID_REQUEST";
      METHOD_NOT_FOUND = "METHOD_NOT_FOUND";
      INVALID_PARAMS = "INVALID_PARAMS";
      INTERNAL_ERROR = "INTERNAL_ERROR";
      SERVER_ERROR = "SERVER_ERROR";
      RESERVED_ERROR_CODES = [-32700, -32600, -32601, -32602, -32603];
      SERVER_ERROR_CODE_RANGE = [-32e3, -32099];
      STANDARD_ERROR_MAP = {
        [PARSE_ERROR]: { code: -32700, message: "Parse error" },
        [INVALID_REQUEST]: { code: -32600, message: "Invalid Request" },
        [METHOD_NOT_FOUND]: { code: -32601, message: "Method not found" },
        [INVALID_PARAMS]: { code: -32602, message: "Invalid params" },
        [INTERNAL_ERROR]: { code: -32603, message: "Internal error" },
        [SERVER_ERROR]: { code: -32e3, message: "Server error" }
      };
      DEFAULT_ERROR = SERVER_ERROR;
    }
  });

  // node_modules/@walletconnect/jsonrpc-utils/dist/esm/error.js
  function isServerErrorCode(code2) {
    return code2 <= SERVER_ERROR_CODE_RANGE[0] && code2 >= SERVER_ERROR_CODE_RANGE[1];
  }
  function isReservedErrorCode(code2) {
    return RESERVED_ERROR_CODES.includes(code2);
  }
  function isValidErrorCode(code2) {
    return typeof code2 === "number";
  }
  function getError(type) {
    if (!Object.keys(STANDARD_ERROR_MAP).includes(type)) {
      return STANDARD_ERROR_MAP[DEFAULT_ERROR];
    }
    return STANDARD_ERROR_MAP[type];
  }
  function getErrorByCode(code2) {
    const match = Object.values(STANDARD_ERROR_MAP).find((e9) => e9.code === code2);
    if (!match) {
      return STANDARD_ERROR_MAP[DEFAULT_ERROR];
    }
    return match;
  }
  function validateJsonRpcError(response) {
    if (typeof response.error.code === "undefined") {
      return { valid: false, error: "Missing code for JSON-RPC error" };
    }
    if (typeof response.error.message === "undefined") {
      return { valid: false, error: "Missing message for JSON-RPC error" };
    }
    if (!isValidErrorCode(response.error.code)) {
      return {
        valid: false,
        error: `Invalid error code type for JSON-RPC: ${response.error.code}`
      };
    }
    if (isReservedErrorCode(response.error.code)) {
      const error = getErrorByCode(response.error.code);
      if (error.message !== STANDARD_ERROR_MAP[DEFAULT_ERROR].message && response.error.message === error.message) {
        return {
          valid: false,
          error: `Invalid error code message for JSON-RPC: ${response.error.code}`
        };
      }
    }
    return { valid: true };
  }
  function parseConnectionError(e9, url, type) {
    return e9.message.includes("getaddrinfo ENOTFOUND") || e9.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${type} RPC url at ${url}`) : e9;
  }
  var init_error = __esm({
    "node_modules/@walletconnect/jsonrpc-utils/dist/esm/error.js"() {
      init_constants2();
    }
  });

  // node_modules/@walletconnect/environment/dist/cjs/crypto.js
  var require_crypto2 = __commonJS({
    "node_modules/@walletconnect/environment/dist/cjs/crypto.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isBrowserCryptoAvailable = exports.getSubtleCrypto = exports.getBrowerCrypto = void 0;
      function getBrowerCrypto() {
        return (global === null || global === void 0 ? void 0 : global.crypto) || (global === null || global === void 0 ? void 0 : global.msCrypto) || {};
      }
      exports.getBrowerCrypto = getBrowerCrypto;
      function getSubtleCrypto() {
        const browserCrypto = getBrowerCrypto();
        return browserCrypto.subtle || browserCrypto.webkitSubtle;
      }
      exports.getSubtleCrypto = getSubtleCrypto;
      function isBrowserCryptoAvailable() {
        return !!getBrowerCrypto() && !!getSubtleCrypto();
      }
      exports.isBrowserCryptoAvailable = isBrowserCryptoAvailable;
    }
  });

  // node_modules/@walletconnect/environment/dist/cjs/env.js
  var require_env = __commonJS({
    "node_modules/@walletconnect/environment/dist/cjs/env.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isBrowser = exports.isNode = exports.isReactNative = void 0;
      function isReactNative() {
        return typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative";
      }
      exports.isReactNative = isReactNative;
      function isNode2() {
        return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
      }
      exports.isNode = isNode2;
      function isBrowser() {
        return !isReactNative() && !isNode2();
      }
      exports.isBrowser = isBrowser;
    }
  });

  // node_modules/@walletconnect/environment/dist/cjs/index.js
  var require_cjs6 = __commonJS({
    "node_modules/@walletconnect/environment/dist/cjs/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
      tslib_1.__exportStar(require_crypto2(), exports);
      tslib_1.__exportStar(require_env(), exports);
    }
  });

  // node_modules/@walletconnect/jsonrpc-utils/dist/esm/env.js
  var env_exports = {};
  __export(env_exports, {
    isNodeJs: () => isNodeJs
  });
  var import_environment, isNodeJs;
  var init_env = __esm({
    "node_modules/@walletconnect/jsonrpc-utils/dist/esm/env.js"() {
      import_environment = __toESM(require_cjs6());
      __reExport(env_exports, __toESM(require_cjs6()));
      isNodeJs = import_environment.isNode;
    }
  });

  // node_modules/@walletconnect/jsonrpc-utils/dist/esm/format.js
  function payloadId(entropy = 3) {
    const date = Date.now() * Math.pow(10, entropy);
    const extra = Math.floor(Math.random() * Math.pow(10, entropy));
    return date + extra;
  }
  function getBigIntRpcId(entropy = 6) {
    return BigInt(payloadId(entropy));
  }
  function formatJsonRpcRequest(method, params, id3) {
    return {
      id: id3 || payloadId(),
      jsonrpc: "2.0",
      method,
      params
    };
  }
  function formatJsonRpcResult(id3, result) {
    return {
      id: id3,
      jsonrpc: "2.0",
      result
    };
  }
  function formatJsonRpcError(id3, error, data2) {
    return {
      id: id3,
      jsonrpc: "2.0",
      error: formatErrorMessage(error, data2)
    };
  }
  function formatErrorMessage(error, data2) {
    if (typeof error === "undefined") {
      return getError(INTERNAL_ERROR);
    }
    if (typeof error === "string") {
      error = Object.assign(Object.assign({}, getError(SERVER_ERROR)), { message: error });
    }
    if (typeof data2 !== "undefined") {
      error.data = data2;
    }
    if (isReservedErrorCode(error.code)) {
      error = getErrorByCode(error.code);
    }
    return error;
  }
  var init_format2 = __esm({
    "node_modules/@walletconnect/jsonrpc-utils/dist/esm/format.js"() {
      init_error();
      init_constants2();
    }
  });

  // node_modules/@walletconnect/jsonrpc-utils/dist/esm/routing.js
  function isValidRoute(route) {
    if (route.includes("*")) {
      return isValidWildcardRoute(route);
    }
    if (/\W/g.test(route)) {
      return false;
    }
    return true;
  }
  function isValidDefaultRoute(route) {
    return route === "*";
  }
  function isValidWildcardRoute(route) {
    if (isValidDefaultRoute(route)) {
      return true;
    }
    if (!route.includes("*")) {
      return false;
    }
    if (route.split("*").length !== 2) {
      return false;
    }
    if (route.split("*").filter((x4) => x4.trim() === "").length !== 1) {
      return false;
    }
    return true;
  }
  function isValidLeadingWildcardRoute(route) {
    return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[0].trim();
  }
  function isValidTrailingWildcardRoute(route) {
    return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[1].trim();
  }
  var init_routing = __esm({
    "node_modules/@walletconnect/jsonrpc-utils/dist/esm/routing.js"() {
    }
  });

  // node_modules/@walletconnect/jsonrpc-types/dist/esm/jsonrpc.js
  var init_jsonrpc2 = __esm({
    "node_modules/@walletconnect/jsonrpc-types/dist/esm/jsonrpc.js"() {
    }
  });

  // node_modules/@walletconnect/jsonrpc-types/dist/esm/misc.js
  var IEvents2;
  var init_misc2 = __esm({
    "node_modules/@walletconnect/jsonrpc-types/dist/esm/misc.js"() {
      IEvents2 = class {
      };
    }
  });

  // node_modules/@walletconnect/jsonrpc-types/dist/esm/provider.js
  var IJsonRpcConnection, IBaseJsonRpcProvider, IJsonRpcProvider;
  var init_provider = __esm({
    "node_modules/@walletconnect/jsonrpc-types/dist/esm/provider.js"() {
      init_misc2();
      IJsonRpcConnection = class extends IEvents2 {
        constructor(opts) {
          super();
        }
      };
      IBaseJsonRpcProvider = class extends IEvents2 {
        constructor() {
          super();
        }
      };
      IJsonRpcProvider = class extends IBaseJsonRpcProvider {
        constructor(connection) {
          super();
        }
      };
    }
  });

  // node_modules/@walletconnect/jsonrpc-types/dist/esm/validator.js
  var init_validator = __esm({
    "node_modules/@walletconnect/jsonrpc-types/dist/esm/validator.js"() {
    }
  });

  // node_modules/@walletconnect/jsonrpc-types/dist/esm/index.js
  var init_esm5 = __esm({
    "node_modules/@walletconnect/jsonrpc-types/dist/esm/index.js"() {
      init_jsonrpc2();
      init_misc2();
      init_provider();
      init_validator();
    }
  });

  // node_modules/@walletconnect/jsonrpc-utils/dist/esm/types.js
  var init_types3 = __esm({
    "node_modules/@walletconnect/jsonrpc-utils/dist/esm/types.js"() {
      init_esm5();
    }
  });

  // node_modules/@walletconnect/jsonrpc-utils/dist/esm/url.js
  function getUrlProtocol(url) {
    const matches = url.match(new RegExp(/^\w+:/, "gi"));
    if (!matches || !matches.length)
      return;
    return matches[0];
  }
  function matchRegexProtocol(url, regex) {
    const protocol2 = getUrlProtocol(url);
    if (typeof protocol2 === "undefined")
      return false;
    return new RegExp(regex).test(protocol2);
  }
  function isHttpUrl(url) {
    return matchRegexProtocol(url, HTTP_REGEX);
  }
  function isWsUrl(url) {
    return matchRegexProtocol(url, WS_REGEX);
  }
  function isLocalhostUrl(url) {
    return new RegExp("wss?://localhost(:d{2,5})?").test(url);
  }
  var HTTP_REGEX, WS_REGEX;
  var init_url = __esm({
    "node_modules/@walletconnect/jsonrpc-utils/dist/esm/url.js"() {
      HTTP_REGEX = "^https?:";
      WS_REGEX = "^wss?:";
    }
  });

  // node_modules/@walletconnect/jsonrpc-utils/dist/esm/validators.js
  function isJsonRpcPayload(payload) {
    return typeof payload === "object" && "id" in payload && "jsonrpc" in payload && payload.jsonrpc === "2.0";
  }
  function isJsonRpcRequest(payload) {
    return isJsonRpcPayload(payload) && "method" in payload;
  }
  function isJsonRpcResponse(payload) {
    return isJsonRpcPayload(payload) && (isJsonRpcResult(payload) || isJsonRpcError(payload));
  }
  function isJsonRpcResult(payload) {
    return "result" in payload;
  }
  function isJsonRpcError(payload) {
    return "error" in payload;
  }
  function isJsonRpcValidationInvalid(validation) {
    return "error" in validation && validation.valid === false;
  }
  var init_validators2 = __esm({
    "node_modules/@walletconnect/jsonrpc-utils/dist/esm/validators.js"() {
    }
  });

  // node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js
  var esm_exports2 = {};
  __export(esm_exports2, {
    DEFAULT_ERROR: () => DEFAULT_ERROR,
    IBaseJsonRpcProvider: () => IBaseJsonRpcProvider,
    IEvents: () => IEvents2,
    IJsonRpcConnection: () => IJsonRpcConnection,
    IJsonRpcProvider: () => IJsonRpcProvider,
    INTERNAL_ERROR: () => INTERNAL_ERROR,
    INVALID_PARAMS: () => INVALID_PARAMS,
    INVALID_REQUEST: () => INVALID_REQUEST,
    METHOD_NOT_FOUND: () => METHOD_NOT_FOUND,
    PARSE_ERROR: () => PARSE_ERROR,
    RESERVED_ERROR_CODES: () => RESERVED_ERROR_CODES,
    SERVER_ERROR: () => SERVER_ERROR,
    SERVER_ERROR_CODE_RANGE: () => SERVER_ERROR_CODE_RANGE,
    STANDARD_ERROR_MAP: () => STANDARD_ERROR_MAP,
    formatErrorMessage: () => formatErrorMessage,
    formatJsonRpcError: () => formatJsonRpcError,
    formatJsonRpcRequest: () => formatJsonRpcRequest,
    formatJsonRpcResult: () => formatJsonRpcResult,
    getBigIntRpcId: () => getBigIntRpcId,
    getError: () => getError,
    getErrorByCode: () => getErrorByCode,
    isHttpUrl: () => isHttpUrl,
    isJsonRpcError: () => isJsonRpcError,
    isJsonRpcPayload: () => isJsonRpcPayload,
    isJsonRpcRequest: () => isJsonRpcRequest,
    isJsonRpcResponse: () => isJsonRpcResponse,
    isJsonRpcResult: () => isJsonRpcResult,
    isJsonRpcValidationInvalid: () => isJsonRpcValidationInvalid,
    isLocalhostUrl: () => isLocalhostUrl,
    isNodeJs: () => isNodeJs,
    isReservedErrorCode: () => isReservedErrorCode,
    isServerErrorCode: () => isServerErrorCode,
    isValidDefaultRoute: () => isValidDefaultRoute,
    isValidErrorCode: () => isValidErrorCode,
    isValidLeadingWildcardRoute: () => isValidLeadingWildcardRoute,
    isValidRoute: () => isValidRoute,
    isValidTrailingWildcardRoute: () => isValidTrailingWildcardRoute,
    isValidWildcardRoute: () => isValidWildcardRoute,
    isWsUrl: () => isWsUrl,
    parseConnectionError: () => parseConnectionError,
    payloadId: () => payloadId,
    validateJsonRpcError: () => validateJsonRpcError
  });
  var init_esm6 = __esm({
    "node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js"() {
      init_constants2();
      init_error();
      init_env();
      __reExport(esm_exports2, env_exports);
      init_format2();
      init_routing();
      init_types3();
      init_url();
      init_validators2();
    }
  });

  // node_modules/@walletconnect/jsonrpc-provider/dist/esm/provider.js
  var import_events3, JsonRpcProvider;
  var init_provider2 = __esm({
    "node_modules/@walletconnect/jsonrpc-provider/dist/esm/provider.js"() {
      import_events3 = __toESM(require_events());
      init_esm6();
      JsonRpcProvider = class extends IJsonRpcProvider {
        constructor(connection) {
          super(connection);
          this.events = new import_events3.EventEmitter();
          this.hasRegisteredEventListeners = false;
          this.connection = this.setConnection(connection);
          if (this.connection.connected) {
            this.registerEventListeners();
          }
        }
        async connect(connection = this.connection) {
          await this.open(connection);
        }
        async disconnect() {
          await this.close();
        }
        on(event, listener) {
          this.events.on(event, listener);
        }
        once(event, listener) {
          this.events.once(event, listener);
        }
        off(event, listener) {
          this.events.off(event, listener);
        }
        removeListener(event, listener) {
          this.events.removeListener(event, listener);
        }
        async request(request, context) {
          return this.requestStrict(formatJsonRpcRequest(request.method, request.params || [], request.id || getBigIntRpcId().toString()), context);
        }
        async requestStrict(request, context) {
          return new Promise(async (resolve, reject) => {
            if (!this.connection.connected) {
              try {
                await this.open();
              } catch (e9) {
                reject(e9);
              }
            }
            this.events.on(`${request.id}`, (response) => {
              if (isJsonRpcError(response)) {
                reject(response.error);
              } else {
                resolve(response.result);
              }
            });
            try {
              await this.connection.send(request, context);
            } catch (e9) {
              reject(e9);
            }
          });
        }
        setConnection(connection = this.connection) {
          return connection;
        }
        onPayload(payload) {
          this.events.emit("payload", payload);
          if (isJsonRpcResponse(payload)) {
            this.events.emit(`${payload.id}`, payload);
          } else {
            this.events.emit("message", {
              type: payload.method,
              data: payload.params
            });
          }
        }
        onClose(event) {
          if (event && event.code === 3e3) {
            this.events.emit("error", new Error(`WebSocket connection closed abnormally with code: ${event.code} ${event.reason ? `(${event.reason})` : ""}`));
          }
          this.events.emit("disconnect");
        }
        async open(connection = this.connection) {
          if (this.connection === connection && this.connection.connected)
            return;
          if (this.connection.connected)
            this.close();
          if (typeof connection === "string") {
            await this.connection.open(connection);
            connection = this.connection;
          }
          this.connection = this.setConnection(connection);
          await this.connection.open();
          this.registerEventListeners();
          this.events.emit("connect");
        }
        async close() {
          await this.connection.close();
        }
        registerEventListeners() {
          if (this.hasRegisteredEventListeners)
            return;
          this.connection.on("payload", (payload) => this.onPayload(payload));
          this.connection.on("close", (event) => this.onClose(event));
          this.connection.on("error", (error) => this.events.emit("error", error));
          this.connection.on("register_error", (error) => this.onClose());
          this.hasRegisteredEventListeners = true;
        }
      };
    }
  });

  // node_modules/@walletconnect/jsonrpc-provider/dist/esm/index.js
  var init_esm7 = __esm({
    "node_modules/@walletconnect/jsonrpc-provider/dist/esm/index.js"() {
      init_provider2();
      init_provider2();
    }
  });

  // node_modules/ws/browser.js
  var require_browser3 = __commonJS({
    "node_modules/ws/browser.js"(exports, module) {
      "use strict";
      module.exports = function() {
        throw new Error(
          "ws does not work in the browser. Browser clients must use the native WebSocket object"
        );
      };
    }
  });

  // node_modules/@walletconnect/jsonrpc-ws-connection/dist/index.es.js
  var import_events4, w2, b2, a2, h4, S4, f;
  var init_index_es4 = __esm({
    "node_modules/@walletconnect/jsonrpc-ws-connection/dist/index.es.js"() {
      import_events4 = __toESM(require_events());
      init_esm2();
      init_esm6();
      w2 = () => typeof WebSocket < "u" ? WebSocket : typeof global < "u" && typeof global.WebSocket < "u" ? global.WebSocket : typeof window < "u" && typeof window.WebSocket < "u" ? window.WebSocket : typeof self < "u" && typeof self.WebSocket < "u" ? self.WebSocket : require_browser3();
      b2 = () => typeof WebSocket < "u" || typeof global < "u" && typeof global.WebSocket < "u" || typeof window < "u" && typeof window.WebSocket < "u" || typeof self < "u" && typeof self.WebSocket < "u";
      a2 = (c9) => c9.split("?")[0];
      h4 = 10;
      S4 = w2();
      f = class {
        constructor(e9) {
          if (this.url = e9, this.events = new import_events4.EventEmitter(), this.registering = false, !isWsUrl(e9))
            throw new Error(`Provided URL is not compatible with WebSocket connection: ${e9}`);
          this.url = e9;
        }
        get connected() {
          return typeof this.socket < "u";
        }
        get connecting() {
          return this.registering;
        }
        on(e9, t6) {
          this.events.on(e9, t6);
        }
        once(e9, t6) {
          this.events.once(e9, t6);
        }
        off(e9, t6) {
          this.events.off(e9, t6);
        }
        removeListener(e9, t6) {
          this.events.removeListener(e9, t6);
        }
        async open(e9 = this.url) {
          await this.register(e9);
        }
        async close() {
          return new Promise((e9, t6) => {
            if (typeof this.socket > "u") {
              t6(new Error("Connection already closed"));
              return;
            }
            this.socket.onclose = (n9) => {
              this.onClose(n9), e9();
            }, this.socket.close();
          });
        }
        async send(e9) {
          typeof this.socket > "u" && (this.socket = await this.register());
          try {
            this.socket.send(safeJsonStringify(e9));
          } catch (t6) {
            this.onError(e9.id, t6);
          }
        }
        register(e9 = this.url) {
          if (!isWsUrl(e9))
            throw new Error(`Provided URL is not compatible with WebSocket connection: ${e9}`);
          if (this.registering) {
            const t6 = this.events.getMaxListeners();
            return (this.events.listenerCount("register_error") >= t6 || this.events.listenerCount("open") >= t6) && this.events.setMaxListeners(t6 + 1), new Promise((n9, o9) => {
              this.events.once("register_error", (s7) => {
                this.resetMaxListeners(), o9(s7);
              }), this.events.once("open", () => {
                if (this.resetMaxListeners(), typeof this.socket > "u")
                  return o9(new Error("WebSocket connection is missing or invalid"));
                n9(this.socket);
              });
            });
          }
          return this.url = e9, this.registering = true, new Promise((t6, n9) => {
            const o9 = new URLSearchParams(e9).get("origin"), s7 = (0, esm_exports2.isReactNative)() ? { headers: { origin: o9 } } : { rejectUnauthorized: !isLocalhostUrl(e9) }, i7 = new S4(e9, [], s7);
            b2() ? i7.onerror = (r8) => {
              const l9 = r8;
              n9(this.emitError(l9.error));
            } : i7.on("error", (r8) => {
              n9(this.emitError(r8));
            }), i7.onopen = () => {
              this.onOpen(i7), t6(i7);
            };
          });
        }
        onOpen(e9) {
          e9.onmessage = (t6) => this.onPayload(t6), e9.onclose = (t6) => this.onClose(t6), this.socket = e9, this.registering = false, this.events.emit("open");
        }
        onClose(e9) {
          this.socket = void 0, this.registering = false, this.events.emit("close", e9);
        }
        onPayload(e9) {
          if (typeof e9.data > "u")
            return;
          const t6 = typeof e9.data == "string" ? safeJsonParse(e9.data) : e9.data;
          this.events.emit("payload", t6);
        }
        onError(e9, t6) {
          const n9 = this.parseError(t6), o9 = n9.message || n9.toString(), s7 = formatJsonRpcError(e9, o9);
          this.events.emit("payload", s7);
        }
        parseError(e9, t6 = this.url) {
          return parseConnectionError(e9, a2(t6), "WS");
        }
        resetMaxListeners() {
          this.events.getMaxListeners() > h4 && this.events.setMaxListeners(h4);
        }
        emitError(e9) {
          const t6 = this.parseError(new Error(e9?.message || `WebSocket connection failed for host: ${a2(this.url)}`));
          return this.events.emit("register_error", t6), t6;
        }
      };
    }
  });

  // node_modules/lodash.isequal/index.js
  var require_lodash = __commonJS({
    "node_modules/lodash.isequal/index.js"(exports, module) {
      var LARGE_ARRAY_SIZE = 200;
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var COMPARE_PARTIAL_FLAG = 1;
      var COMPARE_UNORDERED_FLAG = 2;
      var MAX_SAFE_INTEGER2 = 9007199254740991;
      var argsTag = "[object Arguments]";
      var arrayTag = "[object Array]";
      var asyncTag = "[object AsyncFunction]";
      var boolTag = "[object Boolean]";
      var dateTag = "[object Date]";
      var errorTag = "[object Error]";
      var funcTag = "[object Function]";
      var genTag = "[object GeneratorFunction]";
      var mapTag = "[object Map]";
      var numberTag = "[object Number]";
      var nullTag = "[object Null]";
      var objectTag = "[object Object]";
      var promiseTag = "[object Promise]";
      var proxyTag = "[object Proxy]";
      var regexpTag = "[object RegExp]";
      var setTag = "[object Set]";
      var stringTag = "[object String]";
      var symbolTag = "[object Symbol]";
      var undefinedTag = "[object Undefined]";
      var weakMapTag = "[object WeakMap]";
      var arrayBufferTag = "[object ArrayBuffer]";
      var dataViewTag = "[object DataView]";
      var float32Tag = "[object Float32Array]";
      var float64Tag = "[object Float64Array]";
      var int8Tag = "[object Int8Array]";
      var int16Tag = "[object Int16Array]";
      var int32Tag = "[object Int32Array]";
      var uint8Tag = "[object Uint8Array]";
      var uint8ClampedTag = "[object Uint8ClampedArray]";
      var uint16Tag = "[object Uint16Array]";
      var uint32Tag = "[object Uint32Array]";
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root2 = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e9) {
        }
      }();
      var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function arrayFilter(array, predicate) {
        var index2 = -1, length2 = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index2 < length2) {
          var value = array[index2];
          if (predicate(value, index2, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayPush(array, values) {
        var index2 = -1, length2 = values.length, offset = array.length;
        while (++index2 < length2) {
          array[offset + index2] = values[index2];
        }
        return array;
      }
      function arraySome(array, predicate) {
        var index2 = -1, length2 = array == null ? 0 : array.length;
        while (++index2 < length2) {
          if (predicate(array[index2], index2, array)) {
            return true;
          }
        }
        return false;
      }
      function baseTimes(n9, iteratee) {
        var index2 = -1, result = Array(n9);
        while (++index2 < n9) {
          result[index2] = iteratee(index2);
        }
        return result;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function cacheHas(cache, key2) {
        return cache.has(key2);
      }
      function getValue(object, key2) {
        return object == null ? void 0 : object[key2];
      }
      function mapToArray(map) {
        var index2 = -1, result = Array(map.size);
        map.forEach(function(value, key2) {
          result[++index2] = [key2, value];
        });
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function setToArray(set2) {
        var index2 = -1, result = Array(set2.size);
        set2.forEach(function(value) {
          result[++index2] = value;
        });
        return result;
      }
      var arrayProto = Array.prototype;
      var funcProto = Function.prototype;
      var objectProto = Object.prototype;
      var coreJsData = root2["__core-js_shared__"];
      var funcToString = funcProto.toString;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      var maskSrcKey = function() {
        var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid2 ? "Symbol(src)_1." + uid2 : "";
      }();
      var nativeObjectToString = objectProto.toString;
      var reIsNative = RegExp(
        "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      var Buffer2 = moduleExports ? root2.Buffer : void 0;
      var Symbol2 = root2.Symbol;
      var Uint8Array2 = root2.Uint8Array;
      var propertyIsEnumerable = objectProto.propertyIsEnumerable;
      var splice = arrayProto.splice;
      var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
      var nativeGetSymbols = Object.getOwnPropertySymbols;
      var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
      var nativeKeys = overArg(Object.keys, Object);
      var DataView2 = getNative(root2, "DataView");
      var Map2 = getNative(root2, "Map");
      var Promise2 = getNative(root2, "Promise");
      var Set2 = getNative(root2, "Set");
      var WeakMap2 = getNative(root2, "WeakMap");
      var nativeCreate = getNative(Object, "create");
      var dataViewCtorString = toSource(DataView2);
      var mapCtorString = toSource(Map2);
      var promiseCtorString = toSource(Promise2);
      var setCtorString = toSource(Set2);
      var weakMapCtorString = toSource(WeakMap2);
      var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
      var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
      function Hash2(entries) {
        var index2 = -1, length2 = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length2) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      function hashDelete(key2) {
        var result = this.has(key2) && delete this.__data__[key2];
        this.size -= result ? 1 : 0;
        return result;
      }
      function hashGet(key2) {
        var data2 = this.__data__;
        if (nativeCreate) {
          var result = data2[key2];
          return result === HASH_UNDEFINED ? void 0 : result;
        }
        return hasOwnProperty2.call(data2, key2) ? data2[key2] : void 0;
      }
      function hashHas(key2) {
        var data2 = this.__data__;
        return nativeCreate ? data2[key2] !== void 0 : hasOwnProperty2.call(data2, key2);
      }
      function hashSet(key2, value) {
        var data2 = this.__data__;
        this.size += this.has(key2) ? 0 : 1;
        data2[key2] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
        return this;
      }
      Hash2.prototype.clear = hashClear;
      Hash2.prototype["delete"] = hashDelete;
      Hash2.prototype.get = hashGet;
      Hash2.prototype.has = hashHas;
      Hash2.prototype.set = hashSet;
      function ListCache(entries) {
        var index2 = -1, length2 = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length2) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function listCacheDelete(key2) {
        var data2 = this.__data__, index2 = assocIndexOf(data2, key2);
        if (index2 < 0) {
          return false;
        }
        var lastIndex = data2.length - 1;
        if (index2 == lastIndex) {
          data2.pop();
        } else {
          splice.call(data2, index2, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key2) {
        var data2 = this.__data__, index2 = assocIndexOf(data2, key2);
        return index2 < 0 ? void 0 : data2[index2][1];
      }
      function listCacheHas(key2) {
        return assocIndexOf(this.__data__, key2) > -1;
      }
      function listCacheSet(key2, value) {
        var data2 = this.__data__, index2 = assocIndexOf(data2, key2);
        if (index2 < 0) {
          ++this.size;
          data2.push([key2, value]);
        } else {
          data2[index2][1] = value;
        }
        return this;
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      function MapCache(entries) {
        var index2 = -1, length2 = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length2) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash2(),
          "map": new (Map2 || ListCache)(),
          "string": new Hash2()
        };
      }
      function mapCacheDelete(key2) {
        var result = getMapData(this, key2)["delete"](key2);
        this.size -= result ? 1 : 0;
        return result;
      }
      function mapCacheGet(key2) {
        return getMapData(this, key2).get(key2);
      }
      function mapCacheHas(key2) {
        return getMapData(this, key2).has(key2);
      }
      function mapCacheSet(key2, value) {
        var data2 = getMapData(this, key2), size3 = data2.size;
        data2.set(key2, value);
        this.size += data2.size == size3 ? 0 : 1;
        return this;
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function SetCache(values) {
        var index2 = -1, length2 = values == null ? 0 : values.length;
        this.__data__ = new MapCache();
        while (++index2 < length2) {
          this.add(values[index2]);
        }
      }
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function Stack(entries) {
        var data2 = this.__data__ = new ListCache(entries);
        this.size = data2.size;
      }
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      function stackDelete(key2) {
        var data2 = this.__data__, result = data2["delete"](key2);
        this.size = data2.size;
        return result;
      }
      function stackGet(key2) {
        return this.__data__.get(key2);
      }
      function stackHas(key2) {
        return this.__data__.has(key2);
      }
      function stackSet(key2, value) {
        var data2 = this.__data__;
        if (data2 instanceof ListCache) {
          var pairs = data2.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key2, value]);
            this.size = ++data2.size;
            return this;
          }
          data2 = this.__data__ = new MapCache(pairs);
        }
        data2.set(key2, value);
        this.size = data2.size;
        return this;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer2(value), isType = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length2 = result.length;
        for (var key2 in value) {
          if ((inherited || hasOwnProperty2.call(value, key2)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
          (key2 == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          isBuff && (key2 == "offset" || key2 == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          isType && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || // Skip index properties.
          isIndex(key2, length2)))) {
            result.push(key2);
          }
        }
        return result;
      }
      function assocIndexOf(array, key2) {
        var length2 = array.length;
        while (length2--) {
          if (eq4(array[length2][0], key2)) {
            return length2;
          }
        }
        return -1;
      }
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result = keysFunc(object);
        return isArray2(object) ? result : arrayPush(result, symbolsFunc(object));
      }
      function baseGetTag(value) {
        if (value == null) {
          return value === void 0 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
      }
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
      }
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer2(object)) {
          if (!isBuffer2(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack());
          return objIsArr || isTypedArray2(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack());
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
      }
      function baseIsNative(value) {
        if (!isObject4(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction3(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object);
        }
        var result = [];
        for (var key2 in Object(object)) {
          if (hasOwnProperty2.call(object, key2) && key2 != "constructor") {
            result.push(key2);
          }
        }
        return result;
      }
      function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var stacked = stack.get(array);
        if (stacked && stack.get(other)) {
          return stacked == other;
        }
        var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
        stack.set(array, other);
        stack.set(other, array);
        while (++index2 < arrLength) {
          var arrValue = array[index2], othValue = other[index2];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
          }
          if (compared !== void 0) {
            if (compared) {
              continue;
            }
            result = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result = false;
            break;
          }
        }
        stack["delete"](array);
        stack["delete"](other);
        return result;
      }
      function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq4(+object, +other);
          case errorTag:
            return object.name == other.name && object.message == other.message;
          case regexpTag:
          case stringTag:
            return object == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert || (convert = setToArray);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack.set(object, other);
            var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object);
            return result;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index2 = objLength;
        while (index2--) {
          var key2 = objProps[index2];
          if (!(isPartial ? key2 in other : hasOwnProperty2.call(other, key2))) {
            return false;
          }
        }
        var stacked = stack.get(object);
        if (stacked && stack.get(other)) {
          return stacked == other;
        }
        var result = true;
        stack.set(object, other);
        stack.set(other, object);
        var skipCtor = isPartial;
        while (++index2 < objLength) {
          key2 = objProps[index2];
          var objValue = object[key2], othValue = other[key2];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key2, other, object, stack) : customizer(objValue, othValue, key2, object, other, stack);
          }
          if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result = false;
            break;
          }
          skipCtor || (skipCtor = key2 == "constructor");
        }
        if (result && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result = false;
          }
        }
        stack["delete"](object);
        stack["delete"](other);
        return result;
      }
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys2, getSymbols);
      }
      function getMapData(map, key2) {
        var data2 = map.__data__;
        return isKeyable(key2) ? data2[typeof key2 == "string" ? "string" : "hash"] : data2.map;
      }
      function getNative(object, key2) {
        var value = getValue(object, key2);
        return baseIsNative(value) ? value : void 0;
      }
      function getRawTag(value) {
        var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
        try {
          value[symToStringTag] = void 0;
          var unmasked = true;
        } catch (e9) {
        }
        var result = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result;
      }
      var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
        if (object == null) {
          return [];
        }
        object = Object(object);
        return arrayFilter(nativeGetSymbols(object), function(symbol) {
          return propertyIsEnumerable.call(object, symbol);
        });
      };
      var getTag = baseGetTag;
      if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
        getTag = function(value) {
          var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result;
        };
      }
      function isIndex(value, length2) {
        length2 = length2 == null ? MAX_SAFE_INTEGER2 : length2;
        return !!length2 && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
      }
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value === proto;
      }
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e9) {
          }
          try {
            return func + "";
          } catch (e9) {
          }
        }
        return "";
      }
      function eq4(value, other) {
        return value === other || value !== value && other !== other;
      }
      var isArguments = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      };
      var isArray2 = Array.isArray;
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction3(value);
      }
      var isBuffer2 = nativeIsBuffer || stubFalse;
      function isEqual(value, other) {
        return baseIsEqual(value, other);
      }
      function isFunction3(value) {
        if (!isObject4(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
      }
      function isObject4(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      var isTypedArray2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      function keys2(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      function stubArray() {
        return [];
      }
      function stubFalse() {
        return false;
      }
      module.exports = isEqual;
    }
  });

  // node_modules/@walletconnect/core/dist/index.es.js
  function Vi(r8, e9) {
    if (r8.length >= 255)
      throw new TypeError("Alphabet too long");
    for (var t6 = new Uint8Array(256), i7 = 0; i7 < t6.length; i7++)
      t6[i7] = 255;
    for (var s7 = 0; s7 < r8.length; s7++) {
      var n9 = r8.charAt(s7), o9 = n9.charCodeAt(0);
      if (t6[o9] !== 255)
        throw new TypeError(n9 + " is ambiguous");
      t6[o9] = s7;
    }
    var a6 = r8.length, h10 = r8.charAt(0), l9 = Math.log(a6) / Math.log(256), d7 = Math.log(256) / Math.log(a6);
    function p8(u7) {
      if (u7 instanceof Uint8Array || (ArrayBuffer.isView(u7) ? u7 = new Uint8Array(u7.buffer, u7.byteOffset, u7.byteLength) : Array.isArray(u7) && (u7 = Uint8Array.from(u7))), !(u7 instanceof Uint8Array))
        throw new TypeError("Expected Uint8Array");
      if (u7.length === 0)
        return "";
      for (var m6 = 0, z7 = 0, I5 = 0, _8 = u7.length; I5 !== _8 && u7[I5] === 0; )
        I5++, m6++;
      for (var S12 = (_8 - I5) * d7 + 1 >>> 0, b7 = new Uint8Array(S12); I5 !== _8; ) {
        for (var T6 = u7[I5], A7 = 0, C6 = S12 - 1; (T6 !== 0 || A7 < z7) && C6 !== -1; C6--, A7++)
          T6 += 256 * b7[C6] >>> 0, b7[C6] = T6 % a6 >>> 0, T6 = T6 / a6 >>> 0;
        if (T6 !== 0)
          throw new Error("Non-zero carry");
        z7 = A7, I5++;
      }
      for (var x4 = S12 - z7; x4 !== S12 && b7[x4] === 0; )
        x4++;
      for (var j7 = h10.repeat(m6); x4 < S12; ++x4)
        j7 += r8.charAt(b7[x4]);
      return j7;
    }
    function y11(u7) {
      if (typeof u7 != "string")
        throw new TypeError("Expected String");
      if (u7.length === 0)
        return new Uint8Array();
      var m6 = 0;
      if (u7[m6] !== " ") {
        for (var z7 = 0, I5 = 0; u7[m6] === h10; )
          z7++, m6++;
        for (var _8 = (u7.length - m6) * l9 + 1 >>> 0, S12 = new Uint8Array(_8); u7[m6]; ) {
          var b7 = t6[u7.charCodeAt(m6)];
          if (b7 === 255)
            return;
          for (var T6 = 0, A7 = _8 - 1; (b7 !== 0 || T6 < I5) && A7 !== -1; A7--, T6++)
            b7 += a6 * S12[A7] >>> 0, S12[A7] = b7 % 256 >>> 0, b7 = b7 / 256 >>> 0;
          if (b7 !== 0)
            throw new Error("Non-zero carry");
          I5 = T6, m6++;
        }
        if (u7[m6] !== " ") {
          for (var C6 = _8 - I5; C6 !== _8 && S12[C6] === 0; )
            C6++;
          for (var x4 = new Uint8Array(z7 + (_8 - C6)), j7 = z7; C6 !== _8; )
            x4[j7++] = S12[C6++];
          return x4;
        }
      }
    }
    function M7(u7) {
      var m6 = y11(u7);
      if (m6)
        return m6;
      throw new Error(`Non-${e9} character`);
    }
    return { encode: p8, decodeUnsafe: y11, decode: M7 };
  }
  function Ns(r8) {
    return r8.reduce((e9, t6) => (e9 += As[t6], e9), "");
  }
  function Us(r8) {
    const e9 = [];
    for (const t6 of r8) {
      const i7 = zs[t6.codePointAt(0)];
      if (i7 === void 0)
        throw new Error(`Non-base256emoji character: ${t6}`);
      e9.push(i7);
    }
    return new Uint8Array(e9);
  }
  function $e2(r8, e9, t6) {
    e9 = e9 || [], t6 = t6 || 0;
    for (var i7 = t6; r8 >= Ks; )
      e9[t6++] = r8 & 255 | Fe2, r8 /= 128;
    for (; r8 & ks; )
      e9[t6++] = r8 & 255 | Fe2, r8 >>>= 7;
    return e9[t6] = r8 | 0, $e2.bytes = t6 - i7 + 1, e9;
  }
  function he3(r8, i7) {
    var t6 = 0, i7 = i7 || 0, s7 = 0, n9 = i7, o9, a6 = r8.length;
    do {
      if (n9 >= a6)
        throw he3.bytes = 0, new RangeError("Could not decode varint");
      o9 = r8[n9++], t6 += s7 < 28 ? (o9 & Me2) << s7 : (o9 & Me2) * Math.pow(2, s7), s7 += 7;
    } while (o9 >= Vs);
    return he3.bytes = n9 - i7, t6;
  }
  function He2(r8) {
    return globalThis.Buffer != null ? new Uint8Array(r8.buffer, r8.byteOffset, r8.byteLength) : r8;
  }
  function ur(r8 = 0) {
    return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? He2(globalThis.Buffer.allocUnsafe(r8)) : new Uint8Array(r8);
  }
  function Je2(r8, e9, t6, i7) {
    return { name: r8, prefix: e9, encoder: { name: r8, prefix: e9, encode: t6 }, decoder: { decode: i7 } };
  }
  function dr(r8, e9 = "utf8") {
    const t6 = lr[e9];
    if (!t6)
      throw new Error(`Unsupported encoding "${e9}"`);
    return (e9 === "utf8" || e9 === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? He2(globalThis.Buffer.from(r8, "utf-8")) : t6.decoder.decode(`${t6.prefix}${r8}`);
  }
  var import_events5, import_heartbeat, import_logger, import_time4, import_lodash, qi, ji, Ne, Gi, Yi, Hi, Ji, Wi, Ue2, Xi, X2, B3, Qi, Zi, g2, es, ts, is, ss, rs, ns, os, as, hs, cs, us, ls, ds, gs, ps, Ds, ys, ms, bs, fs, Es, ws2, vs, Is, Cs, Rs, _s, Ss, Ts, Ps, xs, Os, Le, As, zs, Ls, Fs, $s, Fe2, Ms, ks, Ks, Bs, Vs, Me2, qs, js, Gs, Ys, Hs, Js, Ws, Xs, Qs, Zs, er2, ke2, Ke, Be2, ce2, tr2, Ve2, ir, qe2, sr, rr, nr2, je, or2, Ge2, ar, hr, cr, Ye2, We2, ue3, lr, le3, Xe3, Q2, O3, Qe2, Ze2, et, de3, tt, it, st, rt2, nt, ot2, at2, ht2, ct, ge2, pe, ut2, D3, lt2, P, dt2, gt2, pt2, Dt2, yt2, w3, mt2, bt2, ft2, Et2, wt3, F2, V3, R, vt2, It3, Ct, v, Rt2, Z2, $2, ee2, _t, St3, Tt2, Pt2, mr, br, fr, Er, wr, xt2, vr, Ir, Ot3, q, De2, At, Cr, zt2, Rr, _r, Nt2, Sr, Ut, Tr, Lt2, Pr, xr, Ft2, $t, Mt2, kt2, Kt2, Bt2, Vt2, Or, qt2, Ar, zr, jt2, Gt2, te2, Nr;
  var init_index_es5 = __esm({
    "node_modules/@walletconnect/core/dist/index.es.js"() {
      import_events5 = __toESM(require_events());
      init_index_es2();
      import_heartbeat = __toESM(require_cjs4());
      import_logger = __toESM(require_cjs5());
      init_index_es3();
      init_esm2();
      init_esm4();
      init_index_es();
      init_src2();
      import_time4 = __toESM(require_cjs());
      init_esm7();
      init_esm6();
      init_index_es4();
      import_lodash = __toESM(require_lodash());
      qi = Vi;
      ji = qi;
      Ne = (r8) => {
        if (r8 instanceof Uint8Array && r8.constructor.name === "Uint8Array")
          return r8;
        if (r8 instanceof ArrayBuffer)
          return new Uint8Array(r8);
        if (ArrayBuffer.isView(r8))
          return new Uint8Array(r8.buffer, r8.byteOffset, r8.byteLength);
        throw new Error("Unknown type, must be binary type");
      };
      Gi = (r8) => new TextEncoder().encode(r8);
      Yi = (r8) => new TextDecoder().decode(r8);
      Hi = class {
        constructor(e9, t6, i7) {
          this.name = e9, this.prefix = t6, this.baseEncode = i7;
        }
        encode(e9) {
          if (e9 instanceof Uint8Array)
            return `${this.prefix}${this.baseEncode(e9)}`;
          throw Error("Unknown type, must be binary type");
        }
      };
      Ji = class {
        constructor(e9, t6, i7) {
          if (this.name = e9, this.prefix = t6, t6.codePointAt(0) === void 0)
            throw new Error("Invalid prefix character");
          this.prefixCodePoint = t6.codePointAt(0), this.baseDecode = i7;
        }
        decode(e9) {
          if (typeof e9 == "string") {
            if (e9.codePointAt(0) !== this.prefixCodePoint)
              throw Error(`Unable to decode multibase string ${JSON.stringify(e9)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
            return this.baseDecode(e9.slice(this.prefix.length));
          } else
            throw Error("Can only multibase decode strings");
        }
        or(e9) {
          return Ue2(this, e9);
        }
      };
      Wi = class {
        constructor(e9) {
          this.decoders = e9;
        }
        or(e9) {
          return Ue2(this, e9);
        }
        decode(e9) {
          const t6 = e9[0], i7 = this.decoders[t6];
          if (i7)
            return i7.decode(e9);
          throw RangeError(`Unable to decode multibase string ${JSON.stringify(e9)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
        }
      };
      Ue2 = (r8, e9) => new Wi({ ...r8.decoders || { [r8.prefix]: r8 }, ...e9.decoders || { [e9.prefix]: e9 } });
      Xi = class {
        constructor(e9, t6, i7, s7) {
          this.name = e9, this.prefix = t6, this.baseEncode = i7, this.baseDecode = s7, this.encoder = new Hi(e9, t6, i7), this.decoder = new Ji(e9, t6, s7);
        }
        encode(e9) {
          return this.encoder.encode(e9);
        }
        decode(e9) {
          return this.decoder.decode(e9);
        }
      };
      X2 = ({ name: r8, prefix: e9, encode: t6, decode: i7 }) => new Xi(r8, e9, t6, i7);
      B3 = ({ prefix: r8, name: e9, alphabet: t6 }) => {
        const { encode: i7, decode: s7 } = ji(t6, e9);
        return X2({ prefix: r8, name: e9, encode: i7, decode: (n9) => Ne(s7(n9)) });
      };
      Qi = (r8, e9, t6, i7) => {
        const s7 = {};
        for (let d7 = 0; d7 < e9.length; ++d7)
          s7[e9[d7]] = d7;
        let n9 = r8.length;
        for (; r8[n9 - 1] === "="; )
          --n9;
        const o9 = new Uint8Array(n9 * t6 / 8 | 0);
        let a6 = 0, h10 = 0, l9 = 0;
        for (let d7 = 0; d7 < n9; ++d7) {
          const p8 = s7[r8[d7]];
          if (p8 === void 0)
            throw new SyntaxError(`Non-${i7} character`);
          h10 = h10 << t6 | p8, a6 += t6, a6 >= 8 && (a6 -= 8, o9[l9++] = 255 & h10 >> a6);
        }
        if (a6 >= t6 || 255 & h10 << 8 - a6)
          throw new SyntaxError("Unexpected end of data");
        return o9;
      };
      Zi = (r8, e9, t6) => {
        const i7 = e9[e9.length - 1] === "=", s7 = (1 << t6) - 1;
        let n9 = "", o9 = 0, a6 = 0;
        for (let h10 = 0; h10 < r8.length; ++h10)
          for (a6 = a6 << 8 | r8[h10], o9 += 8; o9 > t6; )
            o9 -= t6, n9 += e9[s7 & a6 >> o9];
        if (o9 && (n9 += e9[s7 & a6 << t6 - o9]), i7)
          for (; n9.length * t6 & 7; )
            n9 += "=";
        return n9;
      };
      g2 = ({ name: r8, prefix: e9, bitsPerChar: t6, alphabet: i7 }) => X2({ prefix: e9, name: r8, encode(s7) {
        return Zi(s7, i7, t6);
      }, decode(s7) {
        return Qi(s7, i7, t6, r8);
      } });
      es = X2({ prefix: "\0", name: "identity", encode: (r8) => Yi(r8), decode: (r8) => Gi(r8) });
      ts = Object.freeze({ __proto__: null, identity: es });
      is = g2({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
      ss = Object.freeze({ __proto__: null, base2: is });
      rs = g2({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
      ns = Object.freeze({ __proto__: null, base8: rs });
      os = B3({ prefix: "9", name: "base10", alphabet: "0123456789" });
      as = Object.freeze({ __proto__: null, base10: os });
      hs = g2({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
      cs = g2({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
      us = Object.freeze({ __proto__: null, base16: hs, base16upper: cs });
      ls = g2({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
      ds = g2({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
      gs = g2({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
      ps = g2({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
      Ds = g2({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
      ys = g2({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
      ms = g2({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
      bs = g2({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
      fs = g2({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
      Es = Object.freeze({ __proto__: null, base32: ls, base32upper: ds, base32pad: gs, base32padupper: ps, base32hex: Ds, base32hexupper: ys, base32hexpad: ms, base32hexpadupper: bs, base32z: fs });
      ws2 = B3({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
      vs = B3({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
      Is = Object.freeze({ __proto__: null, base36: ws2, base36upper: vs });
      Cs = B3({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
      Rs = B3({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
      _s = Object.freeze({ __proto__: null, base58btc: Cs, base58flickr: Rs });
      Ss = g2({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
      Ts = g2({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
      Ps = g2({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
      xs = g2({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
      Os = Object.freeze({ __proto__: null, base64: Ss, base64pad: Ts, base64url: Ps, base64urlpad: xs });
      Le = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
      As = Le.reduce((r8, e9, t6) => (r8[t6] = e9, r8), []);
      zs = Le.reduce((r8, e9, t6) => (r8[e9.codePointAt(0)] = t6, r8), []);
      Ls = X2({ prefix: "\u{1F680}", name: "base256emoji", encode: Ns, decode: Us });
      Fs = Object.freeze({ __proto__: null, base256emoji: Ls });
      $s = $e2;
      Fe2 = 128;
      Ms = 127;
      ks = ~Ms;
      Ks = Math.pow(2, 31);
      Bs = he3;
      Vs = 128;
      Me2 = 127;
      qs = Math.pow(2, 7);
      js = Math.pow(2, 14);
      Gs = Math.pow(2, 21);
      Ys = Math.pow(2, 28);
      Hs = Math.pow(2, 35);
      Js = Math.pow(2, 42);
      Ws = Math.pow(2, 49);
      Xs = Math.pow(2, 56);
      Qs = Math.pow(2, 63);
      Zs = function(r8) {
        return r8 < qs ? 1 : r8 < js ? 2 : r8 < Gs ? 3 : r8 < Ys ? 4 : r8 < Hs ? 5 : r8 < Js ? 6 : r8 < Ws ? 7 : r8 < Xs ? 8 : r8 < Qs ? 9 : 10;
      };
      er2 = { encode: $s, decode: Bs, encodingLength: Zs };
      ke2 = er2;
      Ke = (r8, e9, t6 = 0) => (ke2.encode(r8, e9, t6), e9);
      Be2 = (r8) => ke2.encodingLength(r8);
      ce2 = (r8, e9) => {
        const t6 = e9.byteLength, i7 = Be2(r8), s7 = i7 + Be2(t6), n9 = new Uint8Array(s7 + t6);
        return Ke(r8, n9, 0), Ke(t6, n9, i7), n9.set(e9, s7), new tr2(r8, t6, e9, n9);
      };
      tr2 = class {
        constructor(e9, t6, i7, s7) {
          this.code = e9, this.size = t6, this.digest = i7, this.bytes = s7;
        }
      };
      Ve2 = ({ name: r8, code: e9, encode: t6 }) => new ir(r8, e9, t6);
      ir = class {
        constructor(e9, t6, i7) {
          this.name = e9, this.code = t6, this.encode = i7;
        }
        digest(e9) {
          if (e9 instanceof Uint8Array) {
            const t6 = this.encode(e9);
            return t6 instanceof Uint8Array ? ce2(this.code, t6) : t6.then((i7) => ce2(this.code, i7));
          } else
            throw Error("Unknown type, must be binary type");
        }
      };
      qe2 = (r8) => async (e9) => new Uint8Array(await crypto.subtle.digest(r8, e9));
      sr = Ve2({ name: "sha2-256", code: 18, encode: qe2("SHA-256") });
      rr = Ve2({ name: "sha2-512", code: 19, encode: qe2("SHA-512") });
      nr2 = Object.freeze({ __proto__: null, sha256: sr, sha512: rr });
      je = 0;
      or2 = "identity";
      Ge2 = Ne;
      ar = (r8) => ce2(je, Ge2(r8));
      hr = { code: je, name: or2, encode: Ge2, digest: ar };
      cr = Object.freeze({ __proto__: null, identity: hr });
      new TextEncoder(), new TextDecoder();
      Ye2 = { ...ts, ...ss, ...ns, ...as, ...us, ...Es, ...Is, ..._s, ...Os, ...Fs };
      ({ ...nr2, ...cr });
      We2 = Je2("utf8", "u", (r8) => "u" + new TextDecoder("utf8").decode(r8), (r8) => new TextEncoder().encode(r8.substring(1)));
      ue3 = Je2("ascii", "a", (r8) => {
        let e9 = "a";
        for (let t6 = 0; t6 < r8.length; t6++)
          e9 += String.fromCharCode(r8[t6]);
        return e9;
      }, (r8) => {
        r8 = r8.substring(1);
        const e9 = ur(r8.length);
        for (let t6 = 0; t6 < r8.length; t6++)
          e9[t6] = r8.charCodeAt(t6);
        return e9;
      });
      lr = { utf8: We2, "utf-8": We2, hex: Ye2.base16, latin1: ue3, ascii: ue3, binary: ue3, ...Ye2 };
      le3 = "wc";
      Xe3 = 2;
      Q2 = "core";
      O3 = `${le3}@2:${Q2}:`;
      Qe2 = { name: Q2, logger: "error" };
      Ze2 = { database: ":memory:" };
      et = "crypto";
      de3 = "client_ed25519_seed";
      tt = import_time4.ONE_DAY;
      it = "keychain";
      st = "0.3";
      rt2 = "messages";
      nt = "0.3";
      ot2 = import_time4.SIX_HOURS;
      at2 = "publisher";
      ht2 = "irn";
      ct = "error";
      ge2 = "wss://relay.walletconnect.com";
      pe = "wss://relay.walletconnect.org";
      ut2 = "relayer";
      D3 = { message: "relayer_message", message_ack: "relayer_message_ack", connect: "relayer_connect", disconnect: "relayer_disconnect", error: "relayer_error", connection_stalled: "relayer_connection_stalled", transport_closed: "relayer_transport_closed", publish: "relayer_publish" };
      lt2 = "_subscription";
      P = { payload: "payload", connect: "connect", disconnect: "disconnect", error: "error" };
      dt2 = import_time4.ONE_SECOND;
      gt2 = "2.10.6";
      pt2 = 1e4;
      Dt2 = "0.3";
      yt2 = "WALLETCONNECT_CLIENT_ID";
      w3 = { created: "subscription_created", deleted: "subscription_deleted", expired: "subscription_expired", disabled: "subscription_disabled", sync: "subscription_sync", resubscribed: "subscription_resubscribed" };
      mt2 = "subscription";
      bt2 = "0.3";
      ft2 = import_time4.FIVE_SECONDS * 1e3;
      Et2 = "pairing";
      wt3 = "0.3";
      F2 = { wc_pairingDelete: { req: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1e3 }, res: { ttl: import_time4.ONE_DAY, prompt: false, tag: 1001 } }, wc_pairingPing: { req: { ttl: import_time4.THIRTY_SECONDS, prompt: false, tag: 1002 }, res: { ttl: import_time4.THIRTY_SECONDS, prompt: false, tag: 1003 } }, unregistered_method: { req: { ttl: import_time4.ONE_DAY, prompt: false, tag: 0 }, res: { ttl: import_time4.ONE_DAY, prompt: false, tag: 0 } } };
      V3 = { create: "pairing_create", expire: "pairing_expire", delete: "pairing_delete", ping: "pairing_ping" };
      R = { created: "history_created", updated: "history_updated", deleted: "history_deleted", sync: "history_sync" };
      vt2 = "history";
      It3 = "0.3";
      Ct = "expirer";
      v = { created: "expirer_created", deleted: "expirer_deleted", expired: "expirer_expired", sync: "expirer_sync" };
      Rt2 = "0.3";
      Z2 = "verify-api";
      $2 = "https://verify.walletconnect.com";
      ee2 = "https://verify.walletconnect.org";
      _t = [$2, ee2];
      St3 = class {
        constructor(e9, t6) {
          this.core = e9, this.logger = t6, this.keychain = /* @__PURE__ */ new Map(), this.name = it, this.version = st, this.initialized = false, this.storagePrefix = O3, this.init = async () => {
            if (!this.initialized) {
              const i7 = await this.getKeyChain();
              typeof i7 < "u" && (this.keychain = i7), this.initialized = true;
            }
          }, this.has = (i7) => (this.isInitialized(), this.keychain.has(i7)), this.set = async (i7, s7) => {
            this.isInitialized(), this.keychain.set(i7, s7), await this.persist();
          }, this.get = (i7) => {
            this.isInitialized();
            const s7 = this.keychain.get(i7);
            if (typeof s7 > "u") {
              const { message: n9 } = N("NO_MATCHING_KEY", `${this.name}: ${i7}`);
              throw new Error(n9);
            }
            return s7;
          }, this.del = async (i7) => {
            this.isInitialized(), this.keychain.delete(i7), await this.persist();
          }, this.core = e9, this.logger = (0, import_logger.generateChildLogger)(t6, this.name);
        }
        get context() {
          return (0, import_logger.getLoggerContext)(this.logger);
        }
        get storageKey() {
          return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
        }
        async setKeyChain(e9) {
          await this.core.storage.setItem(this.storageKey, rt(e9));
        }
        async getKeyChain() {
          const e9 = await this.core.storage.getItem(this.storageKey);
          return typeof e9 < "u" ? ot(e9) : void 0;
        }
        async persist() {
          await this.setKeyChain(this.keychain);
        }
        isInitialized() {
          if (!this.initialized) {
            const { message: e9 } = N("NOT_INITIALIZED", this.name);
            throw new Error(e9);
          }
        }
      };
      Tt2 = class {
        constructor(e9, t6, i7) {
          this.core = e9, this.logger = t6, this.name = et, this.initialized = false, this.init = async () => {
            this.initialized || (await this.keychain.init(), this.initialized = true);
          }, this.hasKeys = (s7) => (this.isInitialized(), this.keychain.has(s7)), this.getClientId = async () => {
            this.isInitialized();
            const s7 = await this.getClientSeed(), n9 = generateKeyPair3(s7);
            return encodeIss(n9.publicKey);
          }, this.generateKeyPair = () => {
            this.isInitialized();
            const s7 = kn();
            return this.setPrivateKey(s7.publicKey, s7.privateKey);
          }, this.signJWT = async (s7) => {
            this.isInitialized();
            const n9 = await this.getClientSeed(), o9 = generateKeyPair3(n9), a6 = Vn(), h10 = tt;
            return await signJWT(a6, s7, h10, o9);
          }, this.generateSharedKey = (s7, n9, o9) => {
            this.isInitialized();
            const a6 = this.getPrivateKey(s7), h10 = Mn(a6, n9);
            return this.setSymKey(h10, o9);
          }, this.setSymKey = async (s7, n9) => {
            this.isInitialized();
            const o9 = n9 || Kn(s7);
            return await this.keychain.set(o9, s7), o9;
          }, this.deleteKeyPair = async (s7) => {
            this.isInitialized(), await this.keychain.del(s7);
          }, this.deleteSymKey = async (s7) => {
            this.isInitialized(), await this.keychain.del(s7);
          }, this.encode = async (s7, n9, o9) => {
            this.isInitialized();
            const a6 = Te(o9), h10 = safeJsonStringify(n9);
            if (qn(a6)) {
              const y11 = a6.senderPublicKey, M7 = a6.receiverPublicKey;
              s7 = await this.generateSharedKey(y11, M7);
            }
            const l9 = this.getSymKey(s7), { type: d7, senderPublicKey: p8 } = a6;
            return xn({ type: d7, symKey: l9, message: h10, senderPublicKey: p8 });
          }, this.decode = async (s7, n9, o9) => {
            this.isInitialized();
            const a6 = Hn(n9, o9);
            if (qn(a6)) {
              const h10 = a6.receiverPublicKey, l9 = a6.senderPublicKey;
              s7 = await this.generateSharedKey(h10, l9);
            }
            try {
              const h10 = this.getSymKey(s7), l9 = Fn({ symKey: h10, encoded: n9 });
              return safeJsonParse(l9);
            } catch (h10) {
              this.logger.error(`Failed to decode message from topic: '${s7}', clientId: '${await this.getClientId()}'`), this.logger.error(h10);
            }
          }, this.getPayloadType = (s7) => {
            const n9 = ee(s7);
            return $(n9.type);
          }, this.getPayloadSenderPublicKey = (s7) => {
            const n9 = ee(s7);
            return n9.senderPublicKey ? toString2(n9.senderPublicKey, p) : void 0;
          }, this.core = e9, this.logger = (0, import_logger.generateChildLogger)(t6, this.name), this.keychain = i7 || new St3(this.core, this.logger);
        }
        get context() {
          return (0, import_logger.getLoggerContext)(this.logger);
        }
        async setPrivateKey(e9, t6) {
          return await this.keychain.set(e9, t6), e9;
        }
        getPrivateKey(e9) {
          return this.keychain.get(e9);
        }
        async getClientSeed() {
          let e9 = "";
          try {
            e9 = this.keychain.get(de3);
          } catch {
            e9 = Vn(), await this.keychain.set(de3, e9);
          }
          return dr(e9, "base16");
        }
        getSymKey(e9) {
          return this.keychain.get(e9);
        }
        isInitialized() {
          if (!this.initialized) {
            const { message: e9 } = N("NOT_INITIALIZED", this.name);
            throw new Error(e9);
          }
        }
      };
      Pt2 = class extends a {
        constructor(e9, t6) {
          super(e9, t6), this.logger = e9, this.core = t6, this.messages = /* @__PURE__ */ new Map(), this.name = rt2, this.version = nt, this.initialized = false, this.storagePrefix = O3, this.init = async () => {
            if (!this.initialized) {
              this.logger.trace("Initialized");
              try {
                const i7 = await this.getRelayerMessages();
                typeof i7 < "u" && (this.messages = i7), this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", size: this.messages.size });
              } catch (i7) {
                this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(i7);
              } finally {
                this.initialized = true;
              }
            }
          }, this.set = async (i7, s7) => {
            this.isInitialized();
            const n9 = Ln(s7);
            let o9 = this.messages.get(i7);
            return typeof o9 > "u" && (o9 = {}), typeof o9[n9] < "u" || (o9[n9] = s7, this.messages.set(i7, o9), await this.persist()), n9;
          }, this.get = (i7) => {
            this.isInitialized();
            let s7 = this.messages.get(i7);
            return typeof s7 > "u" && (s7 = {}), s7;
          }, this.has = (i7, s7) => {
            this.isInitialized();
            const n9 = this.get(i7), o9 = Ln(s7);
            return typeof n9[o9] < "u";
          }, this.del = async (i7) => {
            this.isInitialized(), this.messages.delete(i7), await this.persist();
          }, this.logger = (0, import_logger.generateChildLogger)(e9, this.name), this.core = t6;
        }
        get context() {
          return (0, import_logger.getLoggerContext)(this.logger);
        }
        get storageKey() {
          return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
        }
        async setRelayerMessages(e9) {
          await this.core.storage.setItem(this.storageKey, rt(e9));
        }
        async getRelayerMessages() {
          const e9 = await this.core.storage.getItem(this.storageKey);
          return typeof e9 < "u" ? ot(e9) : void 0;
        }
        async persist() {
          await this.setRelayerMessages(this.messages);
        }
        isInitialized() {
          if (!this.initialized) {
            const { message: e9 } = N("NOT_INITIALIZED", this.name);
            throw new Error(e9);
          }
        }
      };
      mr = class extends u {
        constructor(e9, t6) {
          super(e9, t6), this.relayer = e9, this.logger = t6, this.events = new import_events5.EventEmitter(), this.name = at2, this.queue = /* @__PURE__ */ new Map(), this.publishTimeout = (0, import_time4.toMiliseconds)(import_time4.TEN_SECONDS), this.needsTransportRestart = false, this.publish = async (i7, s7, n9) => {
            var o9;
            this.logger.debug("Publishing Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: i7, message: s7, opts: n9 } });
            try {
              const a6 = n9?.ttl || ot2, h10 = vt(n9), l9 = n9?.prompt || false, d7 = n9?.tag || 0, p8 = n9?.id || getBigIntRpcId().toString(), y11 = { topic: i7, message: s7, opts: { ttl: a6, relay: h10, prompt: l9, tag: d7, id: p8 } }, M7 = setTimeout(() => this.queue.set(p8, y11), this.publishTimeout);
              try {
                await await ut(this.rpcPublish(i7, s7, a6, h10, l9, d7, p8), this.publishTimeout, "Failed to publish payload, please try again."), this.removeRequestFromQueue(p8), this.relayer.events.emit(D3.publish, y11);
              } catch (u7) {
                if (this.logger.debug("Publishing Payload stalled"), this.needsTransportRestart = true, (o9 = n9?.internal) != null && o9.throwOnFailedPublish)
                  throw this.removeRequestFromQueue(p8), u7;
                return;
              } finally {
                clearTimeout(M7);
              }
              this.logger.debug("Successfully Published Payload"), this.logger.trace({ type: "method", method: "publish", params: { topic: i7, message: s7, opts: n9 } });
            } catch (a6) {
              throw this.logger.debug("Failed to Publish Payload"), this.logger.error(a6), a6;
            }
          }, this.on = (i7, s7) => {
            this.events.on(i7, s7);
          }, this.once = (i7, s7) => {
            this.events.once(i7, s7);
          }, this.off = (i7, s7) => {
            this.events.off(i7, s7);
          }, this.removeListener = (i7, s7) => {
            this.events.removeListener(i7, s7);
          }, this.relayer = e9, this.logger = (0, import_logger.generateChildLogger)(t6, this.name), this.registerEventListeners();
        }
        get context() {
          return (0, import_logger.getLoggerContext)(this.logger);
        }
        rpcPublish(e9, t6, i7, s7, n9, o9, a6) {
          var h10, l9, d7, p8;
          const y11 = { method: Et(s7.protocol).publish, params: { topic: e9, message: t6, ttl: i7, prompt: n9, tag: o9 }, id: a6 };
          return w((h10 = y11.params) == null ? void 0 : h10.prompt) && ((l9 = y11.params) == null || delete l9.prompt), w((d7 = y11.params) == null ? void 0 : d7.tag) && ((p8 = y11.params) == null || delete p8.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "message", direction: "outgoing", request: y11 }), this.relayer.request(y11);
        }
        removeRequestFromQueue(e9) {
          this.queue.delete(e9);
        }
        checkQueue() {
          this.queue.forEach(async (e9) => {
            const { topic: t6, message: i7, opts: s7 } = e9;
            await this.publish(t6, i7, s7);
          });
        }
        registerEventListeners() {
          this.relayer.core.heartbeat.on(import_heartbeat.HEARTBEAT_EVENTS.pulse, () => {
            if (this.needsTransportRestart) {
              this.needsTransportRestart = false, this.relayer.events.emit(D3.connection_stalled);
              return;
            }
            this.checkQueue();
          }), this.relayer.on(D3.message_ack, (e9) => {
            this.removeRequestFromQueue(e9.id.toString());
          });
        }
      };
      br = class {
        constructor() {
          this.map = /* @__PURE__ */ new Map(), this.set = (e9, t6) => {
            const i7 = this.get(e9);
            this.exists(e9, t6) || this.map.set(e9, [...i7, t6]);
          }, this.get = (e9) => this.map.get(e9) || [], this.exists = (e9, t6) => this.get(e9).includes(t6), this.delete = (e9, t6) => {
            if (typeof t6 > "u") {
              this.map.delete(e9);
              return;
            }
            if (!this.map.has(e9))
              return;
            const i7 = this.get(e9);
            if (!this.exists(e9, t6))
              return;
            const s7 = i7.filter((n9) => n9 !== t6);
            if (!s7.length) {
              this.map.delete(e9);
              return;
            }
            this.map.set(e9, s7);
          }, this.clear = () => {
            this.map.clear();
          };
        }
        get topics() {
          return Array.from(this.map.keys());
        }
      };
      fr = Object.defineProperty;
      Er = Object.defineProperties;
      wr = Object.getOwnPropertyDescriptors;
      xt2 = Object.getOwnPropertySymbols;
      vr = Object.prototype.hasOwnProperty;
      Ir = Object.prototype.propertyIsEnumerable;
      Ot3 = (r8, e9, t6) => e9 in r8 ? fr(r8, e9, { enumerable: true, configurable: true, writable: true, value: t6 }) : r8[e9] = t6;
      q = (r8, e9) => {
        for (var t6 in e9 || (e9 = {}))
          vr.call(e9, t6) && Ot3(r8, t6, e9[t6]);
        if (xt2)
          for (var t6 of xt2(e9))
            Ir.call(e9, t6) && Ot3(r8, t6, e9[t6]);
        return r8;
      };
      De2 = (r8, e9) => Er(r8, wr(e9));
      At = class extends d {
        constructor(e9, t6) {
          super(e9, t6), this.relayer = e9, this.logger = t6, this.subscriptions = /* @__PURE__ */ new Map(), this.topicMap = new br(), this.events = new import_events5.EventEmitter(), this.name = mt2, this.version = bt2, this.pending = /* @__PURE__ */ new Map(), this.cached = [], this.initialized = false, this.pendingSubscriptionWatchLabel = "pending_sub_watch_label", this.pollingInterval = 20, this.storagePrefix = O3, this.subscribeTimeout = 1e4, this.restartInProgress = false, this.batchSubscribeTopicsLimit = 500, this.init = async () => {
            this.initialized || (this.logger.trace("Initialized"), this.registerEventListeners(), this.clientId = await this.relayer.core.crypto.getClientId());
          }, this.subscribe = async (i7, s7) => {
            await this.restartToComplete(), this.isInitialized(), this.logger.debug("Subscribing Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i7, opts: s7 } });
            try {
              const n9 = vt(s7), o9 = { topic: i7, relay: n9 };
              this.pending.set(i7, o9);
              const a6 = await this.rpcSubscribe(i7, n9);
              return this.onSubscribe(a6, o9), this.logger.debug("Successfully Subscribed Topic"), this.logger.trace({ type: "method", method: "subscribe", params: { topic: i7, opts: s7 } }), a6;
            } catch (n9) {
              throw this.logger.debug("Failed to Subscribe Topic"), this.logger.error(n9), n9;
            }
          }, this.unsubscribe = async (i7, s7) => {
            await this.restartToComplete(), this.isInitialized(), typeof s7?.id < "u" ? await this.unsubscribeById(i7, s7.id, s7) : await this.unsubscribeByTopic(i7, s7);
          }, this.isSubscribed = async (i7) => this.topics.includes(i7) ? true : await new Promise((s7, n9) => {
            const o9 = new import_time4.Watch();
            o9.start(this.pendingSubscriptionWatchLabel);
            const a6 = setInterval(() => {
              !this.pending.has(i7) && this.topics.includes(i7) && (clearInterval(a6), o9.stop(this.pendingSubscriptionWatchLabel), s7(true)), o9.elapsed(this.pendingSubscriptionWatchLabel) >= ft2 && (clearInterval(a6), o9.stop(this.pendingSubscriptionWatchLabel), n9(new Error("Subscription resolution timeout")));
            }, this.pollingInterval);
          }).catch(() => false), this.on = (i7, s7) => {
            this.events.on(i7, s7);
          }, this.once = (i7, s7) => {
            this.events.once(i7, s7);
          }, this.off = (i7, s7) => {
            this.events.off(i7, s7);
          }, this.removeListener = (i7, s7) => {
            this.events.removeListener(i7, s7);
          }, this.restart = async () => {
            this.restartInProgress = true, await this.restore(), await this.reset(), this.restartInProgress = false;
          }, this.relayer = e9, this.logger = (0, import_logger.generateChildLogger)(t6, this.name), this.clientId = "";
        }
        get context() {
          return (0, import_logger.getLoggerContext)(this.logger);
        }
        get storageKey() {
          return this.storagePrefix + this.version + this.relayer.core.customStoragePrefix + "//" + this.name;
        }
        get length() {
          return this.subscriptions.size;
        }
        get ids() {
          return Array.from(this.subscriptions.keys());
        }
        get values() {
          return Array.from(this.subscriptions.values());
        }
        get topics() {
          return this.topicMap.topics;
        }
        hasSubscription(e9, t6) {
          let i7 = false;
          try {
            i7 = this.getSubscription(e9).topic === t6;
          } catch {
          }
          return i7;
        }
        onEnable() {
          this.cached = [], this.initialized = true;
        }
        onDisable() {
          this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear();
        }
        async unsubscribeByTopic(e9, t6) {
          const i7 = this.topicMap.get(e9);
          await Promise.all(i7.map(async (s7) => await this.unsubscribeById(e9, s7, t6)));
        }
        async unsubscribeById(e9, t6, i7) {
          this.logger.debug("Unsubscribing Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e9, id: t6, opts: i7 } });
          try {
            const s7 = vt(i7);
            await this.rpcUnsubscribe(e9, t6, s7);
            const n9 = U("USER_DISCONNECTED", `${this.name}, ${e9}`);
            await this.onUnsubscribe(e9, t6, n9), this.logger.debug("Successfully Unsubscribed Topic"), this.logger.trace({ type: "method", method: "unsubscribe", params: { topic: e9, id: t6, opts: i7 } });
          } catch (s7) {
            throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(s7), s7;
          }
        }
        async rpcSubscribe(e9, t6) {
          const i7 = { method: Et(t6.protocol).subscribe, params: { topic: e9 } };
          this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i7 });
          try {
            await await ut(this.relayer.request(i7), this.subscribeTimeout);
          } catch {
            this.logger.debug("Outgoing Relay Subscribe Payload stalled"), this.relayer.events.emit(D3.connection_stalled);
          }
          return Ln(e9 + this.clientId);
        }
        async rpcBatchSubscribe(e9) {
          if (!e9.length)
            return;
          const t6 = e9[0].relay, i7 = { method: Et(t6.protocol).batchSubscribe, params: { topics: e9.map((s7) => s7.topic) } };
          this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: i7 });
          try {
            return await await ut(this.relayer.request(i7), this.subscribeTimeout);
          } catch {
            this.logger.debug("Outgoing Relay Payload stalled"), this.relayer.events.emit(D3.connection_stalled);
          }
        }
        rpcUnsubscribe(e9, t6, i7) {
          const s7 = { method: Et(i7.protocol).unsubscribe, params: { topic: e9, id: t6 } };
          return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({ type: "payload", direction: "outgoing", request: s7 }), this.relayer.request(s7);
        }
        onSubscribe(e9, t6) {
          this.setSubscription(e9, De2(q({}, t6), { id: e9 })), this.pending.delete(t6.topic);
        }
        onBatchSubscribe(e9) {
          e9.length && e9.forEach((t6) => {
            this.setSubscription(t6.id, q({}, t6)), this.pending.delete(t6.topic);
          });
        }
        async onUnsubscribe(e9, t6, i7) {
          this.events.removeAllListeners(t6), this.hasSubscription(t6, e9) && this.deleteSubscription(t6, i7), await this.relayer.messages.del(e9);
        }
        async setRelayerSubscriptions(e9) {
          await this.relayer.core.storage.setItem(this.storageKey, e9);
        }
        async getRelayerSubscriptions() {
          return await this.relayer.core.storage.getItem(this.storageKey);
        }
        setSubscription(e9, t6) {
          this.subscriptions.has(e9) || (this.logger.debug("Setting subscription"), this.logger.trace({ type: "method", method: "setSubscription", id: e9, subscription: t6 }), this.addSubscription(e9, t6));
        }
        addSubscription(e9, t6) {
          this.subscriptions.set(e9, q({}, t6)), this.topicMap.set(t6.topic, e9), this.events.emit(w3.created, t6);
        }
        getSubscription(e9) {
          this.logger.debug("Getting subscription"), this.logger.trace({ type: "method", method: "getSubscription", id: e9 });
          const t6 = this.subscriptions.get(e9);
          if (!t6) {
            const { message: i7 } = N("NO_MATCHING_KEY", `${this.name}: ${e9}`);
            throw new Error(i7);
          }
          return t6;
        }
        deleteSubscription(e9, t6) {
          this.logger.debug("Deleting subscription"), this.logger.trace({ type: "method", method: "deleteSubscription", id: e9, reason: t6 });
          const i7 = this.getSubscription(e9);
          this.subscriptions.delete(e9), this.topicMap.delete(i7.topic, e9), this.events.emit(w3.deleted, De2(q({}, i7), { reason: t6 }));
        }
        async persist() {
          await this.setRelayerSubscriptions(this.values), this.events.emit(w3.sync);
        }
        async reset() {
          if (this.cached.length) {
            const e9 = Math.ceil(this.cached.length / this.batchSubscribeTopicsLimit);
            for (let t6 = 0; t6 < e9; t6++) {
              const i7 = this.cached.splice(0, this.batchSubscribeTopicsLimit);
              await this.batchSubscribe(i7);
            }
          }
          this.events.emit(w3.resubscribed);
        }
        async restore() {
          try {
            const e9 = await this.getRelayerSubscriptions();
            if (typeof e9 > "u" || !e9.length)
              return;
            if (this.subscriptions.size) {
              const { message: t6 } = N("RESTORE_WILL_OVERRIDE", this.name);
              throw this.logger.error(t6), this.logger.error(`${this.name}: ${JSON.stringify(this.values)}`), new Error(t6);
            }
            this.cached = e9, this.logger.debug(`Successfully Restored subscriptions for ${this.name}`), this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
          } catch (e9) {
            this.logger.debug(`Failed to Restore subscriptions for ${this.name}`), this.logger.error(e9);
          }
        }
        async batchSubscribe(e9) {
          if (!e9.length)
            return;
          const t6 = await this.rpcBatchSubscribe(e9);
          k(t6) && this.onBatchSubscribe(t6.map((i7, s7) => De2(q({}, e9[s7]), { id: i7 })));
        }
        async onConnect() {
          this.restartInProgress || (await this.restart(), this.onEnable());
        }
        onDisconnect() {
          this.onDisable();
        }
        async checkPending() {
          if (!this.initialized || this.relayer.transportExplicitlyClosed)
            return;
          const e9 = [];
          this.pending.forEach((t6) => {
            e9.push(t6);
          }), await this.batchSubscribe(e9);
        }
        registerEventListeners() {
          this.relayer.core.heartbeat.on(import_heartbeat.HEARTBEAT_EVENTS.pulse, async () => {
            await this.checkPending();
          }), this.relayer.on(D3.connect, async () => {
            await this.onConnect();
          }), this.relayer.on(D3.disconnect, () => {
            this.onDisconnect();
          }), this.events.on(w3.created, async (e9) => {
            const t6 = w3.created;
            this.logger.info(`Emitting ${t6}`), this.logger.debug({ type: "event", event: t6, data: e9 }), await this.persist();
          }), this.events.on(w3.deleted, async (e9) => {
            const t6 = w3.deleted;
            this.logger.info(`Emitting ${t6}`), this.logger.debug({ type: "event", event: t6, data: e9 }), await this.persist();
          });
        }
        isInitialized() {
          if (!this.initialized) {
            const { message: e9 } = N("NOT_INITIALIZED", this.name);
            throw new Error(e9);
          }
        }
        async restartToComplete() {
          this.restartInProgress && await new Promise((e9) => {
            const t6 = setInterval(() => {
              this.restartInProgress || (clearInterval(t6), e9());
            }, this.pollingInterval);
          });
        }
      };
      Cr = Object.defineProperty;
      zt2 = Object.getOwnPropertySymbols;
      Rr = Object.prototype.hasOwnProperty;
      _r = Object.prototype.propertyIsEnumerable;
      Nt2 = (r8, e9, t6) => e9 in r8 ? Cr(r8, e9, { enumerable: true, configurable: true, writable: true, value: t6 }) : r8[e9] = t6;
      Sr = (r8, e9) => {
        for (var t6 in e9 || (e9 = {}))
          Rr.call(e9, t6) && Nt2(r8, t6, e9[t6]);
        if (zt2)
          for (var t6 of zt2(e9))
            _r.call(e9, t6) && Nt2(r8, t6, e9[t6]);
        return r8;
      };
      Ut = class extends g {
        constructor(e9) {
          super(e9), this.protocol = "wc", this.version = 2, this.events = new import_events5.EventEmitter(), this.name = ut2, this.transportExplicitlyClosed = false, this.initialized = false, this.connectionAttemptInProgress = false, this.connectionStatusPollingInterval = 20, this.staleConnectionErrors = ["socket hang up", "socket stalled"], this.hasExperiencedNetworkDisruption = false, this.request = async (t6) => {
            this.logger.debug("Publishing Request Payload");
            try {
              return await this.toEstablishConnection(), await this.provider.request(t6);
            } catch (i7) {
              throw this.logger.debug("Failed to Publish Request"), this.logger.error(i7), i7;
            }
          }, this.onPayloadHandler = (t6) => {
            this.onProviderPayload(t6);
          }, this.onConnectHandler = () => {
            this.events.emit(D3.connect);
          }, this.onDisconnectHandler = () => {
            this.onProviderDisconnect();
          }, this.onProviderErrorHandler = (t6) => {
            this.logger.error(t6), this.events.emit(D3.error, t6), this.logger.info("Fatal socket error received, closing transport"), this.transportClose();
          }, this.registerProviderListeners = () => {
            this.provider.on(P.payload, this.onPayloadHandler), this.provider.on(P.connect, this.onConnectHandler), this.provider.on(P.disconnect, this.onDisconnectHandler), this.provider.on(P.error, this.onProviderErrorHandler);
          }, this.core = e9.core, this.logger = typeof e9.logger < "u" && typeof e9.logger != "string" ? (0, import_logger.generateChildLogger)(e9.logger, this.name) : (0, import_logger.pino)((0, import_logger.getDefaultLoggerOptions)({ level: e9.logger || ct })), this.messages = new Pt2(this.logger, e9.core), this.subscriber = new At(this, this.logger), this.publisher = new mr(this, this.logger), this.relayUrl = e9?.relayUrl || ge2, this.projectId = e9.projectId, this.bundleId = Jn(), this.provider = {};
        }
        async init() {
          this.logger.trace("Initialized"), this.registerEventListeners(), await this.createProvider(), await Promise.all([this.messages.init(), this.subscriber.init()]);
          try {
            await this.transportOpen();
          } catch {
            this.logger.warn(`Connection via ${this.relayUrl} failed, attempting to connect via failover domain ${pe}...`), await this.restartTransport(pe);
          }
          this.initialized = true, setTimeout(async () => {
            this.subscriber.topics.length === 0 && (this.logger.info("No topics subscribed to after init, closing transport"), await this.transportClose(), this.transportExplicitlyClosed = false);
          }, pt2);
        }
        get context() {
          return (0, import_logger.getLoggerContext)(this.logger);
        }
        get connected() {
          return this.provider.connection.connected;
        }
        get connecting() {
          return this.provider.connection.connecting;
        }
        async publish(e9, t6, i7) {
          this.isInitialized(), await this.publisher.publish(e9, t6, i7), await this.recordMessageEvent({ topic: e9, message: t6, publishedAt: Date.now() });
        }
        async subscribe(e9, t6) {
          var i7;
          this.isInitialized();
          let s7 = ((i7 = this.subscriber.topicMap.get(e9)) == null ? void 0 : i7[0]) || "";
          if (s7)
            return s7;
          let n9;
          const o9 = (a6) => {
            a6.topic === e9 && (this.subscriber.off(w3.created, o9), n9());
          };
          return await Promise.all([new Promise((a6) => {
            n9 = a6, this.subscriber.on(w3.created, o9);
          }), new Promise(async (a6) => {
            s7 = await this.subscriber.subscribe(e9, t6), a6();
          })]), s7;
        }
        async unsubscribe(e9, t6) {
          this.isInitialized(), await this.subscriber.unsubscribe(e9, t6);
        }
        on(e9, t6) {
          this.events.on(e9, t6);
        }
        once(e9, t6) {
          this.events.once(e9, t6);
        }
        off(e9, t6) {
          this.events.off(e9, t6);
        }
        removeListener(e9, t6) {
          this.events.removeListener(e9, t6);
        }
        async transportClose() {
          this.transportExplicitlyClosed = true, this.hasExperiencedNetworkDisruption && this.connected ? await ut(this.provider.disconnect(), 1e3, "provider.disconnect()").catch(() => this.onProviderDisconnect()) : this.connected && await this.provider.disconnect();
        }
        async transportOpen(e9) {
          if (this.transportExplicitlyClosed = false, await this.confirmOnlineStateOrThrow(), !this.connectionAttemptInProgress) {
            e9 && e9 !== this.relayUrl && (this.relayUrl = e9, await this.transportClose(), await this.createProvider()), this.connectionAttemptInProgress = true;
            try {
              await Promise.all([new Promise((t6) => {
                if (!this.initialized)
                  return t6();
                this.subscriber.once(w3.resubscribed, () => {
                  t6();
                });
              }), new Promise(async (t6, i7) => {
                try {
                  await ut(this.provider.connect(), 1e4, `Socket stalled when trying to connect to ${this.relayUrl}`);
                } catch (s7) {
                  i7(s7);
                  return;
                }
                t6();
              })]);
            } catch (t6) {
              this.logger.error(t6);
              const i7 = t6;
              if (!this.isConnectionStalled(i7.message))
                throw t6;
              this.provider.events.emit(P.disconnect);
            } finally {
              this.connectionAttemptInProgress = false, this.hasExperiencedNetworkDisruption = false;
            }
          }
        }
        async restartTransport(e9) {
          await this.confirmOnlineStateOrThrow(), !this.connectionAttemptInProgress && (this.relayUrl = e9 || this.relayUrl, await this.transportClose(), await this.createProvider(), await this.transportOpen());
        }
        async confirmOnlineStateOrThrow() {
          if (!await er())
            throw new Error("No internet connection detected. Please restart your network and try again.");
        }
        isConnectionStalled(e9) {
          return this.staleConnectionErrors.some((t6) => e9.includes(t6));
        }
        async createProvider() {
          this.provider.connection && this.unregisterProviderListeners();
          const e9 = await this.core.crypto.signJWT(this.relayUrl);
          this.provider = new JsonRpcProvider(new f(Xn({ sdkVersion: gt2, protocol: this.protocol, version: this.version, relayUrl: this.relayUrl, projectId: this.projectId, auth: e9, useOnCloseEvent: true, bundleId: this.bundleId }))), this.registerProviderListeners();
        }
        async recordMessageEvent(e9) {
          const { topic: t6, message: i7 } = e9;
          await this.messages.set(t6, i7);
        }
        async shouldIgnoreMessageEvent(e9) {
          const { topic: t6, message: i7 } = e9;
          if (!i7 || i7.length === 0)
            return this.logger.debug(`Ignoring invalid/empty message: ${i7}`), true;
          if (!await this.subscriber.isSubscribed(t6))
            return this.logger.debug(`Ignoring message for non-subscribed topic ${t6}`), true;
          const s7 = this.messages.has(t6, i7);
          return s7 && this.logger.debug(`Ignoring duplicate message: ${i7}`), s7;
        }
        async onProviderPayload(e9) {
          if (this.logger.debug("Incoming Relay Payload"), this.logger.trace({ type: "payload", direction: "incoming", payload: e9 }), isJsonRpcRequest(e9)) {
            if (!e9.method.endsWith(lt2))
              return;
            const t6 = e9.params, { topic: i7, message: s7, publishedAt: n9 } = t6.data, o9 = { topic: i7, message: s7, publishedAt: n9 };
            this.logger.debug("Emitting Relayer Payload"), this.logger.trace(Sr({ type: "event", event: t6.id }, o9)), this.events.emit(t6.id, o9), await this.acknowledgePayload(e9), await this.onMessageEvent(o9);
          } else
            isJsonRpcResponse(e9) && this.events.emit(D3.message_ack, e9);
        }
        async onMessageEvent(e9) {
          await this.shouldIgnoreMessageEvent(e9) || (this.events.emit(D3.message, e9), await this.recordMessageEvent(e9));
        }
        async acknowledgePayload(e9) {
          const t6 = formatJsonRpcResult(e9.id, true);
          await this.provider.connection.send(t6);
        }
        unregisterProviderListeners() {
          this.provider.off(P.payload, this.onPayloadHandler), this.provider.off(P.connect, this.onConnectHandler), this.provider.off(P.disconnect, this.onDisconnectHandler), this.provider.off(P.error, this.onProviderErrorHandler);
        }
        async registerEventListeners() {
          this.events.on(D3.connection_stalled, () => {
            this.restartTransport().catch((t6) => this.logger.error(t6));
          });
          let e9 = await er();
          nr(async (t6) => {
            this.initialized && e9 !== t6 && (e9 = t6, t6 ? await this.restartTransport().catch((i7) => this.logger.error(i7)) : (this.hasExperiencedNetworkDisruption = true, await this.transportClose().catch((i7) => this.logger.error(i7))));
          });
        }
        onProviderDisconnect() {
          this.events.emit(D3.disconnect), this.attemptToReconnect();
        }
        attemptToReconnect() {
          this.transportExplicitlyClosed || (this.logger.info("attemptToReconnect called. Connecting..."), setTimeout(async () => {
            await this.restartTransport().catch((e9) => this.logger.error(e9));
          }, (0, import_time4.toMiliseconds)(dt2)));
        }
        isInitialized() {
          if (!this.initialized) {
            const { message: e9 } = N("NOT_INITIALIZED", this.name);
            throw new Error(e9);
          }
        }
        async toEstablishConnection() {
          if (await this.confirmOnlineStateOrThrow(), !this.connected) {
            if (this.connectionAttemptInProgress)
              return await new Promise((e9) => {
                const t6 = setInterval(() => {
                  this.connected && (clearInterval(t6), e9());
                }, this.connectionStatusPollingInterval);
              });
            await this.restartTransport();
          }
        }
      };
      Tr = Object.defineProperty;
      Lt2 = Object.getOwnPropertySymbols;
      Pr = Object.prototype.hasOwnProperty;
      xr = Object.prototype.propertyIsEnumerable;
      Ft2 = (r8, e9, t6) => e9 in r8 ? Tr(r8, e9, { enumerable: true, configurable: true, writable: true, value: t6 }) : r8[e9] = t6;
      $t = (r8, e9) => {
        for (var t6 in e9 || (e9 = {}))
          Pr.call(e9, t6) && Ft2(r8, t6, e9[t6]);
        if (Lt2)
          for (var t6 of Lt2(e9))
            xr.call(e9, t6) && Ft2(r8, t6, e9[t6]);
        return r8;
      };
      Mt2 = class extends p2 {
        constructor(e9, t6, i7, s7 = O3, n9 = void 0) {
          super(e9, t6, i7, s7), this.core = e9, this.logger = t6, this.name = i7, this.map = /* @__PURE__ */ new Map(), this.version = Dt2, this.cached = [], this.initialized = false, this.storagePrefix = O3, this.init = async () => {
            this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((o9) => {
              this.getKey && o9 !== null && !w(o9) ? this.map.set(this.getKey(o9), o9) : Vt(o9) ? this.map.set(o9.id, o9) : Mt(o9) && this.map.set(o9.topic, o9);
            }), this.cached = [], this.initialized = true);
          }, this.set = async (o9, a6) => {
            this.isInitialized(), this.map.has(o9) ? await this.update(o9, a6) : (this.logger.debug("Setting value"), this.logger.trace({ type: "method", method: "set", key: o9, value: a6 }), this.map.set(o9, a6), await this.persist());
          }, this.get = (o9) => (this.isInitialized(), this.logger.debug("Getting value"), this.logger.trace({ type: "method", method: "get", key: o9 }), this.getData(o9)), this.getAll = (o9) => (this.isInitialized(), o9 ? this.values.filter((a6) => Object.keys(o9).every((h10) => (0, import_lodash.default)(a6[h10], o9[h10]))) : this.values), this.update = async (o9, a6) => {
            this.isInitialized(), this.logger.debug("Updating value"), this.logger.trace({ type: "method", method: "update", key: o9, update: a6 });
            const h10 = $t($t({}, this.getData(o9)), a6);
            this.map.set(o9, h10), await this.persist();
          }, this.delete = async (o9, a6) => {
            this.isInitialized(), this.map.has(o9) && (this.logger.debug("Deleting value"), this.logger.trace({ type: "method", method: "delete", key: o9, reason: a6 }), this.map.delete(o9), await this.persist());
          }, this.logger = (0, import_logger.generateChildLogger)(t6, this.name), this.storagePrefix = s7, this.getKey = n9;
        }
        get context() {
          return (0, import_logger.getLoggerContext)(this.logger);
        }
        get storageKey() {
          return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
        }
        get length() {
          return this.map.size;
        }
        get keys() {
          return Array.from(this.map.keys());
        }
        get values() {
          return Array.from(this.map.values());
        }
        async setDataStore(e9) {
          await this.core.storage.setItem(this.storageKey, e9);
        }
        async getDataStore() {
          return await this.core.storage.getItem(this.storageKey);
        }
        getData(e9) {
          const t6 = this.map.get(e9);
          if (!t6) {
            const { message: i7 } = N("NO_MATCHING_KEY", `${this.name}: ${e9}`);
            throw this.logger.error(i7), new Error(i7);
          }
          return t6;
        }
        async persist() {
          await this.setDataStore(this.values);
        }
        async restore() {
          try {
            const e9 = await this.getDataStore();
            if (typeof e9 > "u" || !e9.length)
              return;
            if (this.map.size) {
              const { message: t6 } = N("RESTORE_WILL_OVERRIDE", this.name);
              throw this.logger.error(t6), new Error(t6);
            }
            this.cached = e9, this.logger.debug(`Successfully Restored value for ${this.name}`), this.logger.trace({ type: "method", method: "restore", value: this.values });
          } catch (e9) {
            this.logger.debug(`Failed to Restore value for ${this.name}`), this.logger.error(e9);
          }
        }
        isInitialized() {
          if (!this.initialized) {
            const { message: e9 } = N("NOT_INITIALIZED", this.name);
            throw new Error(e9);
          }
        }
      };
      kt2 = class {
        constructor(e9, t6) {
          this.core = e9, this.logger = t6, this.name = Et2, this.version = wt3, this.events = new import_events5.default(), this.initialized = false, this.storagePrefix = O3, this.ignoredPayloadTypes = [_], this.registeredMethods = [], this.init = async () => {
            this.initialized || (await this.pairings.init(), await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.initialized = true, this.logger.trace("Initialized"));
          }, this.register = ({ methods: i7 }) => {
            this.isInitialized(), this.registeredMethods = [.../* @__PURE__ */ new Set([...this.registeredMethods, ...i7])];
          }, this.create = async () => {
            this.isInitialized();
            const i7 = Vn(), s7 = await this.core.crypto.setSymKey(i7), n9 = pt(import_time4.FIVE_MINUTES), o9 = { protocol: ht2 }, a6 = { topic: s7, expiry: n9, relay: o9, active: false }, h10 = It2({ protocol: this.core.protocol, version: this.core.version, topic: s7, symKey: i7, relay: o9 });
            return await this.pairings.set(s7, a6), await this.core.relayer.subscribe(s7), this.core.expirer.set(s7, n9), { topic: s7, uri: h10 };
          }, this.pair = async (i7) => {
            this.isInitialized(), this.isValidPair(i7);
            const { topic: s7, symKey: n9, relay: o9 } = wt2(i7.uri);
            let a6;
            if (this.pairings.keys.includes(s7) && (a6 = this.pairings.get(s7), a6.active))
              throw new Error(`Pairing already exists: ${s7}. Please try again with a new connection URI.`);
            const h10 = pt(import_time4.FIVE_MINUTES), l9 = { topic: s7, relay: o9, expiry: h10, active: false };
            return await this.pairings.set(s7, l9), this.core.expirer.set(s7, h10), i7.activatePairing && await this.activate({ topic: s7 }), this.events.emit(V3.create, l9), this.core.crypto.keychain.has(s7) || (await this.core.crypto.setSymKey(n9, s7), await this.core.relayer.subscribe(s7, { relay: o9 })), l9;
          }, this.activate = async ({ topic: i7 }) => {
            this.isInitialized();
            const s7 = pt(import_time4.THIRTY_DAYS);
            await this.pairings.update(i7, { active: true, expiry: s7 }), this.core.expirer.set(i7, s7);
          }, this.ping = async (i7) => {
            this.isInitialized(), await this.isValidPing(i7);
            const { topic: s7 } = i7;
            if (this.pairings.keys.includes(s7)) {
              const n9 = await this.sendRequest(s7, "wc_pairingPing", {}), { done: o9, resolve: a6, reject: h10 } = at();
              this.events.once(yt("pairing_ping", n9), ({ error: l9 }) => {
                l9 ? h10(l9) : a6();
              }), await o9();
            }
          }, this.updateExpiry = async ({ topic: i7, expiry: s7 }) => {
            this.isInitialized(), await this.pairings.update(i7, { expiry: s7 });
          }, this.updateMetadata = async ({ topic: i7, metadata: s7 }) => {
            this.isInitialized(), await this.pairings.update(i7, { peerMetadata: s7 });
          }, this.getPairings = () => (this.isInitialized(), this.pairings.values), this.disconnect = async (i7) => {
            this.isInitialized(), await this.isValidDisconnect(i7);
            const { topic: s7 } = i7;
            this.pairings.keys.includes(s7) && (await this.sendRequest(s7, "wc_pairingDelete", U("USER_DISCONNECTED")), await this.deletePairing(s7));
          }, this.sendRequest = async (i7, s7, n9) => {
            const o9 = formatJsonRpcRequest(s7, n9), a6 = await this.core.crypto.encode(i7, o9), h10 = F2[s7].req;
            return this.core.history.set(i7, o9), this.core.relayer.publish(i7, a6, h10), o9.id;
          }, this.sendResult = async (i7, s7, n9) => {
            const o9 = formatJsonRpcResult(i7, n9), a6 = await this.core.crypto.encode(s7, o9), h10 = await this.core.history.get(s7, i7), l9 = F2[h10.request.method].res;
            await this.core.relayer.publish(s7, a6, l9), await this.core.history.resolve(o9);
          }, this.sendError = async (i7, s7, n9) => {
            const o9 = formatJsonRpcError(i7, n9), a6 = await this.core.crypto.encode(s7, o9), h10 = await this.core.history.get(s7, i7), l9 = F2[h10.request.method] ? F2[h10.request.method].res : F2.unregistered_method.res;
            await this.core.relayer.publish(s7, a6, l9), await this.core.history.resolve(o9);
          }, this.deletePairing = async (i7, s7) => {
            await this.core.relayer.unsubscribe(i7), await Promise.all([this.pairings.delete(i7, U("USER_DISCONNECTED")), this.core.crypto.deleteSymKey(i7), s7 ? Promise.resolve() : this.core.expirer.del(i7)]);
          }, this.cleanup = async () => {
            const i7 = this.pairings.getAll().filter((s7) => mt(s7.expiry));
            await Promise.all(i7.map((s7) => this.deletePairing(s7.topic)));
          }, this.onRelayEventRequest = (i7) => {
            const { topic: s7, payload: n9 } = i7;
            switch (n9.method) {
              case "wc_pairingPing":
                return this.onPairingPingRequest(s7, n9);
              case "wc_pairingDelete":
                return this.onPairingDeleteRequest(s7, n9);
              default:
                return this.onUnknownRpcMethodRequest(s7, n9);
            }
          }, this.onRelayEventResponse = async (i7) => {
            const { topic: s7, payload: n9 } = i7, o9 = (await this.core.history.get(s7, n9.id)).request.method;
            switch (o9) {
              case "wc_pairingPing":
                return this.onPairingPingResponse(s7, n9);
              default:
                return this.onUnknownRpcMethodResponse(o9);
            }
          }, this.onPairingPingRequest = async (i7, s7) => {
            const { id: n9 } = s7;
            try {
              this.isValidPing({ topic: i7 }), await this.sendResult(n9, i7, true), this.events.emit(V3.ping, { id: n9, topic: i7 });
            } catch (o9) {
              await this.sendError(n9, i7, o9), this.logger.error(o9);
            }
          }, this.onPairingPingResponse = (i7, s7) => {
            const { id: n9 } = s7;
            setTimeout(() => {
              isJsonRpcResult(s7) ? this.events.emit(yt("pairing_ping", n9), {}) : isJsonRpcError(s7) && this.events.emit(yt("pairing_ping", n9), { error: s7.error });
            }, 500);
          }, this.onPairingDeleteRequest = async (i7, s7) => {
            const { id: n9 } = s7;
            try {
              this.isValidDisconnect({ topic: i7 }), await this.deletePairing(i7), this.events.emit(V3.delete, { id: n9, topic: i7 });
            } catch (o9) {
              await this.sendError(n9, i7, o9), this.logger.error(o9);
            }
          }, this.onUnknownRpcMethodRequest = async (i7, s7) => {
            const { id: n9, method: o9 } = s7;
            try {
              if (this.registeredMethods.includes(o9))
                return;
              const a6 = U("WC_METHOD_UNSUPPORTED", o9);
              await this.sendError(n9, i7, a6), this.logger.error(a6);
            } catch (a6) {
              await this.sendError(n9, i7, a6), this.logger.error(a6);
            }
          }, this.onUnknownRpcMethodResponse = (i7) => {
            this.registeredMethods.includes(i7) || this.logger.error(U("WC_METHOD_UNSUPPORTED", i7));
          }, this.isValidPair = (i7) => {
            var s7;
            if (!Ht(i7)) {
              const { message: o9 } = N("MISSING_OR_INVALID", `pair() params: ${i7}`);
              throw new Error(o9);
            }
            if (!kt(i7.uri)) {
              const { message: o9 } = N("MISSING_OR_INVALID", `pair() uri: ${i7.uri}`);
              throw new Error(o9);
            }
            const n9 = wt2(i7.uri);
            if (!((s7 = n9?.relay) != null && s7.protocol)) {
              const { message: o9 } = N("MISSING_OR_INVALID", "pair() uri#relay-protocol");
              throw new Error(o9);
            }
            if (!(n9 != null && n9.symKey)) {
              const { message: o9 } = N("MISSING_OR_INVALID", "pair() uri#symKey");
              throw new Error(o9);
            }
          }, this.isValidPing = async (i7) => {
            if (!Ht(i7)) {
              const { message: n9 } = N("MISSING_OR_INVALID", `ping() params: ${i7}`);
              throw new Error(n9);
            }
            const { topic: s7 } = i7;
            await this.isValidPairingTopic(s7);
          }, this.isValidDisconnect = async (i7) => {
            if (!Ht(i7)) {
              const { message: n9 } = N("MISSING_OR_INVALID", `disconnect() params: ${i7}`);
              throw new Error(n9);
            }
            const { topic: s7 } = i7;
            await this.isValidPairingTopic(s7);
          }, this.isValidPairingTopic = async (i7) => {
            if (!h(i7, false)) {
              const { message: s7 } = N("MISSING_OR_INVALID", `pairing topic should be a string: ${i7}`);
              throw new Error(s7);
            }
            if (!this.pairings.keys.includes(i7)) {
              const { message: s7 } = N("NO_MATCHING_KEY", `pairing topic doesn't exist: ${i7}`);
              throw new Error(s7);
            }
            if (mt(this.pairings.get(i7).expiry)) {
              await this.deletePairing(i7);
              const { message: s7 } = N("EXPIRED", `pairing topic: ${i7}`);
              throw new Error(s7);
            }
          }, this.core = e9, this.logger = (0, import_logger.generateChildLogger)(t6, this.name), this.pairings = new Mt2(this.core, this.logger, this.name, this.storagePrefix);
        }
        get context() {
          return (0, import_logger.getLoggerContext)(this.logger);
        }
        isInitialized() {
          if (!this.initialized) {
            const { message: e9 } = N("NOT_INITIALIZED", this.name);
            throw new Error(e9);
          }
        }
        registerRelayerEvents() {
          this.core.relayer.on(D3.message, async (e9) => {
            const { topic: t6, message: i7 } = e9;
            if (!this.pairings.keys.includes(t6) || this.ignoredPayloadTypes.includes(this.core.crypto.getPayloadType(i7)))
              return;
            const s7 = await this.core.crypto.decode(t6, i7);
            try {
              isJsonRpcRequest(s7) ? (this.core.history.set(t6, s7), this.onRelayEventRequest({ topic: t6, payload: s7 })) : isJsonRpcResponse(s7) && (await this.core.history.resolve(s7), await this.onRelayEventResponse({ topic: t6, payload: s7 }), this.core.history.delete(t6, s7.id));
            } catch (n9) {
              this.logger.error(n9);
            }
          });
        }
        registerExpirerEvents() {
          this.core.expirer.on(v.expired, async (e9) => {
            const { topic: t6 } = ft(e9.target);
            t6 && this.pairings.keys.includes(t6) && (await this.deletePairing(t6, true), this.events.emit(V3.expire, { topic: t6 }));
          });
        }
      };
      Kt2 = class extends h3 {
        constructor(e9, t6) {
          super(e9, t6), this.core = e9, this.logger = t6, this.records = /* @__PURE__ */ new Map(), this.events = new import_events5.EventEmitter(), this.name = vt2, this.version = It3, this.cached = [], this.initialized = false, this.storagePrefix = O3, this.init = async () => {
            this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i7) => this.records.set(i7.id, i7)), this.cached = [], this.registerEventListeners(), this.initialized = true);
          }, this.set = (i7, s7, n9) => {
            if (this.isInitialized(), this.logger.debug("Setting JSON-RPC request history record"), this.logger.trace({ type: "method", method: "set", topic: i7, request: s7, chainId: n9 }), this.records.has(s7.id))
              return;
            const o9 = { id: s7.id, topic: i7, request: { method: s7.method, params: s7.params || null }, chainId: n9, expiry: pt(import_time4.THIRTY_DAYS) };
            this.records.set(o9.id, o9), this.events.emit(R.created, o9);
          }, this.resolve = async (i7) => {
            if (this.isInitialized(), this.logger.debug("Updating JSON-RPC response history record"), this.logger.trace({ type: "method", method: "update", response: i7 }), !this.records.has(i7.id))
              return;
            const s7 = await this.getRecord(i7.id);
            typeof s7.response > "u" && (s7.response = isJsonRpcError(i7) ? { error: i7.error } : { result: i7.result }, this.records.set(s7.id, s7), this.events.emit(R.updated, s7));
          }, this.get = async (i7, s7) => (this.isInitialized(), this.logger.debug("Getting record"), this.logger.trace({ type: "method", method: "get", topic: i7, id: s7 }), await this.getRecord(s7)), this.delete = (i7, s7) => {
            this.isInitialized(), this.logger.debug("Deleting record"), this.logger.trace({ type: "method", method: "delete", id: s7 }), this.values.forEach((n9) => {
              if (n9.topic === i7) {
                if (typeof s7 < "u" && n9.id !== s7)
                  return;
                this.records.delete(n9.id), this.events.emit(R.deleted, n9);
              }
            });
          }, this.exists = async (i7, s7) => (this.isInitialized(), this.records.has(s7) ? (await this.getRecord(s7)).topic === i7 : false), this.on = (i7, s7) => {
            this.events.on(i7, s7);
          }, this.once = (i7, s7) => {
            this.events.once(i7, s7);
          }, this.off = (i7, s7) => {
            this.events.off(i7, s7);
          }, this.removeListener = (i7, s7) => {
            this.events.removeListener(i7, s7);
          }, this.logger = (0, import_logger.generateChildLogger)(t6, this.name);
        }
        get context() {
          return (0, import_logger.getLoggerContext)(this.logger);
        }
        get storageKey() {
          return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
        }
        get size() {
          return this.records.size;
        }
        get keys() {
          return Array.from(this.records.keys());
        }
        get values() {
          return Array.from(this.records.values());
        }
        get pending() {
          const e9 = [];
          return this.values.forEach((t6) => {
            if (typeof t6.response < "u")
              return;
            const i7 = { topic: t6.topic, request: formatJsonRpcRequest(t6.request.method, t6.request.params, t6.id), chainId: t6.chainId };
            return e9.push(i7);
          }), e9;
        }
        async setJsonRpcRecords(e9) {
          await this.core.storage.setItem(this.storageKey, e9);
        }
        async getJsonRpcRecords() {
          return await this.core.storage.getItem(this.storageKey);
        }
        getRecord(e9) {
          this.isInitialized();
          const t6 = this.records.get(e9);
          if (!t6) {
            const { message: i7 } = N("NO_MATCHING_KEY", `${this.name}: ${e9}`);
            throw new Error(i7);
          }
          return t6;
        }
        async persist() {
          await this.setJsonRpcRecords(this.values), this.events.emit(R.sync);
        }
        async restore() {
          try {
            const e9 = await this.getJsonRpcRecords();
            if (typeof e9 > "u" || !e9.length)
              return;
            if (this.records.size) {
              const { message: t6 } = N("RESTORE_WILL_OVERRIDE", this.name);
              throw this.logger.error(t6), new Error(t6);
            }
            this.cached = e9, this.logger.debug(`Successfully Restored records for ${this.name}`), this.logger.trace({ type: "method", method: "restore", records: this.values });
          } catch (e9) {
            this.logger.debug(`Failed to Restore records for ${this.name}`), this.logger.error(e9);
          }
        }
        registerEventListeners() {
          this.events.on(R.created, (e9) => {
            const t6 = R.created;
            this.logger.info(`Emitting ${t6}`), this.logger.debug({ type: "event", event: t6, record: e9 }), this.persist();
          }), this.events.on(R.updated, (e9) => {
            const t6 = R.updated;
            this.logger.info(`Emitting ${t6}`), this.logger.debug({ type: "event", event: t6, record: e9 }), this.persist();
          }), this.events.on(R.deleted, (e9) => {
            const t6 = R.deleted;
            this.logger.info(`Emitting ${t6}`), this.logger.debug({ type: "event", event: t6, record: e9 }), this.persist();
          }), this.core.heartbeat.on(import_heartbeat.HEARTBEAT_EVENTS.pulse, () => {
            this.cleanup();
          });
        }
        cleanup() {
          try {
            this.records.forEach((e9) => {
              (0, import_time4.toMiliseconds)(e9.expiry || 0) - Date.now() <= 0 && (this.logger.info(`Deleting expired history log: ${e9.id}`), this.delete(e9.topic, e9.id));
            });
          } catch (e9) {
            this.logger.warn(e9);
          }
        }
        isInitialized() {
          if (!this.initialized) {
            const { message: e9 } = N("NOT_INITIALIZED", this.name);
            throw new Error(e9);
          }
        }
      };
      Bt2 = class extends E2 {
        constructor(e9, t6) {
          super(e9, t6), this.core = e9, this.logger = t6, this.expirations = /* @__PURE__ */ new Map(), this.events = new import_events5.EventEmitter(), this.name = Ct, this.version = Rt2, this.cached = [], this.initialized = false, this.storagePrefix = O3, this.init = async () => {
            this.initialized || (this.logger.trace("Initialized"), await this.restore(), this.cached.forEach((i7) => this.expirations.set(i7.target, i7)), this.cached = [], this.registerEventListeners(), this.initialized = true);
          }, this.has = (i7) => {
            try {
              const s7 = this.formatTarget(i7);
              return typeof this.getExpiration(s7) < "u";
            } catch {
              return false;
            }
          }, this.set = (i7, s7) => {
            this.isInitialized();
            const n9 = this.formatTarget(i7), o9 = { target: n9, expiry: s7 };
            this.expirations.set(n9, o9), this.checkExpiry(n9, o9), this.events.emit(v.created, { target: n9, expiration: o9 });
          }, this.get = (i7) => {
            this.isInitialized();
            const s7 = this.formatTarget(i7);
            return this.getExpiration(s7);
          }, this.del = (i7) => {
            if (this.isInitialized(), this.has(i7)) {
              const s7 = this.formatTarget(i7), n9 = this.getExpiration(s7);
              this.expirations.delete(s7), this.events.emit(v.deleted, { target: s7, expiration: n9 });
            }
          }, this.on = (i7, s7) => {
            this.events.on(i7, s7);
          }, this.once = (i7, s7) => {
            this.events.once(i7, s7);
          }, this.off = (i7, s7) => {
            this.events.off(i7, s7);
          }, this.removeListener = (i7, s7) => {
            this.events.removeListener(i7, s7);
          }, this.logger = (0, import_logger.generateChildLogger)(t6, this.name);
        }
        get context() {
          return (0, import_logger.getLoggerContext)(this.logger);
        }
        get storageKey() {
          return this.storagePrefix + this.version + this.core.customStoragePrefix + "//" + this.name;
        }
        get length() {
          return this.expirations.size;
        }
        get keys() {
          return Array.from(this.expirations.keys());
        }
        get values() {
          return Array.from(this.expirations.values());
        }
        formatTarget(e9) {
          if (typeof e9 == "string")
            return lt(e9);
          if (typeof e9 == "number")
            return dt(e9);
          const { message: t6 } = N("UNKNOWN_TYPE", `Target type: ${typeof e9}`);
          throw new Error(t6);
        }
        async setExpirations(e9) {
          await this.core.storage.setItem(this.storageKey, e9);
        }
        async getExpirations() {
          return await this.core.storage.getItem(this.storageKey);
        }
        async persist() {
          await this.setExpirations(this.values), this.events.emit(v.sync);
        }
        async restore() {
          try {
            const e9 = await this.getExpirations();
            if (typeof e9 > "u" || !e9.length)
              return;
            if (this.expirations.size) {
              const { message: t6 } = N("RESTORE_WILL_OVERRIDE", this.name);
              throw this.logger.error(t6), new Error(t6);
            }
            this.cached = e9, this.logger.debug(`Successfully Restored expirations for ${this.name}`), this.logger.trace({ type: "method", method: "restore", expirations: this.values });
          } catch (e9) {
            this.logger.debug(`Failed to Restore expirations for ${this.name}`), this.logger.error(e9);
          }
        }
        getExpiration(e9) {
          const t6 = this.expirations.get(e9);
          if (!t6) {
            const { message: i7 } = N("NO_MATCHING_KEY", `${this.name}: ${e9}`);
            throw this.logger.error(i7), new Error(i7);
          }
          return t6;
        }
        checkExpiry(e9, t6) {
          const { expiry: i7 } = t6;
          (0, import_time4.toMiliseconds)(i7) - Date.now() <= 0 && this.expire(e9, t6);
        }
        expire(e9, t6) {
          this.expirations.delete(e9), this.events.emit(v.expired, { target: e9, expiration: t6 });
        }
        checkExpirations() {
          this.core.relayer.connected && this.expirations.forEach((e9, t6) => this.checkExpiry(t6, e9));
        }
        registerEventListeners() {
          this.core.heartbeat.on(import_heartbeat.HEARTBEAT_EVENTS.pulse, () => this.checkExpirations()), this.events.on(v.created, (e9) => {
            const t6 = v.created;
            this.logger.info(`Emitting ${t6}`), this.logger.debug({ type: "event", event: t6, data: e9 }), this.persist();
          }), this.events.on(v.expired, (e9) => {
            const t6 = v.expired;
            this.logger.info(`Emitting ${t6}`), this.logger.debug({ type: "event", event: t6, data: e9 }), this.persist();
          }), this.events.on(v.deleted, (e9) => {
            const t6 = v.deleted;
            this.logger.info(`Emitting ${t6}`), this.logger.debug({ type: "event", event: t6, data: e9 }), this.persist();
          });
        }
        isInitialized() {
          if (!this.initialized) {
            const { message: e9 } = N("NOT_INITIALIZED", this.name);
            throw new Error(e9);
          }
        }
      };
      Vt2 = class extends y2 {
        constructor(e9, t6) {
          super(e9, t6), this.projectId = e9, this.logger = t6, this.name = Z2, this.initialized = false, this.queue = [], this.verifyDisabled = false, this.init = async (i7) => {
            if (this.verifyDisabled || C() || !D())
              return;
            const s7 = this.getVerifyUrl(i7?.verifyUrl);
            this.verifyUrl !== s7 && this.removeIframe(), this.verifyUrl = s7;
            try {
              await this.createIframe();
            } catch (n9) {
              this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.info(n9);
            }
            if (!this.initialized) {
              this.removeIframe(), this.verifyUrl = ee2;
              try {
                await this.createIframe();
              } catch (n9) {
                this.logger.info(`Verify iframe failed to load: ${this.verifyUrl}`), this.logger.info(n9), this.verifyDisabled = true;
              }
            }
          }, this.register = async (i7) => {
            this.initialized ? this.sendPost(i7.attestationId) : (this.addToQueue(i7.attestationId), await this.init());
          }, this.resolve = async (i7) => {
            if (this.isDevEnv)
              return "";
            const s7 = this.getVerifyUrl(i7?.verifyUrl);
            let n9;
            try {
              n9 = await this.fetchAttestation(i7.attestationId, s7);
            } catch (o9) {
              this.logger.info(`failed to resolve attestation: ${i7.attestationId} from url: ${s7}`), this.logger.info(o9), n9 = await this.fetchAttestation(i7.attestationId, ee2);
            }
            return n9;
          }, this.fetchAttestation = async (i7, s7) => {
            this.logger.info(`resolving attestation: ${i7} from url: ${s7}`);
            const n9 = this.startAbortTimer(import_time4.ONE_SECOND * 2), o9 = await fetch(`${s7}/attestation/${i7}`, { signal: this.abortController.signal });
            return clearTimeout(n9), o9.status === 200 ? await o9.json() : void 0;
          }, this.addToQueue = (i7) => {
            this.queue.push(i7);
          }, this.processQueue = () => {
            this.queue.length !== 0 && (this.queue.forEach((i7) => this.sendPost(i7)), this.queue = []);
          }, this.sendPost = (i7) => {
            var s7;
            try {
              if (!this.iframe)
                return;
              (s7 = this.iframe.contentWindow) == null || s7.postMessage(i7, "*"), this.logger.info(`postMessage sent: ${i7} ${this.verifyUrl}`);
            } catch {
            }
          }, this.createIframe = async () => {
            let i7;
            const s7 = (n9) => {
              n9.data === "verify_ready" && (this.initialized = true, this.processQueue(), window.removeEventListener("message", s7), i7());
            };
            await Promise.race([new Promise((n9) => {
              if (document.getElementById(Z2))
                return n9();
              window.addEventListener("message", s7);
              const o9 = document.createElement("iframe");
              o9.id = Z2, o9.src = `${this.verifyUrl}/${this.projectId}`, o9.style.display = "none", document.body.append(o9), this.iframe = o9, i7 = n9;
            }), new Promise((n9, o9) => setTimeout(() => {
              window.removeEventListener("message", s7), o9("verify iframe load timeout");
            }, (0, import_time4.toMiliseconds)(import_time4.FIVE_SECONDS)))]);
          }, this.removeIframe = () => {
            this.iframe && (this.iframe.remove(), this.iframe = void 0, this.initialized = false);
          }, this.getVerifyUrl = (i7) => {
            let s7 = i7 || $2;
            return _t.includes(s7) || (this.logger.info(`verify url: ${s7}, not included in trusted list, assigning default: ${$2}`), s7 = $2), s7;
          }, this.logger = (0, import_logger.generateChildLogger)(t6, this.name), this.verifyUrl = $2, this.abortController = new AbortController(), this.isDevEnv = te() && process.env.IS_VITEST;
        }
        get context() {
          return (0, import_logger.getLoggerContext)(this.logger);
        }
        startAbortTimer(e9) {
          return this.abortController = new AbortController(), setTimeout(() => this.abortController.abort(), (0, import_time4.toMiliseconds)(e9));
        }
      };
      Or = Object.defineProperty;
      qt2 = Object.getOwnPropertySymbols;
      Ar = Object.prototype.hasOwnProperty;
      zr = Object.prototype.propertyIsEnumerable;
      jt2 = (r8, e9, t6) => e9 in r8 ? Or(r8, e9, { enumerable: true, configurable: true, writable: true, value: t6 }) : r8[e9] = t6;
      Gt2 = (r8, e9) => {
        for (var t6 in e9 || (e9 = {}))
          Ar.call(e9, t6) && jt2(r8, t6, e9[t6]);
        if (qt2)
          for (var t6 of qt2(e9))
            zr.call(e9, t6) && jt2(r8, t6, e9[t6]);
        return r8;
      };
      te2 = class extends n {
        constructor(e9) {
          super(e9), this.protocol = le3, this.version = Xe3, this.name = Q2, this.events = new import_events5.EventEmitter(), this.initialized = false, this.on = (i7, s7) => this.events.on(i7, s7), this.once = (i7, s7) => this.events.once(i7, s7), this.off = (i7, s7) => this.events.off(i7, s7), this.removeListener = (i7, s7) => this.events.removeListener(i7, s7), this.projectId = e9?.projectId, this.relayUrl = e9?.relayUrl || ge2, this.customStoragePrefix = e9 != null && e9.customStoragePrefix ? `:${e9.customStoragePrefix}` : "";
          const t6 = typeof e9?.logger < "u" && typeof e9?.logger != "string" ? e9.logger : (0, import_logger.pino)((0, import_logger.getDefaultLoggerOptions)({ level: e9?.logger || Qe2.logger }));
          this.logger = (0, import_logger.generateChildLogger)(t6, this.name), this.heartbeat = new import_heartbeat.HeartBeat(), this.crypto = new Tt2(this, this.logger, e9?.keychain), this.history = new Kt2(this, this.logger), this.expirer = new Bt2(this, this.logger), this.storage = e9 != null && e9.storage ? e9.storage : new h2(Gt2(Gt2({}, Ze2), e9?.storageOptions)), this.relayer = new Ut({ core: this, logger: this.logger, relayUrl: this.relayUrl, projectId: this.projectId }), this.pairing = new kt2(this, this.logger), this.verify = new Vt2(this.projectId || "", this.logger);
        }
        static async init(e9) {
          const t6 = new te2(e9);
          await t6.initialize();
          const i7 = await t6.crypto.getClientId();
          return await t6.storage.setItem(yt2, i7), t6;
        }
        get context() {
          return (0, import_logger.getLoggerContext)(this.logger);
        }
        async start() {
          this.initialized || await this.initialize();
        }
        async initialize() {
          this.logger.trace("Initialized");
          try {
            await this.crypto.init(), await this.history.init(), await this.expirer.init(), await this.relayer.init(), await this.heartbeat.init(), await this.pairing.init(), this.initialized = true, this.logger.info("Core Initialization Success");
          } catch (e9) {
            throw this.logger.warn(`Core Initialization Failure at epoch ${Date.now()}`, e9), this.logger.error(e9.message), e9;
          }
        }
      };
      Nr = te2;
    }
  });

  // node_modules/@walletconnect/sign-client/dist/index.es.js
  var import_logger2, import_events6, import_time5, X3, F3, H2, G3, M2, W4, ne, oe3, ae2, A2, ce3, V4, U3, I, le4, pe2, os2, as2, cs2, he4, ls2, ps2, de4, g3, b3, hs2, ds2, us2, gs2, Q3;
  var init_index_es6 = __esm({
    "node_modules/@walletconnect/sign-client/dist/index.es.js"() {
      init_index_es5();
      import_logger2 = __toESM(require_cjs5());
      init_index_es3();
      init_index_es();
      import_events6 = __toESM(require_events());
      import_time5 = __toESM(require_cjs());
      init_esm6();
      X3 = "wc";
      F3 = 2;
      H2 = "client";
      G3 = `${X3}@${F3}:${H2}:`;
      M2 = { name: H2, logger: "error", controller: false, relayUrl: "wss://relay.walletconnect.com" };
      W4 = "WALLETCONNECT_DEEPLINK_CHOICE";
      ne = "proposal";
      oe3 = "Proposal expired";
      ae2 = "session";
      A2 = import_time5.SEVEN_DAYS;
      ce3 = "engine";
      V4 = { wc_sessionPropose: { req: { ttl: import_time5.FIVE_MINUTES, prompt: true, tag: 1100 }, res: { ttl: import_time5.FIVE_MINUTES, prompt: false, tag: 1101 } }, wc_sessionSettle: { req: { ttl: import_time5.FIVE_MINUTES, prompt: false, tag: 1102 }, res: { ttl: import_time5.FIVE_MINUTES, prompt: false, tag: 1103 } }, wc_sessionUpdate: { req: { ttl: import_time5.ONE_DAY, prompt: false, tag: 1104 }, res: { ttl: import_time5.ONE_DAY, prompt: false, tag: 1105 } }, wc_sessionExtend: { req: { ttl: import_time5.ONE_DAY, prompt: false, tag: 1106 }, res: { ttl: import_time5.ONE_DAY, prompt: false, tag: 1107 } }, wc_sessionRequest: { req: { ttl: import_time5.FIVE_MINUTES, prompt: true, tag: 1108 }, res: { ttl: import_time5.FIVE_MINUTES, prompt: false, tag: 1109 } }, wc_sessionEvent: { req: { ttl: import_time5.FIVE_MINUTES, prompt: true, tag: 1110 }, res: { ttl: import_time5.FIVE_MINUTES, prompt: false, tag: 1111 } }, wc_sessionDelete: { req: { ttl: import_time5.ONE_DAY, prompt: false, tag: 1112 }, res: { ttl: import_time5.ONE_DAY, prompt: false, tag: 1113 } }, wc_sessionPing: { req: { ttl: import_time5.THIRTY_SECONDS, prompt: false, tag: 1114 }, res: { ttl: import_time5.THIRTY_SECONDS, prompt: false, tag: 1115 } } };
      U3 = { min: import_time5.FIVE_MINUTES, max: import_time5.SEVEN_DAYS };
      I = { idle: "IDLE", active: "ACTIVE" };
      le4 = "request";
      pe2 = ["wc_sessionPropose", "wc_sessionRequest", "wc_authRequest"];
      os2 = Object.defineProperty;
      as2 = Object.defineProperties;
      cs2 = Object.getOwnPropertyDescriptors;
      he4 = Object.getOwnPropertySymbols;
      ls2 = Object.prototype.hasOwnProperty;
      ps2 = Object.prototype.propertyIsEnumerable;
      de4 = (m6, r8, e9) => r8 in m6 ? os2(m6, r8, { enumerable: true, configurable: true, writable: true, value: e9 }) : m6[r8] = e9;
      g3 = (m6, r8) => {
        for (var e9 in r8 || (r8 = {}))
          ls2.call(r8, e9) && de4(m6, e9, r8[e9]);
        if (he4)
          for (var e9 of he4(r8))
            ps2.call(r8, e9) && de4(m6, e9, r8[e9]);
        return m6;
      };
      b3 = (m6, r8) => as2(m6, cs2(r8));
      hs2 = class extends S3 {
        constructor(r8) {
          super(r8), this.name = ce3, this.events = new import_events6.default(), this.initialized = false, this.ignoredPayloadTypes = [_], this.requestQueue = { state: I.idle, queue: [] }, this.sessionRequestQueue = { state: I.idle, queue: [] }, this.requestQueueDelay = import_time5.ONE_SECOND, this.init = async () => {
            this.initialized || (await this.cleanup(), this.registerRelayerEvents(), this.registerExpirerEvents(), this.registerPairingEvents(), this.client.core.pairing.register({ methods: Object.keys(V4) }), this.initialized = true, setTimeout(() => {
              this.sessionRequestQueue.queue = this.getPendingSessionRequests(), this.processSessionRequestQueue();
            }, (0, import_time5.toMiliseconds)(this.requestQueueDelay)));
          }, this.connect = async (e9) => {
            await this.isInitialized();
            const s7 = b3(g3({}, e9), { requiredNamespaces: e9.requiredNamespaces || {}, optionalNamespaces: e9.optionalNamespaces || {} });
            await this.isValidConnect(s7);
            const { pairingTopic: t6, requiredNamespaces: i7, optionalNamespaces: n9, sessionProperties: o9, relays: a6 } = s7;
            let c9 = t6, p8, d7 = false;
            if (c9 && (d7 = this.client.core.pairing.pairings.get(c9).active), !c9 || !d7) {
              const { topic: v6, uri: S12 } = await this.client.core.pairing.create();
              c9 = v6, p8 = S12;
            }
            const h10 = await this.client.core.crypto.generateKeyPair(), R7 = g3({ requiredNamespaces: i7, optionalNamespaces: n9, relays: a6 ?? [{ protocol: ht2 }], proposer: { publicKey: h10, metadata: this.client.metadata } }, o9 && { sessionProperties: o9 }), { reject: w8, resolve: T6, done: K8 } = at(import_time5.FIVE_MINUTES, oe3);
            if (this.events.once(yt("session_connect"), async ({ error: v6, session: S12 }) => {
              if (v6)
                w8(v6);
              else if (S12) {
                S12.self.publicKey = h10;
                const B10 = b3(g3({}, S12), { requiredNamespaces: S12.requiredNamespaces, optionalNamespaces: S12.optionalNamespaces });
                await this.client.session.set(S12.topic, B10), await this.setExpiry(S12.topic, S12.expiry), c9 && await this.client.core.pairing.updateMetadata({ topic: c9, metadata: S12.peer.metadata }), T6(B10);
              }
            }), !c9) {
              const { message: v6 } = N("NO_MATCHING_KEY", `connect() pairing topic: ${c9}`);
              throw new Error(v6);
            }
            const L9 = await this.sendRequest({ topic: c9, method: "wc_sessionPropose", params: R7 }), ue7 = pt(import_time5.FIVE_MINUTES);
            return await this.setProposal(L9, g3({ id: L9, expiry: ue7 }, R7)), { uri: p8, approval: K8 };
          }, this.pair = async (e9) => (await this.isInitialized(), await this.client.core.pairing.pair(e9)), this.approve = async (e9) => {
            await this.isInitialized(), await this.isValidApprove(e9);
            const { id: s7, relayProtocol: t6, namespaces: i7, sessionProperties: n9 } = e9, o9 = this.client.proposal.get(s7);
            let { pairingTopic: a6, proposer: c9, requiredNamespaces: p8, optionalNamespaces: d7 } = o9;
            a6 = a6 || "", B2(p8) || (p8 = jt(i7, "approve()"));
            const h10 = await this.client.core.crypto.generateKeyPair(), R7 = c9.publicKey, w8 = await this.client.core.crypto.generateSharedKey(h10, R7);
            a6 && s7 && (await this.client.core.pairing.updateMetadata({ topic: a6, metadata: c9.metadata }), await this.sendResult({ id: s7, topic: a6, result: { relay: { protocol: t6 ?? "irn" }, responderPublicKey: h10 } }), await this.client.proposal.delete(s7, U("USER_DISCONNECTED")), await this.client.core.pairing.activate({ topic: a6 }));
            const T6 = g3({ relay: { protocol: t6 ?? "irn" }, namespaces: i7, requiredNamespaces: p8, optionalNamespaces: d7, pairingTopic: a6, controller: { publicKey: h10, metadata: this.client.metadata }, expiry: pt(A2) }, n9 && { sessionProperties: n9 });
            await this.client.core.relayer.subscribe(w8), await this.sendRequest({ topic: w8, method: "wc_sessionSettle", params: T6, throwOnFailedPublish: true });
            const K8 = b3(g3({}, T6), { topic: w8, pairingTopic: a6, acknowledged: false, self: T6.controller, peer: { publicKey: c9.publicKey, metadata: c9.metadata }, controller: h10 });
            return await this.client.session.set(w8, K8), await this.setExpiry(w8, pt(A2)), { topic: w8, acknowledged: () => new Promise((L9) => setTimeout(() => L9(this.client.session.get(w8)), 500)) };
          }, this.reject = async (e9) => {
            await this.isInitialized(), await this.isValidReject(e9);
            const { id: s7, reason: t6 } = e9, { pairingTopic: i7 } = this.client.proposal.get(s7);
            i7 && (await this.sendError(s7, i7, t6), await this.client.proposal.delete(s7, U("USER_DISCONNECTED")));
          }, this.update = async (e9) => {
            await this.isInitialized(), await this.isValidUpdate(e9);
            const { topic: s7, namespaces: t6 } = e9, i7 = await this.sendRequest({ topic: s7, method: "wc_sessionUpdate", params: { namespaces: t6 } }), { done: n9, resolve: o9, reject: a6 } = at();
            return this.events.once(yt("session_update", i7), ({ error: c9 }) => {
              c9 ? a6(c9) : o9();
            }), await this.client.session.update(s7, { namespaces: t6 }), { acknowledged: n9 };
          }, this.extend = async (e9) => {
            await this.isInitialized(), await this.isValidExtend(e9);
            const { topic: s7 } = e9, t6 = await this.sendRequest({ topic: s7, method: "wc_sessionExtend", params: {} }), { done: i7, resolve: n9, reject: o9 } = at();
            return this.events.once(yt("session_extend", t6), ({ error: a6 }) => {
              a6 ? o9(a6) : n9();
            }), await this.setExpiry(s7, pt(A2)), { acknowledged: i7 };
          }, this.request = async (e9) => {
            await this.isInitialized(), await this.isValidRequest(e9);
            const { chainId: s7, request: t6, topic: i7, expiry: n9 } = e9, o9 = payloadId(), { done: a6, resolve: c9, reject: p8 } = at(n9, "Request expired. Please try again.");
            return this.events.once(yt("session_request", o9), ({ error: d7, result: h10 }) => {
              d7 ? p8(d7) : c9(h10);
            }), await Promise.all([new Promise(async (d7) => {
              await this.sendRequest({ clientRpcId: o9, topic: i7, method: "wc_sessionRequest", params: { request: t6, chainId: s7 }, expiry: n9, throwOnFailedPublish: true }).catch((h10) => p8(h10)), this.client.events.emit("session_request_sent", { topic: i7, request: t6, chainId: s7, id: o9 }), d7();
            }), new Promise(async (d7) => {
              const h10 = await gt(this.client.core.storage, W4);
              ht({ id: o9, topic: i7, wcDeepLink: h10 }), d7();
            }), a6()]).then((d7) => d7[2]);
          }, this.respond = async (e9) => {
            await this.isInitialized(), await this.isValidRespond(e9);
            const { topic: s7, response: t6 } = e9, { id: i7 } = t6;
            isJsonRpcResult(t6) ? await this.sendResult({ id: i7, topic: s7, result: t6.result, throwOnFailedPublish: true }) : isJsonRpcError(t6) && await this.sendError(i7, s7, t6.error), this.cleanupAfterResponse(e9);
          }, this.ping = async (e9) => {
            await this.isInitialized(), await this.isValidPing(e9);
            const { topic: s7 } = e9;
            if (this.client.session.keys.includes(s7)) {
              const t6 = await this.sendRequest({ topic: s7, method: "wc_sessionPing", params: {} }), { done: i7, resolve: n9, reject: o9 } = at();
              this.events.once(yt("session_ping", t6), ({ error: a6 }) => {
                a6 ? o9(a6) : n9();
              }), await i7();
            } else
              this.client.core.pairing.pairings.keys.includes(s7) && await this.client.core.pairing.ping({ topic: s7 });
          }, this.emit = async (e9) => {
            await this.isInitialized(), await this.isValidEmit(e9);
            const { topic: s7, event: t6, chainId: i7 } = e9;
            await this.sendRequest({ topic: s7, method: "wc_sessionEvent", params: { event: t6, chainId: i7 } });
          }, this.disconnect = async (e9) => {
            await this.isInitialized(), await this.isValidDisconnect(e9);
            const { topic: s7 } = e9;
            this.client.session.keys.includes(s7) ? (await this.sendRequest({ topic: s7, method: "wc_sessionDelete", params: U("USER_DISCONNECTED"), throwOnFailedPublish: true }), await this.deleteSession(s7)) : await this.client.core.pairing.disconnect({ topic: s7 });
          }, this.find = (e9) => (this.isInitialized(), this.client.session.getAll().filter((s7) => Dt(s7, e9))), this.getPendingSessionRequests = () => (this.isInitialized(), this.client.pendingRequest.getAll()), this.cleanupDuplicatePairings = async (e9) => {
            if (e9.pairingTopic)
              try {
                const s7 = this.client.core.pairing.pairings.get(e9.pairingTopic), t6 = this.client.core.pairing.pairings.getAll().filter((i7) => {
                  var n9, o9;
                  return ((n9 = i7.peerMetadata) == null ? void 0 : n9.url) && ((o9 = i7.peerMetadata) == null ? void 0 : o9.url) === e9.peer.metadata.url && i7.topic && i7.topic !== s7.topic;
                });
                if (t6.length === 0)
                  return;
                this.client.logger.info(`Cleaning up ${t6.length} duplicate pairing(s)`), await Promise.all(t6.map((i7) => this.client.core.pairing.disconnect({ topic: i7.topic }))), this.client.logger.info("Duplicate pairings clean up finished");
              } catch (s7) {
                this.client.logger.error(s7);
              }
          }, this.deleteSession = async (e9, s7) => {
            const { self: t6 } = this.client.session.get(e9);
            await this.client.core.relayer.unsubscribe(e9), this.client.session.delete(e9, U("USER_DISCONNECTED")), this.client.core.crypto.keychain.has(t6.publicKey) && await this.client.core.crypto.deleteKeyPair(t6.publicKey), this.client.core.crypto.keychain.has(e9) && await this.client.core.crypto.deleteSymKey(e9), s7 || this.client.core.expirer.del(e9), this.client.core.storage.removeItem(W4).catch((i7) => this.client.logger.warn(i7));
          }, this.deleteProposal = async (e9, s7) => {
            await Promise.all([this.client.proposal.delete(e9, U("USER_DISCONNECTED")), s7 ? Promise.resolve() : this.client.core.expirer.del(e9)]);
          }, this.deletePendingSessionRequest = async (e9, s7, t6 = false) => {
            await Promise.all([this.client.pendingRequest.delete(e9, s7), t6 ? Promise.resolve() : this.client.core.expirer.del(e9)]), this.sessionRequestQueue.queue = this.sessionRequestQueue.queue.filter((i7) => i7.id !== e9), t6 && (this.sessionRequestQueue.state = I.idle);
          }, this.setExpiry = async (e9, s7) => {
            this.client.session.keys.includes(e9) && await this.client.session.update(e9, { expiry: s7 }), this.client.core.expirer.set(e9, s7);
          }, this.setProposal = async (e9, s7) => {
            await this.client.proposal.set(e9, s7), this.client.core.expirer.set(e9, s7.expiry);
          }, this.setPendingSessionRequest = async (e9) => {
            const s7 = V4.wc_sessionRequest.req.ttl, { id: t6, topic: i7, params: n9, verifyContext: o9 } = e9;
            await this.client.pendingRequest.set(t6, { id: t6, topic: i7, params: n9, verifyContext: o9 }), s7 && this.client.core.expirer.set(t6, pt(s7));
          }, this.sendRequest = async (e9) => {
            const { topic: s7, method: t6, params: i7, expiry: n9, relayRpcId: o9, clientRpcId: a6, throwOnFailedPublish: c9 } = e9, p8 = formatJsonRpcRequest(t6, i7, a6);
            if (D() && pe2.includes(t6)) {
              const R7 = Ln(JSON.stringify(p8));
              this.client.core.verify.register({ attestationId: R7 });
            }
            const d7 = await this.client.core.crypto.encode(s7, p8), h10 = V4[t6].req;
            return n9 && (h10.ttl = n9), o9 && (h10.id = o9), this.client.core.history.set(s7, p8), c9 ? (h10.internal = b3(g3({}, h10.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(s7, d7, h10)) : this.client.core.relayer.publish(s7, d7, h10).catch((R7) => this.client.logger.error(R7)), p8.id;
          }, this.sendResult = async (e9) => {
            const { id: s7, topic: t6, result: i7, throwOnFailedPublish: n9 } = e9, o9 = formatJsonRpcResult(s7, i7), a6 = await this.client.core.crypto.encode(t6, o9), c9 = await this.client.core.history.get(t6, s7), p8 = V4[c9.request.method].res;
            n9 ? (p8.internal = b3(g3({}, p8.internal), { throwOnFailedPublish: true }), await this.client.core.relayer.publish(t6, a6, p8)) : this.client.core.relayer.publish(t6, a6, p8).catch((d7) => this.client.logger.error(d7)), await this.client.core.history.resolve(o9);
          }, this.sendError = async (e9, s7, t6) => {
            const i7 = formatJsonRpcError(e9, t6), n9 = await this.client.core.crypto.encode(s7, i7), o9 = await this.client.core.history.get(s7, e9), a6 = V4[o9.request.method].res;
            this.client.core.relayer.publish(s7, n9, a6), await this.client.core.history.resolve(i7);
          }, this.cleanup = async () => {
            const e9 = [], s7 = [];
            this.client.session.getAll().forEach((t6) => {
              mt(t6.expiry) && e9.push(t6.topic);
            }), this.client.proposal.getAll().forEach((t6) => {
              mt(t6.expiry) && s7.push(t6.id);
            }), await Promise.all([...e9.map((t6) => this.deleteSession(t6)), ...s7.map((t6) => this.deleteProposal(t6))]);
          }, this.onRelayEventRequest = async (e9) => {
            this.requestQueue.queue.push(e9), await this.processRequestsQueue();
          }, this.processRequestsQueue = async () => {
            if (this.requestQueue.state === I.active) {
              this.client.logger.info("Request queue already active, skipping...");
              return;
            }
            for (this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`); this.requestQueue.queue.length > 0; ) {
              this.requestQueue.state = I.active;
              const e9 = this.requestQueue.queue.shift();
              if (e9)
                try {
                  this.processRequest(e9), await new Promise((s7) => setTimeout(s7, 300));
                } catch (s7) {
                  this.client.logger.warn(s7);
                }
            }
            this.requestQueue.state = I.idle;
          }, this.processRequest = (e9) => {
            const { topic: s7, payload: t6 } = e9, i7 = t6.method;
            switch (i7) {
              case "wc_sessionPropose":
                return this.onSessionProposeRequest(s7, t6);
              case "wc_sessionSettle":
                return this.onSessionSettleRequest(s7, t6);
              case "wc_sessionUpdate":
                return this.onSessionUpdateRequest(s7, t6);
              case "wc_sessionExtend":
                return this.onSessionExtendRequest(s7, t6);
              case "wc_sessionPing":
                return this.onSessionPingRequest(s7, t6);
              case "wc_sessionDelete":
                return this.onSessionDeleteRequest(s7, t6);
              case "wc_sessionRequest":
                return this.onSessionRequest(s7, t6);
              case "wc_sessionEvent":
                return this.onSessionEventRequest(s7, t6);
              default:
                return this.client.logger.info(`Unsupported request method ${i7}`);
            }
          }, this.onRelayEventResponse = async (e9) => {
            const { topic: s7, payload: t6 } = e9, i7 = (await this.client.core.history.get(s7, t6.id)).request.method;
            switch (i7) {
              case "wc_sessionPropose":
                return this.onSessionProposeResponse(s7, t6);
              case "wc_sessionSettle":
                return this.onSessionSettleResponse(s7, t6);
              case "wc_sessionUpdate":
                return this.onSessionUpdateResponse(s7, t6);
              case "wc_sessionExtend":
                return this.onSessionExtendResponse(s7, t6);
              case "wc_sessionPing":
                return this.onSessionPingResponse(s7, t6);
              case "wc_sessionRequest":
                return this.onSessionRequestResponse(s7, t6);
              default:
                return this.client.logger.info(`Unsupported response method ${i7}`);
            }
          }, this.onRelayEventUnknownPayload = (e9) => {
            const { topic: s7 } = e9, { message: t6 } = N("MISSING_OR_INVALID", `Decoded payload on topic ${s7} is not identifiable as a JSON-RPC request or a response.`);
            throw new Error(t6);
          }, this.onSessionProposeRequest = async (e9, s7) => {
            const { params: t6, id: i7 } = s7;
            try {
              this.isValidConnect(g3({}, s7.params));
              const n9 = pt(import_time5.FIVE_MINUTES), o9 = g3({ id: i7, pairingTopic: e9, expiry: n9 }, t6);
              await this.setProposal(i7, o9);
              const a6 = Ln(JSON.stringify(s7)), c9 = await this.getVerifyContext(a6, o9.proposer.metadata);
              this.client.events.emit("session_proposal", { id: i7, params: o9, verifyContext: c9 });
            } catch (n9) {
              await this.sendError(i7, e9, n9), this.client.logger.error(n9);
            }
          }, this.onSessionProposeResponse = async (e9, s7) => {
            const { id: t6 } = s7;
            if (isJsonRpcResult(s7)) {
              const { result: i7 } = s7;
              this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", result: i7 });
              const n9 = this.client.proposal.get(t6);
              this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", proposal: n9 });
              const o9 = n9.proposer.publicKey;
              this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", selfPublicKey: o9 });
              const a6 = i7.responderPublicKey;
              this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", peerPublicKey: a6 });
              const c9 = await this.client.core.crypto.generateSharedKey(o9, a6);
              this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", sessionTopic: c9 });
              const p8 = await this.client.core.relayer.subscribe(c9);
              this.client.logger.trace({ type: "method", method: "onSessionProposeResponse", subscriptionId: p8 }), await this.client.core.pairing.activate({ topic: e9 });
            } else
              isJsonRpcError(s7) && (await this.client.proposal.delete(t6, U("USER_DISCONNECTED")), this.events.emit(yt("session_connect"), { error: s7.error }));
          }, this.onSessionSettleRequest = async (e9, s7) => {
            const { id: t6, params: i7 } = s7;
            try {
              this.isValidSessionSettleRequest(i7);
              const { relay: n9, controller: o9, expiry: a6, namespaces: c9, requiredNamespaces: p8, optionalNamespaces: d7, sessionProperties: h10, pairingTopic: R7 } = s7.params, w8 = g3({ topic: e9, relay: n9, expiry: a6, namespaces: c9, acknowledged: true, pairingTopic: R7, requiredNamespaces: p8, optionalNamespaces: d7, controller: o9.publicKey, self: { publicKey: "", metadata: this.client.metadata }, peer: { publicKey: o9.publicKey, metadata: o9.metadata } }, h10 && { sessionProperties: h10 });
              await this.sendResult({ id: s7.id, topic: e9, result: true }), this.events.emit(yt("session_connect"), { session: w8 }), this.cleanupDuplicatePairings(w8);
            } catch (n9) {
              await this.sendError(t6, e9, n9), this.client.logger.error(n9);
            }
          }, this.onSessionSettleResponse = async (e9, s7) => {
            const { id: t6 } = s7;
            isJsonRpcResult(s7) ? (await this.client.session.update(e9, { acknowledged: true }), this.events.emit(yt("session_approve", t6), {})) : isJsonRpcError(s7) && (await this.client.session.delete(e9, U("USER_DISCONNECTED")), this.events.emit(yt("session_approve", t6), { error: s7.error }));
          }, this.onSessionUpdateRequest = async (e9, s7) => {
            const { params: t6, id: i7 } = s7;
            try {
              const n9 = `${e9}_session_update`, o9 = tr.get(n9);
              if (o9 && this.isRequestOutOfSync(o9, i7)) {
                this.client.logger.info(`Discarding out of sync request - ${i7}`);
                return;
              }
              this.isValidUpdate(g3({ topic: e9 }, t6)), await this.client.session.update(e9, { namespaces: t6.namespaces }), await this.sendResult({ id: i7, topic: e9, result: true }), this.client.events.emit("session_update", { id: i7, topic: e9, params: t6 }), tr.set(n9, i7);
            } catch (n9) {
              await this.sendError(i7, e9, n9), this.client.logger.error(n9);
            }
          }, this.isRequestOutOfSync = (e9, s7) => parseInt(s7.toString().slice(0, -3)) <= parseInt(e9.toString().slice(0, -3)), this.onSessionUpdateResponse = (e9, s7) => {
            const { id: t6 } = s7;
            isJsonRpcResult(s7) ? this.events.emit(yt("session_update", t6), {}) : isJsonRpcError(s7) && this.events.emit(yt("session_update", t6), { error: s7.error });
          }, this.onSessionExtendRequest = async (e9, s7) => {
            const { id: t6 } = s7;
            try {
              this.isValidExtend({ topic: e9 }), await this.setExpiry(e9, pt(A2)), await this.sendResult({ id: t6, topic: e9, result: true }), this.client.events.emit("session_extend", { id: t6, topic: e9 });
            } catch (i7) {
              await this.sendError(t6, e9, i7), this.client.logger.error(i7);
            }
          }, this.onSessionExtendResponse = (e9, s7) => {
            const { id: t6 } = s7;
            isJsonRpcResult(s7) ? this.events.emit(yt("session_extend", t6), {}) : isJsonRpcError(s7) && this.events.emit(yt("session_extend", t6), { error: s7.error });
          }, this.onSessionPingRequest = async (e9, s7) => {
            const { id: t6 } = s7;
            try {
              this.isValidPing({ topic: e9 }), await this.sendResult({ id: t6, topic: e9, result: true }), this.client.events.emit("session_ping", { id: t6, topic: e9 });
            } catch (i7) {
              await this.sendError(t6, e9, i7), this.client.logger.error(i7);
            }
          }, this.onSessionPingResponse = (e9, s7) => {
            const { id: t6 } = s7;
            setTimeout(() => {
              isJsonRpcResult(s7) ? this.events.emit(yt("session_ping", t6), {}) : isJsonRpcError(s7) && this.events.emit(yt("session_ping", t6), { error: s7.error });
            }, 500);
          }, this.onSessionDeleteRequest = async (e9, s7) => {
            const { id: t6 } = s7;
            try {
              this.isValidDisconnect({ topic: e9, reason: s7.params }), await Promise.all([new Promise((i7) => {
                this.client.core.relayer.once(D3.publish, async () => {
                  i7(await this.deleteSession(e9));
                });
              }), this.sendResult({ id: t6, topic: e9, result: true })]), this.client.events.emit("session_delete", { id: t6, topic: e9 });
            } catch (i7) {
              this.client.logger.error(i7);
            }
          }, this.onSessionRequest = async (e9, s7) => {
            const { id: t6, params: i7 } = s7;
            try {
              this.isValidRequest(g3({ topic: e9 }, i7));
              const n9 = Ln(JSON.stringify(formatJsonRpcRequest("wc_sessionRequest", i7, t6))), o9 = this.client.session.get(e9), a6 = await this.getVerifyContext(n9, o9.peer.metadata), c9 = { id: t6, topic: e9, params: i7, verifyContext: a6 };
              await this.setPendingSessionRequest(c9), this.addSessionRequestToSessionRequestQueue(c9), this.processSessionRequestQueue();
            } catch (n9) {
              await this.sendError(t6, e9, n9), this.client.logger.error(n9);
            }
          }, this.onSessionRequestResponse = (e9, s7) => {
            const { id: t6 } = s7;
            isJsonRpcResult(s7) ? this.events.emit(yt("session_request", t6), { result: s7.result }) : isJsonRpcError(s7) && this.events.emit(yt("session_request", t6), { error: s7.error });
          }, this.onSessionEventRequest = async (e9, s7) => {
            const { id: t6, params: i7 } = s7;
            try {
              const n9 = `${e9}_session_event_${i7.event.name}`, o9 = tr.get(n9);
              if (o9 && this.isRequestOutOfSync(o9, t6)) {
                this.client.logger.info(`Discarding out of sync request - ${t6}`);
                return;
              }
              this.isValidEmit(g3({ topic: e9 }, i7)), this.client.events.emit("session_event", { id: t6, topic: e9, params: i7 }), tr.set(n9, t6);
            } catch (n9) {
              await this.sendError(t6, e9, n9), this.client.logger.error(n9);
            }
          }, this.addSessionRequestToSessionRequestQueue = (e9) => {
            this.sessionRequestQueue.queue.push(e9);
          }, this.cleanupAfterResponse = (e9) => {
            this.deletePendingSessionRequest(e9.response.id, { message: "fulfilled", code: 0 }), setTimeout(() => {
              this.sessionRequestQueue.state = I.idle, this.processSessionRequestQueue();
            }, (0, import_time5.toMiliseconds)(this.requestQueueDelay));
          }, this.processSessionRequestQueue = () => {
            if (this.sessionRequestQueue.state === I.active) {
              this.client.logger.info("session request queue is already active.");
              return;
            }
            const e9 = this.sessionRequestQueue.queue[0];
            if (!e9) {
              this.client.logger.info("session request queue is empty.");
              return;
            }
            try {
              this.sessionRequestQueue.state = I.active, this.client.events.emit("session_request", e9);
            } catch (s7) {
              this.client.logger.error(s7);
            }
          }, this.onPairingCreated = (e9) => {
            if (e9.active)
              return;
            const s7 = this.client.proposal.getAll().find((t6) => t6.pairingTopic === e9.topic);
            s7 && this.onSessionProposeRequest(e9.topic, formatJsonRpcRequest("wc_sessionPropose", { requiredNamespaces: s7.requiredNamespaces, optionalNamespaces: s7.optionalNamespaces, relays: s7.relays, proposer: s7.proposer, sessionProperties: s7.sessionProperties }, s7.id));
          }, this.isValidConnect = async (e9) => {
            if (!Ht(e9)) {
              const { message: a6 } = N("MISSING_OR_INVALID", `connect() params: ${JSON.stringify(e9)}`);
              throw new Error(a6);
            }
            const { pairingTopic: s7, requiredNamespaces: t6, optionalNamespaces: i7, sessionProperties: n9, relays: o9 } = e9;
            if (w(s7) || await this.isValidPairingTopic(s7), !xt(o9, true)) {
              const { message: a6 } = N("MISSING_OR_INVALID", `connect() relays: ${o9}`);
              throw new Error(a6);
            }
            !w(t6) && B2(t6) !== 0 && this.validateNamespaces(t6, "requiredNamespaces"), !w(i7) && B2(i7) !== 0 && this.validateNamespaces(i7, "optionalNamespaces"), w(n9) || this.validateSessionProps(n9, "sessionProperties");
          }, this.validateNamespaces = (e9, s7) => {
            const t6 = Lt(e9, "connect()", s7);
            if (t6)
              throw new Error(t6.message);
          }, this.isValidApprove = async (e9) => {
            if (!Ht(e9))
              throw new Error(N("MISSING_OR_INVALID", `approve() params: ${e9}`).message);
            const { id: s7, namespaces: t6, relayProtocol: i7, sessionProperties: n9 } = e9;
            await this.isValidProposalId(s7);
            const o9 = this.client.proposal.get(s7), a6 = un(t6, "approve()");
            if (a6)
              throw new Error(a6.message);
            const c9 = dn(o9.requiredNamespaces, t6, "approve()");
            if (c9)
              throw new Error(c9.message);
            if (!h(i7, true)) {
              const { message: p8 } = N("MISSING_OR_INVALID", `approve() relayProtocol: ${i7}`);
              throw new Error(p8);
            }
            w(n9) || this.validateSessionProps(n9, "sessionProperties");
          }, this.isValidReject = async (e9) => {
            if (!Ht(e9)) {
              const { message: i7 } = N("MISSING_OR_INVALID", `reject() params: ${e9}`);
              throw new Error(i7);
            }
            const { id: s7, reason: t6 } = e9;
            if (await this.isValidProposalId(s7), !qt(t6)) {
              const { message: i7 } = N("MISSING_OR_INVALID", `reject() reason: ${JSON.stringify(t6)}`);
              throw new Error(i7);
            }
          }, this.isValidSessionSettleRequest = (e9) => {
            if (!Ht(e9)) {
              const { message: c9 } = N("MISSING_OR_INVALID", `onSessionSettleRequest() params: ${e9}`);
              throw new Error(c9);
            }
            const { relay: s7, controller: t6, namespaces: i7, expiry: n9 } = e9;
            if (!ln(s7)) {
              const { message: c9 } = N("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string");
              throw new Error(c9);
            }
            const o9 = Kt(t6, "onSessionSettleRequest()");
            if (o9)
              throw new Error(o9.message);
            const a6 = un(i7, "onSessionSettleRequest()");
            if (a6)
              throw new Error(a6.message);
            if (mt(n9)) {
              const { message: c9 } = N("EXPIRED", "onSessionSettleRequest()");
              throw new Error(c9);
            }
          }, this.isValidUpdate = async (e9) => {
            if (!Ht(e9)) {
              const { message: a6 } = N("MISSING_OR_INVALID", `update() params: ${e9}`);
              throw new Error(a6);
            }
            const { topic: s7, namespaces: t6 } = e9;
            await this.isValidSessionTopic(s7);
            const i7 = this.client.session.get(s7), n9 = un(t6, "update()");
            if (n9)
              throw new Error(n9.message);
            const o9 = dn(i7.requiredNamespaces, t6, "update()");
            if (o9)
              throw new Error(o9.message);
          }, this.isValidExtend = async (e9) => {
            if (!Ht(e9)) {
              const { message: t6 } = N("MISSING_OR_INVALID", `extend() params: ${e9}`);
              throw new Error(t6);
            }
            const { topic: s7 } = e9;
            await this.isValidSessionTopic(s7);
          }, this.isValidRequest = async (e9) => {
            if (!Ht(e9)) {
              const { message: a6 } = N("MISSING_OR_INVALID", `request() params: ${e9}`);
              throw new Error(a6);
            }
            const { topic: s7, request: t6, chainId: i7, expiry: n9 } = e9;
            await this.isValidSessionTopic(s7);
            const { namespaces: o9 } = this.client.session.get(s7);
            if (!zt(o9, i7)) {
              const { message: a6 } = N("MISSING_OR_INVALID", `request() chainId: ${i7}`);
              throw new Error(a6);
            }
            if (!Bt(t6)) {
              const { message: a6 } = N("MISSING_OR_INVALID", `request() ${JSON.stringify(t6)}`);
              throw new Error(a6);
            }
            if (!Yt(o9, i7, t6.method)) {
              const { message: a6 } = N("MISSING_OR_INVALID", `request() method: ${t6.method}`);
              throw new Error(a6);
            }
            if (n9 && !Xt(n9, U3)) {
              const { message: a6 } = N("MISSING_OR_INVALID", `request() expiry: ${n9}. Expiry must be a number (in seconds) between ${U3.min} and ${U3.max}`);
              throw new Error(a6);
            }
          }, this.isValidRespond = async (e9) => {
            if (!Ht(e9)) {
              const { message: i7 } = N("MISSING_OR_INVALID", `respond() params: ${e9}`);
              throw new Error(i7);
            }
            const { topic: s7, response: t6 } = e9;
            if (await this.isValidSessionTopic(s7), !Gt(t6)) {
              const { message: i7 } = N("MISSING_OR_INVALID", `respond() response: ${JSON.stringify(t6)}`);
              throw new Error(i7);
            }
          }, this.isValidPing = async (e9) => {
            if (!Ht(e9)) {
              const { message: t6 } = N("MISSING_OR_INVALID", `ping() params: ${e9}`);
              throw new Error(t6);
            }
            const { topic: s7 } = e9;
            await this.isValidSessionOrPairingTopic(s7);
          }, this.isValidEmit = async (e9) => {
            if (!Ht(e9)) {
              const { message: o9 } = N("MISSING_OR_INVALID", `emit() params: ${e9}`);
              throw new Error(o9);
            }
            const { topic: s7, event: t6, chainId: i7 } = e9;
            await this.isValidSessionTopic(s7);
            const { namespaces: n9 } = this.client.session.get(s7);
            if (!zt(n9, i7)) {
              const { message: o9 } = N("MISSING_OR_INVALID", `emit() chainId: ${i7}`);
              throw new Error(o9);
            }
            if (!Wt(t6)) {
              const { message: o9 } = N("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(t6)}`);
              throw new Error(o9);
            }
            if (!Jt(n9, i7, t6.name)) {
              const { message: o9 } = N("MISSING_OR_INVALID", `emit() event: ${JSON.stringify(t6)}`);
              throw new Error(o9);
            }
          }, this.isValidDisconnect = async (e9) => {
            if (!Ht(e9)) {
              const { message: t6 } = N("MISSING_OR_INVALID", `disconnect() params: ${e9}`);
              throw new Error(t6);
            }
            const { topic: s7 } = e9;
            await this.isValidSessionOrPairingTopic(s7);
          }, this.getVerifyContext = async (e9, s7) => {
            const t6 = { verified: { verifyUrl: s7.verifyUrl || $2, validation: "UNKNOWN", origin: s7.url || "" } };
            try {
              const i7 = await this.client.core.verify.resolve({ attestationId: e9, verifyUrl: s7.verifyUrl });
              i7 && (t6.verified.origin = i7.origin, t6.verified.isScam = i7.isScam, t6.verified.validation = i7.origin === new URL(s7.url).origin ? "VALID" : "INVALID");
            } catch (i7) {
              this.client.logger.info(i7);
            }
            return this.client.logger.info(`Verify context: ${JSON.stringify(t6)}`), t6;
          }, this.validateSessionProps = (e9, s7) => {
            Object.values(e9).forEach((t6) => {
              if (!h(t6, false)) {
                const { message: i7 } = N("MISSING_OR_INVALID", `${s7} must be in Record<string, string> format. Received: ${JSON.stringify(t6)}`);
                throw new Error(i7);
              }
            });
          };
        }
        async isInitialized() {
          if (!this.initialized) {
            const { message: r8 } = N("NOT_INITIALIZED", this.name);
            throw new Error(r8);
          }
          await this.client.core.relayer.confirmOnlineStateOrThrow();
        }
        registerRelayerEvents() {
          this.client.core.relayer.on(D3.message, async (r8) => {
            const { topic: e9, message: s7 } = r8;
            if (this.ignoredPayloadTypes.includes(this.client.core.crypto.getPayloadType(s7)))
              return;
            const t6 = await this.client.core.crypto.decode(e9, s7);
            try {
              isJsonRpcRequest(t6) ? (this.client.core.history.set(e9, t6), this.onRelayEventRequest({ topic: e9, payload: t6 })) : isJsonRpcResponse(t6) ? (await this.client.core.history.resolve(t6), await this.onRelayEventResponse({ topic: e9, payload: t6 }), this.client.core.history.delete(e9, t6.id)) : this.onRelayEventUnknownPayload({ topic: e9, payload: t6 });
            } catch (i7) {
              this.client.logger.error(i7);
            }
          });
        }
        registerExpirerEvents() {
          this.client.core.expirer.on(v.expired, async (r8) => {
            const { topic: e9, id: s7 } = ft(r8.target);
            if (s7 && this.client.pendingRequest.keys.includes(s7))
              return await this.deletePendingSessionRequest(s7, N("EXPIRED"), true);
            e9 ? this.client.session.keys.includes(e9) && (await this.deleteSession(e9, true), this.client.events.emit("session_expire", { topic: e9 })) : s7 && (await this.deleteProposal(s7, true), this.client.events.emit("proposal_expire", { id: s7 }));
          });
        }
        registerPairingEvents() {
          this.client.core.pairing.events.on(V3.create, (r8) => this.onPairingCreated(r8));
        }
        isValidPairingTopic(r8) {
          if (!h(r8, false)) {
            const { message: e9 } = N("MISSING_OR_INVALID", `pairing topic should be a string: ${r8}`);
            throw new Error(e9);
          }
          if (!this.client.core.pairing.pairings.keys.includes(r8)) {
            const { message: e9 } = N("NO_MATCHING_KEY", `pairing topic doesn't exist: ${r8}`);
            throw new Error(e9);
          }
          if (mt(this.client.core.pairing.pairings.get(r8).expiry)) {
            const { message: e9 } = N("EXPIRED", `pairing topic: ${r8}`);
            throw new Error(e9);
          }
        }
        async isValidSessionTopic(r8) {
          if (!h(r8, false)) {
            const { message: e9 } = N("MISSING_OR_INVALID", `session topic should be a string: ${r8}`);
            throw new Error(e9);
          }
          if (!this.client.session.keys.includes(r8)) {
            const { message: e9 } = N("NO_MATCHING_KEY", `session topic doesn't exist: ${r8}`);
            throw new Error(e9);
          }
          if (mt(this.client.session.get(r8).expiry)) {
            await this.deleteSession(r8);
            const { message: e9 } = N("EXPIRED", `session topic: ${r8}`);
            throw new Error(e9);
          }
        }
        async isValidSessionOrPairingTopic(r8) {
          if (this.client.session.keys.includes(r8))
            await this.isValidSessionTopic(r8);
          else if (this.client.core.pairing.pairings.keys.includes(r8))
            this.isValidPairingTopic(r8);
          else if (h(r8, false)) {
            const { message: e9 } = N("NO_MATCHING_KEY", `session or pairing topic doesn't exist: ${r8}`);
            throw new Error(e9);
          } else {
            const { message: e9 } = N("MISSING_OR_INVALID", `session or pairing topic should be a string: ${r8}`);
            throw new Error(e9);
          }
        }
        async isValidProposalId(r8) {
          if (!Ft(r8)) {
            const { message: e9 } = N("MISSING_OR_INVALID", `proposal id should be a number: ${r8}`);
            throw new Error(e9);
          }
          if (!this.client.proposal.keys.includes(r8)) {
            const { message: e9 } = N("NO_MATCHING_KEY", `proposal id doesn't exist: ${r8}`);
            throw new Error(e9);
          }
          if (mt(this.client.proposal.get(r8).expiry)) {
            await this.deleteProposal(r8);
            const { message: e9 } = N("EXPIRED", `proposal id: ${r8}`);
            throw new Error(e9);
          }
        }
      };
      ds2 = class extends Mt2 {
        constructor(r8, e9) {
          super(r8, e9, ne, G3), this.core = r8, this.logger = e9;
        }
      };
      us2 = class extends Mt2 {
        constructor(r8, e9) {
          super(r8, e9, ae2, G3), this.core = r8, this.logger = e9;
        }
      };
      gs2 = class extends Mt2 {
        constructor(r8, e9) {
          super(r8, e9, le4, G3, (s7) => s7.id), this.core = r8, this.logger = e9;
        }
      };
      Q3 = class extends b {
        constructor(r8) {
          super(r8), this.protocol = X3, this.version = F3, this.name = M2.name, this.events = new import_events6.EventEmitter(), this.on = (s7, t6) => this.events.on(s7, t6), this.once = (s7, t6) => this.events.once(s7, t6), this.off = (s7, t6) => this.events.off(s7, t6), this.removeListener = (s7, t6) => this.events.removeListener(s7, t6), this.removeAllListeners = (s7) => this.events.removeAllListeners(s7), this.connect = async (s7) => {
            try {
              return await this.engine.connect(s7);
            } catch (t6) {
              throw this.logger.error(t6.message), t6;
            }
          }, this.pair = async (s7) => {
            try {
              return await this.engine.pair(s7);
            } catch (t6) {
              throw this.logger.error(t6.message), t6;
            }
          }, this.approve = async (s7) => {
            try {
              return await this.engine.approve(s7);
            } catch (t6) {
              throw this.logger.error(t6.message), t6;
            }
          }, this.reject = async (s7) => {
            try {
              return await this.engine.reject(s7);
            } catch (t6) {
              throw this.logger.error(t6.message), t6;
            }
          }, this.update = async (s7) => {
            try {
              return await this.engine.update(s7);
            } catch (t6) {
              throw this.logger.error(t6.message), t6;
            }
          }, this.extend = async (s7) => {
            try {
              return await this.engine.extend(s7);
            } catch (t6) {
              throw this.logger.error(t6.message), t6;
            }
          }, this.request = async (s7) => {
            try {
              return await this.engine.request(s7);
            } catch (t6) {
              throw this.logger.error(t6.message), t6;
            }
          }, this.respond = async (s7) => {
            try {
              return await this.engine.respond(s7);
            } catch (t6) {
              throw this.logger.error(t6.message), t6;
            }
          }, this.ping = async (s7) => {
            try {
              return await this.engine.ping(s7);
            } catch (t6) {
              throw this.logger.error(t6.message), t6;
            }
          }, this.emit = async (s7) => {
            try {
              return await this.engine.emit(s7);
            } catch (t6) {
              throw this.logger.error(t6.message), t6;
            }
          }, this.disconnect = async (s7) => {
            try {
              return await this.engine.disconnect(s7);
            } catch (t6) {
              throw this.logger.error(t6.message), t6;
            }
          }, this.find = (s7) => {
            try {
              return this.engine.find(s7);
            } catch (t6) {
              throw this.logger.error(t6.message), t6;
            }
          }, this.getPendingSessionRequests = () => {
            try {
              return this.engine.getPendingSessionRequests();
            } catch (s7) {
              throw this.logger.error(s7.message), s7;
            }
          }, this.name = r8?.name || M2.name, this.metadata = r8?.metadata || Qn();
          const e9 = typeof r8?.logger < "u" && typeof r8?.logger != "string" ? r8.logger : (0, import_logger2.pino)((0, import_logger2.getDefaultLoggerOptions)({ level: r8?.logger || M2.logger }));
          this.core = r8?.core || new Nr(r8), this.logger = (0, import_logger2.generateChildLogger)(e9, this.name), this.session = new us2(this.core, this.logger), this.proposal = new ds2(this.core, this.logger), this.pendingRequest = new gs2(this.core, this.logger), this.engine = new hs2(this);
        }
        static async init(r8) {
          const e9 = new Q3(r8);
          return await e9.initialize(), e9;
        }
        get context() {
          return (0, import_logger2.getLoggerContext)(this.logger);
        }
        get pairing() {
          return this.core.pairing.pairings;
        }
        async initialize() {
          this.logger.trace("Initialized");
          try {
            await this.core.start(), await this.session.init(), await this.proposal.init(), await this.pendingRequest.init(), await this.engine.init(), this.core.verify.init({ verifyUrl: this.metadata.verifyUrl }), this.logger.info("SignClient Initialization Success");
          } catch (r8) {
            throw this.logger.info("SignClient Initialization Failure"), this.logger.error(r8.message), r8;
          }
        }
      };
    }
  });

  // node_modules/cross-fetch/dist/browser-ponyfill.js
  var require_browser_ponyfill = __commonJS({
    "node_modules/cross-fetch/dist/browser-ponyfill.js"(exports, module) {
      var global2 = typeof self !== "undefined" ? self : exports;
      var __self__ = function() {
        function F8() {
          this.fetch = false;
          this.DOMException = global2.DOMException;
        }
        F8.prototype = global2;
        return new F8();
      }();
      (function(self2) {
        var irrelevant = function(exports2) {
          var support = {
            searchParams: "URLSearchParams" in self2,
            iterable: "Symbol" in self2 && "iterator" in Symbol,
            blob: "FileReader" in self2 && "Blob" in self2 && function() {
              try {
                new Blob();
                return true;
              } catch (e9) {
                return false;
              }
            }(),
            formData: "FormData" in self2,
            arrayBuffer: "ArrayBuffer" in self2
          };
          function isDataView(obj) {
            return obj && DataView.prototype.isPrototypeOf(obj);
          }
          if (support.arrayBuffer) {
            var viewClasses = [
              "[object Int8Array]",
              "[object Uint8Array]",
              "[object Uint8ClampedArray]",
              "[object Int16Array]",
              "[object Uint16Array]",
              "[object Int32Array]",
              "[object Uint32Array]",
              "[object Float32Array]",
              "[object Float64Array]"
            ];
            var isArrayBufferView2 = ArrayBuffer.isView || function(obj) {
              return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
            };
          }
          function normalizeName(name2) {
            if (typeof name2 !== "string") {
              name2 = String(name2);
            }
            if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name2)) {
              throw new TypeError("Invalid character in header field name");
            }
            return name2.toLowerCase();
          }
          function normalizeValue2(value) {
            if (typeof value !== "string") {
              value = String(value);
            }
            return value;
          }
          function iteratorFor(items) {
            var iterator = {
              next: function() {
                var value = items.shift();
                return { done: value === void 0, value };
              }
            };
            if (support.iterable) {
              iterator[Symbol.iterator] = function() {
                return iterator;
              };
            }
            return iterator;
          }
          function Headers(headers) {
            this.map = {};
            if (headers instanceof Headers) {
              headers.forEach(function(value, name2) {
                this.append(name2, value);
              }, this);
            } else if (Array.isArray(headers)) {
              headers.forEach(function(header) {
                this.append(header[0], header[1]);
              }, this);
            } else if (headers) {
              Object.getOwnPropertyNames(headers).forEach(function(name2) {
                this.append(name2, headers[name2]);
              }, this);
            }
          }
          Headers.prototype.append = function(name2, value) {
            name2 = normalizeName(name2);
            value = normalizeValue2(value);
            var oldValue = this.map[name2];
            this.map[name2] = oldValue ? oldValue + ", " + value : value;
          };
          Headers.prototype["delete"] = function(name2) {
            delete this.map[normalizeName(name2)];
          };
          Headers.prototype.get = function(name2) {
            name2 = normalizeName(name2);
            return this.has(name2) ? this.map[name2] : null;
          };
          Headers.prototype.has = function(name2) {
            return this.map.hasOwnProperty(normalizeName(name2));
          };
          Headers.prototype.set = function(name2, value) {
            this.map[normalizeName(name2)] = normalizeValue2(value);
          };
          Headers.prototype.forEach = function(callback, thisArg) {
            for (var name2 in this.map) {
              if (this.map.hasOwnProperty(name2)) {
                callback.call(thisArg, this.map[name2], name2, this);
              }
            }
          };
          Headers.prototype.keys = function() {
            var items = [];
            this.forEach(function(value, name2) {
              items.push(name2);
            });
            return iteratorFor(items);
          };
          Headers.prototype.values = function() {
            var items = [];
            this.forEach(function(value) {
              items.push(value);
            });
            return iteratorFor(items);
          };
          Headers.prototype.entries = function() {
            var items = [];
            this.forEach(function(value, name2) {
              items.push([name2, value]);
            });
            return iteratorFor(items);
          };
          if (support.iterable) {
            Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
          }
          function consumed(body) {
            if (body.bodyUsed) {
              return Promise.reject(new TypeError("Already read"));
            }
            body.bodyUsed = true;
          }
          function fileReaderReady(reader) {
            return new Promise(function(resolve, reject) {
              reader.onload = function() {
                resolve(reader.result);
              };
              reader.onerror = function() {
                reject(reader.error);
              };
            });
          }
          function readBlobAsArrayBuffer(blob) {
            var reader = new FileReader();
            var promise = fileReaderReady(reader);
            reader.readAsArrayBuffer(blob);
            return promise;
          }
          function readBlobAsText(blob) {
            var reader = new FileReader();
            var promise = fileReaderReady(reader);
            reader.readAsText(blob);
            return promise;
          }
          function readArrayBufferAsText(buf) {
            var view = new Uint8Array(buf);
            var chars = new Array(view.length);
            for (var i7 = 0; i7 < view.length; i7++) {
              chars[i7] = String.fromCharCode(view[i7]);
            }
            return chars.join("");
          }
          function bufferClone(buf) {
            if (buf.slice) {
              return buf.slice(0);
            } else {
              var view = new Uint8Array(buf.byteLength);
              view.set(new Uint8Array(buf));
              return view.buffer;
            }
          }
          function Body() {
            this.bodyUsed = false;
            this._initBody = function(body) {
              this._bodyInit = body;
              if (!body) {
                this._bodyText = "";
              } else if (typeof body === "string") {
                this._bodyText = body;
              } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
                this._bodyBlob = body;
              } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
                this._bodyFormData = body;
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this._bodyText = body.toString();
              } else if (support.arrayBuffer && support.blob && isDataView(body)) {
                this._bodyArrayBuffer = bufferClone(body.buffer);
                this._bodyInit = new Blob([this._bodyArrayBuffer]);
              } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView2(body))) {
                this._bodyArrayBuffer = bufferClone(body);
              } else {
                this._bodyText = body = Object.prototype.toString.call(body);
              }
              if (!this.headers.get("content-type")) {
                if (typeof body === "string") {
                  this.headers.set("content-type", "text/plain;charset=UTF-8");
                } else if (this._bodyBlob && this._bodyBlob.type) {
                  this.headers.set("content-type", this._bodyBlob.type);
                } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                  this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
                }
              }
            };
            if (support.blob) {
              this.blob = function() {
                var rejected = consumed(this);
                if (rejected) {
                  return rejected;
                }
                if (this._bodyBlob) {
                  return Promise.resolve(this._bodyBlob);
                } else if (this._bodyArrayBuffer) {
                  return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                } else if (this._bodyFormData) {
                  throw new Error("could not read FormData body as blob");
                } else {
                  return Promise.resolve(new Blob([this._bodyText]));
                }
              };
              this.arrayBuffer = function() {
                if (this._bodyArrayBuffer) {
                  return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
                } else {
                  return this.blob().then(readBlobAsArrayBuffer);
                }
              };
            }
            this.text = function() {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return readBlobAsText(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
              } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as text");
              } else {
                return Promise.resolve(this._bodyText);
              }
            };
            if (support.formData) {
              this.formData = function() {
                return this.text().then(decode8);
              };
            }
            this.json = function() {
              return this.text().then(JSON.parse);
            };
            return this;
          }
          var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
          function normalizeMethod(method) {
            var upcased = method.toUpperCase();
            return methods.indexOf(upcased) > -1 ? upcased : method;
          }
          function Request(input, options2) {
            options2 = options2 || {};
            var body = options2.body;
            if (input instanceof Request) {
              if (input.bodyUsed) {
                throw new TypeError("Already read");
              }
              this.url = input.url;
              this.credentials = input.credentials;
              if (!options2.headers) {
                this.headers = new Headers(input.headers);
              }
              this.method = input.method;
              this.mode = input.mode;
              this.signal = input.signal;
              if (!body && input._bodyInit != null) {
                body = input._bodyInit;
                input.bodyUsed = true;
              }
            } else {
              this.url = String(input);
            }
            this.credentials = options2.credentials || this.credentials || "same-origin";
            if (options2.headers || !this.headers) {
              this.headers = new Headers(options2.headers);
            }
            this.method = normalizeMethod(options2.method || this.method || "GET");
            this.mode = options2.mode || this.mode || null;
            this.signal = options2.signal || this.signal;
            this.referrer = null;
            if ((this.method === "GET" || this.method === "HEAD") && body) {
              throw new TypeError("Body not allowed for GET or HEAD requests");
            }
            this._initBody(body);
          }
          Request.prototype.clone = function() {
            return new Request(this, { body: this._bodyInit });
          };
          function decode8(body) {
            var form = new FormData();
            body.trim().split("&").forEach(function(bytes3) {
              if (bytes3) {
                var split2 = bytes3.split("=");
                var name2 = split2.shift().replace(/\+/g, " ");
                var value = split2.join("=").replace(/\+/g, " ");
                form.append(decodeURIComponent(name2), decodeURIComponent(value));
              }
            });
            return form;
          }
          function parseHeaders(rawHeaders) {
            var headers = new Headers();
            var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
            preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
              var parts = line.split(":");
              var key2 = parts.shift().trim();
              if (key2) {
                var value = parts.join(":").trim();
                headers.append(key2, value);
              }
            });
            return headers;
          }
          Body.call(Request.prototype);
          function Response(bodyInit, options2) {
            if (!options2) {
              options2 = {};
            }
            this.type = "default";
            this.status = options2.status === void 0 ? 200 : options2.status;
            this.ok = this.status >= 200 && this.status < 300;
            this.statusText = "statusText" in options2 ? options2.statusText : "OK";
            this.headers = new Headers(options2.headers);
            this.url = options2.url || "";
            this._initBody(bodyInit);
          }
          Body.call(Response.prototype);
          Response.prototype.clone = function() {
            return new Response(this._bodyInit, {
              status: this.status,
              statusText: this.statusText,
              headers: new Headers(this.headers),
              url: this.url
            });
          };
          Response.error = function() {
            var response = new Response(null, { status: 0, statusText: "" });
            response.type = "error";
            return response;
          };
          var redirectStatuses = [301, 302, 303, 307, 308];
          Response.redirect = function(url, status) {
            if (redirectStatuses.indexOf(status) === -1) {
              throw new RangeError("Invalid status code");
            }
            return new Response(null, { status, headers: { location: url } });
          };
          exports2.DOMException = self2.DOMException;
          try {
            new exports2.DOMException();
          } catch (err) {
            exports2.DOMException = function(message, name2) {
              this.message = message;
              this.name = name2;
              var error = Error(message);
              this.stack = error.stack;
            };
            exports2.DOMException.prototype = Object.create(Error.prototype);
            exports2.DOMException.prototype.constructor = exports2.DOMException;
          }
          function fetch3(input, init2) {
            return new Promise(function(resolve, reject) {
              var request = new Request(input, init2);
              if (request.signal && request.signal.aborted) {
                return reject(new exports2.DOMException("Aborted", "AbortError"));
              }
              var xhr = new XMLHttpRequest();
              function abortXhr() {
                xhr.abort();
              }
              xhr.onload = function() {
                var options2 = {
                  status: xhr.status,
                  statusText: xhr.statusText,
                  headers: parseHeaders(xhr.getAllResponseHeaders() || "")
                };
                options2.url = "responseURL" in xhr ? xhr.responseURL : options2.headers.get("X-Request-URL");
                var body = "response" in xhr ? xhr.response : xhr.responseText;
                resolve(new Response(body, options2));
              };
              xhr.onerror = function() {
                reject(new TypeError("Network request failed"));
              };
              xhr.ontimeout = function() {
                reject(new TypeError("Network request failed"));
              };
              xhr.onabort = function() {
                reject(new exports2.DOMException("Aborted", "AbortError"));
              };
              xhr.open(request.method, request.url, true);
              if (request.credentials === "include") {
                xhr.withCredentials = true;
              } else if (request.credentials === "omit") {
                xhr.withCredentials = false;
              }
              if ("responseType" in xhr && support.blob) {
                xhr.responseType = "blob";
              }
              request.headers.forEach(function(value, name2) {
                xhr.setRequestHeader(name2, value);
              });
              if (request.signal) {
                request.signal.addEventListener("abort", abortXhr);
                xhr.onreadystatechange = function() {
                  if (xhr.readyState === 4) {
                    request.signal.removeEventListener("abort", abortXhr);
                  }
                };
              }
              xhr.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
            });
          }
          fetch3.polyfill = true;
          if (!self2.fetch) {
            self2.fetch = fetch3;
            self2.Headers = Headers;
            self2.Request = Request;
            self2.Response = Response;
          }
          exports2.Headers = Headers;
          exports2.Request = Request;
          exports2.Response = Response;
          exports2.fetch = fetch3;
          Object.defineProperty(exports2, "__esModule", { value: true });
          return exports2;
        }({});
      })(__self__);
      __self__.fetch.ponyfill = true;
      delete __self__.fetch.polyfill;
      var ctx = __self__;
      exports = ctx.fetch;
      exports.default = ctx.fetch;
      exports.fetch = ctx.fetch;
      exports.Headers = ctx.Headers;
      exports.Request = ctx.Request;
      exports.Response = ctx.Response;
      module.exports = exports;
    }
  });

  // node_modules/@walletconnect/jsonrpc-http-connection/dist/esm/http.js
  var import_events7, import_cross_fetch, DEFAULT_HTTP_HEADERS, DEFAULT_HTTP_METHOD, DEFAULT_FETCH_OPTS, EVENT_EMITTER_MAX_LISTENERS_DEFAULT, HttpConnection, http_default;
  var init_http = __esm({
    "node_modules/@walletconnect/jsonrpc-http-connection/dist/esm/http.js"() {
      import_events7 = __toESM(require_events());
      import_cross_fetch = __toESM(require_browser_ponyfill());
      init_esm2();
      init_esm6();
      DEFAULT_HTTP_HEADERS = {
        Accept: "application/json",
        "Content-Type": "application/json"
      };
      DEFAULT_HTTP_METHOD = "POST";
      DEFAULT_FETCH_OPTS = {
        headers: DEFAULT_HTTP_HEADERS,
        method: DEFAULT_HTTP_METHOD
      };
      EVENT_EMITTER_MAX_LISTENERS_DEFAULT = 10;
      HttpConnection = class {
        constructor(url, disableProviderPing = false) {
          this.url = url;
          this.disableProviderPing = disableProviderPing;
          this.events = new import_events7.EventEmitter();
          this.isAvailable = false;
          this.registering = false;
          if (!isHttpUrl(url)) {
            throw new Error(`Provided URL is not compatible with HTTP connection: ${url}`);
          }
          this.url = url;
          this.disableProviderPing = disableProviderPing;
        }
        get connected() {
          return this.isAvailable;
        }
        get connecting() {
          return this.registering;
        }
        on(event, listener) {
          this.events.on(event, listener);
        }
        once(event, listener) {
          this.events.once(event, listener);
        }
        off(event, listener) {
          this.events.off(event, listener);
        }
        removeListener(event, listener) {
          this.events.removeListener(event, listener);
        }
        async open(url = this.url) {
          await this.register(url);
        }
        async close() {
          if (!this.isAvailable) {
            throw new Error("Connection already closed");
          }
          this.onClose();
        }
        async send(payload, context) {
          if (!this.isAvailable) {
            await this.register();
          }
          try {
            const body = safeJsonStringify(payload);
            const res = await (0, import_cross_fetch.default)(this.url, Object.assign(Object.assign({}, DEFAULT_FETCH_OPTS), { body }));
            const data2 = await res.json();
            this.onPayload({ data: data2 });
          } catch (e9) {
            this.onError(payload.id, e9);
          }
        }
        async register(url = this.url) {
          if (!isHttpUrl(url)) {
            throw new Error(`Provided URL is not compatible with HTTP connection: ${url}`);
          }
          if (this.registering) {
            const currentMaxListeners = this.events.getMaxListeners();
            if (this.events.listenerCount("register_error") >= currentMaxListeners || this.events.listenerCount("open") >= currentMaxListeners) {
              this.events.setMaxListeners(currentMaxListeners + 1);
            }
            return new Promise((resolve, reject) => {
              this.events.once("register_error", (error) => {
                this.resetMaxListeners();
                reject(error);
              });
              this.events.once("open", () => {
                this.resetMaxListeners();
                if (typeof this.isAvailable === "undefined") {
                  return reject(new Error("HTTP connection is missing or invalid"));
                }
                resolve();
              });
            });
          }
          this.url = url;
          this.registering = true;
          try {
            if (!this.disableProviderPing) {
              const body = safeJsonStringify({ id: 1, jsonrpc: "2.0", method: "test", params: [] });
              await (0, import_cross_fetch.default)(url, Object.assign(Object.assign({}, DEFAULT_FETCH_OPTS), { body }));
            }
            this.onOpen();
          } catch (e9) {
            const error = this.parseError(e9);
            this.events.emit("register_error", error);
            this.onClose();
            throw error;
          }
        }
        onOpen() {
          this.isAvailable = true;
          this.registering = false;
          this.events.emit("open");
        }
        onClose() {
          this.isAvailable = false;
          this.registering = false;
          this.events.emit("close");
        }
        onPayload(e9) {
          if (typeof e9.data === "undefined")
            return;
          const payload = typeof e9.data === "string" ? safeJsonParse(e9.data) : e9.data;
          this.events.emit("payload", payload);
        }
        onError(id3, e9) {
          const error = this.parseError(e9);
          const message = error.message || error.toString();
          const payload = formatJsonRpcError(id3, message);
          this.events.emit("payload", payload);
        }
        parseError(e9, url = this.url) {
          return parseConnectionError(e9, url, "HTTP");
        }
        resetMaxListeners() {
          if (this.events.getMaxListeners() > EVENT_EMITTER_MAX_LISTENERS_DEFAULT) {
            this.events.setMaxListeners(EVENT_EMITTER_MAX_LISTENERS_DEFAULT);
          }
        }
      };
      http_default = HttpConnection;
    }
  });

  // node_modules/@walletconnect/jsonrpc-http-connection/dist/esm/index.js
  var esm_default;
  var init_esm8 = __esm({
    "node_modules/@walletconnect/jsonrpc-http-connection/dist/esm/index.js"() {
      init_http();
      init_http();
      esm_default = http_default;
    }
  });

  // node_modules/@walletconnect/universal-provider/dist/index.es.js
  function ft3(C6, u7, i7) {
    var d7;
    const w8 = ge(C6);
    return ((d7 = u7.rpcMap) == null ? void 0 : d7[w8.reference]) || `${Mg}?chainId=${w8.namespace}:${w8.reference}&projectId=${i7}`;
  }
  function Ct2(C6) {
    return C6.includes(":") ? C6.split(":")[1] : C6;
  }
  function Sa(C6) {
    return C6.map((u7) => `${u7.split(":")[0]}:${u7.split(":")[1]}`);
  }
  function Zg(C6, u7) {
    const i7 = Object.keys(u7.namespaces).filter((w8) => w8.includes(C6));
    if (!i7.length)
      return [];
    const d7 = [];
    return i7.forEach((w8) => {
      const T6 = u7.namespaces[w8].accounts;
      d7.push(...T6);
    }), d7;
  }
  function Jg(C6 = {}, u7 = {}) {
    const i7 = Oa(C6), d7 = Oa(u7);
    return Ui2.exports.merge(i7, d7);
  }
  function Oa(C6) {
    var u7, i7, d7, w8;
    const T6 = {};
    if (!B2(C6))
      return T6;
    for (const [$8, En2] of Object.entries(C6)) {
      const zt5 = oe2($8) ? [$8] : En2.chains, pr2 = En2.methods || [], It6 = En2.events || [], Ln2 = En2.rpcMap || {}, Fn2 = Xe2($8);
      T6[Fn2] = Yg(cr2(cr2({}, T6[Fn2]), En2), { chains: S2(zt5, (u7 = T6[Fn2]) == null ? void 0 : u7.chains), methods: S2(pr2, (i7 = T6[Fn2]) == null ? void 0 : i7.methods), events: S2(It6, (d7 = T6[Fn2]) == null ? void 0 : d7.events), rpcMap: cr2(cr2({}, Ln2), (w8 = T6[Fn2]) == null ? void 0 : w8.rpcMap) });
    }
    return T6;
  }
  function Xg(C6) {
    return C6.includes(":") ? C6.split(":")[2] : C6;
  }
  function Qg(C6) {
    const u7 = {};
    for (const [i7, d7] of Object.entries(C6)) {
      const w8 = d7.methods || [], T6 = d7.events || [], $8 = d7.accounts || [], En2 = oe2(i7) ? [i7] : d7.chains ? d7.chains : Sa(d7.accounts);
      u7[i7] = { chains: En2, methods: w8, events: T6, accounts: $8 };
    }
    return u7;
  }
  function Wi2(C6) {
    return typeof C6 == "number" ? C6 : C6.includes("0x") ? parseInt(C6, 16) : C6.includes(":") ? Number(C6.split(":")[1]) : Number(C6);
  }
  var import_logger3, import_events8, Ia, Ug, Wg, Fg, xa, Mg, Vn2, ge3, Ui2, qg, Bg, Gg, Ea, zg, Kg, ya, cr2, Yg, Ra, z2, Fi, Vg, kg, jg, nv, tv, ev, rv, iv, sv, uv, av, ba, ov, fv, Ta, hr2, Mi, lr2, cv;
  var init_index_es7 = __esm({
    "node_modules/@walletconnect/universal-provider/dist/index.es.js"() {
      init_index_es6();
      init_index_es();
      import_logger3 = __toESM(require_cjs5());
      init_esm8();
      init_esm7();
      import_events8 = __toESM(require_events());
      Ia = "error";
      Ug = "wss://relay.walletconnect.com";
      Wg = "wc";
      Fg = "universal_provider";
      xa = `${Wg}@2:${Fg}:`;
      Mg = "https://rpc.walletconnect.com/v1/";
      Vn2 = { DEFAULT_CHAIN_CHANGED: "default_chain_changed" };
      ge3 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
      Ui2 = { exports: {} };
      (function(C6, u7) {
        (function() {
          var i7, d7 = "4.17.21", w8 = 200, T6 = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", $8 = "Expected a function", En2 = "Invalid `variable` option passed into `_.template`", zt5 = "__lodash_hash_undefined__", pr2 = 500, It6 = "__lodash_placeholder__", Ln2 = 1, Fn2 = 2, xt5 = 4, Et5 = 1, ve3 = 2, vn = 1, ct4 = 2, qi2 = 4, Dn2 = 8, yt5 = 16, Hn2 = 32, St6 = 64, Mn2 = 128, Kt5 = 256, dr4 = 512, La2 = 30, Da2 = "...", Ha2 = 800, Na2 = 16, Bi2 = 1, $a2 = 2, Ua2 = 3, ht5 = 1 / 0, kn2 = 9007199254740991, Wa2 = 17976931348623157e292, _e6 = 0 / 0, Nn2 = 4294967295, Fa2 = Nn2 - 1, Ma2 = Nn2 >>> 1, qa2 = [["ary", Mn2], ["bind", vn], ["bindKey", ct4], ["curry", Dn2], ["curryRight", yt5], ["flip", dr4], ["partial", Hn2], ["partialRight", St6], ["rearg", Kt5]], Ot6 = "[object Arguments]", me6 = "[object Array]", Ba2 = "[object AsyncFunction]", Yt4 = "[object Boolean]", Zt4 = "[object Date]", Ga2 = "[object DOMException]", we3 = "[object Error]", Pe4 = "[object Function]", Gi2 = "[object GeneratorFunction]", yn2 = "[object Map]", Jt5 = "[object Number]", za2 = "[object Null]", qn2 = "[object Object]", zi = "[object Promise]", Ka2 = "[object Proxy]", Xt4 = "[object RegExp]", Sn2 = "[object Set]", Qt4 = "[object String]", Ae4 = "[object Symbol]", Ya2 = "[object Undefined]", Vt5 = "[object WeakMap]", Za2 = "[object WeakSet]", kt5 = "[object ArrayBuffer]", Rt5 = "[object DataView]", gr2 = "[object Float32Array]", vr3 = "[object Float64Array]", _r3 = "[object Int8Array]", mr4 = "[object Int16Array]", wr3 = "[object Int32Array]", Pr3 = "[object Uint8Array]", Ar3 = "[object Uint8ClampedArray]", Cr3 = "[object Uint16Array]", Ir3 = "[object Uint32Array]", Ja2 = /\b__p \+= '';/g, Xa2 = /\b(__p \+=) '' \+/g, Qa2 = /(__e\(.*?\)|\b__t\)) \+\n'';/g, Ki = /&(?:amp|lt|gt|quot|#39);/g, Yi2 = /[&<>"']/g, Va2 = RegExp(Ki.source), ka2 = RegExp(Yi2.source), ja2 = /<%-([\s\S]+?)%>/g, no3 = /<%([\s\S]+?)%>/g, Zi2 = /<%=([\s\S]+?)%>/g, to3 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, eo3 = /^\w*$/, ro3 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, xr3 = /[\\^$.*+?()[\]{}|]/g, io3 = RegExp(xr3.source), Er3 = /^\s+/, so3 = /\s/, uo3 = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, ao3 = /\{\n\/\* \[wrapped with (.+)\] \*/, oo3 = /,? & /, fo3 = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, co3 = /[()=,{}\[\]\/\s]/, ho3 = /\\(\\)?/g, lo3 = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, Ji2 = /\w*$/, po3 = /^[-+]0x[0-9a-f]+$/i, go3 = /^0b[01]+$/i, vo3 = /^\[object .+?Constructor\]$/, _o3 = /^0o[0-7]+$/i, mo3 = /^(?:0|[1-9]\d*)$/, wo3 = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, Ce4 = /($^)/, Po3 = /['\n\r\u2028\u2029\\]/g, Ie5 = "\\ud800-\\udfff", Ao3 = "\\u0300-\\u036f", Co3 = "\\ufe20-\\ufe2f", Io3 = "\\u20d0-\\u20ff", Xi2 = Ao3 + Co3 + Io3, Qi2 = "\\u2700-\\u27bf", Vi2 = "a-z\\xdf-\\xf6\\xf8-\\xff", xo3 = "\\xac\\xb1\\xd7\\xf7", Eo3 = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", yo3 = "\\u2000-\\u206f", So3 = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", ki2 = "A-Z\\xc0-\\xd6\\xd8-\\xde", ji2 = "\\ufe0e\\ufe0f", ns2 = xo3 + Eo3 + yo3 + So3, yr2 = "['\u2019]", Oo3 = "[" + Ie5 + "]", ts2 = "[" + ns2 + "]", xe3 = "[" + Xi2 + "]", es2 = "\\d+", Ro3 = "[" + Qi2 + "]", rs2 = "[" + Vi2 + "]", is2 = "[^" + Ie5 + ns2 + es2 + Qi2 + Vi2 + ki2 + "]", Sr3 = "\\ud83c[\\udffb-\\udfff]", bo3 = "(?:" + xe3 + "|" + Sr3 + ")", ss2 = "[^" + Ie5 + "]", Or3 = "(?:\\ud83c[\\udde6-\\uddff]){2}", Rr3 = "[\\ud800-\\udbff][\\udc00-\\udfff]", bt5 = "[" + ki2 + "]", us3 = "\\u200d", as3 = "(?:" + rs2 + "|" + is2 + ")", To3 = "(?:" + bt5 + "|" + is2 + ")", os3 = "(?:" + yr2 + "(?:d|ll|m|re|s|t|ve))?", fs2 = "(?:" + yr2 + "(?:D|LL|M|RE|S|T|VE))?", cs3 = bo3 + "?", hs3 = "[" + ji2 + "]?", Lo3 = "(?:" + us3 + "(?:" + [ss2, Or3, Rr3].join("|") + ")" + hs3 + cs3 + ")*", Do3 = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", Ho3 = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", ls3 = hs3 + cs3 + Lo3, No3 = "(?:" + [Ro3, Or3, Rr3].join("|") + ")" + ls3, $o3 = "(?:" + [ss2 + xe3 + "?", xe3, Or3, Rr3, Oo3].join("|") + ")", Uo3 = RegExp(yr2, "g"), Wo3 = RegExp(xe3, "g"), br3 = RegExp(Sr3 + "(?=" + Sr3 + ")|" + $o3 + ls3, "g"), Fo3 = RegExp([bt5 + "?" + rs2 + "+" + os3 + "(?=" + [ts2, bt5, "$"].join("|") + ")", To3 + "+" + fs2 + "(?=" + [ts2, bt5 + as3, "$"].join("|") + ")", bt5 + "?" + as3 + "+" + os3, bt5 + "+" + fs2, Ho3, Do3, es2, No3].join("|"), "g"), Mo3 = RegExp("[" + us3 + Ie5 + Xi2 + ji2 + "]"), qo3 = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, Bo3 = ["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout"], Go3 = -1, B10 = {};
          B10[gr2] = B10[vr3] = B10[_r3] = B10[mr4] = B10[wr3] = B10[Pr3] = B10[Ar3] = B10[Cr3] = B10[Ir3] = true, B10[Ot6] = B10[me6] = B10[kt5] = B10[Yt4] = B10[Rt5] = B10[Zt4] = B10[we3] = B10[Pe4] = B10[yn2] = B10[Jt5] = B10[qn2] = B10[Xt4] = B10[Sn2] = B10[Qt4] = B10[Vt5] = false;
          var q8 = {};
          q8[Ot6] = q8[me6] = q8[kt5] = q8[Rt5] = q8[Yt4] = q8[Zt4] = q8[gr2] = q8[vr3] = q8[_r3] = q8[mr4] = q8[wr3] = q8[yn2] = q8[Jt5] = q8[qn2] = q8[Xt4] = q8[Sn2] = q8[Qt4] = q8[Ae4] = q8[Pr3] = q8[Ar3] = q8[Cr3] = q8[Ir3] = true, q8[we3] = q8[Pe4] = q8[Vt5] = false;
          var zo3 = { \u00C0: "A", \u00C1: "A", \u00C2: "A", \u00C3: "A", \u00C4: "A", \u00C5: "A", \u00E0: "a", \u00E1: "a", \u00E2: "a", \u00E3: "a", \u00E4: "a", \u00E5: "a", \u00C7: "C", \u00E7: "c", \u00D0: "D", \u00F0: "d", \u00C8: "E", \u00C9: "E", \u00CA: "E", \u00CB: "E", \u00E8: "e", \u00E9: "e", \u00EA: "e", \u00EB: "e", \u00CC: "I", \u00CD: "I", \u00CE: "I", \u00CF: "I", \u00EC: "i", \u00ED: "i", \u00EE: "i", \u00EF: "i", \u00D1: "N", \u00F1: "n", \u00D2: "O", \u00D3: "O", \u00D4: "O", \u00D5: "O", \u00D6: "O", \u00D8: "O", \u00F2: "o", \u00F3: "o", \u00F4: "o", \u00F5: "o", \u00F6: "o", \u00F8: "o", \u00D9: "U", \u00DA: "U", \u00DB: "U", \u00DC: "U", \u00F9: "u", \u00FA: "u", \u00FB: "u", \u00FC: "u", \u00DD: "Y", \u00FD: "y", \u00FF: "y", \u00C6: "Ae", \u00E6: "ae", \u00DE: "Th", \u00FE: "th", \u00DF: "ss", \u0100: "A", \u0102: "A", \u0104: "A", \u0101: "a", \u0103: "a", \u0105: "a", \u0106: "C", \u0108: "C", \u010A: "C", \u010C: "C", \u0107: "c", \u0109: "c", \u010B: "c", \u010D: "c", \u010E: "D", \u0110: "D", \u010F: "d", \u0111: "d", \u0112: "E", \u0114: "E", \u0116: "E", \u0118: "E", \u011A: "E", \u0113: "e", \u0115: "e", \u0117: "e", \u0119: "e", \u011B: "e", \u011C: "G", \u011E: "G", \u0120: "G", \u0122: "G", \u011D: "g", \u011F: "g", \u0121: "g", \u0123: "g", \u0124: "H", \u0126: "H", \u0125: "h", \u0127: "h", \u0128: "I", \u012A: "I", \u012C: "I", \u012E: "I", \u0130: "I", \u0129: "i", \u012B: "i", \u012D: "i", \u012F: "i", \u0131: "i", \u0134: "J", \u0135: "j", \u0136: "K", \u0137: "k", \u0138: "k", \u0139: "L", \u013B: "L", \u013D: "L", \u013F: "L", \u0141: "L", \u013A: "l", \u013C: "l", \u013E: "l", \u0140: "l", \u0142: "l", \u0143: "N", \u0145: "N", \u0147: "N", \u014A: "N", \u0144: "n", \u0146: "n", \u0148: "n", \u014B: "n", \u014C: "O", \u014E: "O", \u0150: "O", \u014D: "o", \u014F: "o", \u0151: "o", \u0154: "R", \u0156: "R", \u0158: "R", \u0155: "r", \u0157: "r", \u0159: "r", \u015A: "S", \u015C: "S", \u015E: "S", \u0160: "S", \u015B: "s", \u015D: "s", \u015F: "s", \u0161: "s", \u0162: "T", \u0164: "T", \u0166: "T", \u0163: "t", \u0165: "t", \u0167: "t", \u0168: "U", \u016A: "U", \u016C: "U", \u016E: "U", \u0170: "U", \u0172: "U", \u0169: "u", \u016B: "u", \u016D: "u", \u016F: "u", \u0171: "u", \u0173: "u", \u0174: "W", \u0175: "w", \u0176: "Y", \u0177: "y", \u0178: "Y", \u0179: "Z", \u017B: "Z", \u017D: "Z", \u017A: "z", \u017C: "z", \u017E: "z", \u0132: "IJ", \u0133: "ij", \u0152: "Oe", \u0153: "oe", \u0149: "'n", \u017F: "s" }, Ko3 = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }, Yo3 = { "&amp;": "&", "&lt;": "<", "&gt;": ">", "&quot;": '"', "&#39;": "'" }, Zo3 = { "\\": "\\", "'": "'", "\n": "n", "\r": "r", "\u2028": "u2028", "\u2029": "u2029" }, Jo3 = parseFloat, Xo3 = parseInt, ps3 = typeof ge3 == "object" && ge3 && ge3.Object === Object && ge3, Qo3 = typeof self == "object" && self && self.Object === Object && self, k6 = ps3 || Qo3 || Function("return this")(), Tr3 = u7 && !u7.nodeType && u7, lt4 = Tr3 && true && C6 && !C6.nodeType && C6, ds3 = lt4 && lt4.exports === Tr3, Lr2 = ds3 && ps3.process, _n = function() {
            try {
              var h10 = lt4 && lt4.require && lt4.require("util").types;
              return h10 || Lr2 && Lr2.binding && Lr2.binding("util");
            } catch {
            }
          }(), gs3 = _n && _n.isArrayBuffer, vs2 = _n && _n.isDate, _s2 = _n && _n.isMap, ms2 = _n && _n.isRegExp, ws3 = _n && _n.isSet, Ps2 = _n && _n.isTypedArray;
          function cn2(h10, g7, p8) {
            switch (p8.length) {
              case 0:
                return h10.call(g7);
              case 1:
                return h10.call(g7, p8[0]);
              case 2:
                return h10.call(g7, p8[0], p8[1]);
              case 3:
                return h10.call(g7, p8[0], p8[1], p8[2]);
            }
            return h10.apply(g7, p8);
          }
          function Vo3(h10, g7, p8, A7) {
            for (var S12 = -1, U9 = h10 == null ? 0 : h10.length; ++S12 < U9; ) {
              var X8 = h10[S12];
              g7(A7, X8, p8(X8), h10);
            }
            return A7;
          }
          function mn2(h10, g7) {
            for (var p8 = -1, A7 = h10 == null ? 0 : h10.length; ++p8 < A7 && g7(h10[p8], p8, h10) !== false; )
              ;
            return h10;
          }
          function ko3(h10, g7) {
            for (var p8 = h10 == null ? 0 : h10.length; p8-- && g7(h10[p8], p8, h10) !== false; )
              ;
            return h10;
          }
          function As2(h10, g7) {
            for (var p8 = -1, A7 = h10 == null ? 0 : h10.length; ++p8 < A7; )
              if (!g7(h10[p8], p8, h10))
                return false;
            return true;
          }
          function jn(h10, g7) {
            for (var p8 = -1, A7 = h10 == null ? 0 : h10.length, S12 = 0, U9 = []; ++p8 < A7; ) {
              var X8 = h10[p8];
              g7(X8, p8, h10) && (U9[S12++] = X8);
            }
            return U9;
          }
          function Ee4(h10, g7) {
            var p8 = h10 == null ? 0 : h10.length;
            return !!p8 && Tt5(h10, g7, 0) > -1;
          }
          function Dr2(h10, g7, p8) {
            for (var A7 = -1, S12 = h10 == null ? 0 : h10.length; ++A7 < S12; )
              if (p8(g7, h10[A7]))
                return true;
            return false;
          }
          function G9(h10, g7) {
            for (var p8 = -1, A7 = h10 == null ? 0 : h10.length, S12 = Array(A7); ++p8 < A7; )
              S12[p8] = g7(h10[p8], p8, h10);
            return S12;
          }
          function nt3(h10, g7) {
            for (var p8 = -1, A7 = g7.length, S12 = h10.length; ++p8 < A7; )
              h10[S12 + p8] = g7[p8];
            return h10;
          }
          function Hr2(h10, g7, p8, A7) {
            var S12 = -1, U9 = h10 == null ? 0 : h10.length;
            for (A7 && U9 && (p8 = h10[++S12]); ++S12 < U9; )
              p8 = g7(p8, h10[S12], S12, h10);
            return p8;
          }
          function jo3(h10, g7, p8, A7) {
            var S12 = h10 == null ? 0 : h10.length;
            for (A7 && S12 && (p8 = h10[--S12]); S12--; )
              p8 = g7(p8, h10[S12], S12, h10);
            return p8;
          }
          function Nr3(h10, g7) {
            for (var p8 = -1, A7 = h10 == null ? 0 : h10.length; ++p8 < A7; )
              if (g7(h10[p8], p8, h10))
                return true;
            return false;
          }
          var nf = $r2("length");
          function tf(h10) {
            return h10.split("");
          }
          function ef(h10) {
            return h10.match(fo3) || [];
          }
          function Cs2(h10, g7, p8) {
            var A7;
            return p8(h10, function(S12, U9, X8) {
              if (g7(S12, U9, X8))
                return A7 = U9, false;
            }), A7;
          }
          function ye6(h10, g7, p8, A7) {
            for (var S12 = h10.length, U9 = p8 + (A7 ? 1 : -1); A7 ? U9-- : ++U9 < S12; )
              if (g7(h10[U9], U9, h10))
                return U9;
            return -1;
          }
          function Tt5(h10, g7, p8) {
            return g7 === g7 ? gf(h10, g7, p8) : ye6(h10, Is2, p8);
          }
          function rf(h10, g7, p8, A7) {
            for (var S12 = p8 - 1, U9 = h10.length; ++S12 < U9; )
              if (A7(h10[S12], g7))
                return S12;
            return -1;
          }
          function Is2(h10) {
            return h10 !== h10;
          }
          function xs2(h10, g7) {
            var p8 = h10 == null ? 0 : h10.length;
            return p8 ? Wr2(h10, g7) / p8 : _e6;
          }
          function $r2(h10) {
            return function(g7) {
              return g7 == null ? i7 : g7[h10];
            };
          }
          function Ur2(h10) {
            return function(g7) {
              return h10 == null ? i7 : h10[g7];
            };
          }
          function Es2(h10, g7, p8, A7, S12) {
            return S12(h10, function(U9, X8, M7) {
              p8 = A7 ? (A7 = false, U9) : g7(p8, U9, X8, M7);
            }), p8;
          }
          function sf(h10, g7) {
            var p8 = h10.length;
            for (h10.sort(g7); p8--; )
              h10[p8] = h10[p8].value;
            return h10;
          }
          function Wr2(h10, g7) {
            for (var p8, A7 = -1, S12 = h10.length; ++A7 < S12; ) {
              var U9 = g7(h10[A7]);
              U9 !== i7 && (p8 = p8 === i7 ? U9 : p8 + U9);
            }
            return p8;
          }
          function Fr2(h10, g7) {
            for (var p8 = -1, A7 = Array(h10); ++p8 < h10; )
              A7[p8] = g7(p8);
            return A7;
          }
          function uf(h10, g7) {
            return G9(g7, function(p8) {
              return [p8, h10[p8]];
            });
          }
          function ys2(h10) {
            return h10 && h10.slice(0, bs2(h10) + 1).replace(Er3, "");
          }
          function hn2(h10) {
            return function(g7) {
              return h10(g7);
            };
          }
          function Mr2(h10, g7) {
            return G9(g7, function(p8) {
              return h10[p8];
            });
          }
          function jt5(h10, g7) {
            return h10.has(g7);
          }
          function Ss2(h10, g7) {
            for (var p8 = -1, A7 = h10.length; ++p8 < A7 && Tt5(g7, h10[p8], 0) > -1; )
              ;
            return p8;
          }
          function Os2(h10, g7) {
            for (var p8 = h10.length; p8-- && Tt5(g7, h10[p8], 0) > -1; )
              ;
            return p8;
          }
          function af(h10, g7) {
            for (var p8 = h10.length, A7 = 0; p8--; )
              h10[p8] === g7 && ++A7;
            return A7;
          }
          var of = Ur2(zo3), ff = Ur2(Ko3);
          function cf(h10) {
            return "\\" + Zo3[h10];
          }
          function hf(h10, g7) {
            return h10 == null ? i7 : h10[g7];
          }
          function Lt5(h10) {
            return Mo3.test(h10);
          }
          function lf(h10) {
            return qo3.test(h10);
          }
          function pf(h10) {
            for (var g7, p8 = []; !(g7 = h10.next()).done; )
              p8.push(g7.value);
            return p8;
          }
          function qr2(h10) {
            var g7 = -1, p8 = Array(h10.size);
            return h10.forEach(function(A7, S12) {
              p8[++g7] = [S12, A7];
            }), p8;
          }
          function Rs2(h10, g7) {
            return function(p8) {
              return h10(g7(p8));
            };
          }
          function tt4(h10, g7) {
            for (var p8 = -1, A7 = h10.length, S12 = 0, U9 = []; ++p8 < A7; ) {
              var X8 = h10[p8];
              (X8 === g7 || X8 === It6) && (h10[p8] = It6, U9[S12++] = p8);
            }
            return U9;
          }
          function Se3(h10) {
            var g7 = -1, p8 = Array(h10.size);
            return h10.forEach(function(A7) {
              p8[++g7] = A7;
            }), p8;
          }
          function df(h10) {
            var g7 = -1, p8 = Array(h10.size);
            return h10.forEach(function(A7) {
              p8[++g7] = [A7, A7];
            }), p8;
          }
          function gf(h10, g7, p8) {
            for (var A7 = p8 - 1, S12 = h10.length; ++A7 < S12; )
              if (h10[A7] === g7)
                return A7;
            return -1;
          }
          function vf(h10, g7, p8) {
            for (var A7 = p8 + 1; A7--; )
              if (h10[A7] === g7)
                return A7;
            return A7;
          }
          function Dt5(h10) {
            return Lt5(h10) ? mf(h10) : nf(h10);
          }
          function On3(h10) {
            return Lt5(h10) ? wf(h10) : tf(h10);
          }
          function bs2(h10) {
            for (var g7 = h10.length; g7-- && so3.test(h10.charAt(g7)); )
              ;
            return g7;
          }
          var _f = Ur2(Yo3);
          function mf(h10) {
            for (var g7 = br3.lastIndex = 0; br3.test(h10); )
              ++g7;
            return g7;
          }
          function wf(h10) {
            return h10.match(br3) || [];
          }
          function Pf(h10) {
            return h10.match(Fo3) || [];
          }
          var Af = function h10(g7) {
            g7 = g7 == null ? k6 : Ht4.defaults(k6.Object(), g7, Ht4.pick(k6, Bo3));
            var p8 = g7.Array, A7 = g7.Date, S12 = g7.Error, U9 = g7.Function, X8 = g7.Math, M7 = g7.Object, Br2 = g7.RegExp, Cf = g7.String, wn3 = g7.TypeError, Oe3 = p8.prototype, If = U9.prototype, Nt5 = M7.prototype, Re6 = g7["__core-js_shared__"], be3 = If.toString, F8 = Nt5.hasOwnProperty, xf = 0, Ts2 = function() {
              var n9 = /[^.]+$/.exec(Re6 && Re6.keys && Re6.keys.IE_PROTO || "");
              return n9 ? "Symbol(src)_1." + n9 : "";
            }(), Te5 = Nt5.toString, Ef = be3.call(M7), yf = k6._, Sf = Br2("^" + be3.call(F8).replace(xr3, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), Le4 = ds3 ? g7.Buffer : i7, et4 = g7.Symbol, De5 = g7.Uint8Array, Ls2 = Le4 ? Le4.allocUnsafe : i7, He5 = Rs2(M7.getPrototypeOf, M7), Ds2 = M7.create, Hs2 = Nt5.propertyIsEnumerable, Ne3 = Oe3.splice, Ns2 = et4 ? et4.isConcatSpreadable : i7, ne7 = et4 ? et4.iterator : i7, pt5 = et4 ? et4.toStringTag : i7, $e5 = function() {
              try {
                var n9 = mt5(M7, "defineProperty");
                return n9({}, "", {}), n9;
              } catch {
              }
            }(), Of = g7.clearTimeout !== k6.clearTimeout && g7.clearTimeout, Rf = A7 && A7.now !== k6.Date.now && A7.now, bf = g7.setTimeout !== k6.setTimeout && g7.setTimeout, Ue5 = X8.ceil, We5 = X8.floor, Gr2 = M7.getOwnPropertySymbols, Tf = Le4 ? Le4.isBuffer : i7, $s2 = g7.isFinite, Lf = Oe3.join, Df = Rs2(M7.keys, M7), Q10 = X8.max, nn2 = X8.min, Hf = A7.now, Nf = g7.parseInt, Us2 = X8.random, $f = Oe3.reverse, zr3 = mt5(g7, "DataView"), te9 = mt5(g7, "Map"), Kr2 = mt5(g7, "Promise"), $t4 = mt5(g7, "Set"), ee6 = mt5(g7, "WeakMap"), re6 = mt5(M7, "create"), Fe5 = ee6 && new ee6(), Ut4 = {}, Uf = wt6(zr3), Wf = wt6(te9), Ff = wt6(Kr2), Mf = wt6($t4), qf = wt6(ee6), Me5 = et4 ? et4.prototype : i7, ie6 = Me5 ? Me5.valueOf : i7, Ws2 = Me5 ? Me5.toString : i7;
            function a6(n9) {
              if (Y6(n9) && !O8(n9) && !(n9 instanceof H5)) {
                if (n9 instanceof Pn2)
                  return n9;
                if (F8.call(n9, "__wrapped__"))
                  return Fu(n9);
              }
              return new Pn2(n9);
            }
            var Wt4 = function() {
              function n9() {
              }
              return function(t6) {
                if (!K8(t6))
                  return {};
                if (Ds2)
                  return Ds2(t6);
                n9.prototype = t6;
                var e9 = new n9();
                return n9.prototype = i7, e9;
              };
            }();
            function qe5() {
            }
            function Pn2(n9, t6) {
              this.__wrapped__ = n9, this.__actions__ = [], this.__chain__ = !!t6, this.__index__ = 0, this.__values__ = i7;
            }
            a6.templateSettings = { escape: ja2, evaluate: no3, interpolate: Zi2, variable: "", imports: { _: a6 } }, a6.prototype = qe5.prototype, a6.prototype.constructor = a6, Pn2.prototype = Wt4(qe5.prototype), Pn2.prototype.constructor = Pn2;
            function H5(n9) {
              this.__wrapped__ = n9, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = false, this.__iteratees__ = [], this.__takeCount__ = Nn2, this.__views__ = [];
            }
            function Bf() {
              var n9 = new H5(this.__wrapped__);
              return n9.__actions__ = un2(this.__actions__), n9.__dir__ = this.__dir__, n9.__filtered__ = this.__filtered__, n9.__iteratees__ = un2(this.__iteratees__), n9.__takeCount__ = this.__takeCount__, n9.__views__ = un2(this.__views__), n9;
            }
            function Gf() {
              if (this.__filtered__) {
                var n9 = new H5(this);
                n9.__dir__ = -1, n9.__filtered__ = true;
              } else
                n9 = this.clone(), n9.__dir__ *= -1;
              return n9;
            }
            function zf() {
              var n9 = this.__wrapped__.value(), t6 = this.__dir__, e9 = O8(n9), r8 = t6 < 0, s7 = e9 ? n9.length : 0, o9 = eh(0, s7, this.__views__), f7 = o9.start, c9 = o9.end, l9 = c9 - f7, v6 = r8 ? c9 : f7 - 1, _8 = this.__iteratees__, m6 = _8.length, P7 = 0, I5 = nn2(l9, this.__takeCount__);
              if (!e9 || !r8 && s7 == l9 && I5 == l9)
                return ou(n9, this.__actions__);
              var E8 = [];
              n:
                for (; l9-- && P7 < I5; ) {
                  v6 += t6;
                  for (var b7 = -1, y11 = n9[v6]; ++b7 < m6; ) {
                    var D10 = _8[b7], N17 = D10.iteratee, dn2 = D10.type, sn2 = N17(y11);
                    if (dn2 == $a2)
                      y11 = sn2;
                    else if (!sn2) {
                      if (dn2 == Bi2)
                        continue n;
                      break n;
                    }
                  }
                  E8[P7++] = y11;
                }
              return E8;
            }
            H5.prototype = Wt4(qe5.prototype), H5.prototype.constructor = H5;
            function dt5(n9) {
              var t6 = -1, e9 = n9 == null ? 0 : n9.length;
              for (this.clear(); ++t6 < e9; ) {
                var r8 = n9[t6];
                this.set(r8[0], r8[1]);
              }
            }
            function Kf() {
              this.__data__ = re6 ? re6(null) : {}, this.size = 0;
            }
            function Yf(n9) {
              var t6 = this.has(n9) && delete this.__data__[n9];
              return this.size -= t6 ? 1 : 0, t6;
            }
            function Zf(n9) {
              var t6 = this.__data__;
              if (re6) {
                var e9 = t6[n9];
                return e9 === zt5 ? i7 : e9;
              }
              return F8.call(t6, n9) ? t6[n9] : i7;
            }
            function Jf(n9) {
              var t6 = this.__data__;
              return re6 ? t6[n9] !== i7 : F8.call(t6, n9);
            }
            function Xf(n9, t6) {
              var e9 = this.__data__;
              return this.size += this.has(n9) ? 0 : 1, e9[n9] = re6 && t6 === i7 ? zt5 : t6, this;
            }
            dt5.prototype.clear = Kf, dt5.prototype.delete = Yf, dt5.prototype.get = Zf, dt5.prototype.has = Jf, dt5.prototype.set = Xf;
            function Bn2(n9) {
              var t6 = -1, e9 = n9 == null ? 0 : n9.length;
              for (this.clear(); ++t6 < e9; ) {
                var r8 = n9[t6];
                this.set(r8[0], r8[1]);
              }
            }
            function Qf() {
              this.__data__ = [], this.size = 0;
            }
            function Vf(n9) {
              var t6 = this.__data__, e9 = Be5(t6, n9);
              if (e9 < 0)
                return false;
              var r8 = t6.length - 1;
              return e9 == r8 ? t6.pop() : Ne3.call(t6, e9, 1), --this.size, true;
            }
            function kf(n9) {
              var t6 = this.__data__, e9 = Be5(t6, n9);
              return e9 < 0 ? i7 : t6[e9][1];
            }
            function jf(n9) {
              return Be5(this.__data__, n9) > -1;
            }
            function nc(n9, t6) {
              var e9 = this.__data__, r8 = Be5(e9, n9);
              return r8 < 0 ? (++this.size, e9.push([n9, t6])) : e9[r8][1] = t6, this;
            }
            Bn2.prototype.clear = Qf, Bn2.prototype.delete = Vf, Bn2.prototype.get = kf, Bn2.prototype.has = jf, Bn2.prototype.set = nc;
            function Gn2(n9) {
              var t6 = -1, e9 = n9 == null ? 0 : n9.length;
              for (this.clear(); ++t6 < e9; ) {
                var r8 = n9[t6];
                this.set(r8[0], r8[1]);
              }
            }
            function tc() {
              this.size = 0, this.__data__ = { hash: new dt5(), map: new (te9 || Bn2)(), string: new dt5() };
            }
            function ec2(n9) {
              var t6 = nr5(this, n9).delete(n9);
              return this.size -= t6 ? 1 : 0, t6;
            }
            function rc(n9) {
              return nr5(this, n9).get(n9);
            }
            function ic(n9) {
              return nr5(this, n9).has(n9);
            }
            function sc(n9, t6) {
              var e9 = nr5(this, n9), r8 = e9.size;
              return e9.set(n9, t6), this.size += e9.size == r8 ? 0 : 1, this;
            }
            Gn2.prototype.clear = tc, Gn2.prototype.delete = ec2, Gn2.prototype.get = rc, Gn2.prototype.has = ic, Gn2.prototype.set = sc;
            function gt5(n9) {
              var t6 = -1, e9 = n9 == null ? 0 : n9.length;
              for (this.__data__ = new Gn2(); ++t6 < e9; )
                this.add(n9[t6]);
            }
            function uc(n9) {
              return this.__data__.set(n9, zt5), this;
            }
            function ac(n9) {
              return this.__data__.has(n9);
            }
            gt5.prototype.add = gt5.prototype.push = uc, gt5.prototype.has = ac;
            function Rn(n9) {
              var t6 = this.__data__ = new Bn2(n9);
              this.size = t6.size;
            }
            function oc() {
              this.__data__ = new Bn2(), this.size = 0;
            }
            function fc(n9) {
              var t6 = this.__data__, e9 = t6.delete(n9);
              return this.size = t6.size, e9;
            }
            function cc(n9) {
              return this.__data__.get(n9);
            }
            function hc(n9) {
              return this.__data__.has(n9);
            }
            function lc(n9, t6) {
              var e9 = this.__data__;
              if (e9 instanceof Bn2) {
                var r8 = e9.__data__;
                if (!te9 || r8.length < w8 - 1)
                  return r8.push([n9, t6]), this.size = ++e9.size, this;
                e9 = this.__data__ = new Gn2(r8);
              }
              return e9.set(n9, t6), this.size = e9.size, this;
            }
            Rn.prototype.clear = oc, Rn.prototype.delete = fc, Rn.prototype.get = cc, Rn.prototype.has = hc, Rn.prototype.set = lc;
            function Fs2(n9, t6) {
              var e9 = O8(n9), r8 = !e9 && Pt5(n9), s7 = !e9 && !r8 && at5(n9), o9 = !e9 && !r8 && !s7 && Bt5(n9), f7 = e9 || r8 || s7 || o9, c9 = f7 ? Fr2(n9.length, Cf) : [], l9 = c9.length;
              for (var v6 in n9)
                (t6 || F8.call(n9, v6)) && !(f7 && (v6 == "length" || s7 && (v6 == "offset" || v6 == "parent") || o9 && (v6 == "buffer" || v6 == "byteLength" || v6 == "byteOffset") || Zn(v6, l9))) && c9.push(v6);
              return c9;
            }
            function Ms2(n9) {
              var t6 = n9.length;
              return t6 ? n9[ei2(0, t6 - 1)] : i7;
            }
            function pc(n9, t6) {
              return tr5(un2(n9), vt4(t6, 0, n9.length));
            }
            function dc(n9) {
              return tr5(un2(n9));
            }
            function Yr2(n9, t6, e9) {
              (e9 !== i7 && !bn2(n9[t6], e9) || e9 === i7 && !(t6 in n9)) && zn(n9, t6, e9);
            }
            function se6(n9, t6, e9) {
              var r8 = n9[t6];
              (!(F8.call(n9, t6) && bn2(r8, e9)) || e9 === i7 && !(t6 in n9)) && zn(n9, t6, e9);
            }
            function Be5(n9, t6) {
              for (var e9 = n9.length; e9--; )
                if (bn2(n9[e9][0], t6))
                  return e9;
              return -1;
            }
            function gc(n9, t6, e9, r8) {
              return rt4(n9, function(s7, o9, f7) {
                t6(r8, s7, e9(s7), f7);
              }), r8;
            }
            function qs2(n9, t6) {
              return n9 && Un2(t6, V9(t6), n9);
            }
            function vc(n9, t6) {
              return n9 && Un2(t6, on2(t6), n9);
            }
            function zn(n9, t6, e9) {
              t6 == "__proto__" && $e5 ? $e5(n9, t6, { configurable: true, enumerable: true, value: e9, writable: true }) : n9[t6] = e9;
            }
            function Zr2(n9, t6) {
              for (var e9 = -1, r8 = t6.length, s7 = p8(r8), o9 = n9 == null; ++e9 < r8; )
                s7[e9] = o9 ? i7 : Si(n9, t6[e9]);
              return s7;
            }
            function vt4(n9, t6, e9) {
              return n9 === n9 && (e9 !== i7 && (n9 = n9 <= e9 ? n9 : e9), t6 !== i7 && (n9 = n9 >= t6 ? n9 : t6)), n9;
            }
            function An(n9, t6, e9, r8, s7, o9) {
              var f7, c9 = t6 & Ln2, l9 = t6 & Fn2, v6 = t6 & xt5;
              if (e9 && (f7 = s7 ? e9(n9, r8, s7, o9) : e9(n9)), f7 !== i7)
                return f7;
              if (!K8(n9))
                return n9;
              var _8 = O8(n9);
              if (_8) {
                if (f7 = ih(n9), !c9)
                  return un2(n9, f7);
              } else {
                var m6 = tn2(n9), P7 = m6 == Pe4 || m6 == Gi2;
                if (at5(n9))
                  return hu(n9, c9);
                if (m6 == qn2 || m6 == Ot6 || P7 && !s7) {
                  if (f7 = l9 || P7 ? {} : bu(n9), !c9)
                    return l9 ? Zc(n9, vc(f7, n9)) : Yc(n9, qs2(f7, n9));
                } else {
                  if (!q8[m6])
                    return s7 ? n9 : {};
                  f7 = sh(n9, m6, c9);
                }
              }
              o9 || (o9 = new Rn());
              var I5 = o9.get(n9);
              if (I5)
                return I5;
              o9.set(n9, f7), sa2(n9) ? n9.forEach(function(y11) {
                f7.add(An(y11, t6, e9, y11, n9, o9));
              }) : ra2(n9) && n9.forEach(function(y11, D10) {
                f7.set(D10, An(y11, t6, e9, D10, n9, o9));
              });
              var E8 = v6 ? l9 ? pi2 : li2 : l9 ? on2 : V9, b7 = _8 ? i7 : E8(n9);
              return mn2(b7 || n9, function(y11, D10) {
                b7 && (D10 = y11, y11 = n9[D10]), se6(f7, D10, An(y11, t6, e9, D10, n9, o9));
              }), f7;
            }
            function _c(n9) {
              var t6 = V9(n9);
              return function(e9) {
                return Bs2(e9, n9, t6);
              };
            }
            function Bs2(n9, t6, e9) {
              var r8 = e9.length;
              if (n9 == null)
                return !r8;
              for (n9 = M7(n9); r8--; ) {
                var s7 = e9[r8], o9 = t6[s7], f7 = n9[s7];
                if (f7 === i7 && !(s7 in n9) || !o9(f7))
                  return false;
              }
              return true;
            }
            function Gs2(n9, t6, e9) {
              if (typeof n9 != "function")
                throw new wn3($8);
              return le8(function() {
                n9.apply(i7, e9);
              }, t6);
            }
            function ue7(n9, t6, e9, r8) {
              var s7 = -1, o9 = Ee4, f7 = true, c9 = n9.length, l9 = [], v6 = t6.length;
              if (!c9)
                return l9;
              e9 && (t6 = G9(t6, hn2(e9))), r8 ? (o9 = Dr2, f7 = false) : t6.length >= w8 && (o9 = jt5, f7 = false, t6 = new gt5(t6));
              n:
                for (; ++s7 < c9; ) {
                  var _8 = n9[s7], m6 = e9 == null ? _8 : e9(_8);
                  if (_8 = r8 || _8 !== 0 ? _8 : 0, f7 && m6 === m6) {
                    for (var P7 = v6; P7--; )
                      if (t6[P7] === m6)
                        continue n;
                    l9.push(_8);
                  } else
                    o9(t6, m6, r8) || l9.push(_8);
                }
              return l9;
            }
            var rt4 = vu($n), zs2 = vu(Xr2, true);
            function mc(n9, t6) {
              var e9 = true;
              return rt4(n9, function(r8, s7, o9) {
                return e9 = !!t6(r8, s7, o9), e9;
              }), e9;
            }
            function Ge5(n9, t6, e9) {
              for (var r8 = -1, s7 = n9.length; ++r8 < s7; ) {
                var o9 = n9[r8], f7 = t6(o9);
                if (f7 != null && (c9 === i7 ? f7 === f7 && !pn2(f7) : e9(f7, c9)))
                  var c9 = f7, l9 = o9;
              }
              return l9;
            }
            function wc(n9, t6, e9, r8) {
              var s7 = n9.length;
              for (e9 = R7(e9), e9 < 0 && (e9 = -e9 > s7 ? 0 : s7 + e9), r8 = r8 === i7 || r8 > s7 ? s7 : R7(r8), r8 < 0 && (r8 += s7), r8 = e9 > r8 ? 0 : aa2(r8); e9 < r8; )
                n9[e9++] = t6;
              return n9;
            }
            function Ks2(n9, t6) {
              var e9 = [];
              return rt4(n9, function(r8, s7, o9) {
                t6(r8, s7, o9) && e9.push(r8);
              }), e9;
            }
            function j7(n9, t6, e9, r8, s7) {
              var o9 = -1, f7 = n9.length;
              for (e9 || (e9 = ah), s7 || (s7 = []); ++o9 < f7; ) {
                var c9 = n9[o9];
                t6 > 0 && e9(c9) ? t6 > 1 ? j7(c9, t6 - 1, e9, r8, s7) : nt3(s7, c9) : r8 || (s7[s7.length] = c9);
              }
              return s7;
            }
            var Jr2 = _u(), Ys2 = _u(true);
            function $n(n9, t6) {
              return n9 && Jr2(n9, t6, V9);
            }
            function Xr2(n9, t6) {
              return n9 && Ys2(n9, t6, V9);
            }
            function ze4(n9, t6) {
              return jn(t6, function(e9) {
                return Jn2(n9[e9]);
              });
            }
            function _t4(n9, t6) {
              t6 = st4(t6, n9);
              for (var e9 = 0, r8 = t6.length; n9 != null && e9 < r8; )
                n9 = n9[Wn2(t6[e9++])];
              return e9 && e9 == r8 ? n9 : i7;
            }
            function Zs2(n9, t6, e9) {
              var r8 = t6(n9);
              return O8(n9) ? r8 : nt3(r8, e9(n9));
            }
            function en2(n9) {
              return n9 == null ? n9 === i7 ? Ya2 : za2 : pt5 && pt5 in M7(n9) ? th(n9) : dh(n9);
            }
            function Qr2(n9, t6) {
              return n9 > t6;
            }
            function Pc(n9, t6) {
              return n9 != null && F8.call(n9, t6);
            }
            function Ac(n9, t6) {
              return n9 != null && t6 in M7(n9);
            }
            function Cc(n9, t6, e9) {
              return n9 >= nn2(t6, e9) && n9 < Q10(t6, e9);
            }
            function Vr2(n9, t6, e9) {
              for (var r8 = e9 ? Dr2 : Ee4, s7 = n9[0].length, o9 = n9.length, f7 = o9, c9 = p8(o9), l9 = 1 / 0, v6 = []; f7--; ) {
                var _8 = n9[f7];
                f7 && t6 && (_8 = G9(_8, hn2(t6))), l9 = nn2(_8.length, l9), c9[f7] = !e9 && (t6 || s7 >= 120 && _8.length >= 120) ? new gt5(f7 && _8) : i7;
              }
              _8 = n9[0];
              var m6 = -1, P7 = c9[0];
              n:
                for (; ++m6 < s7 && v6.length < l9; ) {
                  var I5 = _8[m6], E8 = t6 ? t6(I5) : I5;
                  if (I5 = e9 || I5 !== 0 ? I5 : 0, !(P7 ? jt5(P7, E8) : r8(v6, E8, e9))) {
                    for (f7 = o9; --f7; ) {
                      var b7 = c9[f7];
                      if (!(b7 ? jt5(b7, E8) : r8(n9[f7], E8, e9)))
                        continue n;
                    }
                    P7 && P7.push(E8), v6.push(I5);
                  }
                }
              return v6;
            }
            function Ic(n9, t6, e9, r8) {
              return $n(n9, function(s7, o9, f7) {
                t6(r8, e9(s7), o9, f7);
              }), r8;
            }
            function ae6(n9, t6, e9) {
              t6 = st4(t6, n9), n9 = Hu(n9, t6);
              var r8 = n9 == null ? n9 : n9[Wn2(In2(t6))];
              return r8 == null ? i7 : cn2(r8, n9, e9);
            }
            function Js2(n9) {
              return Y6(n9) && en2(n9) == Ot6;
            }
            function xc(n9) {
              return Y6(n9) && en2(n9) == kt5;
            }
            function Ec(n9) {
              return Y6(n9) && en2(n9) == Zt4;
            }
            function oe8(n9, t6, e9, r8, s7) {
              return n9 === t6 ? true : n9 == null || t6 == null || !Y6(n9) && !Y6(t6) ? n9 !== n9 && t6 !== t6 : yc(n9, t6, e9, r8, oe8, s7);
            }
            function yc(n9, t6, e9, r8, s7, o9) {
              var f7 = O8(n9), c9 = O8(t6), l9 = f7 ? me6 : tn2(n9), v6 = c9 ? me6 : tn2(t6);
              l9 = l9 == Ot6 ? qn2 : l9, v6 = v6 == Ot6 ? qn2 : v6;
              var _8 = l9 == qn2, m6 = v6 == qn2, P7 = l9 == v6;
              if (P7 && at5(n9)) {
                if (!at5(t6))
                  return false;
                f7 = true, _8 = false;
              }
              if (P7 && !_8)
                return o9 || (o9 = new Rn()), f7 || Bt5(n9) ? Su(n9, t6, e9, r8, s7, o9) : jc(n9, t6, l9, e9, r8, s7, o9);
              if (!(e9 & Et5)) {
                var I5 = _8 && F8.call(n9, "__wrapped__"), E8 = m6 && F8.call(t6, "__wrapped__");
                if (I5 || E8) {
                  var b7 = I5 ? n9.value() : n9, y11 = E8 ? t6.value() : t6;
                  return o9 || (o9 = new Rn()), s7(b7, y11, e9, r8, o9);
                }
              }
              return P7 ? (o9 || (o9 = new Rn()), nh(n9, t6, e9, r8, s7, o9)) : false;
            }
            function Sc(n9) {
              return Y6(n9) && tn2(n9) == yn2;
            }
            function kr2(n9, t6, e9, r8) {
              var s7 = e9.length, o9 = s7, f7 = !r8;
              if (n9 == null)
                return !o9;
              for (n9 = M7(n9); s7--; ) {
                var c9 = e9[s7];
                if (f7 && c9[2] ? c9[1] !== n9[c9[0]] : !(c9[0] in n9))
                  return false;
              }
              for (; ++s7 < o9; ) {
                c9 = e9[s7];
                var l9 = c9[0], v6 = n9[l9], _8 = c9[1];
                if (f7 && c9[2]) {
                  if (v6 === i7 && !(l9 in n9))
                    return false;
                } else {
                  var m6 = new Rn();
                  if (r8)
                    var P7 = r8(v6, _8, l9, n9, t6, m6);
                  if (!(P7 === i7 ? oe8(_8, v6, Et5 | ve3, r8, m6) : P7))
                    return false;
                }
              }
              return true;
            }
            function Xs2(n9) {
              if (!K8(n9) || fh(n9))
                return false;
              var t6 = Jn2(n9) ? Sf : vo3;
              return t6.test(wt6(n9));
            }
            function Oc(n9) {
              return Y6(n9) && en2(n9) == Xt4;
            }
            function Rc(n9) {
              return Y6(n9) && tn2(n9) == Sn2;
            }
            function bc(n9) {
              return Y6(n9) && ar4(n9.length) && !!B10[en2(n9)];
            }
            function Qs2(n9) {
              return typeof n9 == "function" ? n9 : n9 == null ? fn2 : typeof n9 == "object" ? O8(n9) ? js2(n9[0], n9[1]) : ks2(n9) : ma2(n9);
            }
            function jr2(n9) {
              if (!he7(n9))
                return Df(n9);
              var t6 = [];
              for (var e9 in M7(n9))
                F8.call(n9, e9) && e9 != "constructor" && t6.push(e9);
              return t6;
            }
            function Tc(n9) {
              if (!K8(n9))
                return ph(n9);
              var t6 = he7(n9), e9 = [];
              for (var r8 in n9)
                r8 == "constructor" && (t6 || !F8.call(n9, r8)) || e9.push(r8);
              return e9;
            }
            function ni2(n9, t6) {
              return n9 < t6;
            }
            function Vs2(n9, t6) {
              var e9 = -1, r8 = an2(n9) ? p8(n9.length) : [];
              return rt4(n9, function(s7, o9, f7) {
                r8[++e9] = t6(s7, o9, f7);
              }), r8;
            }
            function ks2(n9) {
              var t6 = gi2(n9);
              return t6.length == 1 && t6[0][2] ? Lu(t6[0][0], t6[0][1]) : function(e9) {
                return e9 === n9 || kr2(e9, n9, t6);
              };
            }
            function js2(n9, t6) {
              return _i(n9) && Tu(t6) ? Lu(Wn2(n9), t6) : function(e9) {
                var r8 = Si(e9, n9);
                return r8 === i7 && r8 === t6 ? Oi2(e9, n9) : oe8(t6, r8, Et5 | ve3);
              };
            }
            function Ke4(n9, t6, e9, r8, s7) {
              n9 !== t6 && Jr2(t6, function(o9, f7) {
                if (s7 || (s7 = new Rn()), K8(o9))
                  Lc(n9, t6, f7, e9, Ke4, r8, s7);
                else {
                  var c9 = r8 ? r8(wi2(n9, f7), o9, f7 + "", n9, t6, s7) : i7;
                  c9 === i7 && (c9 = o9), Yr2(n9, f7, c9);
                }
              }, on2);
            }
            function Lc(n9, t6, e9, r8, s7, o9, f7) {
              var c9 = wi2(n9, e9), l9 = wi2(t6, e9), v6 = f7.get(l9);
              if (v6) {
                Yr2(n9, e9, v6);
                return;
              }
              var _8 = o9 ? o9(c9, l9, e9 + "", n9, t6, f7) : i7, m6 = _8 === i7;
              if (m6) {
                var P7 = O8(l9), I5 = !P7 && at5(l9), E8 = !P7 && !I5 && Bt5(l9);
                _8 = l9, P7 || I5 || E8 ? O8(c9) ? _8 = c9 : Z7(c9) ? _8 = un2(c9) : I5 ? (m6 = false, _8 = hu(l9, true)) : E8 ? (m6 = false, _8 = lu(l9, true)) : _8 = [] : pe5(l9) || Pt5(l9) ? (_8 = c9, Pt5(c9) ? _8 = oa2(c9) : (!K8(c9) || Jn2(c9)) && (_8 = bu(l9))) : m6 = false;
              }
              m6 && (f7.set(l9, _8), s7(_8, l9, r8, o9, f7), f7.delete(l9)), Yr2(n9, e9, _8);
            }
            function nu(n9, t6) {
              var e9 = n9.length;
              if (e9)
                return t6 += t6 < 0 ? e9 : 0, Zn(t6, e9) ? n9[t6] : i7;
            }
            function tu(n9, t6, e9) {
              t6.length ? t6 = G9(t6, function(o9) {
                return O8(o9) ? function(f7) {
                  return _t4(f7, o9.length === 1 ? o9[0] : o9);
                } : o9;
              }) : t6 = [fn2];
              var r8 = -1;
              t6 = G9(t6, hn2(x4()));
              var s7 = Vs2(n9, function(o9, f7, c9) {
                var l9 = G9(t6, function(v6) {
                  return v6(o9);
                });
                return { criteria: l9, index: ++r8, value: o9 };
              });
              return sf(s7, function(o9, f7) {
                return Kc(o9, f7, e9);
              });
            }
            function Dc(n9, t6) {
              return eu(n9, t6, function(e9, r8) {
                return Oi2(n9, r8);
              });
            }
            function eu(n9, t6, e9) {
              for (var r8 = -1, s7 = t6.length, o9 = {}; ++r8 < s7; ) {
                var f7 = t6[r8], c9 = _t4(n9, f7);
                e9(c9, f7) && fe5(o9, st4(f7, n9), c9);
              }
              return o9;
            }
            function Hc(n9) {
              return function(t6) {
                return _t4(t6, n9);
              };
            }
            function ti2(n9, t6, e9, r8) {
              var s7 = r8 ? rf : Tt5, o9 = -1, f7 = t6.length, c9 = n9;
              for (n9 === t6 && (t6 = un2(t6)), e9 && (c9 = G9(n9, hn2(e9))); ++o9 < f7; )
                for (var l9 = 0, v6 = t6[o9], _8 = e9 ? e9(v6) : v6; (l9 = s7(c9, _8, l9, r8)) > -1; )
                  c9 !== n9 && Ne3.call(c9, l9, 1), Ne3.call(n9, l9, 1);
              return n9;
            }
            function ru(n9, t6) {
              for (var e9 = n9 ? t6.length : 0, r8 = e9 - 1; e9--; ) {
                var s7 = t6[e9];
                if (e9 == r8 || s7 !== o9) {
                  var o9 = s7;
                  Zn(s7) ? Ne3.call(n9, s7, 1) : si2(n9, s7);
                }
              }
              return n9;
            }
            function ei2(n9, t6) {
              return n9 + We5(Us2() * (t6 - n9 + 1));
            }
            function Nc(n9, t6, e9, r8) {
              for (var s7 = -1, o9 = Q10(Ue5((t6 - n9) / (e9 || 1)), 0), f7 = p8(o9); o9--; )
                f7[r8 ? o9 : ++s7] = n9, n9 += e9;
              return f7;
            }
            function ri2(n9, t6) {
              var e9 = "";
              if (!n9 || t6 < 1 || t6 > kn2)
                return e9;
              do
                t6 % 2 && (e9 += n9), t6 = We5(t6 / 2), t6 && (n9 += n9);
              while (t6);
              return e9;
            }
            function L9(n9, t6) {
              return Pi(Du(n9, t6, fn2), n9 + "");
            }
            function $c(n9) {
              return Ms2(Gt5(n9));
            }
            function Uc(n9, t6) {
              var e9 = Gt5(n9);
              return tr5(e9, vt4(t6, 0, e9.length));
            }
            function fe5(n9, t6, e9, r8) {
              if (!K8(n9))
                return n9;
              t6 = st4(t6, n9);
              for (var s7 = -1, o9 = t6.length, f7 = o9 - 1, c9 = n9; c9 != null && ++s7 < o9; ) {
                var l9 = Wn2(t6[s7]), v6 = e9;
                if (l9 === "__proto__" || l9 === "constructor" || l9 === "prototype")
                  return n9;
                if (s7 != f7) {
                  var _8 = c9[l9];
                  v6 = r8 ? r8(_8, l9, c9) : i7, v6 === i7 && (v6 = K8(_8) ? _8 : Zn(t6[s7 + 1]) ? [] : {});
                }
                se6(c9, l9, v6), c9 = c9[l9];
              }
              return n9;
            }
            var iu = Fe5 ? function(n9, t6) {
              return Fe5.set(n9, t6), n9;
            } : fn2, Wc = $e5 ? function(n9, t6) {
              return $e5(n9, "toString", { configurable: true, enumerable: false, value: bi2(t6), writable: true });
            } : fn2;
            function Fc(n9) {
              return tr5(Gt5(n9));
            }
            function Cn(n9, t6, e9) {
              var r8 = -1, s7 = n9.length;
              t6 < 0 && (t6 = -t6 > s7 ? 0 : s7 + t6), e9 = e9 > s7 ? s7 : e9, e9 < 0 && (e9 += s7), s7 = t6 > e9 ? 0 : e9 - t6 >>> 0, t6 >>>= 0;
              for (var o9 = p8(s7); ++r8 < s7; )
                o9[r8] = n9[r8 + t6];
              return o9;
            }
            function Mc(n9, t6) {
              var e9;
              return rt4(n9, function(r8, s7, o9) {
                return e9 = t6(r8, s7, o9), !e9;
              }), !!e9;
            }
            function Ye6(n9, t6, e9) {
              var r8 = 0, s7 = n9 == null ? r8 : n9.length;
              if (typeof t6 == "number" && t6 === t6 && s7 <= Ma2) {
                for (; r8 < s7; ) {
                  var o9 = r8 + s7 >>> 1, f7 = n9[o9];
                  f7 !== null && !pn2(f7) && (e9 ? f7 <= t6 : f7 < t6) ? r8 = o9 + 1 : s7 = o9;
                }
                return s7;
              }
              return ii2(n9, t6, fn2, e9);
            }
            function ii2(n9, t6, e9, r8) {
              var s7 = 0, o9 = n9 == null ? 0 : n9.length;
              if (o9 === 0)
                return 0;
              t6 = e9(t6);
              for (var f7 = t6 !== t6, c9 = t6 === null, l9 = pn2(t6), v6 = t6 === i7; s7 < o9; ) {
                var _8 = We5((s7 + o9) / 2), m6 = e9(n9[_8]), P7 = m6 !== i7, I5 = m6 === null, E8 = m6 === m6, b7 = pn2(m6);
                if (f7)
                  var y11 = r8 || E8;
                else
                  v6 ? y11 = E8 && (r8 || P7) : c9 ? y11 = E8 && P7 && (r8 || !I5) : l9 ? y11 = E8 && P7 && !I5 && (r8 || !b7) : I5 || b7 ? y11 = false : y11 = r8 ? m6 <= t6 : m6 < t6;
                y11 ? s7 = _8 + 1 : o9 = _8;
              }
              return nn2(o9, Fa2);
            }
            function su(n9, t6) {
              for (var e9 = -1, r8 = n9.length, s7 = 0, o9 = []; ++e9 < r8; ) {
                var f7 = n9[e9], c9 = t6 ? t6(f7) : f7;
                if (!e9 || !bn2(c9, l9)) {
                  var l9 = c9;
                  o9[s7++] = f7 === 0 ? 0 : f7;
                }
              }
              return o9;
            }
            function uu(n9) {
              return typeof n9 == "number" ? n9 : pn2(n9) ? _e6 : +n9;
            }
            function ln2(n9) {
              if (typeof n9 == "string")
                return n9;
              if (O8(n9))
                return G9(n9, ln2) + "";
              if (pn2(n9))
                return Ws2 ? Ws2.call(n9) : "";
              var t6 = n9 + "";
              return t6 == "0" && 1 / n9 == -ht5 ? "-0" : t6;
            }
            function it3(n9, t6, e9) {
              var r8 = -1, s7 = Ee4, o9 = n9.length, f7 = true, c9 = [], l9 = c9;
              if (e9)
                f7 = false, s7 = Dr2;
              else if (o9 >= w8) {
                var v6 = t6 ? null : Vc(n9);
                if (v6)
                  return Se3(v6);
                f7 = false, s7 = jt5, l9 = new gt5();
              } else
                l9 = t6 ? [] : c9;
              n:
                for (; ++r8 < o9; ) {
                  var _8 = n9[r8], m6 = t6 ? t6(_8) : _8;
                  if (_8 = e9 || _8 !== 0 ? _8 : 0, f7 && m6 === m6) {
                    for (var P7 = l9.length; P7--; )
                      if (l9[P7] === m6)
                        continue n;
                    t6 && l9.push(m6), c9.push(_8);
                  } else
                    s7(l9, m6, e9) || (l9 !== c9 && l9.push(m6), c9.push(_8));
                }
              return c9;
            }
            function si2(n9, t6) {
              return t6 = st4(t6, n9), n9 = Hu(n9, t6), n9 == null || delete n9[Wn2(In2(t6))];
            }
            function au(n9, t6, e9, r8) {
              return fe5(n9, t6, e9(_t4(n9, t6)), r8);
            }
            function Ze4(n9, t6, e9, r8) {
              for (var s7 = n9.length, o9 = r8 ? s7 : -1; (r8 ? o9-- : ++o9 < s7) && t6(n9[o9], o9, n9); )
                ;
              return e9 ? Cn(n9, r8 ? 0 : o9, r8 ? o9 + 1 : s7) : Cn(n9, r8 ? o9 + 1 : 0, r8 ? s7 : o9);
            }
            function ou(n9, t6) {
              var e9 = n9;
              return e9 instanceof H5 && (e9 = e9.value()), Hr2(t6, function(r8, s7) {
                return s7.func.apply(s7.thisArg, nt3([r8], s7.args));
              }, e9);
            }
            function ui2(n9, t6, e9) {
              var r8 = n9.length;
              if (r8 < 2)
                return r8 ? it3(n9[0]) : [];
              for (var s7 = -1, o9 = p8(r8); ++s7 < r8; )
                for (var f7 = n9[s7], c9 = -1; ++c9 < r8; )
                  c9 != s7 && (o9[s7] = ue7(o9[s7] || f7, n9[c9], t6, e9));
              return it3(j7(o9, 1), t6, e9);
            }
            function fu(n9, t6, e9) {
              for (var r8 = -1, s7 = n9.length, o9 = t6.length, f7 = {}; ++r8 < s7; ) {
                var c9 = r8 < o9 ? t6[r8] : i7;
                e9(f7, n9[r8], c9);
              }
              return f7;
            }
            function ai2(n9) {
              return Z7(n9) ? n9 : [];
            }
            function oi2(n9) {
              return typeof n9 == "function" ? n9 : fn2;
            }
            function st4(n9, t6) {
              return O8(n9) ? n9 : _i(n9, t6) ? [n9] : Wu(W8(n9));
            }
            var qc = L9;
            function ut5(n9, t6, e9) {
              var r8 = n9.length;
              return e9 = e9 === i7 ? r8 : e9, !t6 && e9 >= r8 ? n9 : Cn(n9, t6, e9);
            }
            var cu = Of || function(n9) {
              return k6.clearTimeout(n9);
            };
            function hu(n9, t6) {
              if (t6)
                return n9.slice();
              var e9 = n9.length, r8 = Ls2 ? Ls2(e9) : new n9.constructor(e9);
              return n9.copy(r8), r8;
            }
            function fi2(n9) {
              var t6 = new n9.constructor(n9.byteLength);
              return new De5(t6).set(new De5(n9)), t6;
            }
            function Bc(n9, t6) {
              var e9 = t6 ? fi2(n9.buffer) : n9.buffer;
              return new n9.constructor(e9, n9.byteOffset, n9.byteLength);
            }
            function Gc(n9) {
              var t6 = new n9.constructor(n9.source, Ji2.exec(n9));
              return t6.lastIndex = n9.lastIndex, t6;
            }
            function zc(n9) {
              return ie6 ? M7(ie6.call(n9)) : {};
            }
            function lu(n9, t6) {
              var e9 = t6 ? fi2(n9.buffer) : n9.buffer;
              return new n9.constructor(e9, n9.byteOffset, n9.length);
            }
            function pu(n9, t6) {
              if (n9 !== t6) {
                var e9 = n9 !== i7, r8 = n9 === null, s7 = n9 === n9, o9 = pn2(n9), f7 = t6 !== i7, c9 = t6 === null, l9 = t6 === t6, v6 = pn2(t6);
                if (!c9 && !v6 && !o9 && n9 > t6 || o9 && f7 && l9 && !c9 && !v6 || r8 && f7 && l9 || !e9 && l9 || !s7)
                  return 1;
                if (!r8 && !o9 && !v6 && n9 < t6 || v6 && e9 && s7 && !r8 && !o9 || c9 && e9 && s7 || !f7 && s7 || !l9)
                  return -1;
              }
              return 0;
            }
            function Kc(n9, t6, e9) {
              for (var r8 = -1, s7 = n9.criteria, o9 = t6.criteria, f7 = s7.length, c9 = e9.length; ++r8 < f7; ) {
                var l9 = pu(s7[r8], o9[r8]);
                if (l9) {
                  if (r8 >= c9)
                    return l9;
                  var v6 = e9[r8];
                  return l9 * (v6 == "desc" ? -1 : 1);
                }
              }
              return n9.index - t6.index;
            }
            function du(n9, t6, e9, r8) {
              for (var s7 = -1, o9 = n9.length, f7 = e9.length, c9 = -1, l9 = t6.length, v6 = Q10(o9 - f7, 0), _8 = p8(l9 + v6), m6 = !r8; ++c9 < l9; )
                _8[c9] = t6[c9];
              for (; ++s7 < f7; )
                (m6 || s7 < o9) && (_8[e9[s7]] = n9[s7]);
              for (; v6--; )
                _8[c9++] = n9[s7++];
              return _8;
            }
            function gu(n9, t6, e9, r8) {
              for (var s7 = -1, o9 = n9.length, f7 = -1, c9 = e9.length, l9 = -1, v6 = t6.length, _8 = Q10(o9 - c9, 0), m6 = p8(_8 + v6), P7 = !r8; ++s7 < _8; )
                m6[s7] = n9[s7];
              for (var I5 = s7; ++l9 < v6; )
                m6[I5 + l9] = t6[l9];
              for (; ++f7 < c9; )
                (P7 || s7 < o9) && (m6[I5 + e9[f7]] = n9[s7++]);
              return m6;
            }
            function un2(n9, t6) {
              var e9 = -1, r8 = n9.length;
              for (t6 || (t6 = p8(r8)); ++e9 < r8; )
                t6[e9] = n9[e9];
              return t6;
            }
            function Un2(n9, t6, e9, r8) {
              var s7 = !e9;
              e9 || (e9 = {});
              for (var o9 = -1, f7 = t6.length; ++o9 < f7; ) {
                var c9 = t6[o9], l9 = r8 ? r8(e9[c9], n9[c9], c9, e9, n9) : i7;
                l9 === i7 && (l9 = n9[c9]), s7 ? zn(e9, c9, l9) : se6(e9, c9, l9);
              }
              return e9;
            }
            function Yc(n9, t6) {
              return Un2(n9, vi2(n9), t6);
            }
            function Zc(n9, t6) {
              return Un2(n9, Ou(n9), t6);
            }
            function Je6(n9, t6) {
              return function(e9, r8) {
                var s7 = O8(e9) ? Vo3 : gc, o9 = t6 ? t6() : {};
                return s7(e9, n9, x4(r8, 2), o9);
              };
            }
            function Ft5(n9) {
              return L9(function(t6, e9) {
                var r8 = -1, s7 = e9.length, o9 = s7 > 1 ? e9[s7 - 1] : i7, f7 = s7 > 2 ? e9[2] : i7;
                for (o9 = n9.length > 3 && typeof o9 == "function" ? (s7--, o9) : i7, f7 && rn2(e9[0], e9[1], f7) && (o9 = s7 < 3 ? i7 : o9, s7 = 1), t6 = M7(t6); ++r8 < s7; ) {
                  var c9 = e9[r8];
                  c9 && n9(t6, c9, r8, o9);
                }
                return t6;
              });
            }
            function vu(n9, t6) {
              return function(e9, r8) {
                if (e9 == null)
                  return e9;
                if (!an2(e9))
                  return n9(e9, r8);
                for (var s7 = e9.length, o9 = t6 ? s7 : -1, f7 = M7(e9); (t6 ? o9-- : ++o9 < s7) && r8(f7[o9], o9, f7) !== false; )
                  ;
                return e9;
              };
            }
            function _u(n9) {
              return function(t6, e9, r8) {
                for (var s7 = -1, o9 = M7(t6), f7 = r8(t6), c9 = f7.length; c9--; ) {
                  var l9 = f7[n9 ? c9 : ++s7];
                  if (e9(o9[l9], l9, o9) === false)
                    break;
                }
                return t6;
              };
            }
            function Jc(n9, t6, e9) {
              var r8 = t6 & vn, s7 = ce6(n9);
              function o9() {
                var f7 = this && this !== k6 && this instanceof o9 ? s7 : n9;
                return f7.apply(r8 ? e9 : this, arguments);
              }
              return o9;
            }
            function mu(n9) {
              return function(t6) {
                t6 = W8(t6);
                var e9 = Lt5(t6) ? On3(t6) : i7, r8 = e9 ? e9[0] : t6.charAt(0), s7 = e9 ? ut5(e9, 1).join("") : t6.slice(1);
                return r8[n9]() + s7;
              };
            }
            function Mt5(n9) {
              return function(t6) {
                return Hr2(va2(ga2(t6).replace(Uo3, "")), n9, "");
              };
            }
            function ce6(n9) {
              return function() {
                var t6 = arguments;
                switch (t6.length) {
                  case 0:
                    return new n9();
                  case 1:
                    return new n9(t6[0]);
                  case 2:
                    return new n9(t6[0], t6[1]);
                  case 3:
                    return new n9(t6[0], t6[1], t6[2]);
                  case 4:
                    return new n9(t6[0], t6[1], t6[2], t6[3]);
                  case 5:
                    return new n9(t6[0], t6[1], t6[2], t6[3], t6[4]);
                  case 6:
                    return new n9(t6[0], t6[1], t6[2], t6[3], t6[4], t6[5]);
                  case 7:
                    return new n9(t6[0], t6[1], t6[2], t6[3], t6[4], t6[5], t6[6]);
                }
                var e9 = Wt4(n9.prototype), r8 = n9.apply(e9, t6);
                return K8(r8) ? r8 : e9;
              };
            }
            function Xc(n9, t6, e9) {
              var r8 = ce6(n9);
              function s7() {
                for (var o9 = arguments.length, f7 = p8(o9), c9 = o9, l9 = qt5(s7); c9--; )
                  f7[c9] = arguments[c9];
                var v6 = o9 < 3 && f7[0] !== l9 && f7[o9 - 1] !== l9 ? [] : tt4(f7, l9);
                if (o9 -= v6.length, o9 < e9)
                  return Iu(n9, t6, Xe6, s7.placeholder, i7, f7, v6, i7, i7, e9 - o9);
                var _8 = this && this !== k6 && this instanceof s7 ? r8 : n9;
                return cn2(_8, this, f7);
              }
              return s7;
            }
            function wu(n9) {
              return function(t6, e9, r8) {
                var s7 = M7(t6);
                if (!an2(t6)) {
                  var o9 = x4(e9, 3);
                  t6 = V9(t6), e9 = function(c9) {
                    return o9(s7[c9], c9, s7);
                  };
                }
                var f7 = n9(t6, e9, r8);
                return f7 > -1 ? s7[o9 ? t6[f7] : f7] : i7;
              };
            }
            function Pu(n9) {
              return Yn(function(t6) {
                var e9 = t6.length, r8 = e9, s7 = Pn2.prototype.thru;
                for (n9 && t6.reverse(); r8--; ) {
                  var o9 = t6[r8];
                  if (typeof o9 != "function")
                    throw new wn3($8);
                  if (s7 && !f7 && je5(o9) == "wrapper")
                    var f7 = new Pn2([], true);
                }
                for (r8 = f7 ? r8 : e9; ++r8 < e9; ) {
                  o9 = t6[r8];
                  var c9 = je5(o9), l9 = c9 == "wrapper" ? di2(o9) : i7;
                  l9 && mi2(l9[0]) && l9[1] == (Mn2 | Dn2 | Hn2 | Kt5) && !l9[4].length && l9[9] == 1 ? f7 = f7[je5(l9[0])].apply(f7, l9[3]) : f7 = o9.length == 1 && mi2(o9) ? f7[c9]() : f7.thru(o9);
                }
                return function() {
                  var v6 = arguments, _8 = v6[0];
                  if (f7 && v6.length == 1 && O8(_8))
                    return f7.plant(_8).value();
                  for (var m6 = 0, P7 = e9 ? t6[m6].apply(this, v6) : _8; ++m6 < e9; )
                    P7 = t6[m6].call(this, P7);
                  return P7;
                };
              });
            }
            function Xe6(n9, t6, e9, r8, s7, o9, f7, c9, l9, v6) {
              var _8 = t6 & Mn2, m6 = t6 & vn, P7 = t6 & ct4, I5 = t6 & (Dn2 | yt5), E8 = t6 & dr4, b7 = P7 ? i7 : ce6(n9);
              function y11() {
                for (var D10 = arguments.length, N17 = p8(D10), dn2 = D10; dn2--; )
                  N17[dn2] = arguments[dn2];
                if (I5)
                  var sn2 = qt5(y11), gn2 = af(N17, sn2);
                if (r8 && (N17 = du(N17, r8, s7, I5)), o9 && (N17 = gu(N17, o9, f7, I5)), D10 -= gn2, I5 && D10 < v6) {
                  var J5 = tt4(N17, sn2);
                  return Iu(n9, t6, Xe6, y11.placeholder, e9, N17, J5, c9, l9, v6 - D10);
                }
                var Tn = m6 ? e9 : this, Qn2 = P7 ? Tn[n9] : n9;
                return D10 = N17.length, c9 ? N17 = gh(N17, c9) : E8 && D10 > 1 && N17.reverse(), _8 && l9 < D10 && (N17.length = l9), this && this !== k6 && this instanceof y11 && (Qn2 = b7 || ce6(Qn2)), Qn2.apply(Tn, N17);
              }
              return y11;
            }
            function Au(n9, t6) {
              return function(e9, r8) {
                return Ic(e9, n9, t6(r8), {});
              };
            }
            function Qe5(n9, t6) {
              return function(e9, r8) {
                var s7;
                if (e9 === i7 && r8 === i7)
                  return t6;
                if (e9 !== i7 && (s7 = e9), r8 !== i7) {
                  if (s7 === i7)
                    return r8;
                  typeof e9 == "string" || typeof r8 == "string" ? (e9 = ln2(e9), r8 = ln2(r8)) : (e9 = uu(e9), r8 = uu(r8)), s7 = n9(e9, r8);
                }
                return s7;
              };
            }
            function ci2(n9) {
              return Yn(function(t6) {
                return t6 = G9(t6, hn2(x4())), L9(function(e9) {
                  var r8 = this;
                  return n9(t6, function(s7) {
                    return cn2(s7, r8, e9);
                  });
                });
              });
            }
            function Ve5(n9, t6) {
              t6 = t6 === i7 ? " " : ln2(t6);
              var e9 = t6.length;
              if (e9 < 2)
                return e9 ? ri2(t6, n9) : t6;
              var r8 = ri2(t6, Ue5(n9 / Dt5(t6)));
              return Lt5(t6) ? ut5(On3(r8), 0, n9).join("") : r8.slice(0, n9);
            }
            function Qc(n9, t6, e9, r8) {
              var s7 = t6 & vn, o9 = ce6(n9);
              function f7() {
                for (var c9 = -1, l9 = arguments.length, v6 = -1, _8 = r8.length, m6 = p8(_8 + l9), P7 = this && this !== k6 && this instanceof f7 ? o9 : n9; ++v6 < _8; )
                  m6[v6] = r8[v6];
                for (; l9--; )
                  m6[v6++] = arguments[++c9];
                return cn2(P7, s7 ? e9 : this, m6);
              }
              return f7;
            }
            function Cu(n9) {
              return function(t6, e9, r8) {
                return r8 && typeof r8 != "number" && rn2(t6, e9, r8) && (e9 = r8 = i7), t6 = Xn2(t6), e9 === i7 ? (e9 = t6, t6 = 0) : e9 = Xn2(e9), r8 = r8 === i7 ? t6 < e9 ? 1 : -1 : Xn2(r8), Nc(t6, e9, r8, n9);
              };
            }
            function ke5(n9) {
              return function(t6, e9) {
                return typeof t6 == "string" && typeof e9 == "string" || (t6 = xn2(t6), e9 = xn2(e9)), n9(t6, e9);
              };
            }
            function Iu(n9, t6, e9, r8, s7, o9, f7, c9, l9, v6) {
              var _8 = t6 & Dn2, m6 = _8 ? f7 : i7, P7 = _8 ? i7 : f7, I5 = _8 ? o9 : i7, E8 = _8 ? i7 : o9;
              t6 |= _8 ? Hn2 : St6, t6 &= ~(_8 ? St6 : Hn2), t6 & qi2 || (t6 &= ~(vn | ct4));
              var b7 = [n9, t6, s7, I5, m6, E8, P7, c9, l9, v6], y11 = e9.apply(i7, b7);
              return mi2(n9) && Nu(y11, b7), y11.placeholder = r8, $u(y11, n9, t6);
            }
            function hi2(n9) {
              var t6 = X8[n9];
              return function(e9, r8) {
                if (e9 = xn2(e9), r8 = r8 == null ? 0 : nn2(R7(r8), 292), r8 && $s2(e9)) {
                  var s7 = (W8(e9) + "e").split("e"), o9 = t6(s7[0] + "e" + (+s7[1] + r8));
                  return s7 = (W8(o9) + "e").split("e"), +(s7[0] + "e" + (+s7[1] - r8));
                }
                return t6(e9);
              };
            }
            var Vc = $t4 && 1 / Se3(new $t4([, -0]))[1] == ht5 ? function(n9) {
              return new $t4(n9);
            } : Di;
            function xu(n9) {
              return function(t6) {
                var e9 = tn2(t6);
                return e9 == yn2 ? qr2(t6) : e9 == Sn2 ? df(t6) : uf(t6, n9(t6));
              };
            }
            function Kn2(n9, t6, e9, r8, s7, o9, f7, c9) {
              var l9 = t6 & ct4;
              if (!l9 && typeof n9 != "function")
                throw new wn3($8);
              var v6 = r8 ? r8.length : 0;
              if (v6 || (t6 &= ~(Hn2 | St6), r8 = s7 = i7), f7 = f7 === i7 ? f7 : Q10(R7(f7), 0), c9 = c9 === i7 ? c9 : R7(c9), v6 -= s7 ? s7.length : 0, t6 & St6) {
                var _8 = r8, m6 = s7;
                r8 = s7 = i7;
              }
              var P7 = l9 ? i7 : di2(n9), I5 = [n9, t6, e9, r8, s7, _8, m6, o9, f7, c9];
              if (P7 && lh(I5, P7), n9 = I5[0], t6 = I5[1], e9 = I5[2], r8 = I5[3], s7 = I5[4], c9 = I5[9] = I5[9] === i7 ? l9 ? 0 : n9.length : Q10(I5[9] - v6, 0), !c9 && t6 & (Dn2 | yt5) && (t6 &= ~(Dn2 | yt5)), !t6 || t6 == vn)
                var E8 = Jc(n9, t6, e9);
              else
                t6 == Dn2 || t6 == yt5 ? E8 = Xc(n9, t6, c9) : (t6 == Hn2 || t6 == (vn | Hn2)) && !s7.length ? E8 = Qc(n9, t6, e9, r8) : E8 = Xe6.apply(i7, I5);
              var b7 = P7 ? iu : Nu;
              return $u(b7(E8, I5), n9, t6);
            }
            function Eu(n9, t6, e9, r8) {
              return n9 === i7 || bn2(n9, Nt5[e9]) && !F8.call(r8, e9) ? t6 : n9;
            }
            function yu(n9, t6, e9, r8, s7, o9) {
              return K8(n9) && K8(t6) && (o9.set(t6, n9), Ke4(n9, t6, i7, yu, o9), o9.delete(t6)), n9;
            }
            function kc(n9) {
              return pe5(n9) ? i7 : n9;
            }
            function Su(n9, t6, e9, r8, s7, o9) {
              var f7 = e9 & Et5, c9 = n9.length, l9 = t6.length;
              if (c9 != l9 && !(f7 && l9 > c9))
                return false;
              var v6 = o9.get(n9), _8 = o9.get(t6);
              if (v6 && _8)
                return v6 == t6 && _8 == n9;
              var m6 = -1, P7 = true, I5 = e9 & ve3 ? new gt5() : i7;
              for (o9.set(n9, t6), o9.set(t6, n9); ++m6 < c9; ) {
                var E8 = n9[m6], b7 = t6[m6];
                if (r8)
                  var y11 = f7 ? r8(b7, E8, m6, t6, n9, o9) : r8(E8, b7, m6, n9, t6, o9);
                if (y11 !== i7) {
                  if (y11)
                    continue;
                  P7 = false;
                  break;
                }
                if (I5) {
                  if (!Nr3(t6, function(D10, N17) {
                    if (!jt5(I5, N17) && (E8 === D10 || s7(E8, D10, e9, r8, o9)))
                      return I5.push(N17);
                  })) {
                    P7 = false;
                    break;
                  }
                } else if (!(E8 === b7 || s7(E8, b7, e9, r8, o9))) {
                  P7 = false;
                  break;
                }
              }
              return o9.delete(n9), o9.delete(t6), P7;
            }
            function jc(n9, t6, e9, r8, s7, o9, f7) {
              switch (e9) {
                case Rt5:
                  if (n9.byteLength != t6.byteLength || n9.byteOffset != t6.byteOffset)
                    return false;
                  n9 = n9.buffer, t6 = t6.buffer;
                case kt5:
                  return !(n9.byteLength != t6.byteLength || !o9(new De5(n9), new De5(t6)));
                case Yt4:
                case Zt4:
                case Jt5:
                  return bn2(+n9, +t6);
                case we3:
                  return n9.name == t6.name && n9.message == t6.message;
                case Xt4:
                case Qt4:
                  return n9 == t6 + "";
                case yn2:
                  var c9 = qr2;
                case Sn2:
                  var l9 = r8 & Et5;
                  if (c9 || (c9 = Se3), n9.size != t6.size && !l9)
                    return false;
                  var v6 = f7.get(n9);
                  if (v6)
                    return v6 == t6;
                  r8 |= ve3, f7.set(n9, t6);
                  var _8 = Su(c9(n9), c9(t6), r8, s7, o9, f7);
                  return f7.delete(n9), _8;
                case Ae4:
                  if (ie6)
                    return ie6.call(n9) == ie6.call(t6);
              }
              return false;
            }
            function nh(n9, t6, e9, r8, s7, o9) {
              var f7 = e9 & Et5, c9 = li2(n9), l9 = c9.length, v6 = li2(t6), _8 = v6.length;
              if (l9 != _8 && !f7)
                return false;
              for (var m6 = l9; m6--; ) {
                var P7 = c9[m6];
                if (!(f7 ? P7 in t6 : F8.call(t6, P7)))
                  return false;
              }
              var I5 = o9.get(n9), E8 = o9.get(t6);
              if (I5 && E8)
                return I5 == t6 && E8 == n9;
              var b7 = true;
              o9.set(n9, t6), o9.set(t6, n9);
              for (var y11 = f7; ++m6 < l9; ) {
                P7 = c9[m6];
                var D10 = n9[P7], N17 = t6[P7];
                if (r8)
                  var dn2 = f7 ? r8(N17, D10, P7, t6, n9, o9) : r8(D10, N17, P7, n9, t6, o9);
                if (!(dn2 === i7 ? D10 === N17 || s7(D10, N17, e9, r8, o9) : dn2)) {
                  b7 = false;
                  break;
                }
                y11 || (y11 = P7 == "constructor");
              }
              if (b7 && !y11) {
                var sn2 = n9.constructor, gn2 = t6.constructor;
                sn2 != gn2 && "constructor" in n9 && "constructor" in t6 && !(typeof sn2 == "function" && sn2 instanceof sn2 && typeof gn2 == "function" && gn2 instanceof gn2) && (b7 = false);
              }
              return o9.delete(n9), o9.delete(t6), b7;
            }
            function Yn(n9) {
              return Pi(Du(n9, i7, Bu), n9 + "");
            }
            function li2(n9) {
              return Zs2(n9, V9, vi2);
            }
            function pi2(n9) {
              return Zs2(n9, on2, Ou);
            }
            var di2 = Fe5 ? function(n9) {
              return Fe5.get(n9);
            } : Di;
            function je5(n9) {
              for (var t6 = n9.name + "", e9 = Ut4[t6], r8 = F8.call(Ut4, t6) ? e9.length : 0; r8--; ) {
                var s7 = e9[r8], o9 = s7.func;
                if (o9 == null || o9 == n9)
                  return s7.name;
              }
              return t6;
            }
            function qt5(n9) {
              var t6 = F8.call(a6, "placeholder") ? a6 : n9;
              return t6.placeholder;
            }
            function x4() {
              var n9 = a6.iteratee || Ti;
              return n9 = n9 === Ti ? Qs2 : n9, arguments.length ? n9(arguments[0], arguments[1]) : n9;
            }
            function nr5(n9, t6) {
              var e9 = n9.__data__;
              return oh(t6) ? e9[typeof t6 == "string" ? "string" : "hash"] : e9.map;
            }
            function gi2(n9) {
              for (var t6 = V9(n9), e9 = t6.length; e9--; ) {
                var r8 = t6[e9], s7 = n9[r8];
                t6[e9] = [r8, s7, Tu(s7)];
              }
              return t6;
            }
            function mt5(n9, t6) {
              var e9 = hf(n9, t6);
              return Xs2(e9) ? e9 : i7;
            }
            function th(n9) {
              var t6 = F8.call(n9, pt5), e9 = n9[pt5];
              try {
                n9[pt5] = i7;
                var r8 = true;
              } catch {
              }
              var s7 = Te5.call(n9);
              return r8 && (t6 ? n9[pt5] = e9 : delete n9[pt5]), s7;
            }
            var vi2 = Gr2 ? function(n9) {
              return n9 == null ? [] : (n9 = M7(n9), jn(Gr2(n9), function(t6) {
                return Hs2.call(n9, t6);
              }));
            } : Hi2, Ou = Gr2 ? function(n9) {
              for (var t6 = []; n9; )
                nt3(t6, vi2(n9)), n9 = He5(n9);
              return t6;
            } : Hi2, tn2 = en2;
            (zr3 && tn2(new zr3(new ArrayBuffer(1))) != Rt5 || te9 && tn2(new te9()) != yn2 || Kr2 && tn2(Kr2.resolve()) != zi || $t4 && tn2(new $t4()) != Sn2 || ee6 && tn2(new ee6()) != Vt5) && (tn2 = function(n9) {
              var t6 = en2(n9), e9 = t6 == qn2 ? n9.constructor : i7, r8 = e9 ? wt6(e9) : "";
              if (r8)
                switch (r8) {
                  case Uf:
                    return Rt5;
                  case Wf:
                    return yn2;
                  case Ff:
                    return zi;
                  case Mf:
                    return Sn2;
                  case qf:
                    return Vt5;
                }
              return t6;
            });
            function eh(n9, t6, e9) {
              for (var r8 = -1, s7 = e9.length; ++r8 < s7; ) {
                var o9 = e9[r8], f7 = o9.size;
                switch (o9.type) {
                  case "drop":
                    n9 += f7;
                    break;
                  case "dropRight":
                    t6 -= f7;
                    break;
                  case "take":
                    t6 = nn2(t6, n9 + f7);
                    break;
                  case "takeRight":
                    n9 = Q10(n9, t6 - f7);
                    break;
                }
              }
              return { start: n9, end: t6 };
            }
            function rh(n9) {
              var t6 = n9.match(ao3);
              return t6 ? t6[1].split(oo3) : [];
            }
            function Ru(n9, t6, e9) {
              t6 = st4(t6, n9);
              for (var r8 = -1, s7 = t6.length, o9 = false; ++r8 < s7; ) {
                var f7 = Wn2(t6[r8]);
                if (!(o9 = n9 != null && e9(n9, f7)))
                  break;
                n9 = n9[f7];
              }
              return o9 || ++r8 != s7 ? o9 : (s7 = n9 == null ? 0 : n9.length, !!s7 && ar4(s7) && Zn(f7, s7) && (O8(n9) || Pt5(n9)));
            }
            function ih(n9) {
              var t6 = n9.length, e9 = new n9.constructor(t6);
              return t6 && typeof n9[0] == "string" && F8.call(n9, "index") && (e9.index = n9.index, e9.input = n9.input), e9;
            }
            function bu(n9) {
              return typeof n9.constructor == "function" && !he7(n9) ? Wt4(He5(n9)) : {};
            }
            function sh(n9, t6, e9) {
              var r8 = n9.constructor;
              switch (t6) {
                case kt5:
                  return fi2(n9);
                case Yt4:
                case Zt4:
                  return new r8(+n9);
                case Rt5:
                  return Bc(n9, e9);
                case gr2:
                case vr3:
                case _r3:
                case mr4:
                case wr3:
                case Pr3:
                case Ar3:
                case Cr3:
                case Ir3:
                  return lu(n9, e9);
                case yn2:
                  return new r8();
                case Jt5:
                case Qt4:
                  return new r8(n9);
                case Xt4:
                  return Gc(n9);
                case Sn2:
                  return new r8();
                case Ae4:
                  return zc(n9);
              }
            }
            function uh(n9, t6) {
              var e9 = t6.length;
              if (!e9)
                return n9;
              var r8 = e9 - 1;
              return t6[r8] = (e9 > 1 ? "& " : "") + t6[r8], t6 = t6.join(e9 > 2 ? ", " : " "), n9.replace(uo3, `{
/* [wrapped with ` + t6 + `] */
`);
            }
            function ah(n9) {
              return O8(n9) || Pt5(n9) || !!(Ns2 && n9 && n9[Ns2]);
            }
            function Zn(n9, t6) {
              var e9 = typeof n9;
              return t6 = t6 ?? kn2, !!t6 && (e9 == "number" || e9 != "symbol" && mo3.test(n9)) && n9 > -1 && n9 % 1 == 0 && n9 < t6;
            }
            function rn2(n9, t6, e9) {
              if (!K8(e9))
                return false;
              var r8 = typeof t6;
              return (r8 == "number" ? an2(e9) && Zn(t6, e9.length) : r8 == "string" && t6 in e9) ? bn2(e9[t6], n9) : false;
            }
            function _i(n9, t6) {
              if (O8(n9))
                return false;
              var e9 = typeof n9;
              return e9 == "number" || e9 == "symbol" || e9 == "boolean" || n9 == null || pn2(n9) ? true : eo3.test(n9) || !to3.test(n9) || t6 != null && n9 in M7(t6);
            }
            function oh(n9) {
              var t6 = typeof n9;
              return t6 == "string" || t6 == "number" || t6 == "symbol" || t6 == "boolean" ? n9 !== "__proto__" : n9 === null;
            }
            function mi2(n9) {
              var t6 = je5(n9), e9 = a6[t6];
              if (typeof e9 != "function" || !(t6 in H5.prototype))
                return false;
              if (n9 === e9)
                return true;
              var r8 = di2(e9);
              return !!r8 && n9 === r8[0];
            }
            function fh(n9) {
              return !!Ts2 && Ts2 in n9;
            }
            var ch = Re6 ? Jn2 : Ni2;
            function he7(n9) {
              var t6 = n9 && n9.constructor, e9 = typeof t6 == "function" && t6.prototype || Nt5;
              return n9 === e9;
            }
            function Tu(n9) {
              return n9 === n9 && !K8(n9);
            }
            function Lu(n9, t6) {
              return function(e9) {
                return e9 == null ? false : e9[n9] === t6 && (t6 !== i7 || n9 in M7(e9));
              };
            }
            function hh(n9) {
              var t6 = sr4(n9, function(r8) {
                return e9.size === pr2 && e9.clear(), r8;
              }), e9 = t6.cache;
              return t6;
            }
            function lh(n9, t6) {
              var e9 = n9[1], r8 = t6[1], s7 = e9 | r8, o9 = s7 < (vn | ct4 | Mn2), f7 = r8 == Mn2 && e9 == Dn2 || r8 == Mn2 && e9 == Kt5 && n9[7].length <= t6[8] || r8 == (Mn2 | Kt5) && t6[7].length <= t6[8] && e9 == Dn2;
              if (!(o9 || f7))
                return n9;
              r8 & vn && (n9[2] = t6[2], s7 |= e9 & vn ? 0 : qi2);
              var c9 = t6[3];
              if (c9) {
                var l9 = n9[3];
                n9[3] = l9 ? du(l9, c9, t6[4]) : c9, n9[4] = l9 ? tt4(n9[3], It6) : t6[4];
              }
              return c9 = t6[5], c9 && (l9 = n9[5], n9[5] = l9 ? gu(l9, c9, t6[6]) : c9, n9[6] = l9 ? tt4(n9[5], It6) : t6[6]), c9 = t6[7], c9 && (n9[7] = c9), r8 & Mn2 && (n9[8] = n9[8] == null ? t6[8] : nn2(n9[8], t6[8])), n9[9] == null && (n9[9] = t6[9]), n9[0] = t6[0], n9[1] = s7, n9;
            }
            function ph(n9) {
              var t6 = [];
              if (n9 != null)
                for (var e9 in M7(n9))
                  t6.push(e9);
              return t6;
            }
            function dh(n9) {
              return Te5.call(n9);
            }
            function Du(n9, t6, e9) {
              return t6 = Q10(t6 === i7 ? n9.length - 1 : t6, 0), function() {
                for (var r8 = arguments, s7 = -1, o9 = Q10(r8.length - t6, 0), f7 = p8(o9); ++s7 < o9; )
                  f7[s7] = r8[t6 + s7];
                s7 = -1;
                for (var c9 = p8(t6 + 1); ++s7 < t6; )
                  c9[s7] = r8[s7];
                return c9[t6] = e9(f7), cn2(n9, this, c9);
              };
            }
            function Hu(n9, t6) {
              return t6.length < 2 ? n9 : _t4(n9, Cn(t6, 0, -1));
            }
            function gh(n9, t6) {
              for (var e9 = n9.length, r8 = nn2(t6.length, e9), s7 = un2(n9); r8--; ) {
                var o9 = t6[r8];
                n9[r8] = Zn(o9, e9) ? s7[o9] : i7;
              }
              return n9;
            }
            function wi2(n9, t6) {
              if (!(t6 === "constructor" && typeof n9[t6] == "function") && t6 != "__proto__")
                return n9[t6];
            }
            var Nu = Uu(iu), le8 = bf || function(n9, t6) {
              return k6.setTimeout(n9, t6);
            }, Pi = Uu(Wc);
            function $u(n9, t6, e9) {
              var r8 = t6 + "";
              return Pi(n9, uh(r8, vh(rh(r8), e9)));
            }
            function Uu(n9) {
              var t6 = 0, e9 = 0;
              return function() {
                var r8 = Hf(), s7 = Na2 - (r8 - e9);
                if (e9 = r8, s7 > 0) {
                  if (++t6 >= Ha2)
                    return arguments[0];
                } else
                  t6 = 0;
                return n9.apply(i7, arguments);
              };
            }
            function tr5(n9, t6) {
              var e9 = -1, r8 = n9.length, s7 = r8 - 1;
              for (t6 = t6 === i7 ? r8 : t6; ++e9 < t6; ) {
                var o9 = ei2(e9, s7), f7 = n9[o9];
                n9[o9] = n9[e9], n9[e9] = f7;
              }
              return n9.length = t6, n9;
            }
            var Wu = hh(function(n9) {
              var t6 = [];
              return n9.charCodeAt(0) === 46 && t6.push(""), n9.replace(ro3, function(e9, r8, s7, o9) {
                t6.push(s7 ? o9.replace(ho3, "$1") : r8 || e9);
              }), t6;
            });
            function Wn2(n9) {
              if (typeof n9 == "string" || pn2(n9))
                return n9;
              var t6 = n9 + "";
              return t6 == "0" && 1 / n9 == -ht5 ? "-0" : t6;
            }
            function wt6(n9) {
              if (n9 != null) {
                try {
                  return be3.call(n9);
                } catch {
                }
                try {
                  return n9 + "";
                } catch {
                }
              }
              return "";
            }
            function vh(n9, t6) {
              return mn2(qa2, function(e9) {
                var r8 = "_." + e9[0];
                t6 & e9[1] && !Ee4(n9, r8) && n9.push(r8);
              }), n9.sort();
            }
            function Fu(n9) {
              if (n9 instanceof H5)
                return n9.clone();
              var t6 = new Pn2(n9.__wrapped__, n9.__chain__);
              return t6.__actions__ = un2(n9.__actions__), t6.__index__ = n9.__index__, t6.__values__ = n9.__values__, t6;
            }
            function _h(n9, t6, e9) {
              (e9 ? rn2(n9, t6, e9) : t6 === i7) ? t6 = 1 : t6 = Q10(R7(t6), 0);
              var r8 = n9 == null ? 0 : n9.length;
              if (!r8 || t6 < 1)
                return [];
              for (var s7 = 0, o9 = 0, f7 = p8(Ue5(r8 / t6)); s7 < r8; )
                f7[o9++] = Cn(n9, s7, s7 += t6);
              return f7;
            }
            function mh(n9) {
              for (var t6 = -1, e9 = n9 == null ? 0 : n9.length, r8 = 0, s7 = []; ++t6 < e9; ) {
                var o9 = n9[t6];
                o9 && (s7[r8++] = o9);
              }
              return s7;
            }
            function wh() {
              var n9 = arguments.length;
              if (!n9)
                return [];
              for (var t6 = p8(n9 - 1), e9 = arguments[0], r8 = n9; r8--; )
                t6[r8 - 1] = arguments[r8];
              return nt3(O8(e9) ? un2(e9) : [e9], j7(t6, 1));
            }
            var Ph = L9(function(n9, t6) {
              return Z7(n9) ? ue7(n9, j7(t6, 1, Z7, true)) : [];
            }), Ah = L9(function(n9, t6) {
              var e9 = In2(t6);
              return Z7(e9) && (e9 = i7), Z7(n9) ? ue7(n9, j7(t6, 1, Z7, true), x4(e9, 2)) : [];
            }), Ch = L9(function(n9, t6) {
              var e9 = In2(t6);
              return Z7(e9) && (e9 = i7), Z7(n9) ? ue7(n9, j7(t6, 1, Z7, true), i7, e9) : [];
            });
            function Ih(n9, t6, e9) {
              var r8 = n9 == null ? 0 : n9.length;
              return r8 ? (t6 = e9 || t6 === i7 ? 1 : R7(t6), Cn(n9, t6 < 0 ? 0 : t6, r8)) : [];
            }
            function xh(n9, t6, e9) {
              var r8 = n9 == null ? 0 : n9.length;
              return r8 ? (t6 = e9 || t6 === i7 ? 1 : R7(t6), t6 = r8 - t6, Cn(n9, 0, t6 < 0 ? 0 : t6)) : [];
            }
            function Eh(n9, t6) {
              return n9 && n9.length ? Ze4(n9, x4(t6, 3), true, true) : [];
            }
            function yh(n9, t6) {
              return n9 && n9.length ? Ze4(n9, x4(t6, 3), true) : [];
            }
            function Sh(n9, t6, e9, r8) {
              var s7 = n9 == null ? 0 : n9.length;
              return s7 ? (e9 && typeof e9 != "number" && rn2(n9, t6, e9) && (e9 = 0, r8 = s7), wc(n9, t6, e9, r8)) : [];
            }
            function Mu(n9, t6, e9) {
              var r8 = n9 == null ? 0 : n9.length;
              if (!r8)
                return -1;
              var s7 = e9 == null ? 0 : R7(e9);
              return s7 < 0 && (s7 = Q10(r8 + s7, 0)), ye6(n9, x4(t6, 3), s7);
            }
            function qu(n9, t6, e9) {
              var r8 = n9 == null ? 0 : n9.length;
              if (!r8)
                return -1;
              var s7 = r8 - 1;
              return e9 !== i7 && (s7 = R7(e9), s7 = e9 < 0 ? Q10(r8 + s7, 0) : nn2(s7, r8 - 1)), ye6(n9, x4(t6, 3), s7, true);
            }
            function Bu(n9) {
              var t6 = n9 == null ? 0 : n9.length;
              return t6 ? j7(n9, 1) : [];
            }
            function Oh(n9) {
              var t6 = n9 == null ? 0 : n9.length;
              return t6 ? j7(n9, ht5) : [];
            }
            function Rh(n9, t6) {
              var e9 = n9 == null ? 0 : n9.length;
              return e9 ? (t6 = t6 === i7 ? 1 : R7(t6), j7(n9, t6)) : [];
            }
            function bh(n9) {
              for (var t6 = -1, e9 = n9 == null ? 0 : n9.length, r8 = {}; ++t6 < e9; ) {
                var s7 = n9[t6];
                r8[s7[0]] = s7[1];
              }
              return r8;
            }
            function Gu(n9) {
              return n9 && n9.length ? n9[0] : i7;
            }
            function Th(n9, t6, e9) {
              var r8 = n9 == null ? 0 : n9.length;
              if (!r8)
                return -1;
              var s7 = e9 == null ? 0 : R7(e9);
              return s7 < 0 && (s7 = Q10(r8 + s7, 0)), Tt5(n9, t6, s7);
            }
            function Lh(n9) {
              var t6 = n9 == null ? 0 : n9.length;
              return t6 ? Cn(n9, 0, -1) : [];
            }
            var Dh = L9(function(n9) {
              var t6 = G9(n9, ai2);
              return t6.length && t6[0] === n9[0] ? Vr2(t6) : [];
            }), Hh = L9(function(n9) {
              var t6 = In2(n9), e9 = G9(n9, ai2);
              return t6 === In2(e9) ? t6 = i7 : e9.pop(), e9.length && e9[0] === n9[0] ? Vr2(e9, x4(t6, 2)) : [];
            }), Nh = L9(function(n9) {
              var t6 = In2(n9), e9 = G9(n9, ai2);
              return t6 = typeof t6 == "function" ? t6 : i7, t6 && e9.pop(), e9.length && e9[0] === n9[0] ? Vr2(e9, i7, t6) : [];
            });
            function $h(n9, t6) {
              return n9 == null ? "" : Lf.call(n9, t6);
            }
            function In2(n9) {
              var t6 = n9 == null ? 0 : n9.length;
              return t6 ? n9[t6 - 1] : i7;
            }
            function Uh(n9, t6, e9) {
              var r8 = n9 == null ? 0 : n9.length;
              if (!r8)
                return -1;
              var s7 = r8;
              return e9 !== i7 && (s7 = R7(e9), s7 = s7 < 0 ? Q10(r8 + s7, 0) : nn2(s7, r8 - 1)), t6 === t6 ? vf(n9, t6, s7) : ye6(n9, Is2, s7, true);
            }
            function Wh(n9, t6) {
              return n9 && n9.length ? nu(n9, R7(t6)) : i7;
            }
            var Fh = L9(zu);
            function zu(n9, t6) {
              return n9 && n9.length && t6 && t6.length ? ti2(n9, t6) : n9;
            }
            function Mh(n9, t6, e9) {
              return n9 && n9.length && t6 && t6.length ? ti2(n9, t6, x4(e9, 2)) : n9;
            }
            function qh(n9, t6, e9) {
              return n9 && n9.length && t6 && t6.length ? ti2(n9, t6, i7, e9) : n9;
            }
            var Bh = Yn(function(n9, t6) {
              var e9 = n9 == null ? 0 : n9.length, r8 = Zr2(n9, t6);
              return ru(n9, G9(t6, function(s7) {
                return Zn(s7, e9) ? +s7 : s7;
              }).sort(pu)), r8;
            });
            function Gh(n9, t6) {
              var e9 = [];
              if (!(n9 && n9.length))
                return e9;
              var r8 = -1, s7 = [], o9 = n9.length;
              for (t6 = x4(t6, 3); ++r8 < o9; ) {
                var f7 = n9[r8];
                t6(f7, r8, n9) && (e9.push(f7), s7.push(r8));
              }
              return ru(n9, s7), e9;
            }
            function Ai(n9) {
              return n9 == null ? n9 : $f.call(n9);
            }
            function zh(n9, t6, e9) {
              var r8 = n9 == null ? 0 : n9.length;
              return r8 ? (e9 && typeof e9 != "number" && rn2(n9, t6, e9) ? (t6 = 0, e9 = r8) : (t6 = t6 == null ? 0 : R7(t6), e9 = e9 === i7 ? r8 : R7(e9)), Cn(n9, t6, e9)) : [];
            }
            function Kh(n9, t6) {
              return Ye6(n9, t6);
            }
            function Yh(n9, t6, e9) {
              return ii2(n9, t6, x4(e9, 2));
            }
            function Zh(n9, t6) {
              var e9 = n9 == null ? 0 : n9.length;
              if (e9) {
                var r8 = Ye6(n9, t6);
                if (r8 < e9 && bn2(n9[r8], t6))
                  return r8;
              }
              return -1;
            }
            function Jh(n9, t6) {
              return Ye6(n9, t6, true);
            }
            function Xh(n9, t6, e9) {
              return ii2(n9, t6, x4(e9, 2), true);
            }
            function Qh(n9, t6) {
              var e9 = n9 == null ? 0 : n9.length;
              if (e9) {
                var r8 = Ye6(n9, t6, true) - 1;
                if (bn2(n9[r8], t6))
                  return r8;
              }
              return -1;
            }
            function Vh(n9) {
              return n9 && n9.length ? su(n9) : [];
            }
            function kh(n9, t6) {
              return n9 && n9.length ? su(n9, x4(t6, 2)) : [];
            }
            function jh(n9) {
              var t6 = n9 == null ? 0 : n9.length;
              return t6 ? Cn(n9, 1, t6) : [];
            }
            function nl(n9, t6, e9) {
              return n9 && n9.length ? (t6 = e9 || t6 === i7 ? 1 : R7(t6), Cn(n9, 0, t6 < 0 ? 0 : t6)) : [];
            }
            function tl(n9, t6, e9) {
              var r8 = n9 == null ? 0 : n9.length;
              return r8 ? (t6 = e9 || t6 === i7 ? 1 : R7(t6), t6 = r8 - t6, Cn(n9, t6 < 0 ? 0 : t6, r8)) : [];
            }
            function el(n9, t6) {
              return n9 && n9.length ? Ze4(n9, x4(t6, 3), false, true) : [];
            }
            function rl(n9, t6) {
              return n9 && n9.length ? Ze4(n9, x4(t6, 3)) : [];
            }
            var il = L9(function(n9) {
              return it3(j7(n9, 1, Z7, true));
            }), sl = L9(function(n9) {
              var t6 = In2(n9);
              return Z7(t6) && (t6 = i7), it3(j7(n9, 1, Z7, true), x4(t6, 2));
            }), ul = L9(function(n9) {
              var t6 = In2(n9);
              return t6 = typeof t6 == "function" ? t6 : i7, it3(j7(n9, 1, Z7, true), i7, t6);
            });
            function al(n9) {
              return n9 && n9.length ? it3(n9) : [];
            }
            function ol(n9, t6) {
              return n9 && n9.length ? it3(n9, x4(t6, 2)) : [];
            }
            function fl(n9, t6) {
              return t6 = typeof t6 == "function" ? t6 : i7, n9 && n9.length ? it3(n9, i7, t6) : [];
            }
            function Ci2(n9) {
              if (!(n9 && n9.length))
                return [];
              var t6 = 0;
              return n9 = jn(n9, function(e9) {
                if (Z7(e9))
                  return t6 = Q10(e9.length, t6), true;
              }), Fr2(t6, function(e9) {
                return G9(n9, $r2(e9));
              });
            }
            function Ku(n9, t6) {
              if (!(n9 && n9.length))
                return [];
              var e9 = Ci2(n9);
              return t6 == null ? e9 : G9(e9, function(r8) {
                return cn2(t6, i7, r8);
              });
            }
            var cl = L9(function(n9, t6) {
              return Z7(n9) ? ue7(n9, t6) : [];
            }), hl = L9(function(n9) {
              return ui2(jn(n9, Z7));
            }), ll = L9(function(n9) {
              var t6 = In2(n9);
              return Z7(t6) && (t6 = i7), ui2(jn(n9, Z7), x4(t6, 2));
            }), pl = L9(function(n9) {
              var t6 = In2(n9);
              return t6 = typeof t6 == "function" ? t6 : i7, ui2(jn(n9, Z7), i7, t6);
            }), dl = L9(Ci2);
            function gl(n9, t6) {
              return fu(n9 || [], t6 || [], se6);
            }
            function vl(n9, t6) {
              return fu(n9 || [], t6 || [], fe5);
            }
            var _l = L9(function(n9) {
              var t6 = n9.length, e9 = t6 > 1 ? n9[t6 - 1] : i7;
              return e9 = typeof e9 == "function" ? (n9.pop(), e9) : i7, Ku(n9, e9);
            });
            function Yu(n9) {
              var t6 = a6(n9);
              return t6.__chain__ = true, t6;
            }
            function ml(n9, t6) {
              return t6(n9), n9;
            }
            function er5(n9, t6) {
              return t6(n9);
            }
            var wl = Yn(function(n9) {
              var t6 = n9.length, e9 = t6 ? n9[0] : 0, r8 = this.__wrapped__, s7 = function(o9) {
                return Zr2(o9, n9);
              };
              return t6 > 1 || this.__actions__.length || !(r8 instanceof H5) || !Zn(e9) ? this.thru(s7) : (r8 = r8.slice(e9, +e9 + (t6 ? 1 : 0)), r8.__actions__.push({ func: er5, args: [s7], thisArg: i7 }), new Pn2(r8, this.__chain__).thru(function(o9) {
                return t6 && !o9.length && o9.push(i7), o9;
              }));
            });
            function Pl() {
              return Yu(this);
            }
            function Al() {
              return new Pn2(this.value(), this.__chain__);
            }
            function Cl() {
              this.__values__ === i7 && (this.__values__ = ua2(this.value()));
              var n9 = this.__index__ >= this.__values__.length, t6 = n9 ? i7 : this.__values__[this.__index__++];
              return { done: n9, value: t6 };
            }
            function Il() {
              return this;
            }
            function xl(n9) {
              for (var t6, e9 = this; e9 instanceof qe5; ) {
                var r8 = Fu(e9);
                r8.__index__ = 0, r8.__values__ = i7, t6 ? s7.__wrapped__ = r8 : t6 = r8;
                var s7 = r8;
                e9 = e9.__wrapped__;
              }
              return s7.__wrapped__ = n9, t6;
            }
            function El() {
              var n9 = this.__wrapped__;
              if (n9 instanceof H5) {
                var t6 = n9;
                return this.__actions__.length && (t6 = new H5(this)), t6 = t6.reverse(), t6.__actions__.push({ func: er5, args: [Ai], thisArg: i7 }), new Pn2(t6, this.__chain__);
              }
              return this.thru(Ai);
            }
            function yl() {
              return ou(this.__wrapped__, this.__actions__);
            }
            var Sl = Je6(function(n9, t6, e9) {
              F8.call(n9, e9) ? ++n9[e9] : zn(n9, e9, 1);
            });
            function Ol(n9, t6, e9) {
              var r8 = O8(n9) ? As2 : mc;
              return e9 && rn2(n9, t6, e9) && (t6 = i7), r8(n9, x4(t6, 3));
            }
            function Rl(n9, t6) {
              var e9 = O8(n9) ? jn : Ks2;
              return e9(n9, x4(t6, 3));
            }
            var bl = wu(Mu), Tl = wu(qu);
            function Ll(n9, t6) {
              return j7(rr4(n9, t6), 1);
            }
            function Dl(n9, t6) {
              return j7(rr4(n9, t6), ht5);
            }
            function Hl(n9, t6, e9) {
              return e9 = e9 === i7 ? 1 : R7(e9), j7(rr4(n9, t6), e9);
            }
            function Zu(n9, t6) {
              var e9 = O8(n9) ? mn2 : rt4;
              return e9(n9, x4(t6, 3));
            }
            function Ju(n9, t6) {
              var e9 = O8(n9) ? ko3 : zs2;
              return e9(n9, x4(t6, 3));
            }
            var Nl = Je6(function(n9, t6, e9) {
              F8.call(n9, e9) ? n9[e9].push(t6) : zn(n9, e9, [t6]);
            });
            function $l(n9, t6, e9, r8) {
              n9 = an2(n9) ? n9 : Gt5(n9), e9 = e9 && !r8 ? R7(e9) : 0;
              var s7 = n9.length;
              return e9 < 0 && (e9 = Q10(s7 + e9, 0)), or5(n9) ? e9 <= s7 && n9.indexOf(t6, e9) > -1 : !!s7 && Tt5(n9, t6, e9) > -1;
            }
            var Ul = L9(function(n9, t6, e9) {
              var r8 = -1, s7 = typeof t6 == "function", o9 = an2(n9) ? p8(n9.length) : [];
              return rt4(n9, function(f7) {
                o9[++r8] = s7 ? cn2(t6, f7, e9) : ae6(f7, t6, e9);
              }), o9;
            }), Wl = Je6(function(n9, t6, e9) {
              zn(n9, e9, t6);
            });
            function rr4(n9, t6) {
              var e9 = O8(n9) ? G9 : Vs2;
              return e9(n9, x4(t6, 3));
            }
            function Fl(n9, t6, e9, r8) {
              return n9 == null ? [] : (O8(t6) || (t6 = t6 == null ? [] : [t6]), e9 = r8 ? i7 : e9, O8(e9) || (e9 = e9 == null ? [] : [e9]), tu(n9, t6, e9));
            }
            var Ml = Je6(function(n9, t6, e9) {
              n9[e9 ? 0 : 1].push(t6);
            }, function() {
              return [[], []];
            });
            function ql(n9, t6, e9) {
              var r8 = O8(n9) ? Hr2 : Es2, s7 = arguments.length < 3;
              return r8(n9, x4(t6, 4), e9, s7, rt4);
            }
            function Bl(n9, t6, e9) {
              var r8 = O8(n9) ? jo3 : Es2, s7 = arguments.length < 3;
              return r8(n9, x4(t6, 4), e9, s7, zs2);
            }
            function Gl(n9, t6) {
              var e9 = O8(n9) ? jn : Ks2;
              return e9(n9, ur3(x4(t6, 3)));
            }
            function zl(n9) {
              var t6 = O8(n9) ? Ms2 : $c;
              return t6(n9);
            }
            function Kl(n9, t6, e9) {
              (e9 ? rn2(n9, t6, e9) : t6 === i7) ? t6 = 1 : t6 = R7(t6);
              var r8 = O8(n9) ? pc : Uc;
              return r8(n9, t6);
            }
            function Yl(n9) {
              var t6 = O8(n9) ? dc : Fc;
              return t6(n9);
            }
            function Zl(n9) {
              if (n9 == null)
                return 0;
              if (an2(n9))
                return or5(n9) ? Dt5(n9) : n9.length;
              var t6 = tn2(n9);
              return t6 == yn2 || t6 == Sn2 ? n9.size : jr2(n9).length;
            }
            function Jl(n9, t6, e9) {
              var r8 = O8(n9) ? Nr3 : Mc;
              return e9 && rn2(n9, t6, e9) && (t6 = i7), r8(n9, x4(t6, 3));
            }
            var Xl = L9(function(n9, t6) {
              if (n9 == null)
                return [];
              var e9 = t6.length;
              return e9 > 1 && rn2(n9, t6[0], t6[1]) ? t6 = [] : e9 > 2 && rn2(t6[0], t6[1], t6[2]) && (t6 = [t6[0]]), tu(n9, j7(t6, 1), []);
            }), ir4 = Rf || function() {
              return k6.Date.now();
            };
            function Ql(n9, t6) {
              if (typeof t6 != "function")
                throw new wn3($8);
              return n9 = R7(n9), function() {
                if (--n9 < 1)
                  return t6.apply(this, arguments);
              };
            }
            function Xu(n9, t6, e9) {
              return t6 = e9 ? i7 : t6, t6 = n9 && t6 == null ? n9.length : t6, Kn2(n9, Mn2, i7, i7, i7, i7, t6);
            }
            function Qu(n9, t6) {
              var e9;
              if (typeof t6 != "function")
                throw new wn3($8);
              return n9 = R7(n9), function() {
                return --n9 > 0 && (e9 = t6.apply(this, arguments)), n9 <= 1 && (t6 = i7), e9;
              };
            }
            var Ii2 = L9(function(n9, t6, e9) {
              var r8 = vn;
              if (e9.length) {
                var s7 = tt4(e9, qt5(Ii2));
                r8 |= Hn2;
              }
              return Kn2(n9, r8, t6, e9, s7);
            }), Vu = L9(function(n9, t6, e9) {
              var r8 = vn | ct4;
              if (e9.length) {
                var s7 = tt4(e9, qt5(Vu));
                r8 |= Hn2;
              }
              return Kn2(t6, r8, n9, e9, s7);
            });
            function ku(n9, t6, e9) {
              t6 = e9 ? i7 : t6;
              var r8 = Kn2(n9, Dn2, i7, i7, i7, i7, i7, t6);
              return r8.placeholder = ku.placeholder, r8;
            }
            function ju(n9, t6, e9) {
              t6 = e9 ? i7 : t6;
              var r8 = Kn2(n9, yt5, i7, i7, i7, i7, i7, t6);
              return r8.placeholder = ju.placeholder, r8;
            }
            function na2(n9, t6, e9) {
              var r8, s7, o9, f7, c9, l9, v6 = 0, _8 = false, m6 = false, P7 = true;
              if (typeof n9 != "function")
                throw new wn3($8);
              t6 = xn2(t6) || 0, K8(e9) && (_8 = !!e9.leading, m6 = "maxWait" in e9, o9 = m6 ? Q10(xn2(e9.maxWait) || 0, t6) : o9, P7 = "trailing" in e9 ? !!e9.trailing : P7);
              function I5(J5) {
                var Tn = r8, Qn2 = s7;
                return r8 = s7 = i7, v6 = J5, f7 = n9.apply(Qn2, Tn), f7;
              }
              function E8(J5) {
                return v6 = J5, c9 = le8(D10, t6), _8 ? I5(J5) : f7;
              }
              function b7(J5) {
                var Tn = J5 - l9, Qn2 = J5 - v6, wa2 = t6 - Tn;
                return m6 ? nn2(wa2, o9 - Qn2) : wa2;
              }
              function y11(J5) {
                var Tn = J5 - l9, Qn2 = J5 - v6;
                return l9 === i7 || Tn >= t6 || Tn < 0 || m6 && Qn2 >= o9;
              }
              function D10() {
                var J5 = ir4();
                if (y11(J5))
                  return N17(J5);
                c9 = le8(D10, b7(J5));
              }
              function N17(J5) {
                return c9 = i7, P7 && r8 ? I5(J5) : (r8 = s7 = i7, f7);
              }
              function dn2() {
                c9 !== i7 && cu(c9), v6 = 0, r8 = l9 = s7 = c9 = i7;
              }
              function sn2() {
                return c9 === i7 ? f7 : N17(ir4());
              }
              function gn2() {
                var J5 = ir4(), Tn = y11(J5);
                if (r8 = arguments, s7 = this, l9 = J5, Tn) {
                  if (c9 === i7)
                    return E8(l9);
                  if (m6)
                    return cu(c9), c9 = le8(D10, t6), I5(l9);
                }
                return c9 === i7 && (c9 = le8(D10, t6)), f7;
              }
              return gn2.cancel = dn2, gn2.flush = sn2, gn2;
            }
            var Vl = L9(function(n9, t6) {
              return Gs2(n9, 1, t6);
            }), kl = L9(function(n9, t6, e9) {
              return Gs2(n9, xn2(t6) || 0, e9);
            });
            function jl(n9) {
              return Kn2(n9, dr4);
            }
            function sr4(n9, t6) {
              if (typeof n9 != "function" || t6 != null && typeof t6 != "function")
                throw new wn3($8);
              var e9 = function() {
                var r8 = arguments, s7 = t6 ? t6.apply(this, r8) : r8[0], o9 = e9.cache;
                if (o9.has(s7))
                  return o9.get(s7);
                var f7 = n9.apply(this, r8);
                return e9.cache = o9.set(s7, f7) || o9, f7;
              };
              return e9.cache = new (sr4.Cache || Gn2)(), e9;
            }
            sr4.Cache = Gn2;
            function ur3(n9) {
              if (typeof n9 != "function")
                throw new wn3($8);
              return function() {
                var t6 = arguments;
                switch (t6.length) {
                  case 0:
                    return !n9.call(this);
                  case 1:
                    return !n9.call(this, t6[0]);
                  case 2:
                    return !n9.call(this, t6[0], t6[1]);
                  case 3:
                    return !n9.call(this, t6[0], t6[1], t6[2]);
                }
                return !n9.apply(this, t6);
              };
            }
            function np(n9) {
              return Qu(2, n9);
            }
            var tp = qc(function(n9, t6) {
              t6 = t6.length == 1 && O8(t6[0]) ? G9(t6[0], hn2(x4())) : G9(j7(t6, 1), hn2(x4()));
              var e9 = t6.length;
              return L9(function(r8) {
                for (var s7 = -1, o9 = nn2(r8.length, e9); ++s7 < o9; )
                  r8[s7] = t6[s7].call(this, r8[s7]);
                return cn2(n9, this, r8);
              });
            }), xi2 = L9(function(n9, t6) {
              var e9 = tt4(t6, qt5(xi2));
              return Kn2(n9, Hn2, i7, t6, e9);
            }), ta2 = L9(function(n9, t6) {
              var e9 = tt4(t6, qt5(ta2));
              return Kn2(n9, St6, i7, t6, e9);
            }), ep = Yn(function(n9, t6) {
              return Kn2(n9, Kt5, i7, i7, i7, t6);
            });
            function rp(n9, t6) {
              if (typeof n9 != "function")
                throw new wn3($8);
              return t6 = t6 === i7 ? t6 : R7(t6), L9(n9, t6);
            }
            function ip(n9, t6) {
              if (typeof n9 != "function")
                throw new wn3($8);
              return t6 = t6 == null ? 0 : Q10(R7(t6), 0), L9(function(e9) {
                var r8 = e9[t6], s7 = ut5(e9, 0, t6);
                return r8 && nt3(s7, r8), cn2(n9, this, s7);
              });
            }
            function sp(n9, t6, e9) {
              var r8 = true, s7 = true;
              if (typeof n9 != "function")
                throw new wn3($8);
              return K8(e9) && (r8 = "leading" in e9 ? !!e9.leading : r8, s7 = "trailing" in e9 ? !!e9.trailing : s7), na2(n9, t6, { leading: r8, maxWait: t6, trailing: s7 });
            }
            function up(n9) {
              return Xu(n9, 1);
            }
            function ap(n9, t6) {
              return xi2(oi2(t6), n9);
            }
            function op() {
              if (!arguments.length)
                return [];
              var n9 = arguments[0];
              return O8(n9) ? n9 : [n9];
            }
            function fp(n9) {
              return An(n9, xt5);
            }
            function cp(n9, t6) {
              return t6 = typeof t6 == "function" ? t6 : i7, An(n9, xt5, t6);
            }
            function hp(n9) {
              return An(n9, Ln2 | xt5);
            }
            function lp(n9, t6) {
              return t6 = typeof t6 == "function" ? t6 : i7, An(n9, Ln2 | xt5, t6);
            }
            function pp(n9, t6) {
              return t6 == null || Bs2(n9, t6, V9(t6));
            }
            function bn2(n9, t6) {
              return n9 === t6 || n9 !== n9 && t6 !== t6;
            }
            var dp = ke5(Qr2), gp = ke5(function(n9, t6) {
              return n9 >= t6;
            }), Pt5 = Js2(function() {
              return arguments;
            }()) ? Js2 : function(n9) {
              return Y6(n9) && F8.call(n9, "callee") && !Hs2.call(n9, "callee");
            }, O8 = p8.isArray, vp = gs3 ? hn2(gs3) : xc;
            function an2(n9) {
              return n9 != null && ar4(n9.length) && !Jn2(n9);
            }
            function Z7(n9) {
              return Y6(n9) && an2(n9);
            }
            function _p(n9) {
              return n9 === true || n9 === false || Y6(n9) && en2(n9) == Yt4;
            }
            var at5 = Tf || Ni2, mp = vs2 ? hn2(vs2) : Ec;
            function wp(n9) {
              return Y6(n9) && n9.nodeType === 1 && !pe5(n9);
            }
            function Pp(n9) {
              if (n9 == null)
                return true;
              if (an2(n9) && (O8(n9) || typeof n9 == "string" || typeof n9.splice == "function" || at5(n9) || Bt5(n9) || Pt5(n9)))
                return !n9.length;
              var t6 = tn2(n9);
              if (t6 == yn2 || t6 == Sn2)
                return !n9.size;
              if (he7(n9))
                return !jr2(n9).length;
              for (var e9 in n9)
                if (F8.call(n9, e9))
                  return false;
              return true;
            }
            function Ap(n9, t6) {
              return oe8(n9, t6);
            }
            function Cp(n9, t6, e9) {
              e9 = typeof e9 == "function" ? e9 : i7;
              var r8 = e9 ? e9(n9, t6) : i7;
              return r8 === i7 ? oe8(n9, t6, i7, e9) : !!r8;
            }
            function Ei2(n9) {
              if (!Y6(n9))
                return false;
              var t6 = en2(n9);
              return t6 == we3 || t6 == Ga2 || typeof n9.message == "string" && typeof n9.name == "string" && !pe5(n9);
            }
            function Ip(n9) {
              return typeof n9 == "number" && $s2(n9);
            }
            function Jn2(n9) {
              if (!K8(n9))
                return false;
              var t6 = en2(n9);
              return t6 == Pe4 || t6 == Gi2 || t6 == Ba2 || t6 == Ka2;
            }
            function ea2(n9) {
              return typeof n9 == "number" && n9 == R7(n9);
            }
            function ar4(n9) {
              return typeof n9 == "number" && n9 > -1 && n9 % 1 == 0 && n9 <= kn2;
            }
            function K8(n9) {
              var t6 = typeof n9;
              return n9 != null && (t6 == "object" || t6 == "function");
            }
            function Y6(n9) {
              return n9 != null && typeof n9 == "object";
            }
            var ra2 = _s2 ? hn2(_s2) : Sc;
            function xp(n9, t6) {
              return n9 === t6 || kr2(n9, t6, gi2(t6));
            }
            function Ep(n9, t6, e9) {
              return e9 = typeof e9 == "function" ? e9 : i7, kr2(n9, t6, gi2(t6), e9);
            }
            function yp(n9) {
              return ia2(n9) && n9 != +n9;
            }
            function Sp(n9) {
              if (ch(n9))
                throw new S12(T6);
              return Xs2(n9);
            }
            function Op(n9) {
              return n9 === null;
            }
            function Rp(n9) {
              return n9 == null;
            }
            function ia2(n9) {
              return typeof n9 == "number" || Y6(n9) && en2(n9) == Jt5;
            }
            function pe5(n9) {
              if (!Y6(n9) || en2(n9) != qn2)
                return false;
              var t6 = He5(n9);
              if (t6 === null)
                return true;
              var e9 = F8.call(t6, "constructor") && t6.constructor;
              return typeof e9 == "function" && e9 instanceof e9 && be3.call(e9) == Ef;
            }
            var yi2 = ms2 ? hn2(ms2) : Oc;
            function bp(n9) {
              return ea2(n9) && n9 >= -kn2 && n9 <= kn2;
            }
            var sa2 = ws3 ? hn2(ws3) : Rc;
            function or5(n9) {
              return typeof n9 == "string" || !O8(n9) && Y6(n9) && en2(n9) == Qt4;
            }
            function pn2(n9) {
              return typeof n9 == "symbol" || Y6(n9) && en2(n9) == Ae4;
            }
            var Bt5 = Ps2 ? hn2(Ps2) : bc;
            function Tp(n9) {
              return n9 === i7;
            }
            function Lp(n9) {
              return Y6(n9) && tn2(n9) == Vt5;
            }
            function Dp(n9) {
              return Y6(n9) && en2(n9) == Za2;
            }
            var Hp = ke5(ni2), Np = ke5(function(n9, t6) {
              return n9 <= t6;
            });
            function ua2(n9) {
              if (!n9)
                return [];
              if (an2(n9))
                return or5(n9) ? On3(n9) : un2(n9);
              if (ne7 && n9[ne7])
                return pf(n9[ne7]());
              var t6 = tn2(n9), e9 = t6 == yn2 ? qr2 : t6 == Sn2 ? Se3 : Gt5;
              return e9(n9);
            }
            function Xn2(n9) {
              if (!n9)
                return n9 === 0 ? n9 : 0;
              if (n9 = xn2(n9), n9 === ht5 || n9 === -ht5) {
                var t6 = n9 < 0 ? -1 : 1;
                return t6 * Wa2;
              }
              return n9 === n9 ? n9 : 0;
            }
            function R7(n9) {
              var t6 = Xn2(n9), e9 = t6 % 1;
              return t6 === t6 ? e9 ? t6 - e9 : t6 : 0;
            }
            function aa2(n9) {
              return n9 ? vt4(R7(n9), 0, Nn2) : 0;
            }
            function xn2(n9) {
              if (typeof n9 == "number")
                return n9;
              if (pn2(n9))
                return _e6;
              if (K8(n9)) {
                var t6 = typeof n9.valueOf == "function" ? n9.valueOf() : n9;
                n9 = K8(t6) ? t6 + "" : t6;
              }
              if (typeof n9 != "string")
                return n9 === 0 ? n9 : +n9;
              n9 = ys2(n9);
              var e9 = go3.test(n9);
              return e9 || _o3.test(n9) ? Xo3(n9.slice(2), e9 ? 2 : 8) : po3.test(n9) ? _e6 : +n9;
            }
            function oa2(n9) {
              return Un2(n9, on2(n9));
            }
            function $p(n9) {
              return n9 ? vt4(R7(n9), -kn2, kn2) : n9 === 0 ? n9 : 0;
            }
            function W8(n9) {
              return n9 == null ? "" : ln2(n9);
            }
            var Up = Ft5(function(n9, t6) {
              if (he7(t6) || an2(t6)) {
                Un2(t6, V9(t6), n9);
                return;
              }
              for (var e9 in t6)
                F8.call(t6, e9) && se6(n9, e9, t6[e9]);
            }), fa2 = Ft5(function(n9, t6) {
              Un2(t6, on2(t6), n9);
            }), fr3 = Ft5(function(n9, t6, e9, r8) {
              Un2(t6, on2(t6), n9, r8);
            }), Wp = Ft5(function(n9, t6, e9, r8) {
              Un2(t6, V9(t6), n9, r8);
            }), Fp = Yn(Zr2);
            function Mp(n9, t6) {
              var e9 = Wt4(n9);
              return t6 == null ? e9 : qs2(e9, t6);
            }
            var qp = L9(function(n9, t6) {
              n9 = M7(n9);
              var e9 = -1, r8 = t6.length, s7 = r8 > 2 ? t6[2] : i7;
              for (s7 && rn2(t6[0], t6[1], s7) && (r8 = 1); ++e9 < r8; )
                for (var o9 = t6[e9], f7 = on2(o9), c9 = -1, l9 = f7.length; ++c9 < l9; ) {
                  var v6 = f7[c9], _8 = n9[v6];
                  (_8 === i7 || bn2(_8, Nt5[v6]) && !F8.call(n9, v6)) && (n9[v6] = o9[v6]);
                }
              return n9;
            }), Bp = L9(function(n9) {
              return n9.push(i7, yu), cn2(ca2, i7, n9);
            });
            function Gp(n9, t6) {
              return Cs2(n9, x4(t6, 3), $n);
            }
            function zp(n9, t6) {
              return Cs2(n9, x4(t6, 3), Xr2);
            }
            function Kp(n9, t6) {
              return n9 == null ? n9 : Jr2(n9, x4(t6, 3), on2);
            }
            function Yp(n9, t6) {
              return n9 == null ? n9 : Ys2(n9, x4(t6, 3), on2);
            }
            function Zp(n9, t6) {
              return n9 && $n(n9, x4(t6, 3));
            }
            function Jp(n9, t6) {
              return n9 && Xr2(n9, x4(t6, 3));
            }
            function Xp(n9) {
              return n9 == null ? [] : ze4(n9, V9(n9));
            }
            function Qp(n9) {
              return n9 == null ? [] : ze4(n9, on2(n9));
            }
            function Si(n9, t6, e9) {
              var r8 = n9 == null ? i7 : _t4(n9, t6);
              return r8 === i7 ? e9 : r8;
            }
            function Vp(n9, t6) {
              return n9 != null && Ru(n9, t6, Pc);
            }
            function Oi2(n9, t6) {
              return n9 != null && Ru(n9, t6, Ac);
            }
            var kp = Au(function(n9, t6, e9) {
              t6 != null && typeof t6.toString != "function" && (t6 = Te5.call(t6)), n9[t6] = e9;
            }, bi2(fn2)), jp = Au(function(n9, t6, e9) {
              t6 != null && typeof t6.toString != "function" && (t6 = Te5.call(t6)), F8.call(n9, t6) ? n9[t6].push(e9) : n9[t6] = [e9];
            }, x4), nd = L9(ae6);
            function V9(n9) {
              return an2(n9) ? Fs2(n9) : jr2(n9);
            }
            function on2(n9) {
              return an2(n9) ? Fs2(n9, true) : Tc(n9);
            }
            function td(n9, t6) {
              var e9 = {};
              return t6 = x4(t6, 3), $n(n9, function(r8, s7, o9) {
                zn(e9, t6(r8, s7, o9), r8);
              }), e9;
            }
            function ed(n9, t6) {
              var e9 = {};
              return t6 = x4(t6, 3), $n(n9, function(r8, s7, o9) {
                zn(e9, s7, t6(r8, s7, o9));
              }), e9;
            }
            var rd = Ft5(function(n9, t6, e9) {
              Ke4(n9, t6, e9);
            }), ca2 = Ft5(function(n9, t6, e9, r8) {
              Ke4(n9, t6, e9, r8);
            }), id3 = Yn(function(n9, t6) {
              var e9 = {};
              if (n9 == null)
                return e9;
              var r8 = false;
              t6 = G9(t6, function(o9) {
                return o9 = st4(o9, n9), r8 || (r8 = o9.length > 1), o9;
              }), Un2(n9, pi2(n9), e9), r8 && (e9 = An(e9, Ln2 | Fn2 | xt5, kc));
              for (var s7 = t6.length; s7--; )
                si2(e9, t6[s7]);
              return e9;
            });
            function sd(n9, t6) {
              return ha2(n9, ur3(x4(t6)));
            }
            var ud = Yn(function(n9, t6) {
              return n9 == null ? {} : Dc(n9, t6);
            });
            function ha2(n9, t6) {
              if (n9 == null)
                return {};
              var e9 = G9(pi2(n9), function(r8) {
                return [r8];
              });
              return t6 = x4(t6), eu(n9, e9, function(r8, s7) {
                return t6(r8, s7[0]);
              });
            }
            function ad(n9, t6, e9) {
              t6 = st4(t6, n9);
              var r8 = -1, s7 = t6.length;
              for (s7 || (s7 = 1, n9 = i7); ++r8 < s7; ) {
                var o9 = n9 == null ? i7 : n9[Wn2(t6[r8])];
                o9 === i7 && (r8 = s7, o9 = e9), n9 = Jn2(o9) ? o9.call(n9) : o9;
              }
              return n9;
            }
            function od(n9, t6, e9) {
              return n9 == null ? n9 : fe5(n9, t6, e9);
            }
            function fd(n9, t6, e9, r8) {
              return r8 = typeof r8 == "function" ? r8 : i7, n9 == null ? n9 : fe5(n9, t6, e9, r8);
            }
            var la2 = xu(V9), pa2 = xu(on2);
            function cd(n9, t6, e9) {
              var r8 = O8(n9), s7 = r8 || at5(n9) || Bt5(n9);
              if (t6 = x4(t6, 4), e9 == null) {
                var o9 = n9 && n9.constructor;
                s7 ? e9 = r8 ? new o9() : [] : K8(n9) ? e9 = Jn2(o9) ? Wt4(He5(n9)) : {} : e9 = {};
              }
              return (s7 ? mn2 : $n)(n9, function(f7, c9, l9) {
                return t6(e9, f7, c9, l9);
              }), e9;
            }
            function hd(n9, t6) {
              return n9 == null ? true : si2(n9, t6);
            }
            function ld(n9, t6, e9) {
              return n9 == null ? n9 : au(n9, t6, oi2(e9));
            }
            function pd(n9, t6, e9, r8) {
              return r8 = typeof r8 == "function" ? r8 : i7, n9 == null ? n9 : au(n9, t6, oi2(e9), r8);
            }
            function Gt5(n9) {
              return n9 == null ? [] : Mr2(n9, V9(n9));
            }
            function dd(n9) {
              return n9 == null ? [] : Mr2(n9, on2(n9));
            }
            function gd(n9, t6, e9) {
              return e9 === i7 && (e9 = t6, t6 = i7), e9 !== i7 && (e9 = xn2(e9), e9 = e9 === e9 ? e9 : 0), t6 !== i7 && (t6 = xn2(t6), t6 = t6 === t6 ? t6 : 0), vt4(xn2(n9), t6, e9);
            }
            function vd(n9, t6, e9) {
              return t6 = Xn2(t6), e9 === i7 ? (e9 = t6, t6 = 0) : e9 = Xn2(e9), n9 = xn2(n9), Cc(n9, t6, e9);
            }
            function _d(n9, t6, e9) {
              if (e9 && typeof e9 != "boolean" && rn2(n9, t6, e9) && (t6 = e9 = i7), e9 === i7 && (typeof t6 == "boolean" ? (e9 = t6, t6 = i7) : typeof n9 == "boolean" && (e9 = n9, n9 = i7)), n9 === i7 && t6 === i7 ? (n9 = 0, t6 = 1) : (n9 = Xn2(n9), t6 === i7 ? (t6 = n9, n9 = 0) : t6 = Xn2(t6)), n9 > t6) {
                var r8 = n9;
                n9 = t6, t6 = r8;
              }
              if (e9 || n9 % 1 || t6 % 1) {
                var s7 = Us2();
                return nn2(n9 + s7 * (t6 - n9 + Jo3("1e-" + ((s7 + "").length - 1))), t6);
              }
              return ei2(n9, t6);
            }
            var md = Mt5(function(n9, t6, e9) {
              return t6 = t6.toLowerCase(), n9 + (e9 ? da2(t6) : t6);
            });
            function da2(n9) {
              return Ri(W8(n9).toLowerCase());
            }
            function ga2(n9) {
              return n9 = W8(n9), n9 && n9.replace(wo3, of).replace(Wo3, "");
            }
            function wd(n9, t6, e9) {
              n9 = W8(n9), t6 = ln2(t6);
              var r8 = n9.length;
              e9 = e9 === i7 ? r8 : vt4(R7(e9), 0, r8);
              var s7 = e9;
              return e9 -= t6.length, e9 >= 0 && n9.slice(e9, s7) == t6;
            }
            function Pd(n9) {
              return n9 = W8(n9), n9 && ka2.test(n9) ? n9.replace(Yi2, ff) : n9;
            }
            function Ad(n9) {
              return n9 = W8(n9), n9 && io3.test(n9) ? n9.replace(xr3, "\\$&") : n9;
            }
            var Cd = Mt5(function(n9, t6, e9) {
              return n9 + (e9 ? "-" : "") + t6.toLowerCase();
            }), Id = Mt5(function(n9, t6, e9) {
              return n9 + (e9 ? " " : "") + t6.toLowerCase();
            }), xd = mu("toLowerCase");
            function Ed(n9, t6, e9) {
              n9 = W8(n9), t6 = R7(t6);
              var r8 = t6 ? Dt5(n9) : 0;
              if (!t6 || r8 >= t6)
                return n9;
              var s7 = (t6 - r8) / 2;
              return Ve5(We5(s7), e9) + n9 + Ve5(Ue5(s7), e9);
            }
            function yd(n9, t6, e9) {
              n9 = W8(n9), t6 = R7(t6);
              var r8 = t6 ? Dt5(n9) : 0;
              return t6 && r8 < t6 ? n9 + Ve5(t6 - r8, e9) : n9;
            }
            function Sd(n9, t6, e9) {
              n9 = W8(n9), t6 = R7(t6);
              var r8 = t6 ? Dt5(n9) : 0;
              return t6 && r8 < t6 ? Ve5(t6 - r8, e9) + n9 : n9;
            }
            function Od(n9, t6, e9) {
              return e9 || t6 == null ? t6 = 0 : t6 && (t6 = +t6), Nf(W8(n9).replace(Er3, ""), t6 || 0);
            }
            function Rd(n9, t6, e9) {
              return (e9 ? rn2(n9, t6, e9) : t6 === i7) ? t6 = 1 : t6 = R7(t6), ri2(W8(n9), t6);
            }
            function bd() {
              var n9 = arguments, t6 = W8(n9[0]);
              return n9.length < 3 ? t6 : t6.replace(n9[1], n9[2]);
            }
            var Td = Mt5(function(n9, t6, e9) {
              return n9 + (e9 ? "_" : "") + t6.toLowerCase();
            });
            function Ld(n9, t6, e9) {
              return e9 && typeof e9 != "number" && rn2(n9, t6, e9) && (t6 = e9 = i7), e9 = e9 === i7 ? Nn2 : e9 >>> 0, e9 ? (n9 = W8(n9), n9 && (typeof t6 == "string" || t6 != null && !yi2(t6)) && (t6 = ln2(t6), !t6 && Lt5(n9)) ? ut5(On3(n9), 0, e9) : n9.split(t6, e9)) : [];
            }
            var Dd = Mt5(function(n9, t6, e9) {
              return n9 + (e9 ? " " : "") + Ri(t6);
            });
            function Hd(n9, t6, e9) {
              return n9 = W8(n9), e9 = e9 == null ? 0 : vt4(R7(e9), 0, n9.length), t6 = ln2(t6), n9.slice(e9, e9 + t6.length) == t6;
            }
            function Nd(n9, t6, e9) {
              var r8 = a6.templateSettings;
              e9 && rn2(n9, t6, e9) && (t6 = i7), n9 = W8(n9), t6 = fr3({}, t6, r8, Eu);
              var s7 = fr3({}, t6.imports, r8.imports, Eu), o9 = V9(s7), f7 = Mr2(s7, o9), c9, l9, v6 = 0, _8 = t6.interpolate || Ce4, m6 = "__p += '", P7 = Br2((t6.escape || Ce4).source + "|" + _8.source + "|" + (_8 === Zi2 ? lo3 : Ce4).source + "|" + (t6.evaluate || Ce4).source + "|$", "g"), I5 = "//# sourceURL=" + (F8.call(t6, "sourceURL") ? (t6.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++Go3 + "]") + `
`;
              n9.replace(P7, function(y11, D10, N17, dn2, sn2, gn2) {
                return N17 || (N17 = dn2), m6 += n9.slice(v6, gn2).replace(Po3, cf), D10 && (c9 = true, m6 += `' +
__e(` + D10 + `) +
'`), sn2 && (l9 = true, m6 += `';
` + sn2 + `;
__p += '`), N17 && (m6 += `' +
((__t = (` + N17 + `)) == null ? '' : __t) +
'`), v6 = gn2 + y11.length, y11;
              }), m6 += `';
`;
              var E8 = F8.call(t6, "variable") && t6.variable;
              if (!E8)
                m6 = `with (obj) {
` + m6 + `
}
`;
              else if (co3.test(E8))
                throw new S12(En2);
              m6 = (l9 ? m6.replace(Ja2, "") : m6).replace(Xa2, "$1").replace(Qa2, "$1;"), m6 = "function(" + (E8 || "obj") + `) {
` + (E8 ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (c9 ? ", __e = _.escape" : "") + (l9 ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + m6 + `return __p
}`;
              var b7 = _a2(function() {
                return U9(o9, I5 + "return " + m6).apply(i7, f7);
              });
              if (b7.source = m6, Ei2(b7))
                throw b7;
              return b7;
            }
            function $d(n9) {
              return W8(n9).toLowerCase();
            }
            function Ud(n9) {
              return W8(n9).toUpperCase();
            }
            function Wd(n9, t6, e9) {
              if (n9 = W8(n9), n9 && (e9 || t6 === i7))
                return ys2(n9);
              if (!n9 || !(t6 = ln2(t6)))
                return n9;
              var r8 = On3(n9), s7 = On3(t6), o9 = Ss2(r8, s7), f7 = Os2(r8, s7) + 1;
              return ut5(r8, o9, f7).join("");
            }
            function Fd(n9, t6, e9) {
              if (n9 = W8(n9), n9 && (e9 || t6 === i7))
                return n9.slice(0, bs2(n9) + 1);
              if (!n9 || !(t6 = ln2(t6)))
                return n9;
              var r8 = On3(n9), s7 = Os2(r8, On3(t6)) + 1;
              return ut5(r8, 0, s7).join("");
            }
            function Md(n9, t6, e9) {
              if (n9 = W8(n9), n9 && (e9 || t6 === i7))
                return n9.replace(Er3, "");
              if (!n9 || !(t6 = ln2(t6)))
                return n9;
              var r8 = On3(n9), s7 = Ss2(r8, On3(t6));
              return ut5(r8, s7).join("");
            }
            function qd(n9, t6) {
              var e9 = La2, r8 = Da2;
              if (K8(t6)) {
                var s7 = "separator" in t6 ? t6.separator : s7;
                e9 = "length" in t6 ? R7(t6.length) : e9, r8 = "omission" in t6 ? ln2(t6.omission) : r8;
              }
              n9 = W8(n9);
              var o9 = n9.length;
              if (Lt5(n9)) {
                var f7 = On3(n9);
                o9 = f7.length;
              }
              if (e9 >= o9)
                return n9;
              var c9 = e9 - Dt5(r8);
              if (c9 < 1)
                return r8;
              var l9 = f7 ? ut5(f7, 0, c9).join("") : n9.slice(0, c9);
              if (s7 === i7)
                return l9 + r8;
              if (f7 && (c9 += l9.length - c9), yi2(s7)) {
                if (n9.slice(c9).search(s7)) {
                  var v6, _8 = l9;
                  for (s7.global || (s7 = Br2(s7.source, W8(Ji2.exec(s7)) + "g")), s7.lastIndex = 0; v6 = s7.exec(_8); )
                    var m6 = v6.index;
                  l9 = l9.slice(0, m6 === i7 ? c9 : m6);
                }
              } else if (n9.indexOf(ln2(s7), c9) != c9) {
                var P7 = l9.lastIndexOf(s7);
                P7 > -1 && (l9 = l9.slice(0, P7));
              }
              return l9 + r8;
            }
            function Bd(n9) {
              return n9 = W8(n9), n9 && Va2.test(n9) ? n9.replace(Ki, _f) : n9;
            }
            var Gd = Mt5(function(n9, t6, e9) {
              return n9 + (e9 ? " " : "") + t6.toUpperCase();
            }), Ri = mu("toUpperCase");
            function va2(n9, t6, e9) {
              return n9 = W8(n9), t6 = e9 ? i7 : t6, t6 === i7 ? lf(n9) ? Pf(n9) : ef(n9) : n9.match(t6) || [];
            }
            var _a2 = L9(function(n9, t6) {
              try {
                return cn2(n9, i7, t6);
              } catch (e9) {
                return Ei2(e9) ? e9 : new S12(e9);
              }
            }), zd = Yn(function(n9, t6) {
              return mn2(t6, function(e9) {
                e9 = Wn2(e9), zn(n9, e9, Ii2(n9[e9], n9));
              }), n9;
            });
            function Kd(n9) {
              var t6 = n9 == null ? 0 : n9.length, e9 = x4();
              return n9 = t6 ? G9(n9, function(r8) {
                if (typeof r8[1] != "function")
                  throw new wn3($8);
                return [e9(r8[0]), r8[1]];
              }) : [], L9(function(r8) {
                for (var s7 = -1; ++s7 < t6; ) {
                  var o9 = n9[s7];
                  if (cn2(o9[0], this, r8))
                    return cn2(o9[1], this, r8);
                }
              });
            }
            function Yd(n9) {
              return _c(An(n9, Ln2));
            }
            function bi2(n9) {
              return function() {
                return n9;
              };
            }
            function Zd(n9, t6) {
              return n9 == null || n9 !== n9 ? t6 : n9;
            }
            var Jd = Pu(), Xd = Pu(true);
            function fn2(n9) {
              return n9;
            }
            function Ti(n9) {
              return Qs2(typeof n9 == "function" ? n9 : An(n9, Ln2));
            }
            function Qd(n9) {
              return ks2(An(n9, Ln2));
            }
            function Vd(n9, t6) {
              return js2(n9, An(t6, Ln2));
            }
            var kd = L9(function(n9, t6) {
              return function(e9) {
                return ae6(e9, n9, t6);
              };
            }), jd = L9(function(n9, t6) {
              return function(e9) {
                return ae6(n9, e9, t6);
              };
            });
            function Li2(n9, t6, e9) {
              var r8 = V9(t6), s7 = ze4(t6, r8);
              e9 == null && !(K8(t6) && (s7.length || !r8.length)) && (e9 = t6, t6 = n9, n9 = this, s7 = ze4(t6, V9(t6)));
              var o9 = !(K8(e9) && "chain" in e9) || !!e9.chain, f7 = Jn2(n9);
              return mn2(s7, function(c9) {
                var l9 = t6[c9];
                n9[c9] = l9, f7 && (n9.prototype[c9] = function() {
                  var v6 = this.__chain__;
                  if (o9 || v6) {
                    var _8 = n9(this.__wrapped__), m6 = _8.__actions__ = un2(this.__actions__);
                    return m6.push({ func: l9, args: arguments, thisArg: n9 }), _8.__chain__ = v6, _8;
                  }
                  return l9.apply(n9, nt3([this.value()], arguments));
                });
              }), n9;
            }
            function ng() {
              return k6._ === this && (k6._ = yf), this;
            }
            function Di() {
            }
            function tg(n9) {
              return n9 = R7(n9), L9(function(t6) {
                return nu(t6, n9);
              });
            }
            var eg = ci2(G9), rg = ci2(As2), ig = ci2(Nr3);
            function ma2(n9) {
              return _i(n9) ? $r2(Wn2(n9)) : Hc(n9);
            }
            function sg(n9) {
              return function(t6) {
                return n9 == null ? i7 : _t4(n9, t6);
              };
            }
            var ug = Cu(), ag = Cu(true);
            function Hi2() {
              return [];
            }
            function Ni2() {
              return false;
            }
            function og() {
              return {};
            }
            function fg() {
              return "";
            }
            function cg() {
              return true;
            }
            function hg(n9, t6) {
              if (n9 = R7(n9), n9 < 1 || n9 > kn2)
                return [];
              var e9 = Nn2, r8 = nn2(n9, Nn2);
              t6 = x4(t6), n9 -= Nn2;
              for (var s7 = Fr2(r8, t6); ++e9 < n9; )
                t6(e9);
              return s7;
            }
            function lg(n9) {
              return O8(n9) ? G9(n9, Wn2) : pn2(n9) ? [n9] : un2(Wu(W8(n9)));
            }
            function pg(n9) {
              var t6 = ++xf;
              return W8(n9) + t6;
            }
            var dg = Qe5(function(n9, t6) {
              return n9 + t6;
            }, 0), gg = hi2("ceil"), vg = Qe5(function(n9, t6) {
              return n9 / t6;
            }, 1), _g = hi2("floor");
            function mg(n9) {
              return n9 && n9.length ? Ge5(n9, fn2, Qr2) : i7;
            }
            function wg(n9, t6) {
              return n9 && n9.length ? Ge5(n9, x4(t6, 2), Qr2) : i7;
            }
            function Pg(n9) {
              return xs2(n9, fn2);
            }
            function Ag(n9, t6) {
              return xs2(n9, x4(t6, 2));
            }
            function Cg(n9) {
              return n9 && n9.length ? Ge5(n9, fn2, ni2) : i7;
            }
            function Ig(n9, t6) {
              return n9 && n9.length ? Ge5(n9, x4(t6, 2), ni2) : i7;
            }
            var xg = Qe5(function(n9, t6) {
              return n9 * t6;
            }, 1), Eg = hi2("round"), yg = Qe5(function(n9, t6) {
              return n9 - t6;
            }, 0);
            function Sg(n9) {
              return n9 && n9.length ? Wr2(n9, fn2) : 0;
            }
            function Og(n9, t6) {
              return n9 && n9.length ? Wr2(n9, x4(t6, 2)) : 0;
            }
            return a6.after = Ql, a6.ary = Xu, a6.assign = Up, a6.assignIn = fa2, a6.assignInWith = fr3, a6.assignWith = Wp, a6.at = Fp, a6.before = Qu, a6.bind = Ii2, a6.bindAll = zd, a6.bindKey = Vu, a6.castArray = op, a6.chain = Yu, a6.chunk = _h, a6.compact = mh, a6.concat = wh, a6.cond = Kd, a6.conforms = Yd, a6.constant = bi2, a6.countBy = Sl, a6.create = Mp, a6.curry = ku, a6.curryRight = ju, a6.debounce = na2, a6.defaults = qp, a6.defaultsDeep = Bp, a6.defer = Vl, a6.delay = kl, a6.difference = Ph, a6.differenceBy = Ah, a6.differenceWith = Ch, a6.drop = Ih, a6.dropRight = xh, a6.dropRightWhile = Eh, a6.dropWhile = yh, a6.fill = Sh, a6.filter = Rl, a6.flatMap = Ll, a6.flatMapDeep = Dl, a6.flatMapDepth = Hl, a6.flatten = Bu, a6.flattenDeep = Oh, a6.flattenDepth = Rh, a6.flip = jl, a6.flow = Jd, a6.flowRight = Xd, a6.fromPairs = bh, a6.functions = Xp, a6.functionsIn = Qp, a6.groupBy = Nl, a6.initial = Lh, a6.intersection = Dh, a6.intersectionBy = Hh, a6.intersectionWith = Nh, a6.invert = kp, a6.invertBy = jp, a6.invokeMap = Ul, a6.iteratee = Ti, a6.keyBy = Wl, a6.keys = V9, a6.keysIn = on2, a6.map = rr4, a6.mapKeys = td, a6.mapValues = ed, a6.matches = Qd, a6.matchesProperty = Vd, a6.memoize = sr4, a6.merge = rd, a6.mergeWith = ca2, a6.method = kd, a6.methodOf = jd, a6.mixin = Li2, a6.negate = ur3, a6.nthArg = tg, a6.omit = id3, a6.omitBy = sd, a6.once = np, a6.orderBy = Fl, a6.over = eg, a6.overArgs = tp, a6.overEvery = rg, a6.overSome = ig, a6.partial = xi2, a6.partialRight = ta2, a6.partition = Ml, a6.pick = ud, a6.pickBy = ha2, a6.property = ma2, a6.propertyOf = sg, a6.pull = Fh, a6.pullAll = zu, a6.pullAllBy = Mh, a6.pullAllWith = qh, a6.pullAt = Bh, a6.range = ug, a6.rangeRight = ag, a6.rearg = ep, a6.reject = Gl, a6.remove = Gh, a6.rest = rp, a6.reverse = Ai, a6.sampleSize = Kl, a6.set = od, a6.setWith = fd, a6.shuffle = Yl, a6.slice = zh, a6.sortBy = Xl, a6.sortedUniq = Vh, a6.sortedUniqBy = kh, a6.split = Ld, a6.spread = ip, a6.tail = jh, a6.take = nl, a6.takeRight = tl, a6.takeRightWhile = el, a6.takeWhile = rl, a6.tap = ml, a6.throttle = sp, a6.thru = er5, a6.toArray = ua2, a6.toPairs = la2, a6.toPairsIn = pa2, a6.toPath = lg, a6.toPlainObject = oa2, a6.transform = cd, a6.unary = up, a6.union = il, a6.unionBy = sl, a6.unionWith = ul, a6.uniq = al, a6.uniqBy = ol, a6.uniqWith = fl, a6.unset = hd, a6.unzip = Ci2, a6.unzipWith = Ku, a6.update = ld, a6.updateWith = pd, a6.values = Gt5, a6.valuesIn = dd, a6.without = cl, a6.words = va2, a6.wrap = ap, a6.xor = hl, a6.xorBy = ll, a6.xorWith = pl, a6.zip = dl, a6.zipObject = gl, a6.zipObjectDeep = vl, a6.zipWith = _l, a6.entries = la2, a6.entriesIn = pa2, a6.extend = fa2, a6.extendWith = fr3, Li2(a6, a6), a6.add = dg, a6.attempt = _a2, a6.camelCase = md, a6.capitalize = da2, a6.ceil = gg, a6.clamp = gd, a6.clone = fp, a6.cloneDeep = hp, a6.cloneDeepWith = lp, a6.cloneWith = cp, a6.conformsTo = pp, a6.deburr = ga2, a6.defaultTo = Zd, a6.divide = vg, a6.endsWith = wd, a6.eq = bn2, a6.escape = Pd, a6.escapeRegExp = Ad, a6.every = Ol, a6.find = bl, a6.findIndex = Mu, a6.findKey = Gp, a6.findLast = Tl, a6.findLastIndex = qu, a6.findLastKey = zp, a6.floor = _g, a6.forEach = Zu, a6.forEachRight = Ju, a6.forIn = Kp, a6.forInRight = Yp, a6.forOwn = Zp, a6.forOwnRight = Jp, a6.get = Si, a6.gt = dp, a6.gte = gp, a6.has = Vp, a6.hasIn = Oi2, a6.head = Gu, a6.identity = fn2, a6.includes = $l, a6.indexOf = Th, a6.inRange = vd, a6.invoke = nd, a6.isArguments = Pt5, a6.isArray = O8, a6.isArrayBuffer = vp, a6.isArrayLike = an2, a6.isArrayLikeObject = Z7, a6.isBoolean = _p, a6.isBuffer = at5, a6.isDate = mp, a6.isElement = wp, a6.isEmpty = Pp, a6.isEqual = Ap, a6.isEqualWith = Cp, a6.isError = Ei2, a6.isFinite = Ip, a6.isFunction = Jn2, a6.isInteger = ea2, a6.isLength = ar4, a6.isMap = ra2, a6.isMatch = xp, a6.isMatchWith = Ep, a6.isNaN = yp, a6.isNative = Sp, a6.isNil = Rp, a6.isNull = Op, a6.isNumber = ia2, a6.isObject = K8, a6.isObjectLike = Y6, a6.isPlainObject = pe5, a6.isRegExp = yi2, a6.isSafeInteger = bp, a6.isSet = sa2, a6.isString = or5, a6.isSymbol = pn2, a6.isTypedArray = Bt5, a6.isUndefined = Tp, a6.isWeakMap = Lp, a6.isWeakSet = Dp, a6.join = $h, a6.kebabCase = Cd, a6.last = In2, a6.lastIndexOf = Uh, a6.lowerCase = Id, a6.lowerFirst = xd, a6.lt = Hp, a6.lte = Np, a6.max = mg, a6.maxBy = wg, a6.mean = Pg, a6.meanBy = Ag, a6.min = Cg, a6.minBy = Ig, a6.stubArray = Hi2, a6.stubFalse = Ni2, a6.stubObject = og, a6.stubString = fg, a6.stubTrue = cg, a6.multiply = xg, a6.nth = Wh, a6.noConflict = ng, a6.noop = Di, a6.now = ir4, a6.pad = Ed, a6.padEnd = yd, a6.padStart = Sd, a6.parseInt = Od, a6.random = _d, a6.reduce = ql, a6.reduceRight = Bl, a6.repeat = Rd, a6.replace = bd, a6.result = ad, a6.round = Eg, a6.runInContext = h10, a6.sample = zl, a6.size = Zl, a6.snakeCase = Td, a6.some = Jl, a6.sortedIndex = Kh, a6.sortedIndexBy = Yh, a6.sortedIndexOf = Zh, a6.sortedLastIndex = Jh, a6.sortedLastIndexBy = Xh, a6.sortedLastIndexOf = Qh, a6.startCase = Dd, a6.startsWith = Hd, a6.subtract = yg, a6.sum = Sg, a6.sumBy = Og, a6.template = Nd, a6.times = hg, a6.toFinite = Xn2, a6.toInteger = R7, a6.toLength = aa2, a6.toLower = $d, a6.toNumber = xn2, a6.toSafeInteger = $p, a6.toString = W8, a6.toUpper = Ud, a6.trim = Wd, a6.trimEnd = Fd, a6.trimStart = Md, a6.truncate = qd, a6.unescape = Bd, a6.uniqueId = pg, a6.upperCase = Gd, a6.upperFirst = Ri, a6.each = Zu, a6.eachRight = Ju, a6.first = Gu, Li2(a6, function() {
              var n9 = {};
              return $n(a6, function(t6, e9) {
                F8.call(a6.prototype, e9) || (n9[e9] = t6);
              }), n9;
            }(), { chain: false }), a6.VERSION = d7, mn2(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(n9) {
              a6[n9].placeholder = a6;
            }), mn2(["drop", "take"], function(n9, t6) {
              H5.prototype[n9] = function(e9) {
                e9 = e9 === i7 ? 1 : Q10(R7(e9), 0);
                var r8 = this.__filtered__ && !t6 ? new H5(this) : this.clone();
                return r8.__filtered__ ? r8.__takeCount__ = nn2(e9, r8.__takeCount__) : r8.__views__.push({ size: nn2(e9, Nn2), type: n9 + (r8.__dir__ < 0 ? "Right" : "") }), r8;
              }, H5.prototype[n9 + "Right"] = function(e9) {
                return this.reverse()[n9](e9).reverse();
              };
            }), mn2(["filter", "map", "takeWhile"], function(n9, t6) {
              var e9 = t6 + 1, r8 = e9 == Bi2 || e9 == Ua2;
              H5.prototype[n9] = function(s7) {
                var o9 = this.clone();
                return o9.__iteratees__.push({ iteratee: x4(s7, 3), type: e9 }), o9.__filtered__ = o9.__filtered__ || r8, o9;
              };
            }), mn2(["head", "last"], function(n9, t6) {
              var e9 = "take" + (t6 ? "Right" : "");
              H5.prototype[n9] = function() {
                return this[e9](1).value()[0];
              };
            }), mn2(["initial", "tail"], function(n9, t6) {
              var e9 = "drop" + (t6 ? "" : "Right");
              H5.prototype[n9] = function() {
                return this.__filtered__ ? new H5(this) : this[e9](1);
              };
            }), H5.prototype.compact = function() {
              return this.filter(fn2);
            }, H5.prototype.find = function(n9) {
              return this.filter(n9).head();
            }, H5.prototype.findLast = function(n9) {
              return this.reverse().find(n9);
            }, H5.prototype.invokeMap = L9(function(n9, t6) {
              return typeof n9 == "function" ? new H5(this) : this.map(function(e9) {
                return ae6(e9, n9, t6);
              });
            }), H5.prototype.reject = function(n9) {
              return this.filter(ur3(x4(n9)));
            }, H5.prototype.slice = function(n9, t6) {
              n9 = R7(n9);
              var e9 = this;
              return e9.__filtered__ && (n9 > 0 || t6 < 0) ? new H5(e9) : (n9 < 0 ? e9 = e9.takeRight(-n9) : n9 && (e9 = e9.drop(n9)), t6 !== i7 && (t6 = R7(t6), e9 = t6 < 0 ? e9.dropRight(-t6) : e9.take(t6 - n9)), e9);
            }, H5.prototype.takeRightWhile = function(n9) {
              return this.reverse().takeWhile(n9).reverse();
            }, H5.prototype.toArray = function() {
              return this.take(Nn2);
            }, $n(H5.prototype, function(n9, t6) {
              var e9 = /^(?:filter|find|map|reject)|While$/.test(t6), r8 = /^(?:head|last)$/.test(t6), s7 = a6[r8 ? "take" + (t6 == "last" ? "Right" : "") : t6], o9 = r8 || /^find/.test(t6);
              s7 && (a6.prototype[t6] = function() {
                var f7 = this.__wrapped__, c9 = r8 ? [1] : arguments, l9 = f7 instanceof H5, v6 = c9[0], _8 = l9 || O8(f7), m6 = function(D10) {
                  var N17 = s7.apply(a6, nt3([D10], c9));
                  return r8 && P7 ? N17[0] : N17;
                };
                _8 && e9 && typeof v6 == "function" && v6.length != 1 && (l9 = _8 = false);
                var P7 = this.__chain__, I5 = !!this.__actions__.length, E8 = o9 && !P7, b7 = l9 && !I5;
                if (!o9 && _8) {
                  f7 = b7 ? f7 : new H5(this);
                  var y11 = n9.apply(f7, c9);
                  return y11.__actions__.push({ func: er5, args: [m6], thisArg: i7 }), new Pn2(y11, P7);
                }
                return E8 && b7 ? n9.apply(this, c9) : (y11 = this.thru(m6), E8 ? r8 ? y11.value()[0] : y11.value() : y11);
              });
            }), mn2(["pop", "push", "shift", "sort", "splice", "unshift"], function(n9) {
              var t6 = Oe3[n9], e9 = /^(?:push|sort|unshift)$/.test(n9) ? "tap" : "thru", r8 = /^(?:pop|shift)$/.test(n9);
              a6.prototype[n9] = function() {
                var s7 = arguments;
                if (r8 && !this.__chain__) {
                  var o9 = this.value();
                  return t6.apply(O8(o9) ? o9 : [], s7);
                }
                return this[e9](function(f7) {
                  return t6.apply(O8(f7) ? f7 : [], s7);
                });
              };
            }), $n(H5.prototype, function(n9, t6) {
              var e9 = a6[t6];
              if (e9) {
                var r8 = e9.name + "";
                F8.call(Ut4, r8) || (Ut4[r8] = []), Ut4[r8].push({ name: t6, func: e9 });
              }
            }), Ut4[Xe6(i7, ct4).name] = [{ name: "wrapper", func: i7 }], H5.prototype.clone = Bf, H5.prototype.reverse = Gf, H5.prototype.value = zf, a6.prototype.at = wl, a6.prototype.chain = Pl, a6.prototype.commit = Al, a6.prototype.next = Cl, a6.prototype.plant = xl, a6.prototype.reverse = El, a6.prototype.toJSON = a6.prototype.valueOf = a6.prototype.value = yl, a6.prototype.first = a6.prototype.head, ne7 && (a6.prototype[ne7] = Il), a6;
          }, Ht4 = Af();
          lt4 ? ((lt4.exports = Ht4)._ = Ht4, Tr3._ = Ht4) : k6._ = Ht4;
        }).call(ge3);
      })(Ui2, Ui2.exports);
      qg = Object.defineProperty;
      Bg = Object.defineProperties;
      Gg = Object.getOwnPropertyDescriptors;
      Ea = Object.getOwnPropertySymbols;
      zg = Object.prototype.hasOwnProperty;
      Kg = Object.prototype.propertyIsEnumerable;
      ya = (C6, u7, i7) => u7 in C6 ? qg(C6, u7, { enumerable: true, configurable: true, writable: true, value: i7 }) : C6[u7] = i7;
      cr2 = (C6, u7) => {
        for (var i7 in u7 || (u7 = {}))
          zg.call(u7, i7) && ya(C6, i7, u7[i7]);
        if (Ea)
          for (var i7 of Ea(u7))
            Kg.call(u7, i7) && ya(C6, i7, u7[i7]);
        return C6;
      };
      Yg = (C6, u7) => Bg(C6, Gg(u7));
      Ra = {};
      z2 = (C6) => Ra[C6];
      Fi = (C6, u7) => {
        Ra[C6] = u7;
      };
      Vg = class {
        constructor(u7) {
          this.name = "polkadot", this.namespace = u7.namespace, this.events = z2("events"), this.client = z2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
        }
        updateNamespace(u7) {
          this.namespace = Object.assign(this.namespace, u7);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        getDefaultChain() {
          if (this.chainId)
            return this.chainId;
          if (this.namespace.defaultChain)
            return this.namespace.defaultChain;
          const u7 = this.namespace.chains[0];
          if (!u7)
            throw new Error("ChainId not found");
          return u7.split(":")[1];
        }
        request(u7) {
          return this.namespace.methods.includes(u7.request.method) ? this.client.request(u7) : this.getHttpProvider().request(u7.request);
        }
        setDefaultChain(u7, i7) {
          this.httpProviders[u7] || this.setHttpProvider(u7, i7), this.chainId = u7, this.events.emit(Vn2.DEFAULT_CHAIN_CHANGED, `${this.name}:${u7}`);
        }
        getAccounts() {
          const u7 = this.namespace.accounts;
          return u7 ? u7.filter((i7) => i7.split(":")[1] === this.chainId.toString()).map((i7) => i7.split(":")[2]) || [] : [];
        }
        createHttpProviders() {
          const u7 = {};
          return this.namespace.chains.forEach((i7) => {
            var d7;
            const w8 = Ct2(i7);
            u7[w8] = this.createHttpProvider(w8, (d7 = this.namespace.rpcMap) == null ? void 0 : d7[i7]);
          }), u7;
        }
        getHttpProvider() {
          const u7 = `${this.name}:${this.chainId}`, i7 = this.httpProviders[u7];
          if (typeof i7 > "u")
            throw new Error(`JSON-RPC provider for ${u7} not found`);
          return i7;
        }
        setHttpProvider(u7, i7) {
          const d7 = this.createHttpProvider(u7, i7);
          d7 && (this.httpProviders[u7] = d7);
        }
        createHttpProvider(u7, i7) {
          const d7 = i7 || ft3(u7, this.namespace, this.client.core.projectId);
          if (!d7)
            throw new Error(`No RPC url provided for chainId: ${u7}`);
          return new JsonRpcProvider(new esm_default(d7, z2("disableProviderPing")));
        }
      };
      kg = class {
        constructor(u7) {
          this.name = "eip155", this.namespace = u7.namespace, this.events = z2("events"), this.client = z2("client"), this.httpProviders = this.createHttpProviders(), this.chainId = parseInt(this.getDefaultChain());
        }
        async request(u7) {
          switch (u7.request.method) {
            case "eth_requestAccounts":
              return this.getAccounts();
            case "eth_accounts":
              return this.getAccounts();
            case "wallet_switchEthereumChain":
              return await this.handleSwitchChain(u7);
            case "eth_chainId":
              return parseInt(this.getDefaultChain());
          }
          return this.namespace.methods.includes(u7.request.method) ? await this.client.request(u7) : this.getHttpProvider().request(u7.request);
        }
        updateNamespace(u7) {
          this.namespace = Object.assign(this.namespace, u7);
        }
        setDefaultChain(u7, i7) {
          this.httpProviders[u7] || this.setHttpProvider(parseInt(u7), i7), this.chainId = parseInt(u7), this.events.emit(Vn2.DEFAULT_CHAIN_CHANGED, `${this.name}:${u7}`);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        getDefaultChain() {
          if (this.chainId)
            return this.chainId.toString();
          if (this.namespace.defaultChain)
            return this.namespace.defaultChain;
          const u7 = this.namespace.chains[0];
          if (!u7)
            throw new Error("ChainId not found");
          return u7.split(":")[1];
        }
        createHttpProvider(u7, i7) {
          const d7 = i7 || ft3(`${this.name}:${u7}`, this.namespace, this.client.core.projectId);
          if (!d7)
            throw new Error(`No RPC url provided for chainId: ${u7}`);
          return new JsonRpcProvider(new HttpConnection(d7, z2("disableProviderPing")));
        }
        setHttpProvider(u7, i7) {
          const d7 = this.createHttpProvider(u7, i7);
          d7 && (this.httpProviders[u7] = d7);
        }
        createHttpProviders() {
          const u7 = {};
          return this.namespace.chains.forEach((i7) => {
            var d7;
            const w8 = parseInt(Ct2(i7));
            u7[w8] = this.createHttpProvider(w8, (d7 = this.namespace.rpcMap) == null ? void 0 : d7[i7]);
          }), u7;
        }
        getAccounts() {
          const u7 = this.namespace.accounts;
          return u7 ? [...new Set(u7.filter((i7) => i7.split(":")[1] === this.chainId.toString()).map((i7) => i7.split(":")[2]))] : [];
        }
        getHttpProvider() {
          const u7 = this.chainId, i7 = this.httpProviders[u7];
          if (typeof i7 > "u")
            throw new Error(`JSON-RPC provider for ${u7} not found`);
          return i7;
        }
        async handleSwitchChain(u7) {
          var i7, d7;
          let w8 = u7.request.params ? (i7 = u7.request.params[0]) == null ? void 0 : i7.chainId : "0x0";
          w8 = w8.startsWith("0x") ? w8 : `0x${w8}`;
          const T6 = parseInt(w8, 16);
          if (this.isChainApproved(T6))
            this.setDefaultChain(`${T6}`);
          else if (this.namespace.methods.includes("wallet_switchEthereumChain"))
            await this.client.request({ topic: u7.topic, request: { method: u7.request.method, params: [{ chainId: w8 }] }, chainId: (d7 = this.namespace.chains) == null ? void 0 : d7[0] }), this.setDefaultChain(`${T6}`);
          else
            throw new Error(`Failed to switch to chain 'eip155:${T6}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);
          return null;
        }
        isChainApproved(u7) {
          return this.namespace.chains.includes(`${this.name}:${u7}`);
        }
      };
      jg = class {
        constructor(u7) {
          this.name = "solana", this.namespace = u7.namespace, this.events = z2("events"), this.client = z2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
        }
        updateNamespace(u7) {
          this.namespace = Object.assign(this.namespace, u7);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        request(u7) {
          return this.namespace.methods.includes(u7.request.method) ? this.client.request(u7) : this.getHttpProvider().request(u7.request);
        }
        setDefaultChain(u7, i7) {
          this.httpProviders[u7] || this.setHttpProvider(u7, i7), this.chainId = u7, this.events.emit(Vn2.DEFAULT_CHAIN_CHANGED, `${this.name}:${u7}`);
        }
        getDefaultChain() {
          if (this.chainId)
            return this.chainId;
          if (this.namespace.defaultChain)
            return this.namespace.defaultChain;
          const u7 = this.namespace.chains[0];
          if (!u7)
            throw new Error("ChainId not found");
          return u7.split(":")[1];
        }
        getAccounts() {
          const u7 = this.namespace.accounts;
          return u7 ? [...new Set(u7.filter((i7) => i7.split(":")[1] === this.chainId.toString()).map((i7) => i7.split(":")[2]))] : [];
        }
        createHttpProviders() {
          const u7 = {};
          return this.namespace.chains.forEach((i7) => {
            var d7;
            const w8 = Ct2(i7);
            u7[w8] = this.createHttpProvider(w8, (d7 = this.namespace.rpcMap) == null ? void 0 : d7[i7]);
          }), u7;
        }
        getHttpProvider() {
          const u7 = `${this.name}:${this.chainId}`, i7 = this.httpProviders[u7];
          if (typeof i7 > "u")
            throw new Error(`JSON-RPC provider for ${u7} not found`);
          return i7;
        }
        setHttpProvider(u7, i7) {
          const d7 = this.createHttpProvider(u7, i7);
          d7 && (this.httpProviders[u7] = d7);
        }
        createHttpProvider(u7, i7) {
          const d7 = i7 || ft3(u7, this.namespace, this.client.core.projectId);
          if (!d7)
            throw new Error(`No RPC url provided for chainId: ${u7}`);
          return new JsonRpcProvider(new esm_default(d7, z2("disableProviderPing")));
        }
      };
      nv = class {
        constructor(u7) {
          this.name = "cosmos", this.namespace = u7.namespace, this.events = z2("events"), this.client = z2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
        }
        updateNamespace(u7) {
          this.namespace = Object.assign(this.namespace, u7);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        getDefaultChain() {
          if (this.chainId)
            return this.chainId;
          if (this.namespace.defaultChain)
            return this.namespace.defaultChain;
          const u7 = this.namespace.chains[0];
          if (!u7)
            throw new Error("ChainId not found");
          return u7.split(":")[1];
        }
        request(u7) {
          return this.namespace.methods.includes(u7.request.method) ? this.client.request(u7) : this.getHttpProvider().request(u7.request);
        }
        setDefaultChain(u7, i7) {
          this.httpProviders[u7] || this.setHttpProvider(u7, i7), this.chainId = u7, this.events.emit(Vn2.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
        }
        getAccounts() {
          const u7 = this.namespace.accounts;
          return u7 ? [...new Set(u7.filter((i7) => i7.split(":")[1] === this.chainId.toString()).map((i7) => i7.split(":")[2]))] : [];
        }
        createHttpProviders() {
          const u7 = {};
          return this.namespace.chains.forEach((i7) => {
            var d7;
            const w8 = Ct2(i7);
            u7[w8] = this.createHttpProvider(w8, (d7 = this.namespace.rpcMap) == null ? void 0 : d7[i7]);
          }), u7;
        }
        getHttpProvider() {
          const u7 = `${this.name}:${this.chainId}`, i7 = this.httpProviders[u7];
          if (typeof i7 > "u")
            throw new Error(`JSON-RPC provider for ${u7} not found`);
          return i7;
        }
        setHttpProvider(u7, i7) {
          const d7 = this.createHttpProvider(u7, i7);
          d7 && (this.httpProviders[u7] = d7);
        }
        createHttpProvider(u7, i7) {
          const d7 = i7 || ft3(u7, this.namespace, this.client.core.projectId);
          if (!d7)
            throw new Error(`No RPC url provided for chainId: ${u7}`);
          return new JsonRpcProvider(new esm_default(d7, z2("disableProviderPing")));
        }
      };
      tv = class {
        constructor(u7) {
          this.name = "cip34", this.namespace = u7.namespace, this.events = z2("events"), this.client = z2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
        }
        updateNamespace(u7) {
          this.namespace = Object.assign(this.namespace, u7);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        getDefaultChain() {
          if (this.chainId)
            return this.chainId;
          if (this.namespace.defaultChain)
            return this.namespace.defaultChain;
          const u7 = this.namespace.chains[0];
          if (!u7)
            throw new Error("ChainId not found");
          return u7.split(":")[1];
        }
        request(u7) {
          return this.namespace.methods.includes(u7.request.method) ? this.client.request(u7) : this.getHttpProvider().request(u7.request);
        }
        setDefaultChain(u7, i7) {
          this.httpProviders[u7] || this.setHttpProvider(u7, i7), this.chainId = u7, this.events.emit(Vn2.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
        }
        getAccounts() {
          const u7 = this.namespace.accounts;
          return u7 ? [...new Set(u7.filter((i7) => i7.split(":")[1] === this.chainId.toString()).map((i7) => i7.split(":")[2]))] : [];
        }
        createHttpProviders() {
          const u7 = {};
          return this.namespace.chains.forEach((i7) => {
            const d7 = this.getCardanoRPCUrl(i7), w8 = Ct2(i7);
            u7[w8] = this.createHttpProvider(w8, d7);
          }), u7;
        }
        getHttpProvider() {
          const u7 = `${this.name}:${this.chainId}`, i7 = this.httpProviders[u7];
          if (typeof i7 > "u")
            throw new Error(`JSON-RPC provider for ${u7} not found`);
          return i7;
        }
        getCardanoRPCUrl(u7) {
          const i7 = this.namespace.rpcMap;
          if (i7)
            return i7[u7];
        }
        setHttpProvider(u7, i7) {
          const d7 = this.createHttpProvider(u7, i7);
          d7 && (this.httpProviders[u7] = d7);
        }
        createHttpProvider(u7, i7) {
          const d7 = i7 || this.getCardanoRPCUrl(u7);
          if (!d7)
            throw new Error(`No RPC url provided for chainId: ${u7}`);
          return new JsonRpcProvider(new esm_default(d7, z2("disableProviderPing")));
        }
      };
      ev = class {
        constructor(u7) {
          this.name = "elrond", this.namespace = u7.namespace, this.events = z2("events"), this.client = z2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
        }
        updateNamespace(u7) {
          this.namespace = Object.assign(this.namespace, u7);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        request(u7) {
          return this.namespace.methods.includes(u7.request.method) ? this.client.request(u7) : this.getHttpProvider().request(u7.request);
        }
        setDefaultChain(u7, i7) {
          this.httpProviders[u7] || this.setHttpProvider(u7, i7), this.chainId = u7, this.events.emit(Vn2.DEFAULT_CHAIN_CHANGED, `${this.name}:${u7}`);
        }
        getDefaultChain() {
          if (this.chainId)
            return this.chainId;
          if (this.namespace.defaultChain)
            return this.namespace.defaultChain;
          const u7 = this.namespace.chains[0];
          if (!u7)
            throw new Error("ChainId not found");
          return u7.split(":")[1];
        }
        getAccounts() {
          const u7 = this.namespace.accounts;
          return u7 ? [...new Set(u7.filter((i7) => i7.split(":")[1] === this.chainId.toString()).map((i7) => i7.split(":")[2]))] : [];
        }
        createHttpProviders() {
          const u7 = {};
          return this.namespace.chains.forEach((i7) => {
            var d7;
            const w8 = Ct2(i7);
            u7[w8] = this.createHttpProvider(w8, (d7 = this.namespace.rpcMap) == null ? void 0 : d7[i7]);
          }), u7;
        }
        getHttpProvider() {
          const u7 = `${this.name}:${this.chainId}`, i7 = this.httpProviders[u7];
          if (typeof i7 > "u")
            throw new Error(`JSON-RPC provider for ${u7} not found`);
          return i7;
        }
        setHttpProvider(u7, i7) {
          const d7 = this.createHttpProvider(u7, i7);
          d7 && (this.httpProviders[u7] = d7);
        }
        createHttpProvider(u7, i7) {
          const d7 = i7 || ft3(u7, this.namespace, this.client.core.projectId);
          if (!d7)
            throw new Error(`No RPC url provided for chainId: ${u7}`);
          return new JsonRpcProvider(new esm_default(d7, z2("disableProviderPing")));
        }
      };
      rv = class {
        constructor(u7) {
          this.name = "multiversx", this.namespace = u7.namespace, this.events = z2("events"), this.client = z2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
        }
        updateNamespace(u7) {
          this.namespace = Object.assign(this.namespace, u7);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        request(u7) {
          return this.namespace.methods.includes(u7.request.method) ? this.client.request(u7) : this.getHttpProvider().request(u7.request);
        }
        setDefaultChain(u7, i7) {
          this.httpProviders[u7] || this.setHttpProvider(u7, i7), this.chainId = u7, this.events.emit(Vn2.DEFAULT_CHAIN_CHANGED, `${this.name}:${u7}`);
        }
        getDefaultChain() {
          if (this.chainId)
            return this.chainId;
          if (this.namespace.defaultChain)
            return this.namespace.defaultChain;
          const u7 = this.namespace.chains[0];
          if (!u7)
            throw new Error("ChainId not found");
          return u7.split(":")[1];
        }
        getAccounts() {
          const u7 = this.namespace.accounts;
          return u7 ? [...new Set(u7.filter((i7) => i7.split(":")[1] === this.chainId.toString()).map((i7) => i7.split(":")[2]))] : [];
        }
        createHttpProviders() {
          const u7 = {};
          return this.namespace.chains.forEach((i7) => {
            var d7;
            const w8 = Ct2(i7);
            u7[w8] = this.createHttpProvider(w8, (d7 = this.namespace.rpcMap) == null ? void 0 : d7[i7]);
          }), u7;
        }
        getHttpProvider() {
          const u7 = `${this.name}:${this.chainId}`, i7 = this.httpProviders[u7];
          if (typeof i7 > "u")
            throw new Error(`JSON-RPC provider for ${u7} not found`);
          return i7;
        }
        setHttpProvider(u7, i7) {
          const d7 = this.createHttpProvider(u7, i7);
          d7 && (this.httpProviders[u7] = d7);
        }
        createHttpProvider(u7, i7) {
          const d7 = i7 || ft3(u7, this.namespace, this.client.core.projectId);
          if (!d7)
            throw new Error(`No RPC url provided for chainId: ${u7}`);
          return new JsonRpcProvider(new esm_default(d7, z2("disableProviderPing")));
        }
      };
      iv = class {
        constructor(u7) {
          this.name = "near", this.namespace = u7.namespace, this.events = z2("events"), this.client = z2("client"), this.chainId = this.getDefaultChain(), this.httpProviders = this.createHttpProviders();
        }
        updateNamespace(u7) {
          this.namespace = Object.assign(this.namespace, u7);
        }
        requestAccounts() {
          return this.getAccounts();
        }
        getDefaultChain() {
          if (this.chainId)
            return this.chainId;
          if (this.namespace.defaultChain)
            return this.namespace.defaultChain;
          const u7 = this.namespace.chains[0];
          if (!u7)
            throw new Error("ChainId not found");
          return u7.split(":")[1];
        }
        request(u7) {
          return this.namespace.methods.includes(u7.request.method) ? this.client.request(u7) : this.getHttpProvider().request(u7.request);
        }
        setDefaultChain(u7, i7) {
          if (this.chainId = u7, !this.httpProviders[u7]) {
            const d7 = i7 || ft3(`${this.name}:${u7}`, this.namespace);
            if (!d7)
              throw new Error(`No RPC url provided for chainId: ${u7}`);
            this.setHttpProvider(u7, d7);
          }
          this.events.emit(Vn2.DEFAULT_CHAIN_CHANGED, `${this.name}:${this.chainId}`);
        }
        getAccounts() {
          const u7 = this.namespace.accounts;
          return u7 ? u7.filter((i7) => i7.split(":")[1] === this.chainId.toString()).map((i7) => i7.split(":")[2]) || [] : [];
        }
        createHttpProviders() {
          const u7 = {};
          return this.namespace.chains.forEach((i7) => {
            var d7;
            u7[i7] = this.createHttpProvider(i7, (d7 = this.namespace.rpcMap) == null ? void 0 : d7[i7]);
          }), u7;
        }
        getHttpProvider() {
          const u7 = `${this.name}:${this.chainId}`, i7 = this.httpProviders[u7];
          if (typeof i7 > "u")
            throw new Error(`JSON-RPC provider for ${u7} not found`);
          return i7;
        }
        setHttpProvider(u7, i7) {
          const d7 = this.createHttpProvider(u7, i7);
          d7 && (this.httpProviders[u7] = d7);
        }
        createHttpProvider(u7, i7) {
          const d7 = i7 || ft3(u7, this.namespace);
          return typeof d7 > "u" ? void 0 : new JsonRpcProvider(new esm_default(d7, z2("disableProviderPing")));
        }
      };
      sv = Object.defineProperty;
      uv = Object.defineProperties;
      av = Object.getOwnPropertyDescriptors;
      ba = Object.getOwnPropertySymbols;
      ov = Object.prototype.hasOwnProperty;
      fv = Object.prototype.propertyIsEnumerable;
      Ta = (C6, u7, i7) => u7 in C6 ? sv(C6, u7, { enumerable: true, configurable: true, writable: true, value: i7 }) : C6[u7] = i7;
      hr2 = (C6, u7) => {
        for (var i7 in u7 || (u7 = {}))
          ov.call(u7, i7) && Ta(C6, i7, u7[i7]);
        if (ba)
          for (var i7 of ba(u7))
            fv.call(u7, i7) && Ta(C6, i7, u7[i7]);
        return C6;
      };
      Mi = (C6, u7) => uv(C6, av(u7));
      lr2 = class {
        constructor(u7) {
          this.events = new import_events8.default(), this.rpcProviders = {}, this.shouldAbortPairingAttempt = false, this.maxPairingAttempts = 10, this.disableProviderPing = false, this.providerOpts = u7, this.logger = typeof u7?.logger < "u" && typeof u7?.logger != "string" ? u7.logger : (0, import_logger3.pino)((0, import_logger3.getDefaultLoggerOptions)({ level: u7?.logger || Ia })), this.disableProviderPing = u7?.disableProviderPing || false;
        }
        static async init(u7) {
          const i7 = new lr2(u7);
          return await i7.initialize(), i7;
        }
        async request(u7, i7) {
          const [d7, w8] = this.validateChain(i7);
          if (!this.session)
            throw new Error("Please call connect() before request()");
          return await this.getProvider(d7).request({ request: hr2({}, u7), chainId: `${d7}:${w8}`, topic: this.session.topic });
        }
        sendAsync(u7, i7, d7) {
          this.request(u7, d7).then((w8) => i7(null, w8)).catch((w8) => i7(w8, void 0));
        }
        async enable() {
          if (!this.client)
            throw new Error("Sign Client not initialized");
          return this.session || await this.connect({ namespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties }), await this.requestAccounts();
        }
        async disconnect() {
          var u7;
          if (!this.session)
            throw new Error("Please call connect() before enable()");
          await this.client.disconnect({ topic: (u7 = this.session) == null ? void 0 : u7.topic, reason: U("USER_DISCONNECTED") }), await this.cleanup();
        }
        async connect(u7) {
          if (!this.client)
            throw new Error("Sign Client not initialized");
          if (this.setNamespaces(u7), await this.cleanupPendingPairings(), !u7.skipPairing)
            return await this.pair(u7.pairingTopic);
        }
        on(u7, i7) {
          this.events.on(u7, i7);
        }
        once(u7, i7) {
          this.events.once(u7, i7);
        }
        removeListener(u7, i7) {
          this.events.removeListener(u7, i7);
        }
        off(u7, i7) {
          this.events.off(u7, i7);
        }
        get isWalletConnect() {
          return true;
        }
        async pair(u7) {
          this.shouldAbortPairingAttempt = false;
          let i7 = 0;
          do {
            if (this.shouldAbortPairingAttempt)
              throw new Error("Pairing aborted");
            if (i7 >= this.maxPairingAttempts)
              throw new Error("Max auto pairing attempts reached");
            const { uri: d7, approval: w8 } = await this.client.connect({ pairingTopic: u7, requiredNamespaces: this.namespaces, optionalNamespaces: this.optionalNamespaces, sessionProperties: this.sessionProperties });
            d7 && (this.uri = d7, this.events.emit("display_uri", d7)), await w8().then((T6) => {
              this.session = T6, this.namespaces || (this.namespaces = Qg(T6.namespaces), this.persist("namespaces", this.namespaces));
            }).catch((T6) => {
              if (T6.message !== oe3)
                throw T6;
              i7++;
            });
          } while (!this.session);
          return this.onConnect(), this.session;
        }
        setDefaultChain(u7, i7) {
          try {
            if (!this.session)
              return;
            const [d7, w8] = this.validateChain(u7);
            this.getProvider(d7).setDefaultChain(w8, i7);
          } catch (d7) {
            if (!/Please call connect/.test(d7.message))
              throw d7;
          }
        }
        async cleanupPendingPairings(u7 = {}) {
          this.logger.info("Cleaning up inactive pairings...");
          const i7 = this.client.pairing.getAll();
          if (k(i7)) {
            for (const d7 of i7)
              u7.deletePairings ? this.client.core.expirer.set(d7.topic, 0) : await this.client.core.relayer.subscriber.unsubscribe(d7.topic);
            this.logger.info(`Inactive pairings cleared: ${i7.length}`);
          }
        }
        abortPairingAttempt() {
          this.shouldAbortPairingAttempt = true;
        }
        async checkStorage() {
          if (this.namespaces = await this.getFromStore("namespaces"), this.optionalNamespaces = await this.getFromStore("optionalNamespaces") || {}, this.client.session.length) {
            const u7 = this.client.session.keys.length - 1;
            this.session = this.client.session.get(this.client.session.keys[u7]), this.createProviders();
          }
        }
        async initialize() {
          this.logger.trace("Initialized"), await this.createClient(), await this.checkStorage(), this.registerEventListeners();
        }
        async createClient() {
          this.client = this.providerOpts.client || await Q3.init({ logger: this.providerOpts.logger || Ia, relayUrl: this.providerOpts.relayUrl || Ug, projectId: this.providerOpts.projectId, metadata: this.providerOpts.metadata, storageOptions: this.providerOpts.storageOptions, storage: this.providerOpts.storage, name: this.providerOpts.name }), this.logger.trace("SignClient Initialized");
        }
        createProviders() {
          if (!this.client)
            throw new Error("Sign Client not initialized");
          if (!this.session)
            throw new Error("Session not initialized. Please call connect() before enable()");
          const u7 = [...new Set(Object.keys(this.session.namespaces).map((i7) => Xe2(i7)))];
          Fi("client", this.client), Fi("events", this.events), Fi("disableProviderPing", this.disableProviderPing), u7.forEach((i7) => {
            if (!this.session)
              return;
            const d7 = Zg(i7, this.session), w8 = Sa(d7), T6 = Jg(this.namespaces, this.optionalNamespaces), $8 = Mi(hr2({}, T6[i7]), { accounts: d7, chains: w8 });
            switch (i7) {
              case "eip155":
                this.rpcProviders[i7] = new kg({ namespace: $8 });
                break;
              case "solana":
                this.rpcProviders[i7] = new jg({ namespace: $8 });
                break;
              case "cosmos":
                this.rpcProviders[i7] = new nv({ namespace: $8 });
                break;
              case "polkadot":
                this.rpcProviders[i7] = new Vg({ namespace: $8 });
                break;
              case "cip34":
                this.rpcProviders[i7] = new tv({ namespace: $8 });
                break;
              case "elrond":
                this.rpcProviders[i7] = new ev({ namespace: $8 });
                break;
              case "multiversx":
                this.rpcProviders[i7] = new rv({ namespace: $8 });
                break;
              case "near":
                this.rpcProviders[i7] = new iv({ namespace: $8 });
                break;
            }
          });
        }
        registerEventListeners() {
          if (typeof this.client > "u")
            throw new Error("Sign Client is not initialized");
          this.client.on("session_ping", (u7) => {
            this.events.emit("session_ping", u7);
          }), this.client.on("session_event", (u7) => {
            const { params: i7 } = u7, { event: d7 } = i7;
            if (d7.name === "accountsChanged") {
              const w8 = d7.data;
              w8 && k(w8) && this.events.emit("accountsChanged", w8.map(Xg));
            } else if (d7.name === "chainChanged") {
              const w8 = i7.chainId, T6 = i7.event.data, $8 = Xe2(w8), En2 = Wi2(w8) !== Wi2(T6) ? `${$8}:${Wi2(T6)}` : w8;
              this.onChainChanged(En2);
            } else
              this.events.emit(d7.name, d7.data);
            this.events.emit("session_event", u7);
          }), this.client.on("session_update", ({ topic: u7, params: i7 }) => {
            var d7;
            const { namespaces: w8 } = i7, T6 = (d7 = this.client) == null ? void 0 : d7.session.get(u7);
            this.session = Mi(hr2({}, T6), { namespaces: w8 }), this.onSessionUpdate(), this.events.emit("session_update", { topic: u7, params: i7 });
          }), this.client.on("session_delete", async (u7) => {
            await this.cleanup(), this.events.emit("session_delete", u7), this.events.emit("disconnect", Mi(hr2({}, U("USER_DISCONNECTED")), { data: u7.topic }));
          }), this.on(Vn2.DEFAULT_CHAIN_CHANGED, (u7) => {
            this.onChainChanged(u7, true);
          });
        }
        getProvider(u7) {
          if (!this.rpcProviders[u7])
            throw new Error(`Provider not found: ${u7}`);
          return this.rpcProviders[u7];
        }
        onSessionUpdate() {
          Object.keys(this.rpcProviders).forEach((u7) => {
            var i7;
            this.getProvider(u7).updateNamespace((i7 = this.session) == null ? void 0 : i7.namespaces[u7]);
          });
        }
        setNamespaces(u7) {
          const { namespaces: i7, optionalNamespaces: d7, sessionProperties: w8 } = u7;
          i7 && Object.keys(i7).length && (this.namespaces = i7), d7 && Object.keys(d7).length && (this.optionalNamespaces = d7), this.sessionProperties = w8, this.persist("namespaces", i7), this.persist("optionalNamespaces", d7);
        }
        validateChain(u7) {
          const [i7, d7] = u7?.split(":") || ["", ""];
          if (!this.namespaces || !Object.keys(this.namespaces).length)
            return [i7, d7];
          if (i7 && !Object.keys(this.namespaces || {}).map(($8) => Xe2($8)).includes(i7))
            throw new Error(`Namespace '${i7}' is not configured. Please call connect() first with namespace config.`);
          if (i7 && d7)
            return [i7, d7];
          const w8 = Xe2(Object.keys(this.namespaces)[0]), T6 = this.rpcProviders[w8].getDefaultChain();
          return [w8, T6];
        }
        async requestAccounts() {
          const [u7] = this.validateChain();
          return await this.getProvider(u7).requestAccounts();
        }
        onChainChanged(u7, i7 = false) {
          var d7;
          if (!this.namespaces)
            return;
          const [w8, T6] = this.validateChain(u7);
          i7 || this.getProvider(w8).setDefaultChain(T6), ((d7 = this.namespaces[w8]) != null ? d7 : this.namespaces[`${w8}:${T6}`]).defaultChain = T6, this.persist("namespaces", this.namespaces), this.events.emit("chainChanged", T6);
        }
        onConnect() {
          this.createProviders(), this.events.emit("connect", { session: this.session });
        }
        async cleanup() {
          this.session = void 0, this.namespaces = void 0, this.optionalNamespaces = void 0, this.sessionProperties = void 0, this.persist("namespaces", void 0), this.persist("optionalNamespaces", void 0), this.persist("sessionProperties", void 0), await this.cleanupPendingPairings({ deletePairings: true });
        }
        persist(u7, i7) {
          this.client.core.storage.setItem(`${xa}/${u7}`, i7);
        }
        async getFromStore(u7) {
          return await this.client.core.storage.getItem(`${xa}/${u7}`);
        }
      };
      cv = lr2;
    }
  });

  // node_modules/proxy-compare/dist/index.modern.js
  var e, t, s, c3, l2, y5, h5;
  var init_index_modern = __esm({
    "node_modules/proxy-compare/dist/index.modern.js"() {
      e = Symbol();
      t = Symbol();
      s = Object.getPrototypeOf;
      c3 = /* @__PURE__ */ new WeakMap();
      l2 = (e9) => e9 && (c3.has(e9) ? c3.get(e9) : s(e9) === Object.prototype || s(e9) === Array.prototype);
      y5 = (e9) => l2(e9) && e9[t] || null;
      h5 = (e9, t6 = true) => {
        c3.set(e9, t6);
      };
    }
  });

  // node_modules/@walletconnect/modal-core/node_modules/valtio/esm/vanilla.mjs
  function proxy(initialObject = {}) {
    return defaultProxyFunction(initialObject);
  }
  function subscribe(proxyObject, callback, notifyInSync) {
    const proxyState = proxyStateMap.get(proxyObject);
    if ((import_meta3.env ? import_meta3.env.MODE : void 0) !== "production" && !proxyState) {
      console.warn("Please use proxy object");
    }
    let promise;
    const ops = [];
    const addListener = proxyState[3];
    let isListenerActive = false;
    const listener = (op) => {
      ops.push(op);
      if (notifyInSync) {
        callback(ops.splice(0));
        return;
      }
      if (!promise) {
        promise = Promise.resolve().then(() => {
          promise = void 0;
          if (isListenerActive) {
            callback(ops.splice(0));
          }
        });
      }
    };
    const removeListener = addListener(listener);
    isListenerActive = true;
    return () => {
      isListenerActive = false;
      removeListener();
    };
  }
  function snapshot2(proxyObject, handlePromise) {
    const proxyState = proxyStateMap.get(proxyObject);
    if ((import_meta3.env ? import_meta3.env.MODE : void 0) !== "production" && !proxyState) {
      console.warn("Please use proxy object");
    }
    const [target, ensureVersion, createSnapshot] = proxyState;
    return createSnapshot(target, ensureVersion(), handlePromise);
  }
  var import_meta3, isObject, proxyStateMap, refSet, buildProxyFunction, defaultProxyFunction;
  var init_vanilla = __esm({
    "node_modules/@walletconnect/modal-core/node_modules/valtio/esm/vanilla.mjs"() {
      init_index_modern();
      import_meta3 = {};
      isObject = (x4) => typeof x4 === "object" && x4 !== null;
      proxyStateMap = /* @__PURE__ */ new WeakMap();
      refSet = /* @__PURE__ */ new WeakSet();
      buildProxyFunction = (objectIs = Object.is, newProxy = (target, handler) => new Proxy(target, handler), canProxy = (x4) => isObject(x4) && !refSet.has(x4) && (Array.isArray(x4) || !(Symbol.iterator in x4)) && !(x4 instanceof WeakMap) && !(x4 instanceof WeakSet) && !(x4 instanceof Error) && !(x4 instanceof Number) && !(x4 instanceof Date) && !(x4 instanceof String) && !(x4 instanceof RegExp) && !(x4 instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
        switch (promise.status) {
          case "fulfilled":
            return promise.value;
          case "rejected":
            throw promise.reason;
          default:
            throw promise;
        }
      }, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version30, handlePromise = defaultHandlePromise) => {
        const cache = snapCache.get(target);
        if ((cache == null ? void 0 : cache[0]) === version30) {
          return cache[1];
        }
        const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
        h5(snap, true);
        snapCache.set(target, [version30, snap]);
        Reflect.ownKeys(target).forEach((key2) => {
          if (Object.getOwnPropertyDescriptor(snap, key2)) {
            return;
          }
          const value = Reflect.get(target, key2);
          const desc = {
            value,
            enumerable: true,
            // This is intentional to avoid copying with proxy-compare.
            // It's still non-writable, so it avoids assigning a value.
            configurable: true
          };
          if (refSet.has(value)) {
            h5(value, false);
          } else if (value instanceof Promise) {
            delete desc.value;
            desc.get = () => handlePromise(value);
          } else if (proxyStateMap.has(value)) {
            const [target2, ensureVersion] = proxyStateMap.get(
              value
            );
            desc.value = createSnapshot(
              target2,
              ensureVersion(),
              handlePromise
            );
          }
          Object.defineProperty(snap, key2, desc);
        });
        return Object.preventExtensions(snap);
      }, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction = (initialObject) => {
        if (!isObject(initialObject)) {
          throw new Error("object required");
        }
        const found = proxyCache.get(initialObject);
        if (found) {
          return found;
        }
        let version30 = versionHolder[0];
        const listeners = /* @__PURE__ */ new Set();
        const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
          if (version30 !== nextVersion) {
            version30 = nextVersion;
            listeners.forEach((listener) => listener(op, nextVersion));
          }
        };
        let checkVersion = versionHolder[1];
        const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
          if (checkVersion !== nextCheckVersion && !listeners.size) {
            checkVersion = nextCheckVersion;
            propProxyStates.forEach(([propProxyState]) => {
              const propVersion = propProxyState[1](nextCheckVersion);
              if (propVersion > version30) {
                version30 = propVersion;
              }
            });
          }
          return version30;
        };
        const createPropListener = (prop) => (op, nextVersion) => {
          const newOp = [...op];
          newOp[1] = [prop, ...newOp[1]];
          notifyUpdate(newOp, nextVersion);
        };
        const propProxyStates = /* @__PURE__ */ new Map();
        const addPropListener = (prop, propProxyState) => {
          if ((import_meta3.env ? import_meta3.env.MODE : void 0) !== "production" && propProxyStates.has(prop)) {
            throw new Error("prop listener already exists");
          }
          if (listeners.size) {
            const remove = propProxyState[3](createPropListener(prop));
            propProxyStates.set(prop, [propProxyState, remove]);
          } else {
            propProxyStates.set(prop, [propProxyState]);
          }
        };
        const removePropListener = (prop) => {
          var _a2;
          const entry = propProxyStates.get(prop);
          if (entry) {
            propProxyStates.delete(prop);
            (_a2 = entry[1]) == null ? void 0 : _a2.call(entry);
          }
        };
        const addListener = (listener) => {
          listeners.add(listener);
          if (listeners.size === 1) {
            propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
              if ((import_meta3.env ? import_meta3.env.MODE : void 0) !== "production" && prevRemove) {
                throw new Error("remove already exists");
              }
              const remove = propProxyState[3](createPropListener(prop));
              propProxyStates.set(prop, [propProxyState, remove]);
            });
          }
          const removeListener = () => {
            listeners.delete(listener);
            if (listeners.size === 0) {
              propProxyStates.forEach(([propProxyState, remove], prop) => {
                if (remove) {
                  remove();
                  propProxyStates.set(prop, [propProxyState]);
                }
              });
            }
          };
          return removeListener;
        };
        const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
        const handler = {
          deleteProperty(target, prop) {
            const prevValue = Reflect.get(target, prop);
            removePropListener(prop);
            const deleted = Reflect.deleteProperty(target, prop);
            if (deleted) {
              notifyUpdate(["delete", [prop], prevValue]);
            }
            return deleted;
          },
          set(target, prop, value, receiver) {
            const hasPrevValue = Reflect.has(target, prop);
            const prevValue = Reflect.get(target, prop, receiver);
            if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
              return true;
            }
            removePropListener(prop);
            if (isObject(value)) {
              value = y5(value) || value;
            }
            let nextValue = value;
            if (value instanceof Promise) {
              value.then((v6) => {
                value.status = "fulfilled";
                value.value = v6;
                notifyUpdate(["resolve", [prop], v6]);
              }).catch((e9) => {
                value.status = "rejected";
                value.reason = e9;
                notifyUpdate(["reject", [prop], e9]);
              });
            } else {
              if (!proxyStateMap.has(value) && canProxy(value)) {
                nextValue = proxyFunction(value);
              }
              const childProxyState = !refSet.has(nextValue) && proxyStateMap.get(nextValue);
              if (childProxyState) {
                addPropListener(prop, childProxyState);
              }
            }
            Reflect.set(target, prop, nextValue, receiver);
            notifyUpdate(["set", [prop], value, prevValue]);
            return true;
          }
        };
        const proxyObject = newProxy(baseObject, handler);
        proxyCache.set(initialObject, proxyObject);
        const proxyState = [
          baseObject,
          ensureVersion,
          createSnapshot,
          addListener
        ];
        proxyStateMap.set(proxyObject, proxyState);
        Reflect.ownKeys(initialObject).forEach((key2) => {
          const desc = Object.getOwnPropertyDescriptor(
            initialObject,
            key2
          );
          if ("value" in desc) {
            proxyObject[key2] = initialObject[key2];
            delete desc.value;
            delete desc.writable;
          }
          Object.defineProperty(baseObject, key2, desc);
        });
        return proxyObject;
      }) => [
        // public functions
        proxyFunction,
        // shared state
        proxyStateMap,
        refSet,
        // internal things
        objectIs,
        newProxy,
        canProxy,
        defaultHandlePromise,
        snapCache,
        createSnapshot,
        proxyCache,
        versionHolder
      ];
      [defaultProxyFunction] = buildProxyFunction();
    }
  });

  // node_modules/@walletconnect/modal-core/dist/index.js
  async function w4(e9, t6) {
    const s7 = K3({ sdkType: E4, sdkVersion: O5 }, t6), n9 = new URL(e9, L3);
    return n9.searchParams.append("projectId", y6.state.projectId), Object.entries(s7).forEach(([i7, l9]) => {
      l9 && n9.searchParams.append(i7, String(l9));
    }), (await fetch(n9)).json();
  }
  function Z3() {
    return typeof matchMedia < "u" && matchMedia("(prefers-color-scheme: dark)").matches;
  }
  var o, T2, a3, _3, r2, R2, c4, p3, W5, y6, V5, D4, H3, B4, M3, K3, L3, E4, O5, m2, z3, j2, J2, q2, k3, F4, N12, d2, te4, I2, se2, G4, $3, Q4, X4, S5, Y, C2, ne2, g4, oe4;
  var init_dist5 = __esm({
    "node_modules/@walletconnect/modal-core/dist/index.js"() {
      init_vanilla();
      o = proxy({ history: ["ConnectWallet"], view: "ConnectWallet", data: void 0 });
      T2 = { state: o, subscribe(e9) {
        return subscribe(o, () => e9(o));
      }, push(e9, t6) {
        e9 !== o.view && (o.view = e9, t6 && (o.data = t6), o.history.push(e9));
      }, reset(e9) {
        o.view = e9, o.history = [e9];
      }, replace(e9) {
        o.history.length > 1 && (o.history[o.history.length - 1] = e9, o.view = e9);
      }, goBack() {
        if (o.history.length > 1) {
          o.history.pop();
          const [e9] = o.history.slice(-1);
          o.view = e9;
        }
      }, setData(e9) {
        o.data = e9;
      } };
      a3 = { WALLETCONNECT_DEEPLINK_CHOICE: "WALLETCONNECT_DEEPLINK_CHOICE", WCM_VERSION: "WCM_VERSION", RECOMMENDED_WALLET_AMOUNT: 9, isMobile() {
        return typeof window < "u" ? Boolean(window.matchMedia("(pointer:coarse)").matches || /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(navigator.userAgent)) : false;
      }, isAndroid() {
        return a3.isMobile() && navigator.userAgent.toLowerCase().includes("android");
      }, isIos() {
        const e9 = navigator.userAgent.toLowerCase();
        return a3.isMobile() && (e9.includes("iphone") || e9.includes("ipad"));
      }, isHttpUrl(e9) {
        return e9.startsWith("http://") || e9.startsWith("https://");
      }, isArray(e9) {
        return Array.isArray(e9) && e9.length > 0;
      }, formatNativeUrl(e9, t6, s7) {
        if (a3.isHttpUrl(e9))
          return this.formatUniversalUrl(e9, t6, s7);
        let n9 = e9;
        n9.includes("://") || (n9 = e9.replaceAll("/", "").replaceAll(":", ""), n9 = `${n9}://`), n9.endsWith("/") || (n9 = `${n9}/`), this.setWalletConnectDeepLink(n9, s7);
        const i7 = encodeURIComponent(t6);
        return `${n9}wc?uri=${i7}`;
      }, formatUniversalUrl(e9, t6, s7) {
        if (!a3.isHttpUrl(e9))
          return this.formatNativeUrl(e9, t6, s7);
        let n9 = e9;
        n9.endsWith("/") || (n9 = `${n9}/`), this.setWalletConnectDeepLink(n9, s7);
        const i7 = encodeURIComponent(t6);
        return `${n9}wc?uri=${i7}`;
      }, async wait(e9) {
        return new Promise((t6) => {
          setTimeout(t6, e9);
        });
      }, openHref(e9, t6) {
        window.open(e9, t6, "noreferrer noopener");
      }, setWalletConnectDeepLink(e9, t6) {
        try {
          localStorage.setItem(a3.WALLETCONNECT_DEEPLINK_CHOICE, JSON.stringify({ href: e9, name: t6 }));
        } catch {
          console.info("Unable to set WalletConnect deep link");
        }
      }, setWalletConnectAndroidDeepLink(e9) {
        try {
          const [t6] = e9.split("?");
          localStorage.setItem(a3.WALLETCONNECT_DEEPLINK_CHOICE, JSON.stringify({ href: t6, name: "Android" }));
        } catch {
          console.info("Unable to set WalletConnect android deep link");
        }
      }, removeWalletConnectDeepLink() {
        try {
          localStorage.removeItem(a3.WALLETCONNECT_DEEPLINK_CHOICE);
        } catch {
          console.info("Unable to remove WalletConnect deep link");
        }
      }, setModalVersionInStorage() {
        try {
          typeof localStorage < "u" && localStorage.setItem(a3.WCM_VERSION, "2.6.2");
        } catch {
          console.info("Unable to set Web3Modal version in storage");
        }
      }, getWalletRouterData() {
        var e9;
        const t6 = (e9 = T2.state.data) == null ? void 0 : e9.Wallet;
        if (!t6)
          throw new Error('Missing "Wallet" view data');
        return t6;
      } };
      _3 = typeof location < "u" && (location.hostname.includes("localhost") || location.protocol.includes("https"));
      r2 = proxy({ enabled: _3, userSessionId: "", events: [], connectedWalletId: void 0 });
      R2 = { state: r2, subscribe(e9) {
        return subscribe(r2.events, () => e9(snapshot2(r2.events[r2.events.length - 1])));
      }, initialize() {
        r2.enabled && typeof (crypto == null ? void 0 : crypto.randomUUID) < "u" && (r2.userSessionId = crypto.randomUUID());
      }, setConnectedWalletId(e9) {
        r2.connectedWalletId = e9;
      }, click(e9) {
        if (r2.enabled) {
          const t6 = { type: "CLICK", name: e9.name, userSessionId: r2.userSessionId, timestamp: Date.now(), data: e9 };
          r2.events.push(t6);
        }
      }, track(e9) {
        if (r2.enabled) {
          const t6 = { type: "TRACK", name: e9.name, userSessionId: r2.userSessionId, timestamp: Date.now(), data: e9 };
          r2.events.push(t6);
        }
      }, view(e9) {
        if (r2.enabled) {
          const t6 = { type: "VIEW", name: e9.name, userSessionId: r2.userSessionId, timestamp: Date.now(), data: e9 };
          r2.events.push(t6);
        }
      } };
      c4 = proxy({ chains: void 0, walletConnectUri: void 0, isAuth: false, isCustomDesktop: false, isCustomMobile: false, isDataLoaded: false, isUiLoaded: false });
      p3 = { state: c4, subscribe(e9) {
        return subscribe(c4, () => e9(c4));
      }, setChains(e9) {
        c4.chains = e9;
      }, setWalletConnectUri(e9) {
        c4.walletConnectUri = e9;
      }, setIsCustomDesktop(e9) {
        c4.isCustomDesktop = e9;
      }, setIsCustomMobile(e9) {
        c4.isCustomMobile = e9;
      }, setIsDataLoaded(e9) {
        c4.isDataLoaded = e9;
      }, setIsUiLoaded(e9) {
        c4.isUiLoaded = e9;
      }, setIsAuth(e9) {
        c4.isAuth = e9;
      } };
      W5 = proxy({ projectId: "", mobileWallets: void 0, desktopWallets: void 0, walletImages: void 0, chains: void 0, enableAuthMode: false, enableExplorer: true, explorerExcludedWalletIds: void 0, explorerRecommendedWalletIds: void 0, termsOfServiceUrl: void 0, privacyPolicyUrl: void 0 });
      y6 = { state: W5, subscribe(e9) {
        return subscribe(W5, () => e9(W5));
      }, setConfig(e9) {
        var t6, s7;
        R2.initialize(), p3.setChains(e9.chains), p3.setIsAuth(Boolean(e9.enableAuthMode)), p3.setIsCustomMobile(Boolean((t6 = e9.mobileWallets) == null ? void 0 : t6.length)), p3.setIsCustomDesktop(Boolean((s7 = e9.desktopWallets) == null ? void 0 : s7.length)), a3.setModalVersionInStorage(), Object.assign(W5, e9);
      } };
      V5 = Object.defineProperty;
      D4 = Object.getOwnPropertySymbols;
      H3 = Object.prototype.hasOwnProperty;
      B4 = Object.prototype.propertyIsEnumerable;
      M3 = (e9, t6, s7) => t6 in e9 ? V5(e9, t6, { enumerable: true, configurable: true, writable: true, value: s7 }) : e9[t6] = s7;
      K3 = (e9, t6) => {
        for (var s7 in t6 || (t6 = {}))
          H3.call(t6, s7) && M3(e9, s7, t6[s7]);
        if (D4)
          for (var s7 of D4(t6))
            B4.call(t6, s7) && M3(e9, s7, t6[s7]);
        return e9;
      };
      L3 = "https://explorer-api.walletconnect.com";
      E4 = "wcm";
      O5 = "js-2.6.2";
      m2 = { async getDesktopListings(e9) {
        return w4("/w3m/v1/getDesktopListings", e9);
      }, async getMobileListings(e9) {
        return w4("/w3m/v1/getMobileListings", e9);
      }, async getInjectedListings(e9) {
        return w4("/w3m/v1/getInjectedListings", e9);
      }, async getAllListings(e9) {
        return w4("/w3m/v1/getAllListings", e9);
      }, getWalletImageUrl(e9) {
        return `${L3}/w3m/v1/getWalletImage/${e9}?projectId=${y6.state.projectId}&sdkType=${E4}&sdkVersion=${O5}`;
      }, getAssetImageUrl(e9) {
        return `${L3}/w3m/v1/getAssetImage/${e9}?projectId=${y6.state.projectId}&sdkType=${E4}&sdkVersion=${O5}`;
      } };
      z3 = Object.defineProperty;
      j2 = Object.getOwnPropertySymbols;
      J2 = Object.prototype.hasOwnProperty;
      q2 = Object.prototype.propertyIsEnumerable;
      k3 = (e9, t6, s7) => t6 in e9 ? z3(e9, t6, { enumerable: true, configurable: true, writable: true, value: s7 }) : e9[t6] = s7;
      F4 = (e9, t6) => {
        for (var s7 in t6 || (t6 = {}))
          J2.call(t6, s7) && k3(e9, s7, t6[s7]);
        if (j2)
          for (var s7 of j2(t6))
            q2.call(t6, s7) && k3(e9, s7, t6[s7]);
        return e9;
      };
      N12 = a3.isMobile();
      d2 = proxy({ wallets: { listings: [], total: 0, page: 1 }, search: { listings: [], total: 0, page: 1 }, recomendedWallets: [] });
      te4 = { state: d2, async getRecomendedWallets() {
        const { explorerRecommendedWalletIds: e9, explorerExcludedWalletIds: t6 } = y6.state;
        if (e9 === "NONE" || t6 === "ALL" && !e9)
          return d2.recomendedWallets;
        if (a3.isArray(e9)) {
          const s7 = { recommendedIds: e9.join(",") }, { listings: n9 } = await m2.getAllListings(s7), i7 = Object.values(n9);
          i7.sort((l9, v6) => {
            const b7 = e9.indexOf(l9.id), f7 = e9.indexOf(v6.id);
            return b7 - f7;
          }), d2.recomendedWallets = i7;
        } else {
          const { chains: s7, isAuth: n9 } = p3.state, i7 = s7?.join(","), l9 = a3.isArray(t6), v6 = { page: 1, sdks: n9 ? "auth_v1" : void 0, entries: a3.RECOMMENDED_WALLET_AMOUNT, chains: i7, version: 2, excludedIds: l9 ? t6.join(",") : void 0 }, { listings: b7 } = N12 ? await m2.getMobileListings(v6) : await m2.getDesktopListings(v6);
          d2.recomendedWallets = Object.values(b7);
        }
        return d2.recomendedWallets;
      }, async getWallets(e9) {
        const t6 = F4({}, e9), { explorerRecommendedWalletIds: s7, explorerExcludedWalletIds: n9 } = y6.state, { recomendedWallets: i7 } = d2;
        if (n9 === "ALL")
          return d2.wallets;
        i7.length ? t6.excludedIds = i7.map((x4) => x4.id).join(",") : a3.isArray(s7) && (t6.excludedIds = s7.join(",")), a3.isArray(n9) && (t6.excludedIds = [t6.excludedIds, n9].filter(Boolean).join(",")), p3.state.isAuth && (t6.sdks = "auth_v1");
        const { page: l9, search: v6 } = e9, { listings: b7, total: f7 } = N12 ? await m2.getMobileListings(t6) : await m2.getDesktopListings(t6), A7 = Object.values(b7), U9 = v6 ? "search" : "wallets";
        return d2[U9] = { listings: [...d2[U9].listings, ...A7], total: f7, page: l9 ?? 1 }, { listings: A7, total: f7 };
      }, getWalletImageUrl(e9) {
        return m2.getWalletImageUrl(e9);
      }, getAssetImageUrl(e9) {
        return m2.getAssetImageUrl(e9);
      }, resetSearch() {
        d2.search = { listings: [], total: 0, page: 1 };
      } };
      I2 = proxy({ open: false });
      se2 = { state: I2, subscribe(e9) {
        return subscribe(I2, () => e9(I2));
      }, async open(e9) {
        return new Promise((t6) => {
          const { isUiLoaded: s7, isDataLoaded: n9 } = p3.state;
          if (a3.removeWalletConnectDeepLink(), p3.setWalletConnectUri(e9?.uri), p3.setChains(e9?.chains), T2.reset("ConnectWallet"), s7 && n9)
            I2.open = true, t6();
          else {
            const i7 = setInterval(() => {
              const l9 = p3.state;
              l9.isUiLoaded && l9.isDataLoaded && (clearInterval(i7), I2.open = true, t6());
            }, 200);
          }
        });
      }, close() {
        I2.open = false;
      } };
      G4 = Object.defineProperty;
      $3 = Object.getOwnPropertySymbols;
      Q4 = Object.prototype.hasOwnProperty;
      X4 = Object.prototype.propertyIsEnumerable;
      S5 = (e9, t6, s7) => t6 in e9 ? G4(e9, t6, { enumerable: true, configurable: true, writable: true, value: s7 }) : e9[t6] = s7;
      Y = (e9, t6) => {
        for (var s7 in t6 || (t6 = {}))
          Q4.call(t6, s7) && S5(e9, s7, t6[s7]);
        if ($3)
          for (var s7 of $3(t6))
            X4.call(t6, s7) && S5(e9, s7, t6[s7]);
        return e9;
      };
      C2 = proxy({ themeMode: Z3() ? "dark" : "light" });
      ne2 = { state: C2, subscribe(e9) {
        return subscribe(C2, () => e9(C2));
      }, setThemeConfig(e9) {
        const { themeMode: t6, themeVariables: s7 } = e9;
        t6 && (C2.themeMode = t6), s7 && (C2.themeVariables = Y({}, s7));
      } };
      g4 = proxy({ open: false, message: "", variant: "success" });
      oe4 = { state: g4, subscribe(e9) {
        return subscribe(g4, () => e9(g4));
      }, openToast(e9, t6) {
        g4.open = true, g4.message = e9, g4.variant = t6;
      }, closeToast() {
        g4.open = false;
      } };
    }
  });

  // node_modules/@lit/reactive-element/css-tag.js
  var t2, e2, s2, n2, o2, r3, i2, S6, c5;
  var init_css_tag = __esm({
    "node_modules/@lit/reactive-element/css-tag.js"() {
      t2 = window;
      e2 = t2.ShadowRoot && (void 0 === t2.ShadyCSS || t2.ShadyCSS.nativeShadow) && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
      s2 = Symbol();
      n2 = /* @__PURE__ */ new WeakMap();
      o2 = class {
        constructor(t6, e9, n9) {
          if (this._$cssResult$ = true, n9 !== s2)
            throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
          this.cssText = t6, this.t = e9;
        }
        get styleSheet() {
          let t6 = this.o;
          const s7 = this.t;
          if (e2 && void 0 === t6) {
            const e9 = void 0 !== s7 && 1 === s7.length;
            e9 && (t6 = n2.get(s7)), void 0 === t6 && ((this.o = t6 = new CSSStyleSheet()).replaceSync(this.cssText), e9 && n2.set(s7, t6));
          }
          return t6;
        }
        toString() {
          return this.cssText;
        }
      };
      r3 = (t6) => new o2("string" == typeof t6 ? t6 : t6 + "", void 0, s2);
      i2 = (t6, ...e9) => {
        const n9 = 1 === t6.length ? t6[0] : e9.reduce((e10, s7, n10) => e10 + ((t7) => {
          if (true === t7._$cssResult$)
            return t7.cssText;
          if ("number" == typeof t7)
            return t7;
          throw Error("Value passed to 'css' function must be a 'css' function result: " + t7 + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.");
        })(s7) + t6[n10 + 1], t6[0]);
        return new o2(n9, t6, s2);
      };
      S6 = (s7, n9) => {
        e2 ? s7.adoptedStyleSheets = n9.map((t6) => t6 instanceof CSSStyleSheet ? t6 : t6.styleSheet) : n9.forEach((e9) => {
          const n10 = document.createElement("style"), o9 = t2.litNonce;
          void 0 !== o9 && n10.setAttribute("nonce", o9), n10.textContent = e9.cssText, s7.appendChild(n10);
        });
      };
      c5 = e2 ? (t6) => t6 : (t6) => t6 instanceof CSSStyleSheet ? ((t7) => {
        let e9 = "";
        for (const s7 of t7.cssRules)
          e9 += s7.cssText;
        return r3(e9);
      })(t6) : t6;
    }
  });

  // node_modules/@lit/reactive-element/reactive-element.js
  var s3, e3, r4, h6, o3, n3, a4, l3, d3, u3;
  var init_reactive_element = __esm({
    "node_modules/@lit/reactive-element/reactive-element.js"() {
      init_css_tag();
      init_css_tag();
      e3 = window;
      r4 = e3.trustedTypes;
      h6 = r4 ? r4.emptyScript : "";
      o3 = e3.reactiveElementPolyfillSupport;
      n3 = { toAttribute(t6, i7) {
        switch (i7) {
          case Boolean:
            t6 = t6 ? h6 : null;
            break;
          case Object:
          case Array:
            t6 = null == t6 ? t6 : JSON.stringify(t6);
        }
        return t6;
      }, fromAttribute(t6, i7) {
        let s7 = t6;
        switch (i7) {
          case Boolean:
            s7 = null !== t6;
            break;
          case Number:
            s7 = null === t6 ? null : Number(t6);
            break;
          case Object:
          case Array:
            try {
              s7 = JSON.parse(t6);
            } catch (t7) {
              s7 = null;
            }
        }
        return s7;
      } };
      a4 = (t6, i7) => i7 !== t6 && (i7 == i7 || t6 == t6);
      l3 = { attribute: true, type: String, converter: n3, reflect: false, hasChanged: a4 };
      d3 = "finalized";
      u3 = class extends HTMLElement {
        constructor() {
          super(), this._$Ei = /* @__PURE__ */ new Map(), this.isUpdatePending = false, this.hasUpdated = false, this._$El = null, this._$Eu();
        }
        static addInitializer(t6) {
          var i7;
          this.finalize(), (null !== (i7 = this.h) && void 0 !== i7 ? i7 : this.h = []).push(t6);
        }
        static get observedAttributes() {
          this.finalize();
          const t6 = [];
          return this.elementProperties.forEach((i7, s7) => {
            const e9 = this._$Ep(s7, i7);
            void 0 !== e9 && (this._$Ev.set(e9, s7), t6.push(e9));
          }), t6;
        }
        static createProperty(t6, i7 = l3) {
          if (i7.state && (i7.attribute = false), this.finalize(), this.elementProperties.set(t6, i7), !i7.noAccessor && !this.prototype.hasOwnProperty(t6)) {
            const s7 = "symbol" == typeof t6 ? Symbol() : "__" + t6, e9 = this.getPropertyDescriptor(t6, s7, i7);
            void 0 !== e9 && Object.defineProperty(this.prototype, t6, e9);
          }
        }
        static getPropertyDescriptor(t6, i7, s7) {
          return { get() {
            return this[i7];
          }, set(e9) {
            const r8 = this[t6];
            this[i7] = e9, this.requestUpdate(t6, r8, s7);
          }, configurable: true, enumerable: true };
        }
        static getPropertyOptions(t6) {
          return this.elementProperties.get(t6) || l3;
        }
        static finalize() {
          if (this.hasOwnProperty(d3))
            return false;
          this[d3] = true;
          const t6 = Object.getPrototypeOf(this);
          if (t6.finalize(), void 0 !== t6.h && (this.h = [...t6.h]), this.elementProperties = new Map(t6.elementProperties), this._$Ev = /* @__PURE__ */ new Map(), this.hasOwnProperty("properties")) {
            const t7 = this.properties, i7 = [...Object.getOwnPropertyNames(t7), ...Object.getOwnPropertySymbols(t7)];
            for (const s7 of i7)
              this.createProperty(s7, t7[s7]);
          }
          return this.elementStyles = this.finalizeStyles(this.styles), true;
        }
        static finalizeStyles(i7) {
          const s7 = [];
          if (Array.isArray(i7)) {
            const e9 = new Set(i7.flat(1 / 0).reverse());
            for (const i8 of e9)
              s7.unshift(c5(i8));
          } else
            void 0 !== i7 && s7.push(c5(i7));
          return s7;
        }
        static _$Ep(t6, i7) {
          const s7 = i7.attribute;
          return false === s7 ? void 0 : "string" == typeof s7 ? s7 : "string" == typeof t6 ? t6.toLowerCase() : void 0;
        }
        _$Eu() {
          var t6;
          this._$E_ = new Promise((t7) => this.enableUpdating = t7), this._$AL = /* @__PURE__ */ new Map(), this._$Eg(), this.requestUpdate(), null === (t6 = this.constructor.h) || void 0 === t6 || t6.forEach((t7) => t7(this));
        }
        addController(t6) {
          var i7, s7;
          (null !== (i7 = this._$ES) && void 0 !== i7 ? i7 : this._$ES = []).push(t6), void 0 !== this.renderRoot && this.isConnected && (null === (s7 = t6.hostConnected) || void 0 === s7 || s7.call(t6));
        }
        removeController(t6) {
          var i7;
          null === (i7 = this._$ES) || void 0 === i7 || i7.splice(this._$ES.indexOf(t6) >>> 0, 1);
        }
        _$Eg() {
          this.constructor.elementProperties.forEach((t6, i7) => {
            this.hasOwnProperty(i7) && (this._$Ei.set(i7, this[i7]), delete this[i7]);
          });
        }
        createRenderRoot() {
          var t6;
          const s7 = null !== (t6 = this.shadowRoot) && void 0 !== t6 ? t6 : this.attachShadow(this.constructor.shadowRootOptions);
          return S6(s7, this.constructor.elementStyles), s7;
        }
        connectedCallback() {
          var t6;
          void 0 === this.renderRoot && (this.renderRoot = this.createRenderRoot()), this.enableUpdating(true), null === (t6 = this._$ES) || void 0 === t6 || t6.forEach((t7) => {
            var i7;
            return null === (i7 = t7.hostConnected) || void 0 === i7 ? void 0 : i7.call(t7);
          });
        }
        enableUpdating(t6) {
        }
        disconnectedCallback() {
          var t6;
          null === (t6 = this._$ES) || void 0 === t6 || t6.forEach((t7) => {
            var i7;
            return null === (i7 = t7.hostDisconnected) || void 0 === i7 ? void 0 : i7.call(t7);
          });
        }
        attributeChangedCallback(t6, i7, s7) {
          this._$AK(t6, s7);
        }
        _$EO(t6, i7, s7 = l3) {
          var e9;
          const r8 = this.constructor._$Ep(t6, s7);
          if (void 0 !== r8 && true === s7.reflect) {
            const h10 = (void 0 !== (null === (e9 = s7.converter) || void 0 === e9 ? void 0 : e9.toAttribute) ? s7.converter : n3).toAttribute(i7, s7.type);
            this._$El = t6, null == h10 ? this.removeAttribute(r8) : this.setAttribute(r8, h10), this._$El = null;
          }
        }
        _$AK(t6, i7) {
          var s7;
          const e9 = this.constructor, r8 = e9._$Ev.get(t6);
          if (void 0 !== r8 && this._$El !== r8) {
            const t7 = e9.getPropertyOptions(r8), h10 = "function" == typeof t7.converter ? { fromAttribute: t7.converter } : void 0 !== (null === (s7 = t7.converter) || void 0 === s7 ? void 0 : s7.fromAttribute) ? t7.converter : n3;
            this._$El = r8, this[r8] = h10.fromAttribute(i7, t7.type), this._$El = null;
          }
        }
        requestUpdate(t6, i7, s7) {
          let e9 = true;
          void 0 !== t6 && (((s7 = s7 || this.constructor.getPropertyOptions(t6)).hasChanged || a4)(this[t6], i7) ? (this._$AL.has(t6) || this._$AL.set(t6, i7), true === s7.reflect && this._$El !== t6 && (void 0 === this._$EC && (this._$EC = /* @__PURE__ */ new Map()), this._$EC.set(t6, s7))) : e9 = false), !this.isUpdatePending && e9 && (this._$E_ = this._$Ej());
        }
        async _$Ej() {
          this.isUpdatePending = true;
          try {
            await this._$E_;
          } catch (t7) {
            Promise.reject(t7);
          }
          const t6 = this.scheduleUpdate();
          return null != t6 && await t6, !this.isUpdatePending;
        }
        scheduleUpdate() {
          return this.performUpdate();
        }
        performUpdate() {
          var t6;
          if (!this.isUpdatePending)
            return;
          this.hasUpdated, this._$Ei && (this._$Ei.forEach((t7, i8) => this[i8] = t7), this._$Ei = void 0);
          let i7 = false;
          const s7 = this._$AL;
          try {
            i7 = this.shouldUpdate(s7), i7 ? (this.willUpdate(s7), null === (t6 = this._$ES) || void 0 === t6 || t6.forEach((t7) => {
              var i8;
              return null === (i8 = t7.hostUpdate) || void 0 === i8 ? void 0 : i8.call(t7);
            }), this.update(s7)) : this._$Ek();
          } catch (t7) {
            throw i7 = false, this._$Ek(), t7;
          }
          i7 && this._$AE(s7);
        }
        willUpdate(t6) {
        }
        _$AE(t6) {
          var i7;
          null === (i7 = this._$ES) || void 0 === i7 || i7.forEach((t7) => {
            var i8;
            return null === (i8 = t7.hostUpdated) || void 0 === i8 ? void 0 : i8.call(t7);
          }), this.hasUpdated || (this.hasUpdated = true, this.firstUpdated(t6)), this.updated(t6);
        }
        _$Ek() {
          this._$AL = /* @__PURE__ */ new Map(), this.isUpdatePending = false;
        }
        get updateComplete() {
          return this.getUpdateComplete();
        }
        getUpdateComplete() {
          return this._$E_;
        }
        shouldUpdate(t6) {
          return true;
        }
        update(t6) {
          void 0 !== this._$EC && (this._$EC.forEach((t7, i7) => this._$EO(i7, this[i7], t7)), this._$EC = void 0), this._$Ek();
        }
        updated(t6) {
        }
        firstUpdated(t6) {
        }
      };
      u3[d3] = true, u3.elementProperties = /* @__PURE__ */ new Map(), u3.elementStyles = [], u3.shadowRootOptions = { mode: "open" }, null == o3 || o3({ ReactiveElement: u3 }), (null !== (s3 = e3.reactiveElementVersions) && void 0 !== s3 ? s3 : e3.reactiveElementVersions = []).push("1.6.3");
    }
  });

  // node_modules/lit-html/lit-html.js
  function P2(t6, i7) {
    if (!Array.isArray(t6) || !t6.hasOwnProperty("raw"))
      throw Error("invalid template strings array");
    return void 0 !== e4 ? e4.createHTML(i7) : i7;
  }
  function S7(t6, i7, s7 = t6, e9) {
    var o9, n9, l9, h10;
    if (i7 === T3)
      return i7;
    let r8 = void 0 !== e9 ? null === (o9 = s7._$Co) || void 0 === o9 ? void 0 : o9[e9] : s7._$Cl;
    const u7 = d4(i7) ? void 0 : i7._$litDirective$;
    return (null == r8 ? void 0 : r8.constructor) !== u7 && (null === (n9 = null == r8 ? void 0 : r8._$AO) || void 0 === n9 || n9.call(r8, false), void 0 === u7 ? r8 = void 0 : (r8 = new u7(t6), r8._$AT(t6, s7, e9)), void 0 !== e9 ? (null !== (l9 = (h10 = s7)._$Co) && void 0 !== l9 ? l9 : h10._$Co = [])[e9] = r8 : s7._$Cl = r8), void 0 !== r8 && (i7 = S7(t6, r8._$AS(t6, i7.values), r8, e9)), i7;
  }
  var t3, i3, s4, e4, o4, n4, l4, h7, r5, u4, d4, c6, v2, a5, f3, _4, m3, p4, g5, $4, y7, w5, x2, b4, T3, A3, E5, C3, V6, N13, M4, R3, k4, H4, I3, L4, z4, Z4, B5, D5;
  var init_lit_html = __esm({
    "node_modules/lit-html/lit-html.js"() {
      i3 = window;
      s4 = i3.trustedTypes;
      e4 = s4 ? s4.createPolicy("lit-html", { createHTML: (t6) => t6 }) : void 0;
      o4 = "$lit$";
      n4 = `lit$${(Math.random() + "").slice(9)}$`;
      l4 = "?" + n4;
      h7 = `<${l4}>`;
      r5 = document;
      u4 = () => r5.createComment("");
      d4 = (t6) => null === t6 || "object" != typeof t6 && "function" != typeof t6;
      c6 = Array.isArray;
      v2 = (t6) => c6(t6) || "function" == typeof (null == t6 ? void 0 : t6[Symbol.iterator]);
      a5 = "[ 	\n\f\r]";
      f3 = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g;
      _4 = /-->/g;
      m3 = />/g;
      p4 = RegExp(`>|${a5}(?:([^\\s"'>=/]+)(${a5}*=${a5}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g");
      g5 = /'/g;
      $4 = /"/g;
      y7 = /^(?:script|style|textarea|title)$/i;
      w5 = (t6) => (i7, ...s7) => ({ _$litType$: t6, strings: i7, values: s7 });
      x2 = w5(1);
      b4 = w5(2);
      T3 = Symbol.for("lit-noChange");
      A3 = Symbol.for("lit-nothing");
      E5 = /* @__PURE__ */ new WeakMap();
      C3 = r5.createTreeWalker(r5, 129, null, false);
      V6 = (t6, i7) => {
        const s7 = t6.length - 1, e9 = [];
        let l9, r8 = 2 === i7 ? "<svg>" : "", u7 = f3;
        for (let i8 = 0; i8 < s7; i8++) {
          const s8 = t6[i8];
          let d7, c9, v6 = -1, a6 = 0;
          for (; a6 < s8.length && (u7.lastIndex = a6, c9 = u7.exec(s8), null !== c9); )
            a6 = u7.lastIndex, u7 === f3 ? "!--" === c9[1] ? u7 = _4 : void 0 !== c9[1] ? u7 = m3 : void 0 !== c9[2] ? (y7.test(c9[2]) && (l9 = RegExp("</" + c9[2], "g")), u7 = p4) : void 0 !== c9[3] && (u7 = p4) : u7 === p4 ? ">" === c9[0] ? (u7 = null != l9 ? l9 : f3, v6 = -1) : void 0 === c9[1] ? v6 = -2 : (v6 = u7.lastIndex - c9[2].length, d7 = c9[1], u7 = void 0 === c9[3] ? p4 : '"' === c9[3] ? $4 : g5) : u7 === $4 || u7 === g5 ? u7 = p4 : u7 === _4 || u7 === m3 ? u7 = f3 : (u7 = p4, l9 = void 0);
          const w8 = u7 === p4 && t6[i8 + 1].startsWith("/>") ? " " : "";
          r8 += u7 === f3 ? s8 + h7 : v6 >= 0 ? (e9.push(d7), s8.slice(0, v6) + o4 + s8.slice(v6) + n4 + w8) : s8 + n4 + (-2 === v6 ? (e9.push(void 0), i8) : w8);
        }
        return [P2(t6, r8 + (t6[s7] || "<?>") + (2 === i7 ? "</svg>" : "")), e9];
      };
      N13 = class {
        constructor({ strings: t6, _$litType$: i7 }, e9) {
          let h10;
          this.parts = [];
          let r8 = 0, d7 = 0;
          const c9 = t6.length - 1, v6 = this.parts, [a6, f7] = V6(t6, i7);
          if (this.el = N13.createElement(a6, e9), C3.currentNode = this.el.content, 2 === i7) {
            const t7 = this.el.content, i8 = t7.firstChild;
            i8.remove(), t7.append(...i8.childNodes);
          }
          for (; null !== (h10 = C3.nextNode()) && v6.length < c9; ) {
            if (1 === h10.nodeType) {
              if (h10.hasAttributes()) {
                const t7 = [];
                for (const i8 of h10.getAttributeNames())
                  if (i8.endsWith(o4) || i8.startsWith(n4)) {
                    const s7 = f7[d7++];
                    if (t7.push(i8), void 0 !== s7) {
                      const t8 = h10.getAttribute(s7.toLowerCase() + o4).split(n4), i9 = /([.?@])?(.*)/.exec(s7);
                      v6.push({ type: 1, index: r8, name: i9[2], strings: t8, ctor: "." === i9[1] ? H4 : "?" === i9[1] ? L4 : "@" === i9[1] ? z4 : k4 });
                    } else
                      v6.push({ type: 6, index: r8 });
                  }
                for (const i8 of t7)
                  h10.removeAttribute(i8);
              }
              if (y7.test(h10.tagName)) {
                const t7 = h10.textContent.split(n4), i8 = t7.length - 1;
                if (i8 > 0) {
                  h10.textContent = s4 ? s4.emptyScript : "";
                  for (let s7 = 0; s7 < i8; s7++)
                    h10.append(t7[s7], u4()), C3.nextNode(), v6.push({ type: 2, index: ++r8 });
                  h10.append(t7[i8], u4());
                }
              }
            } else if (8 === h10.nodeType)
              if (h10.data === l4)
                v6.push({ type: 2, index: r8 });
              else {
                let t7 = -1;
                for (; -1 !== (t7 = h10.data.indexOf(n4, t7 + 1)); )
                  v6.push({ type: 7, index: r8 }), t7 += n4.length - 1;
              }
            r8++;
          }
        }
        static createElement(t6, i7) {
          const s7 = r5.createElement("template");
          return s7.innerHTML = t6, s7;
        }
      };
      M4 = class {
        constructor(t6, i7) {
          this._$AV = [], this._$AN = void 0, this._$AD = t6, this._$AM = i7;
        }
        get parentNode() {
          return this._$AM.parentNode;
        }
        get _$AU() {
          return this._$AM._$AU;
        }
        u(t6) {
          var i7;
          const { el: { content: s7 }, parts: e9 } = this._$AD, o9 = (null !== (i7 = null == t6 ? void 0 : t6.creationScope) && void 0 !== i7 ? i7 : r5).importNode(s7, true);
          C3.currentNode = o9;
          let n9 = C3.nextNode(), l9 = 0, h10 = 0, u7 = e9[0];
          for (; void 0 !== u7; ) {
            if (l9 === u7.index) {
              let i8;
              2 === u7.type ? i8 = new R3(n9, n9.nextSibling, this, t6) : 1 === u7.type ? i8 = new u7.ctor(n9, u7.name, u7.strings, this, t6) : 6 === u7.type && (i8 = new Z4(n9, this, t6)), this._$AV.push(i8), u7 = e9[++h10];
            }
            l9 !== (null == u7 ? void 0 : u7.index) && (n9 = C3.nextNode(), l9++);
          }
          return C3.currentNode = r5, o9;
        }
        v(t6) {
          let i7 = 0;
          for (const s7 of this._$AV)
            void 0 !== s7 && (void 0 !== s7.strings ? (s7._$AI(t6, s7, i7), i7 += s7.strings.length - 2) : s7._$AI(t6[i7])), i7++;
        }
      };
      R3 = class {
        constructor(t6, i7, s7, e9) {
          var o9;
          this.type = 2, this._$AH = A3, this._$AN = void 0, this._$AA = t6, this._$AB = i7, this._$AM = s7, this.options = e9, this._$Cp = null === (o9 = null == e9 ? void 0 : e9.isConnected) || void 0 === o9 || o9;
        }
        get _$AU() {
          var t6, i7;
          return null !== (i7 = null === (t6 = this._$AM) || void 0 === t6 ? void 0 : t6._$AU) && void 0 !== i7 ? i7 : this._$Cp;
        }
        get parentNode() {
          let t6 = this._$AA.parentNode;
          const i7 = this._$AM;
          return void 0 !== i7 && 11 === (null == t6 ? void 0 : t6.nodeType) && (t6 = i7.parentNode), t6;
        }
        get startNode() {
          return this._$AA;
        }
        get endNode() {
          return this._$AB;
        }
        _$AI(t6, i7 = this) {
          t6 = S7(this, t6, i7), d4(t6) ? t6 === A3 || null == t6 || "" === t6 ? (this._$AH !== A3 && this._$AR(), this._$AH = A3) : t6 !== this._$AH && t6 !== T3 && this._(t6) : void 0 !== t6._$litType$ ? this.g(t6) : void 0 !== t6.nodeType ? this.$(t6) : v2(t6) ? this.T(t6) : this._(t6);
        }
        k(t6) {
          return this._$AA.parentNode.insertBefore(t6, this._$AB);
        }
        $(t6) {
          this._$AH !== t6 && (this._$AR(), this._$AH = this.k(t6));
        }
        _(t6) {
          this._$AH !== A3 && d4(this._$AH) ? this._$AA.nextSibling.data = t6 : this.$(r5.createTextNode(t6)), this._$AH = t6;
        }
        g(t6) {
          var i7;
          const { values: s7, _$litType$: e9 } = t6, o9 = "number" == typeof e9 ? this._$AC(t6) : (void 0 === e9.el && (e9.el = N13.createElement(P2(e9.h, e9.h[0]), this.options)), e9);
          if ((null === (i7 = this._$AH) || void 0 === i7 ? void 0 : i7._$AD) === o9)
            this._$AH.v(s7);
          else {
            const t7 = new M4(o9, this), i8 = t7.u(this.options);
            t7.v(s7), this.$(i8), this._$AH = t7;
          }
        }
        _$AC(t6) {
          let i7 = E5.get(t6.strings);
          return void 0 === i7 && E5.set(t6.strings, i7 = new N13(t6)), i7;
        }
        T(t6) {
          c6(this._$AH) || (this._$AH = [], this._$AR());
          const i7 = this._$AH;
          let s7, e9 = 0;
          for (const o9 of t6)
            e9 === i7.length ? i7.push(s7 = new R3(this.k(u4()), this.k(u4()), this, this.options)) : s7 = i7[e9], s7._$AI(o9), e9++;
          e9 < i7.length && (this._$AR(s7 && s7._$AB.nextSibling, e9), i7.length = e9);
        }
        _$AR(t6 = this._$AA.nextSibling, i7) {
          var s7;
          for (null === (s7 = this._$AP) || void 0 === s7 || s7.call(this, false, true, i7); t6 && t6 !== this._$AB; ) {
            const i8 = t6.nextSibling;
            t6.remove(), t6 = i8;
          }
        }
        setConnected(t6) {
          var i7;
          void 0 === this._$AM && (this._$Cp = t6, null === (i7 = this._$AP) || void 0 === i7 || i7.call(this, t6));
        }
      };
      k4 = class {
        constructor(t6, i7, s7, e9, o9) {
          this.type = 1, this._$AH = A3, this._$AN = void 0, this.element = t6, this.name = i7, this._$AM = e9, this.options = o9, s7.length > 2 || "" !== s7[0] || "" !== s7[1] ? (this._$AH = Array(s7.length - 1).fill(new String()), this.strings = s7) : this._$AH = A3;
        }
        get tagName() {
          return this.element.tagName;
        }
        get _$AU() {
          return this._$AM._$AU;
        }
        _$AI(t6, i7 = this, s7, e9) {
          const o9 = this.strings;
          let n9 = false;
          if (void 0 === o9)
            t6 = S7(this, t6, i7, 0), n9 = !d4(t6) || t6 !== this._$AH && t6 !== T3, n9 && (this._$AH = t6);
          else {
            const e10 = t6;
            let l9, h10;
            for (t6 = o9[0], l9 = 0; l9 < o9.length - 1; l9++)
              h10 = S7(this, e10[s7 + l9], i7, l9), h10 === T3 && (h10 = this._$AH[l9]), n9 || (n9 = !d4(h10) || h10 !== this._$AH[l9]), h10 === A3 ? t6 = A3 : t6 !== A3 && (t6 += (null != h10 ? h10 : "") + o9[l9 + 1]), this._$AH[l9] = h10;
          }
          n9 && !e9 && this.j(t6);
        }
        j(t6) {
          t6 === A3 ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, null != t6 ? t6 : "");
        }
      };
      H4 = class extends k4 {
        constructor() {
          super(...arguments), this.type = 3;
        }
        j(t6) {
          this.element[this.name] = t6 === A3 ? void 0 : t6;
        }
      };
      I3 = s4 ? s4.emptyScript : "";
      L4 = class extends k4 {
        constructor() {
          super(...arguments), this.type = 4;
        }
        j(t6) {
          t6 && t6 !== A3 ? this.element.setAttribute(this.name, I3) : this.element.removeAttribute(this.name);
        }
      };
      z4 = class extends k4 {
        constructor(t6, i7, s7, e9, o9) {
          super(t6, i7, s7, e9, o9), this.type = 5;
        }
        _$AI(t6, i7 = this) {
          var s7;
          if ((t6 = null !== (s7 = S7(this, t6, i7, 0)) && void 0 !== s7 ? s7 : A3) === T3)
            return;
          const e9 = this._$AH, o9 = t6 === A3 && e9 !== A3 || t6.capture !== e9.capture || t6.once !== e9.once || t6.passive !== e9.passive, n9 = t6 !== A3 && (e9 === A3 || o9);
          o9 && this.element.removeEventListener(this.name, this, e9), n9 && this.element.addEventListener(this.name, this, t6), this._$AH = t6;
        }
        handleEvent(t6) {
          var i7, s7;
          "function" == typeof this._$AH ? this._$AH.call(null !== (s7 = null === (i7 = this.options) || void 0 === i7 ? void 0 : i7.host) && void 0 !== s7 ? s7 : this.element, t6) : this._$AH.handleEvent(t6);
        }
      };
      Z4 = class {
        constructor(t6, i7, s7) {
          this.element = t6, this.type = 6, this._$AN = void 0, this._$AM = i7, this.options = s7;
        }
        get _$AU() {
          return this._$AM._$AU;
        }
        _$AI(t6) {
          S7(this, t6);
        }
      };
      B5 = i3.litHtmlPolyfillSupport;
      null == B5 || B5(N13, R3), (null !== (t3 = i3.litHtmlVersions) && void 0 !== t3 ? t3 : i3.litHtmlVersions = []).push("2.8.0");
      D5 = (t6, i7, s7) => {
        var e9, o9;
        const n9 = null !== (e9 = null == s7 ? void 0 : s7.renderBefore) && void 0 !== e9 ? e9 : i7;
        let l9 = n9._$litPart$;
        if (void 0 === l9) {
          const t7 = null !== (o9 = null == s7 ? void 0 : s7.renderBefore) && void 0 !== o9 ? o9 : null;
          n9._$litPart$ = l9 = new R3(i7.insertBefore(u4(), t7), t7, void 0, null != s7 ? s7 : {});
        }
        return l9._$AI(t6), l9;
      };
    }
  });

  // node_modules/lit-element/lit-element.js
  var l5, o5, s5, n5;
  var init_lit_element = __esm({
    "node_modules/lit-element/lit-element.js"() {
      init_reactive_element();
      init_reactive_element();
      init_lit_html();
      init_lit_html();
      s5 = class extends u3 {
        constructor() {
          super(...arguments), this.renderOptions = { host: this }, this._$Do = void 0;
        }
        createRenderRoot() {
          var t6, e9;
          const i7 = super.createRenderRoot();
          return null !== (t6 = (e9 = this.renderOptions).renderBefore) && void 0 !== t6 || (e9.renderBefore = i7.firstChild), i7;
        }
        update(t6) {
          const i7 = this.render();
          this.hasUpdated || (this.renderOptions.isConnected = this.isConnected), super.update(t6), this._$Do = D5(i7, this.renderRoot, this.renderOptions);
        }
        connectedCallback() {
          var t6;
          super.connectedCallback(), null === (t6 = this._$Do) || void 0 === t6 || t6.setConnected(true);
        }
        disconnectedCallback() {
          var t6;
          super.disconnectedCallback(), null === (t6 = this._$Do) || void 0 === t6 || t6.setConnected(false);
        }
        render() {
          return T3;
        }
      };
      s5.finalized = true, s5._$litElement$ = true, null === (l5 = globalThis.litElementHydrateSupport) || void 0 === l5 || l5.call(globalThis, { LitElement: s5 });
      n5 = globalThis.litElementPolyfillSupport;
      null == n5 || n5({ LitElement: s5 });
      (null !== (o5 = globalThis.litElementVersions) && void 0 !== o5 ? o5 : globalThis.litElementVersions = []).push("3.3.3");
    }
  });

  // node_modules/lit-html/is-server.js
  var init_is_server = __esm({
    "node_modules/lit-html/is-server.js"() {
    }
  });

  // node_modules/@walletconnect/modal-ui/node_modules/lit/index.js
  var init_lit = __esm({
    "node_modules/@walletconnect/modal-ui/node_modules/lit/index.js"() {
      init_reactive_element();
      init_lit_html();
      init_lit_element();
      init_is_server();
    }
  });

  // node_modules/@lit/reactive-element/decorators/custom-element.js
  var e5;
  var init_custom_element = __esm({
    "node_modules/@lit/reactive-element/decorators/custom-element.js"() {
      e5 = (e9) => (n9) => "function" == typeof n9 ? ((e10, n10) => (customElements.define(e10, n10), n10))(e9, n9) : ((e10, n10) => {
        const { kind: t6, elements: s7 } = n10;
        return { kind: t6, elements: s7, finisher(n11) {
          customElements.define(e10, n11);
        } };
      })(e9, n9);
    }
  });

  // node_modules/@lit/reactive-element/decorators/property.js
  function n6(n9) {
    return (t6, o9) => void 0 !== o9 ? e6(n9, t6, o9) : i4(n9, t6);
  }
  var i4, e6;
  var init_property = __esm({
    "node_modules/@lit/reactive-element/decorators/property.js"() {
      i4 = (i7, e9) => "method" === e9.kind && e9.descriptor && !("value" in e9.descriptor) ? { ...e9, finisher(n9) {
        n9.createProperty(e9.key, i7);
      } } : { kind: "field", key: Symbol(), placement: "own", descriptor: {}, originalKey: e9.key, initializer() {
        "function" == typeof e9.initializer && (this[e9.key] = e9.initializer.call(this));
      }, finisher(n9) {
        n9.createProperty(e9.key, i7);
      } };
      e6 = (i7, e9, n9) => {
        e9.constructor.createProperty(n9, i7);
      };
    }
  });

  // node_modules/@lit/reactive-element/decorators/state.js
  function t4(t6) {
    return n6({ ...t6, state: true });
  }
  var init_state = __esm({
    "node_modules/@lit/reactive-element/decorators/state.js"() {
      init_property();
    }
  });

  // node_modules/@lit/reactive-element/decorators/base.js
  var init_base3 = __esm({
    "node_modules/@lit/reactive-element/decorators/base.js"() {
    }
  });

  // node_modules/@lit/reactive-element/decorators/event-options.js
  var init_event_options = __esm({
    "node_modules/@lit/reactive-element/decorators/event-options.js"() {
      init_base3();
    }
  });

  // node_modules/@lit/reactive-element/decorators/query.js
  var init_query = __esm({
    "node_modules/@lit/reactive-element/decorators/query.js"() {
      init_base3();
    }
  });

  // node_modules/@lit/reactive-element/decorators/query-all.js
  var init_query_all = __esm({
    "node_modules/@lit/reactive-element/decorators/query-all.js"() {
      init_base3();
    }
  });

  // node_modules/@lit/reactive-element/decorators/query-async.js
  var init_query_async = __esm({
    "node_modules/@lit/reactive-element/decorators/query-async.js"() {
      init_base3();
    }
  });

  // node_modules/@lit/reactive-element/decorators/query-assigned-elements.js
  var n7, e7;
  var init_query_assigned_elements = __esm({
    "node_modules/@lit/reactive-element/decorators/query-assigned-elements.js"() {
      init_base3();
      e7 = null != (null === (n7 = window.HTMLSlotElement) || void 0 === n7 ? void 0 : n7.prototype.assignedElements) ? (o9, n9) => o9.assignedElements(n9) : (o9, n9) => o9.assignedNodes(n9).filter((o10) => o10.nodeType === Node.ELEMENT_NODE);
    }
  });

  // node_modules/@lit/reactive-element/decorators/query-assigned-nodes.js
  var init_query_assigned_nodes = __esm({
    "node_modules/@lit/reactive-element/decorators/query-assigned-nodes.js"() {
      init_base3();
      init_query_assigned_elements();
    }
  });

  // node_modules/@walletconnect/modal-ui/node_modules/lit/decorators.js
  var init_decorators = __esm({
    "node_modules/@walletconnect/modal-ui/node_modules/lit/decorators.js"() {
      init_custom_element();
      init_property();
      init_state();
      init_event_options();
      init_query();
      init_query_all();
      init_query_async();
      init_query_assigned_elements();
      init_query_assigned_nodes();
    }
  });

  // node_modules/lit-html/directive.js
  var t5, e8, i5;
  var init_directive = __esm({
    "node_modules/lit-html/directive.js"() {
      t5 = { ATTRIBUTE: 1, CHILD: 2, PROPERTY: 3, BOOLEAN_ATTRIBUTE: 4, EVENT: 5, ELEMENT: 6 };
      e8 = (t6) => (...e9) => ({ _$litDirective$: t6, values: e9 });
      i5 = class {
        constructor(t6) {
        }
        get _$AU() {
          return this._$AM._$AU;
        }
        _$AT(t6, e9, i7) {
          this._$Ct = t6, this._$AM = e9, this._$Ci = i7;
        }
        _$AS(t6, e9) {
          return this.update(t6, e9);
        }
        update(t6, e9) {
          return this.render(...e9);
        }
      };
    }
  });

  // node_modules/lit-html/directives/class-map.js
  var o7;
  var init_class_map = __esm({
    "node_modules/lit-html/directives/class-map.js"() {
      init_lit_html();
      init_directive();
      o7 = e8(class extends i5 {
        constructor(t6) {
          var i7;
          if (super(t6), t6.type !== t5.ATTRIBUTE || "class" !== t6.name || (null === (i7 = t6.strings) || void 0 === i7 ? void 0 : i7.length) > 2)
            throw Error("`classMap()` can only be used in the `class` attribute and must be the only part in the attribute.");
        }
        render(t6) {
          return " " + Object.keys(t6).filter((i7) => t6[i7]).join(" ") + " ";
        }
        update(i7, [s7]) {
          var r8, o9;
          if (void 0 === this.it) {
            this.it = /* @__PURE__ */ new Set(), void 0 !== i7.strings && (this.nt = new Set(i7.strings.join(" ").split(/\s/).filter((t6) => "" !== t6)));
            for (const t6 in s7)
              s7[t6] && !(null === (r8 = this.nt) || void 0 === r8 ? void 0 : r8.has(t6)) && this.it.add(t6);
            return this.render(s7);
          }
          const e9 = i7.element.classList;
          this.it.forEach((t6) => {
            t6 in s7 || (e9.remove(t6), this.it.delete(t6));
          });
          for (const t6 in s7) {
            const i8 = !!s7[t6];
            i8 === this.it.has(t6) || (null === (o9 = this.nt) || void 0 === o9 ? void 0 : o9.has(t6)) || (i8 ? (e9.add(t6), this.it.add(t6)) : (e9.remove(t6), this.it.delete(t6)));
          }
          return T3;
        }
      });
    }
  });

  // node_modules/@walletconnect/modal-ui/node_modules/lit/directives/class-map.js
  var init_class_map2 = __esm({
    "node_modules/@walletconnect/modal-ui/node_modules/lit/directives/class-map.js"() {
      init_class_map();
    }
  });

  // node_modules/@motionone/utils/dist/array.es.js
  function addUniqueItem(array, item) {
    array.indexOf(item) === -1 && array.push(item);
  }
  var init_array_es = __esm({
    "node_modules/@motionone/utils/dist/array.es.js"() {
    }
  });

  // node_modules/@motionone/utils/dist/clamp.es.js
  var clamp;
  var init_clamp_es = __esm({
    "node_modules/@motionone/utils/dist/clamp.es.js"() {
      clamp = (min, max, v6) => Math.min(Math.max(v6, min), max);
    }
  });

  // node_modules/@motionone/utils/dist/defaults.es.js
  var defaults;
  var init_defaults_es = __esm({
    "node_modules/@motionone/utils/dist/defaults.es.js"() {
      defaults = {
        duration: 0.3,
        delay: 0,
        endDelay: 0,
        repeat: 0,
        easing: "ease"
      };
    }
  });

  // node_modules/@motionone/utils/dist/is-number.es.js
  var isNumber;
  var init_is_number_es = __esm({
    "node_modules/@motionone/utils/dist/is-number.es.js"() {
      isNumber = (value) => typeof value === "number";
    }
  });

  // node_modules/@motionone/utils/dist/is-easing-list.es.js
  var isEasingList;
  var init_is_easing_list_es = __esm({
    "node_modules/@motionone/utils/dist/is-easing-list.es.js"() {
      init_is_number_es();
      isEasingList = (easing) => Array.isArray(easing) && !isNumber(easing[0]);
    }
  });

  // node_modules/@motionone/utils/dist/wrap.es.js
  var wrap;
  var init_wrap_es = __esm({
    "node_modules/@motionone/utils/dist/wrap.es.js"() {
      wrap = (min, max, v6) => {
        const rangeSize = max - min;
        return ((v6 - min) % rangeSize + rangeSize) % rangeSize + min;
      };
    }
  });

  // node_modules/@motionone/utils/dist/easing.es.js
  function getEasingForSegment(easing, i7) {
    return isEasingList(easing) ? easing[wrap(0, easing.length, i7)] : easing;
  }
  var init_easing_es = __esm({
    "node_modules/@motionone/utils/dist/easing.es.js"() {
      init_is_easing_list_es();
      init_wrap_es();
    }
  });

  // node_modules/@motionone/utils/dist/mix.es.js
  var mix;
  var init_mix_es = __esm({
    "node_modules/@motionone/utils/dist/mix.es.js"() {
      mix = (min, max, progress2) => -progress2 * min + progress2 * max + min;
    }
  });

  // node_modules/@motionone/utils/dist/noop.es.js
  var noop, noopReturn;
  var init_noop_es = __esm({
    "node_modules/@motionone/utils/dist/noop.es.js"() {
      noop = () => {
      };
      noopReturn = (v6) => v6;
    }
  });

  // node_modules/@motionone/utils/dist/progress.es.js
  var progress;
  var init_progress_es = __esm({
    "node_modules/@motionone/utils/dist/progress.es.js"() {
      progress = (min, max, value) => max - min === 0 ? 1 : (value - min) / (max - min);
    }
  });

  // node_modules/@motionone/utils/dist/offset.es.js
  function fillOffset(offset, remaining) {
    const min = offset[offset.length - 1];
    for (let i7 = 1; i7 <= remaining; i7++) {
      const offsetProgress = progress(0, remaining, i7);
      offset.push(mix(min, 1, offsetProgress));
    }
  }
  function defaultOffset(length2) {
    const offset = [0];
    fillOffset(offset, length2 - 1);
    return offset;
  }
  var init_offset_es = __esm({
    "node_modules/@motionone/utils/dist/offset.es.js"() {
      init_mix_es();
      init_progress_es();
    }
  });

  // node_modules/@motionone/utils/dist/interpolate.es.js
  function interpolate(output2, input = defaultOffset(output2.length), easing = noopReturn) {
    const length2 = output2.length;
    const remainder = length2 - input.length;
    remainder > 0 && fillOffset(input, remainder);
    return (t6) => {
      let i7 = 0;
      for (; i7 < length2 - 2; i7++) {
        if (t6 < input[i7 + 1])
          break;
      }
      let progressInRange = clamp(0, 1, progress(input[i7], input[i7 + 1], t6));
      const segmentEasing = getEasingForSegment(easing, i7);
      progressInRange = segmentEasing(progressInRange);
      return mix(output2[i7], output2[i7 + 1], progressInRange);
    };
  }
  var init_interpolate_es = __esm({
    "node_modules/@motionone/utils/dist/interpolate.es.js"() {
      init_mix_es();
      init_noop_es();
      init_offset_es();
      init_progress_es();
      init_easing_es();
      init_clamp_es();
    }
  });

  // node_modules/@motionone/utils/dist/is-cubic-bezier.es.js
  var isCubicBezier;
  var init_is_cubic_bezier_es = __esm({
    "node_modules/@motionone/utils/dist/is-cubic-bezier.es.js"() {
      init_is_number_es();
      isCubicBezier = (easing) => Array.isArray(easing) && isNumber(easing[0]);
    }
  });

  // node_modules/@motionone/utils/dist/is-easing-generator.es.js
  var isEasingGenerator;
  var init_is_easing_generator_es = __esm({
    "node_modules/@motionone/utils/dist/is-easing-generator.es.js"() {
      isEasingGenerator = (easing) => typeof easing === "object" && Boolean(easing.createAnimation);
    }
  });

  // node_modules/@motionone/utils/dist/is-function.es.js
  var isFunction;
  var init_is_function_es = __esm({
    "node_modules/@motionone/utils/dist/is-function.es.js"() {
      isFunction = (value) => typeof value === "function";
    }
  });

  // node_modules/@motionone/utils/dist/is-string.es.js
  var isString;
  var init_is_string_es = __esm({
    "node_modules/@motionone/utils/dist/is-string.es.js"() {
      isString = (value) => typeof value === "string";
    }
  });

  // node_modules/@motionone/utils/dist/time.es.js
  var time;
  var init_time_es = __esm({
    "node_modules/@motionone/utils/dist/time.es.js"() {
      time = {
        ms: (seconds) => seconds * 1e3,
        s: (milliseconds) => milliseconds / 1e3
      };
    }
  });

  // node_modules/@motionone/utils/dist/index.es.js
  var init_index_es8 = __esm({
    "node_modules/@motionone/utils/dist/index.es.js"() {
      init_array_es();
      init_clamp_es();
      init_defaults_es();
      init_interpolate_es();
      init_is_cubic_bezier_es();
      init_is_easing_generator_es();
      init_is_easing_list_es();
      init_is_function_es();
      init_is_number_es();
      init_is_string_es();
      init_noop_es();
      init_progress_es();
      init_time_es();
    }
  });

  // node_modules/@motionone/easing/dist/cubic-bezier.es.js
  function binarySubdivide(x4, lowerBound, upperBound, mX1, mX2) {
    let currentX;
    let currentT;
    let i7 = 0;
    do {
      currentT = lowerBound + (upperBound - lowerBound) / 2;
      currentX = calcBezier(currentT, mX1, mX2) - x4;
      if (currentX > 0) {
        upperBound = currentT;
      } else {
        lowerBound = currentT;
      }
    } while (Math.abs(currentX) > subdivisionPrecision && ++i7 < subdivisionMaxIterations);
    return currentT;
  }
  function cubicBezier(mX1, mY1, mX2, mY2) {
    if (mX1 === mY1 && mX2 === mY2)
      return noopReturn;
    const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);
    return (t6) => t6 === 0 || t6 === 1 ? t6 : calcBezier(getTForX(t6), mY1, mY2);
  }
  var calcBezier, subdivisionPrecision, subdivisionMaxIterations;
  var init_cubic_bezier_es = __esm({
    "node_modules/@motionone/easing/dist/cubic-bezier.es.js"() {
      init_index_es8();
      calcBezier = (t6, a1, a22) => (((1 - 3 * a22 + 3 * a1) * t6 + (3 * a22 - 6 * a1)) * t6 + 3 * a1) * t6;
      subdivisionPrecision = 1e-7;
      subdivisionMaxIterations = 12;
    }
  });

  // node_modules/@motionone/easing/dist/steps.es.js
  var steps;
  var init_steps_es = __esm({
    "node_modules/@motionone/easing/dist/steps.es.js"() {
      init_index_es8();
      steps = (steps2, direction = "end") => (progress2) => {
        progress2 = direction === "end" ? Math.min(progress2, 0.999) : Math.max(progress2, 1e-3);
        const expanded = progress2 * steps2;
        const rounded = direction === "end" ? Math.floor(expanded) : Math.ceil(expanded);
        return clamp(0, 1, rounded / steps2);
      };
    }
  });

  // node_modules/@motionone/easing/dist/index.es.js
  var init_index_es9 = __esm({
    "node_modules/@motionone/easing/dist/index.es.js"() {
      init_cubic_bezier_es();
      init_steps_es();
    }
  });

  // node_modules/@motionone/animation/dist/utils/easing.es.js
  function getEasingFunction(definition) {
    if (isFunction(definition))
      return definition;
    if (isCubicBezier(definition))
      return cubicBezier(...definition);
    if (namedEasings[definition])
      return namedEasings[definition];
    if (definition.startsWith("steps")) {
      const args = functionArgsRegex.exec(definition);
      if (args) {
        const argsArray = args[1].split(",");
        return steps(parseFloat(argsArray[0]), argsArray[1].trim());
      }
    }
    return noopReturn;
  }
  var namedEasings, functionArgsRegex;
  var init_easing_es2 = __esm({
    "node_modules/@motionone/animation/dist/utils/easing.es.js"() {
      init_index_es9();
      init_index_es8();
      namedEasings = {
        ease: cubicBezier(0.25, 0.1, 0.25, 1),
        "ease-in": cubicBezier(0.42, 0, 1, 1),
        "ease-in-out": cubicBezier(0.42, 0, 0.58, 1),
        "ease-out": cubicBezier(0, 0, 0.58, 1)
      };
      functionArgsRegex = /\((.*?)\)/;
    }
  });

  // node_modules/@motionone/animation/dist/Animation.es.js
  var Animation;
  var init_Animation_es = __esm({
    "node_modules/@motionone/animation/dist/Animation.es.js"() {
      init_index_es8();
      init_easing_es2();
      Animation = class {
        constructor(output2, keyframes = [0, 1], { easing, duration: initialDuration = defaults.duration, delay = defaults.delay, endDelay = defaults.endDelay, repeat = defaults.repeat, offset, direction = "normal" } = {}) {
          this.startTime = null;
          this.rate = 1;
          this.t = 0;
          this.cancelTimestamp = null;
          this.easing = noopReturn;
          this.duration = 0;
          this.totalDuration = 0;
          this.repeat = 0;
          this.playState = "idle";
          this.finished = new Promise((resolve, reject) => {
            this.resolve = resolve;
            this.reject = reject;
          });
          easing = easing || defaults.easing;
          if (isEasingGenerator(easing)) {
            const custom2 = easing.createAnimation(keyframes);
            easing = custom2.easing;
            keyframes = custom2.keyframes || keyframes;
            initialDuration = custom2.duration || initialDuration;
          }
          this.repeat = repeat;
          this.easing = isEasingList(easing) ? noopReturn : getEasingFunction(easing);
          this.updateDuration(initialDuration);
          const interpolate$1 = interpolate(keyframes, offset, isEasingList(easing) ? easing.map(getEasingFunction) : noopReturn);
          this.tick = (timestamp) => {
            var _a2;
            delay = delay;
            let t6 = 0;
            if (this.pauseTime !== void 0) {
              t6 = this.pauseTime;
            } else {
              t6 = (timestamp - this.startTime) * this.rate;
            }
            this.t = t6;
            t6 /= 1e3;
            t6 = Math.max(t6 - delay, 0);
            if (this.playState === "finished" && this.pauseTime === void 0) {
              t6 = this.totalDuration;
            }
            const progress2 = t6 / this.duration;
            let currentIteration = Math.floor(progress2);
            let iterationProgress = progress2 % 1;
            if (!iterationProgress && progress2 >= 1) {
              iterationProgress = 1;
            }
            iterationProgress === 1 && currentIteration--;
            const iterationIsOdd = currentIteration % 2;
            if (direction === "reverse" || direction === "alternate" && iterationIsOdd || direction === "alternate-reverse" && !iterationIsOdd) {
              iterationProgress = 1 - iterationProgress;
            }
            const p8 = t6 >= this.totalDuration ? 1 : Math.min(iterationProgress, 1);
            const latest = interpolate$1(this.easing(p8));
            output2(latest);
            const isAnimationFinished = this.pauseTime === void 0 && (this.playState === "finished" || t6 >= this.totalDuration + endDelay);
            if (isAnimationFinished) {
              this.playState = "finished";
              (_a2 = this.resolve) === null || _a2 === void 0 ? void 0 : _a2.call(this, latest);
            } else if (this.playState !== "idle") {
              this.frameRequestId = requestAnimationFrame(this.tick);
            }
          };
          this.play();
        }
        play() {
          const now2 = performance.now();
          this.playState = "running";
          if (this.pauseTime !== void 0) {
            this.startTime = now2 - this.pauseTime;
          } else if (!this.startTime) {
            this.startTime = now2;
          }
          this.cancelTimestamp = this.startTime;
          this.pauseTime = void 0;
          this.frameRequestId = requestAnimationFrame(this.tick);
        }
        pause() {
          this.playState = "paused";
          this.pauseTime = this.t;
        }
        finish() {
          this.playState = "finished";
          this.tick(0);
        }
        stop() {
          var _a2;
          this.playState = "idle";
          if (this.frameRequestId !== void 0) {
            cancelAnimationFrame(this.frameRequestId);
          }
          (_a2 = this.reject) === null || _a2 === void 0 ? void 0 : _a2.call(this, false);
        }
        cancel() {
          this.stop();
          this.tick(this.cancelTimestamp);
        }
        reverse() {
          this.rate *= -1;
        }
        commitStyles() {
        }
        updateDuration(duration) {
          this.duration = duration;
          this.totalDuration = duration * (this.repeat + 1);
        }
        get currentTime() {
          return this.t;
        }
        set currentTime(t6) {
          if (this.pauseTime !== void 0 || this.rate === 0) {
            this.pauseTime = t6;
          } else {
            this.startTime = performance.now() - t6 / this.rate;
          }
        }
        get playbackRate() {
          return this.rate;
        }
        set playbackRate(rate) {
          this.rate = rate;
        }
      };
    }
  });

  // node_modules/@motionone/animation/dist/index.es.js
  var init_index_es10 = __esm({
    "node_modules/@motionone/animation/dist/index.es.js"() {
      init_Animation_es();
    }
  });

  // node_modules/hey-listen/dist/hey-listen.es.js
  var warning, invariant;
  var init_hey_listen_es = __esm({
    "node_modules/hey-listen/dist/hey-listen.es.js"() {
      warning = function() {
      };
      invariant = function() {
      };
      if (true) {
        warning = function(check, message) {
          if (!check && typeof console !== "undefined") {
            console.warn(message);
          }
        };
        invariant = function(check, message) {
          if (!check) {
            throw new Error(message);
          }
        };
      }
    }
  });

  // node_modules/@motionone/types/dist/MotionValue.es.js
  var MotionValue;
  var init_MotionValue_es = __esm({
    "node_modules/@motionone/types/dist/MotionValue.es.js"() {
      MotionValue = class {
        setAnimation(animation) {
          this.animation = animation;
          animation === null || animation === void 0 ? void 0 : animation.finished.then(() => this.clearAnimation()).catch(() => {
          });
        }
        clearAnimation() {
          this.animation = this.generator = void 0;
        }
      };
    }
  });

  // node_modules/@motionone/types/dist/index.es.js
  var init_index_es11 = __esm({
    "node_modules/@motionone/types/dist/index.es.js"() {
      init_MotionValue_es();
    }
  });

  // node_modules/@motionone/dom/dist/animate/data.es.js
  function getAnimationData(element) {
    if (!data.has(element)) {
      data.set(element, {
        transforms: [],
        values: /* @__PURE__ */ new Map()
      });
    }
    return data.get(element);
  }
  function getMotionValue(motionValues, name2) {
    if (!motionValues.has(name2)) {
      motionValues.set(name2, new MotionValue());
    }
    return motionValues.get(name2);
  }
  var data;
  var init_data_es = __esm({
    "node_modules/@motionone/dom/dist/animate/data.es.js"() {
      init_index_es11();
      data = /* @__PURE__ */ new WeakMap();
    }
  });

  // node_modules/@motionone/dom/dist/animate/utils/transforms.es.js
  var axes, order, transformAlias, rotation, baseTransformProperties, transformDefinitions, asTransformCssVar, transforms, compareTransformOrder, transformLookup, isTransform, addTransformToElement, buildTransformTemplate, transformListToString;
  var init_transforms_es = __esm({
    "node_modules/@motionone/dom/dist/animate/utils/transforms.es.js"() {
      init_index_es8();
      init_data_es();
      axes = ["", "X", "Y", "Z"];
      order = ["translate", "scale", "rotate", "skew"];
      transformAlias = {
        x: "translateX",
        y: "translateY",
        z: "translateZ"
      };
      rotation = {
        syntax: "<angle>",
        initialValue: "0deg",
        toDefaultUnit: (v6) => v6 + "deg"
      };
      baseTransformProperties = {
        translate: {
          syntax: "<length-percentage>",
          initialValue: "0px",
          toDefaultUnit: (v6) => v6 + "px"
        },
        rotate: rotation,
        scale: {
          syntax: "<number>",
          initialValue: 1,
          toDefaultUnit: noopReturn
        },
        skew: rotation
      };
      transformDefinitions = /* @__PURE__ */ new Map();
      asTransformCssVar = (name2) => `--motion-${name2}`;
      transforms = ["x", "y", "z"];
      order.forEach((name2) => {
        axes.forEach((axis) => {
          transforms.push(name2 + axis);
          transformDefinitions.set(asTransformCssVar(name2 + axis), baseTransformProperties[name2]);
        });
      });
      compareTransformOrder = (a6, b7) => transforms.indexOf(a6) - transforms.indexOf(b7);
      transformLookup = new Set(transforms);
      isTransform = (name2) => transformLookup.has(name2);
      addTransformToElement = (element, name2) => {
        if (transformAlias[name2])
          name2 = transformAlias[name2];
        const { transforms: transforms2 } = getAnimationData(element);
        addUniqueItem(transforms2, name2);
        element.style.transform = buildTransformTemplate(transforms2);
      };
      buildTransformTemplate = (transforms2) => transforms2.sort(compareTransformOrder).reduce(transformListToString, "").trim();
      transformListToString = (template, name2) => `${template} ${name2}(var(${asTransformCssVar(name2)}))`;
    }
  });

  // node_modules/@motionone/dom/dist/animate/utils/css-var.es.js
  function registerCssVariable(name2) {
    if (registeredProperties.has(name2))
      return;
    registeredProperties.add(name2);
    try {
      const { syntax, initialValue } = transformDefinitions.has(name2) ? transformDefinitions.get(name2) : {};
      CSS.registerProperty({
        name: name2,
        inherits: false,
        syntax,
        initialValue
      });
    } catch (e9) {
    }
  }
  var isCssVar, registeredProperties;
  var init_css_var_es = __esm({
    "node_modules/@motionone/dom/dist/animate/utils/css-var.es.js"() {
      init_transforms_es();
      isCssVar = (name2) => name2.startsWith("--");
      registeredProperties = /* @__PURE__ */ new Set();
    }
  });

  // node_modules/@motionone/dom/dist/animate/utils/feature-detection.es.js
  var testAnimation, featureTests, results, supports;
  var init_feature_detection_es = __esm({
    "node_modules/@motionone/dom/dist/animate/utils/feature-detection.es.js"() {
      testAnimation = (keyframes, options2) => document.createElement("div").animate(keyframes, options2);
      featureTests = {
        cssRegisterProperty: () => typeof CSS !== "undefined" && Object.hasOwnProperty.call(CSS, "registerProperty"),
        waapi: () => Object.hasOwnProperty.call(Element.prototype, "animate"),
        partialKeyframes: () => {
          try {
            testAnimation({ opacity: [1] });
          } catch (e9) {
            return false;
          }
          return true;
        },
        finished: () => Boolean(testAnimation({ opacity: [0, 1] }, { duration: 1e-3 }).finished),
        linearEasing: () => {
          try {
            testAnimation({ opacity: 0 }, { easing: "linear(0, 1)" });
          } catch (e9) {
            return false;
          }
          return true;
        }
      };
      results = {};
      supports = {};
      for (const key2 in featureTests) {
        supports[key2] = () => {
          if (results[key2] === void 0)
            results[key2] = featureTests[key2]();
          return results[key2];
        };
      }
    }
  });

  // node_modules/@motionone/dom/dist/animate/utils/easing.es.js
  var resolution, generateLinearEasingPoints, convertEasing, cubicBezierAsString;
  var init_easing_es3 = __esm({
    "node_modules/@motionone/dom/dist/animate/utils/easing.es.js"() {
      init_index_es8();
      init_feature_detection_es();
      resolution = 0.015;
      generateLinearEasingPoints = (easing, duration) => {
        let points = "";
        const numPoints = Math.round(duration / resolution);
        for (let i7 = 0; i7 < numPoints; i7++) {
          points += easing(progress(0, numPoints - 1, i7)) + ", ";
        }
        return points.substring(0, points.length - 2);
      };
      convertEasing = (easing, duration) => {
        if (isFunction(easing)) {
          return supports.linearEasing() ? `linear(${generateLinearEasingPoints(easing, duration)})` : defaults.easing;
        } else {
          return isCubicBezier(easing) ? cubicBezierAsString(easing) : easing;
        }
      };
      cubicBezierAsString = ([a6, b7, c9, d7]) => `cubic-bezier(${a6}, ${b7}, ${c9}, ${d7})`;
    }
  });

  // node_modules/@motionone/dom/dist/animate/utils/keyframes.es.js
  function hydrateKeyframes(keyframes, readInitialValue) {
    for (let i7 = 0; i7 < keyframes.length; i7++) {
      if (keyframes[i7] === null) {
        keyframes[i7] = i7 ? keyframes[i7 - 1] : readInitialValue();
      }
    }
    return keyframes;
  }
  var keyframesList;
  var init_keyframes_es = __esm({
    "node_modules/@motionone/dom/dist/animate/utils/keyframes.es.js"() {
      keyframesList = (keyframes) => Array.isArray(keyframes) ? keyframes : [keyframes];
    }
  });

  // node_modules/@motionone/dom/dist/animate/utils/get-style-name.es.js
  function getStyleName(key2) {
    if (transformAlias[key2])
      key2 = transformAlias[key2];
    return isTransform(key2) ? asTransformCssVar(key2) : key2;
  }
  var init_get_style_name_es = __esm({
    "node_modules/@motionone/dom/dist/animate/utils/get-style-name.es.js"() {
      init_transforms_es();
    }
  });

  // node_modules/@motionone/dom/dist/animate/style.es.js
  var style;
  var init_style_es = __esm({
    "node_modules/@motionone/dom/dist/animate/style.es.js"() {
      init_css_var_es();
      init_get_style_name_es();
      init_transforms_es();
      style = {
        get: (element, name2) => {
          name2 = getStyleName(name2);
          let value = isCssVar(name2) ? element.style.getPropertyValue(name2) : getComputedStyle(element)[name2];
          if (!value && value !== 0) {
            const definition = transformDefinitions.get(name2);
            if (definition)
              value = definition.initialValue;
          }
          return value;
        },
        set: (element, name2, value) => {
          name2 = getStyleName(name2);
          if (isCssVar(name2)) {
            element.style.setProperty(name2, value);
          } else {
            element.style[name2] = value;
          }
        }
      };
    }
  });

  // node_modules/@motionone/dom/dist/animate/utils/stop-animation.es.js
  function stopAnimation(animation, needsCommit = true) {
    if (!animation || animation.playState === "finished")
      return;
    try {
      if (animation.stop) {
        animation.stop();
      } else {
        needsCommit && animation.commitStyles();
        animation.cancel();
      }
    } catch (e9) {
    }
  }
  var init_stop_animation_es = __esm({
    "node_modules/@motionone/dom/dist/animate/utils/stop-animation.es.js"() {
    }
  });

  // node_modules/@motionone/dom/dist/animate/utils/get-unit.es.js
  function getUnitConverter(keyframes, definition) {
    var _a2;
    let toUnit = (definition === null || definition === void 0 ? void 0 : definition.toDefaultUnit) || noopReturn;
    const finalKeyframe = keyframes[keyframes.length - 1];
    if (isString(finalKeyframe)) {
      const unit = ((_a2 = finalKeyframe.match(/(-?[\d.]+)([a-z%]*)/)) === null || _a2 === void 0 ? void 0 : _a2[2]) || "";
      if (unit)
        toUnit = (value) => value + unit;
    }
    return toUnit;
  }
  var init_get_unit_es = __esm({
    "node_modules/@motionone/dom/dist/animate/utils/get-unit.es.js"() {
      init_index_es8();
    }
  });

  // node_modules/@motionone/dom/dist/animate/animate-style.es.js
  function getDevToolsRecord() {
    return window.__MOTION_DEV_TOOLS_RECORD;
  }
  function animateStyle(element, key2, keyframesDefinition, options2 = {}, AnimationPolyfill) {
    const record = getDevToolsRecord();
    const isRecording = options2.record !== false && record;
    let animation;
    let { duration = defaults.duration, delay = defaults.delay, endDelay = defaults.endDelay, repeat = defaults.repeat, easing = defaults.easing, persist: persist2 = false, direction, offset, allowWebkitAcceleration = false } = options2;
    const data2 = getAnimationData(element);
    const valueIsTransform = isTransform(key2);
    let canAnimateNatively = supports.waapi();
    valueIsTransform && addTransformToElement(element, key2);
    const name2 = getStyleName(key2);
    const motionValue = getMotionValue(data2.values, name2);
    const definition = transformDefinitions.get(name2);
    stopAnimation(motionValue.animation, !(isEasingGenerator(easing) && motionValue.generator) && options2.record !== false);
    return () => {
      const readInitialValue = () => {
        var _a2, _b;
        return (_b = (_a2 = style.get(element, name2)) !== null && _a2 !== void 0 ? _a2 : definition === null || definition === void 0 ? void 0 : definition.initialValue) !== null && _b !== void 0 ? _b : 0;
      };
      let keyframes = hydrateKeyframes(keyframesList(keyframesDefinition), readInitialValue);
      const toUnit = getUnitConverter(keyframes, definition);
      if (isEasingGenerator(easing)) {
        const custom2 = easing.createAnimation(keyframes, key2 !== "opacity", readInitialValue, name2, motionValue);
        easing = custom2.easing;
        keyframes = custom2.keyframes || keyframes;
        duration = custom2.duration || duration;
      }
      if (isCssVar(name2)) {
        if (supports.cssRegisterProperty()) {
          registerCssVariable(name2);
        } else {
          canAnimateNatively = false;
        }
      }
      if (valueIsTransform && !supports.linearEasing() && (isFunction(easing) || isEasingList(easing) && easing.some(isFunction))) {
        canAnimateNatively = false;
      }
      if (canAnimateNatively) {
        if (definition) {
          keyframes = keyframes.map((value) => isNumber(value) ? definition.toDefaultUnit(value) : value);
        }
        if (keyframes.length === 1 && (!supports.partialKeyframes() || isRecording)) {
          keyframes.unshift(readInitialValue());
        }
        const animationOptions = {
          delay: time.ms(delay),
          duration: time.ms(duration),
          endDelay: time.ms(endDelay),
          easing: !isEasingList(easing) ? convertEasing(easing, duration) : void 0,
          direction,
          iterations: repeat + 1,
          fill: "both"
        };
        animation = element.animate({
          [name2]: keyframes,
          offset,
          easing: isEasingList(easing) ? easing.map((thisEasing) => convertEasing(thisEasing, duration)) : void 0
        }, animationOptions);
        if (!animation.finished) {
          animation.finished = new Promise((resolve, reject) => {
            animation.onfinish = resolve;
            animation.oncancel = reject;
          });
        }
        const target = keyframes[keyframes.length - 1];
        animation.finished.then(() => {
          if (persist2)
            return;
          style.set(element, name2, target);
          animation.cancel();
        }).catch(noop);
        if (!allowWebkitAcceleration)
          animation.playbackRate = 1.000001;
      } else if (AnimationPolyfill && valueIsTransform) {
        keyframes = keyframes.map((value) => typeof value === "string" ? parseFloat(value) : value);
        if (keyframes.length === 1) {
          keyframes.unshift(parseFloat(readInitialValue()));
        }
        animation = new AnimationPolyfill((latest) => {
          style.set(element, name2, toUnit ? toUnit(latest) : latest);
        }, keyframes, Object.assign(Object.assign({}, options2), {
          duration,
          easing
        }));
      } else {
        const target = keyframes[keyframes.length - 1];
        style.set(element, name2, definition && isNumber(target) ? definition.toDefaultUnit(target) : target);
      }
      if (isRecording) {
        record(element, key2, keyframes, {
          duration,
          delay,
          easing,
          repeat,
          offset
        }, "motion-one");
      }
      motionValue.setAnimation(animation);
      return animation;
    };
  }
  var init_animate_style_es = __esm({
    "node_modules/@motionone/dom/dist/animate/animate-style.es.js"() {
      init_data_es();
      init_css_var_es();
      init_index_es8();
      init_transforms_es();
      init_easing_es3();
      init_feature_detection_es();
      init_keyframes_es();
      init_style_es();
      init_get_style_name_es();
      init_stop_animation_es();
      init_get_unit_es();
    }
  });

  // node_modules/@motionone/dom/dist/animate/utils/options.es.js
  var getOptions;
  var init_options_es = __esm({
    "node_modules/@motionone/dom/dist/animate/utils/options.es.js"() {
      getOptions = (options2, key2) => (
        /**
         * TODO: Make test for this
         * Always return a new object otherwise delay is overwritten by results of stagger
         * and this results in no stagger
         */
        options2[key2] ? Object.assign(Object.assign({}, options2), options2[key2]) : Object.assign({}, options2)
      );
    }
  });

  // node_modules/@motionone/dom/dist/utils/resolve-elements.es.js
  function resolveElements(elements, selectorCache) {
    var _a2;
    if (typeof elements === "string") {
      if (selectorCache) {
        (_a2 = selectorCache[elements]) !== null && _a2 !== void 0 ? _a2 : selectorCache[elements] = document.querySelectorAll(elements);
        elements = selectorCache[elements];
      } else {
        elements = document.querySelectorAll(elements);
      }
    } else if (elements instanceof Element) {
      elements = [elements];
    }
    return Array.from(elements || []);
  }
  var init_resolve_elements_es = __esm({
    "node_modules/@motionone/dom/dist/utils/resolve-elements.es.js"() {
    }
  });

  // node_modules/@motionone/dom/dist/animate/utils/controls.es.js
  var createAnimation, withControls, getActiveAnimation, controls, selectFinished;
  var init_controls_es = __esm({
    "node_modules/@motionone/dom/dist/animate/utils/controls.es.js"() {
      init_index_es8();
      init_stop_animation_es();
      createAnimation = (factory) => factory();
      withControls = (animationFactory, options2, duration = defaults.duration) => {
        return new Proxy({
          animations: animationFactory.map(createAnimation).filter(Boolean),
          duration,
          options: options2
        }, controls);
      };
      getActiveAnimation = (state) => state.animations[0];
      controls = {
        get: (target, key2) => {
          const activeAnimation = getActiveAnimation(target);
          switch (key2) {
            case "duration":
              return target.duration;
            case "currentTime":
              return time.s((activeAnimation === null || activeAnimation === void 0 ? void 0 : activeAnimation[key2]) || 0);
            case "playbackRate":
            case "playState":
              return activeAnimation === null || activeAnimation === void 0 ? void 0 : activeAnimation[key2];
            case "finished":
              if (!target.finished) {
                target.finished = Promise.all(target.animations.map(selectFinished)).catch(noop);
              }
              return target.finished;
            case "stop":
              return () => {
                target.animations.forEach((animation) => stopAnimation(animation));
              };
            case "forEachNative":
              return (callback) => {
                target.animations.forEach((animation) => callback(animation, target));
              };
            default:
              return typeof (activeAnimation === null || activeAnimation === void 0 ? void 0 : activeAnimation[key2]) === "undefined" ? void 0 : () => target.animations.forEach((animation) => animation[key2]());
          }
        },
        set: (target, key2, value) => {
          switch (key2) {
            case "currentTime":
              value = time.ms(value);
            case "playbackRate":
              for (let i7 = 0; i7 < target.animations.length; i7++) {
                target.animations[i7][key2] = value;
              }
              return true;
          }
          return false;
        }
      };
      selectFinished = (animation) => animation.finished;
    }
  });

  // node_modules/@motionone/dom/dist/utils/stagger.es.js
  function resolveOption(option, i7, total) {
    return isFunction(option) ? option(i7, total) : option;
  }
  var init_stagger_es = __esm({
    "node_modules/@motionone/dom/dist/utils/stagger.es.js"() {
      init_index_es8();
    }
  });

  // node_modules/@motionone/dom/dist/animate/create-animate.es.js
  function createAnimate(AnimatePolyfill) {
    return function animate3(elements, keyframes, options2 = {}) {
      elements = resolveElements(elements);
      const numElements = elements.length;
      invariant(Boolean(numElements), "No valid element provided.");
      invariant(Boolean(keyframes), "No keyframes defined.");
      const animationFactories = [];
      for (let i7 = 0; i7 < numElements; i7++) {
        const element = elements[i7];
        for (const key2 in keyframes) {
          const valueOptions = getOptions(options2, key2);
          valueOptions.delay = resolveOption(valueOptions.delay, i7, numElements);
          const animation = animateStyle(element, key2, keyframes[key2], valueOptions, AnimatePolyfill);
          animationFactories.push(animation);
        }
      }
      return withControls(
        animationFactories,
        options2,
        /**
         * TODO:
         * If easing is set to spring or glide, duration will be dynamically
         * generated. Ideally we would dynamically generate this from
         * animation.effect.getComputedTiming().duration but this isn't
         * supported in iOS13 or our number polyfill. Perhaps it's possible
         * to Proxy animations returned from animateStyle that has duration
         * as a getter.
         */
        options2.duration
      );
    };
  }
  var init_create_animate_es = __esm({
    "node_modules/@motionone/dom/dist/animate/create-animate.es.js"() {
      init_hey_listen_es();
      init_animate_style_es();
      init_options_es();
      init_resolve_elements_es();
      init_controls_es();
      init_stagger_es();
    }
  });

  // node_modules/@motionone/dom/dist/animate/index.es.js
  var animate;
  var init_index_es12 = __esm({
    "node_modules/@motionone/dom/dist/animate/index.es.js"() {
      init_index_es10();
      init_create_animate_es();
      animate = createAnimate(Animation);
    }
  });

  // node_modules/@motionone/dom/dist/index.es.js
  var init_index_es13 = __esm({
    "node_modules/@motionone/dom/dist/index.es.js"() {
      init_index_es12();
      init_controls_es();
    }
  });

  // node_modules/motion/dist/animate.es.js
  function animateProgress(target, options2 = {}) {
    return withControls([
      () => {
        const animation = new Animation(target, [0, 1], options2);
        animation.finished.catch(() => {
        });
        return animation;
      }
    ], options2, options2.duration);
  }
  function animate2(target, keyframesOrOptions, options2) {
    const factory = isFunction(target) ? animateProgress : animate;
    return factory(target, keyframesOrOptions, options2);
  }
  var init_animate_es = __esm({
    "node_modules/motion/dist/animate.es.js"() {
      init_index_es13();
      init_index_es8();
      init_index_es10();
    }
  });

  // node_modules/motion/dist/main.es.js
  var init_main_es = __esm({
    "node_modules/motion/dist/main.es.js"() {
      init_index_es13();
      init_index_es11();
      init_animate_es();
    }
  });

  // node_modules/lit-html/directives/if-defined.js
  var l7;
  var init_if_defined = __esm({
    "node_modules/lit-html/directives/if-defined.js"() {
      init_lit_html();
      l7 = (l9) => null != l9 ? l9 : A3;
    }
  });

  // node_modules/@walletconnect/modal-ui/node_modules/lit/directives/if-defined.js
  var init_if_defined2 = __esm({
    "node_modules/@walletconnect/modal-ui/node_modules/lit/directives/if-defined.js"() {
      init_if_defined();
    }
  });

  // node_modules/qrcode/lib/can-promise.js
  var require_can_promise = __commonJS({
    "node_modules/qrcode/lib/can-promise.js"(exports, module) {
      module.exports = function() {
        return typeof Promise === "function" && Promise.prototype && Promise.prototype.then;
      };
    }
  });

  // node_modules/qrcode/lib/core/utils.js
  var require_utils3 = __commonJS({
    "node_modules/qrcode/lib/core/utils.js"(exports) {
      var toSJISFunction;
      var CODEWORDS_COUNT = [
        0,
        // Not used
        26,
        44,
        70,
        100,
        134,
        172,
        196,
        242,
        292,
        346,
        404,
        466,
        532,
        581,
        655,
        733,
        815,
        901,
        991,
        1085,
        1156,
        1258,
        1364,
        1474,
        1588,
        1706,
        1828,
        1921,
        2051,
        2185,
        2323,
        2465,
        2611,
        2761,
        2876,
        3034,
        3196,
        3362,
        3532,
        3706
      ];
      exports.getSymbolSize = function getSymbolSize(version30) {
        if (!version30)
          throw new Error('"version" cannot be null or undefined');
        if (version30 < 1 || version30 > 40)
          throw new Error('"version" should be in range from 1 to 40');
        return version30 * 4 + 17;
      };
      exports.getSymbolTotalCodewords = function getSymbolTotalCodewords(version30) {
        return CODEWORDS_COUNT[version30];
      };
      exports.getBCHDigit = function(data2) {
        let digit = 0;
        while (data2 !== 0) {
          digit++;
          data2 >>>= 1;
        }
        return digit;
      };
      exports.setToSJISFunction = function setToSJISFunction(f7) {
        if (typeof f7 !== "function") {
          throw new Error('"toSJISFunc" is not a valid function.');
        }
        toSJISFunction = f7;
      };
      exports.isKanjiModeEnabled = function() {
        return typeof toSJISFunction !== "undefined";
      };
      exports.toSJIS = function toSJIS(kanji) {
        return toSJISFunction(kanji);
      };
    }
  });

  // node_modules/qrcode/lib/core/error-correction-level.js
  var require_error_correction_level = __commonJS({
    "node_modules/qrcode/lib/core/error-correction-level.js"(exports) {
      exports.L = { bit: 1 };
      exports.M = { bit: 0 };
      exports.Q = { bit: 3 };
      exports.H = { bit: 2 };
      function fromString3(string2) {
        if (typeof string2 !== "string") {
          throw new Error("Param is not a string");
        }
        const lcStr = string2.toLowerCase();
        switch (lcStr) {
          case "l":
          case "low":
            return exports.L;
          case "m":
          case "medium":
            return exports.M;
          case "q":
          case "quartile":
            return exports.Q;
          case "h":
          case "high":
            return exports.H;
          default:
            throw new Error("Unknown EC Level: " + string2);
        }
      }
      exports.isValid = function isValid(level) {
        return level && typeof level.bit !== "undefined" && level.bit >= 0 && level.bit < 4;
      };
      exports.from = function from3(value, defaultValue) {
        if (exports.isValid(value)) {
          return value;
        }
        try {
          return fromString3(value);
        } catch (e9) {
          return defaultValue;
        }
      };
    }
  });

  // node_modules/qrcode/lib/core/bit-buffer.js
  var require_bit_buffer = __commonJS({
    "node_modules/qrcode/lib/core/bit-buffer.js"(exports, module) {
      function BitBuffer() {
        this.buffer = [];
        this.length = 0;
      }
      BitBuffer.prototype = {
        get: function(index2) {
          const bufIndex = Math.floor(index2 / 8);
          return (this.buffer[bufIndex] >>> 7 - index2 % 8 & 1) === 1;
        },
        put: function(num, length2) {
          for (let i7 = 0; i7 < length2; i7++) {
            this.putBit((num >>> length2 - i7 - 1 & 1) === 1);
          }
        },
        getLengthInBits: function() {
          return this.length;
        },
        putBit: function(bit) {
          const bufIndex = Math.floor(this.length / 8);
          if (this.buffer.length <= bufIndex) {
            this.buffer.push(0);
          }
          if (bit) {
            this.buffer[bufIndex] |= 128 >>> this.length % 8;
          }
          this.length++;
        }
      };
      module.exports = BitBuffer;
    }
  });

  // node_modules/qrcode/lib/core/bit-matrix.js
  var require_bit_matrix = __commonJS({
    "node_modules/qrcode/lib/core/bit-matrix.js"(exports, module) {
      function BitMatrix(size3) {
        if (!size3 || size3 < 1) {
          throw new Error("BitMatrix size must be defined and greater than 0");
        }
        this.size = size3;
        this.data = new Uint8Array(size3 * size3);
        this.reservedBit = new Uint8Array(size3 * size3);
      }
      BitMatrix.prototype.set = function(row, col, value, reserved) {
        const index2 = row * this.size + col;
        this.data[index2] = value;
        if (reserved)
          this.reservedBit[index2] = true;
      };
      BitMatrix.prototype.get = function(row, col) {
        return this.data[row * this.size + col];
      };
      BitMatrix.prototype.xor = function(row, col, value) {
        this.data[row * this.size + col] ^= value;
      };
      BitMatrix.prototype.isReserved = function(row, col) {
        return this.reservedBit[row * this.size + col];
      };
      module.exports = BitMatrix;
    }
  });

  // node_modules/qrcode/lib/core/alignment-pattern.js
  var require_alignment_pattern = __commonJS({
    "node_modules/qrcode/lib/core/alignment-pattern.js"(exports) {
      var getSymbolSize = require_utils3().getSymbolSize;
      exports.getRowColCoords = function getRowColCoords(version30) {
        if (version30 === 1)
          return [];
        const posCount = Math.floor(version30 / 7) + 2;
        const size3 = getSymbolSize(version30);
        const intervals = size3 === 145 ? 26 : Math.ceil((size3 - 13) / (2 * posCount - 2)) * 2;
        const positions = [size3 - 7];
        for (let i7 = 1; i7 < posCount - 1; i7++) {
          positions[i7] = positions[i7 - 1] - intervals;
        }
        positions.push(6);
        return positions.reverse();
      };
      exports.getPositions = function getPositions(version30) {
        const coords = [];
        const pos = exports.getRowColCoords(version30);
        const posLength = pos.length;
        for (let i7 = 0; i7 < posLength; i7++) {
          for (let j7 = 0; j7 < posLength; j7++) {
            if (i7 === 0 && j7 === 0 || // top-left
            i7 === 0 && j7 === posLength - 1 || // bottom-left
            i7 === posLength - 1 && j7 === 0) {
              continue;
            }
            coords.push([pos[i7], pos[j7]]);
          }
        }
        return coords;
      };
    }
  });

  // node_modules/qrcode/lib/core/finder-pattern.js
  var require_finder_pattern = __commonJS({
    "node_modules/qrcode/lib/core/finder-pattern.js"(exports) {
      var getSymbolSize = require_utils3().getSymbolSize;
      var FINDER_PATTERN_SIZE = 7;
      exports.getPositions = function getPositions(version30) {
        const size3 = getSymbolSize(version30);
        return [
          // top-left
          [0, 0],
          // top-right
          [size3 - FINDER_PATTERN_SIZE, 0],
          // bottom-left
          [0, size3 - FINDER_PATTERN_SIZE]
        ];
      };
    }
  });

  // node_modules/qrcode/lib/core/mask-pattern.js
  var require_mask_pattern = __commonJS({
    "node_modules/qrcode/lib/core/mask-pattern.js"(exports) {
      exports.Patterns = {
        PATTERN000: 0,
        PATTERN001: 1,
        PATTERN010: 2,
        PATTERN011: 3,
        PATTERN100: 4,
        PATTERN101: 5,
        PATTERN110: 6,
        PATTERN111: 7
      };
      var PenaltyScores = {
        N1: 3,
        N2: 3,
        N3: 40,
        N4: 10
      };
      exports.isValid = function isValid(mask) {
        return mask != null && mask !== "" && !isNaN(mask) && mask >= 0 && mask <= 7;
      };
      exports.from = function from3(value) {
        return exports.isValid(value) ? parseInt(value, 10) : void 0;
      };
      exports.getPenaltyN1 = function getPenaltyN1(data2) {
        const size3 = data2.size;
        let points = 0;
        let sameCountCol = 0;
        let sameCountRow = 0;
        let lastCol = null;
        let lastRow = null;
        for (let row = 0; row < size3; row++) {
          sameCountCol = sameCountRow = 0;
          lastCol = lastRow = null;
          for (let col = 0; col < size3; col++) {
            let module2 = data2.get(row, col);
            if (module2 === lastCol) {
              sameCountCol++;
            } else {
              if (sameCountCol >= 5)
                points += PenaltyScores.N1 + (sameCountCol - 5);
              lastCol = module2;
              sameCountCol = 1;
            }
            module2 = data2.get(col, row);
            if (module2 === lastRow) {
              sameCountRow++;
            } else {
              if (sameCountRow >= 5)
                points += PenaltyScores.N1 + (sameCountRow - 5);
              lastRow = module2;
              sameCountRow = 1;
            }
          }
          if (sameCountCol >= 5)
            points += PenaltyScores.N1 + (sameCountCol - 5);
          if (sameCountRow >= 5)
            points += PenaltyScores.N1 + (sameCountRow - 5);
        }
        return points;
      };
      exports.getPenaltyN2 = function getPenaltyN2(data2) {
        const size3 = data2.size;
        let points = 0;
        for (let row = 0; row < size3 - 1; row++) {
          for (let col = 0; col < size3 - 1; col++) {
            const last = data2.get(row, col) + data2.get(row, col + 1) + data2.get(row + 1, col) + data2.get(row + 1, col + 1);
            if (last === 4 || last === 0)
              points++;
          }
        }
        return points * PenaltyScores.N2;
      };
      exports.getPenaltyN3 = function getPenaltyN3(data2) {
        const size3 = data2.size;
        let points = 0;
        let bitsCol = 0;
        let bitsRow = 0;
        for (let row = 0; row < size3; row++) {
          bitsCol = bitsRow = 0;
          for (let col = 0; col < size3; col++) {
            bitsCol = bitsCol << 1 & 2047 | data2.get(row, col);
            if (col >= 10 && (bitsCol === 1488 || bitsCol === 93))
              points++;
            bitsRow = bitsRow << 1 & 2047 | data2.get(col, row);
            if (col >= 10 && (bitsRow === 1488 || bitsRow === 93))
              points++;
          }
        }
        return points * PenaltyScores.N3;
      };
      exports.getPenaltyN4 = function getPenaltyN4(data2) {
        let darkCount = 0;
        const modulesCount = data2.data.length;
        for (let i7 = 0; i7 < modulesCount; i7++)
          darkCount += data2.data[i7];
        const k6 = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);
        return k6 * PenaltyScores.N4;
      };
      function getMaskAt(maskPattern, i7, j7) {
        switch (maskPattern) {
          case exports.Patterns.PATTERN000:
            return (i7 + j7) % 2 === 0;
          case exports.Patterns.PATTERN001:
            return i7 % 2 === 0;
          case exports.Patterns.PATTERN010:
            return j7 % 3 === 0;
          case exports.Patterns.PATTERN011:
            return (i7 + j7) % 3 === 0;
          case exports.Patterns.PATTERN100:
            return (Math.floor(i7 / 2) + Math.floor(j7 / 3)) % 2 === 0;
          case exports.Patterns.PATTERN101:
            return i7 * j7 % 2 + i7 * j7 % 3 === 0;
          case exports.Patterns.PATTERN110:
            return (i7 * j7 % 2 + i7 * j7 % 3) % 2 === 0;
          case exports.Patterns.PATTERN111:
            return (i7 * j7 % 3 + (i7 + j7) % 2) % 2 === 0;
          default:
            throw new Error("bad maskPattern:" + maskPattern);
        }
      }
      exports.applyMask = function applyMask(pattern, data2) {
        const size3 = data2.size;
        for (let col = 0; col < size3; col++) {
          for (let row = 0; row < size3; row++) {
            if (data2.isReserved(row, col))
              continue;
            data2.xor(row, col, getMaskAt(pattern, row, col));
          }
        }
      };
      exports.getBestMask = function getBestMask(data2, setupFormatFunc) {
        const numPatterns = Object.keys(exports.Patterns).length;
        let bestPattern = 0;
        let lowerPenalty = Infinity;
        for (let p8 = 0; p8 < numPatterns; p8++) {
          setupFormatFunc(p8);
          exports.applyMask(p8, data2);
          const penalty = exports.getPenaltyN1(data2) + exports.getPenaltyN2(data2) + exports.getPenaltyN3(data2) + exports.getPenaltyN4(data2);
          exports.applyMask(p8, data2);
          if (penalty < lowerPenalty) {
            lowerPenalty = penalty;
            bestPattern = p8;
          }
        }
        return bestPattern;
      };
    }
  });

  // node_modules/qrcode/lib/core/error-correction-code.js
  var require_error_correction_code = __commonJS({
    "node_modules/qrcode/lib/core/error-correction-code.js"(exports) {
      var ECLevel = require_error_correction_level();
      var EC_BLOCKS_TABLE = [
        // L  M  Q  H
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        1,
        2,
        2,
        1,
        2,
        2,
        4,
        1,
        2,
        4,
        4,
        2,
        4,
        4,
        4,
        2,
        4,
        6,
        5,
        2,
        4,
        6,
        6,
        2,
        5,
        8,
        8,
        4,
        5,
        8,
        8,
        4,
        5,
        8,
        11,
        4,
        8,
        10,
        11,
        4,
        9,
        12,
        16,
        4,
        9,
        16,
        16,
        6,
        10,
        12,
        18,
        6,
        10,
        17,
        16,
        6,
        11,
        16,
        19,
        6,
        13,
        18,
        21,
        7,
        14,
        21,
        25,
        8,
        16,
        20,
        25,
        8,
        17,
        23,
        25,
        9,
        17,
        23,
        34,
        9,
        18,
        25,
        30,
        10,
        20,
        27,
        32,
        12,
        21,
        29,
        35,
        12,
        23,
        34,
        37,
        12,
        25,
        34,
        40,
        13,
        26,
        35,
        42,
        14,
        28,
        38,
        45,
        15,
        29,
        40,
        48,
        16,
        31,
        43,
        51,
        17,
        33,
        45,
        54,
        18,
        35,
        48,
        57,
        19,
        37,
        51,
        60,
        19,
        38,
        53,
        63,
        20,
        40,
        56,
        66,
        21,
        43,
        59,
        70,
        22,
        45,
        62,
        74,
        24,
        47,
        65,
        77,
        25,
        49,
        68,
        81
      ];
      var EC_CODEWORDS_TABLE = [
        // L  M  Q  H
        7,
        10,
        13,
        17,
        10,
        16,
        22,
        28,
        15,
        26,
        36,
        44,
        20,
        36,
        52,
        64,
        26,
        48,
        72,
        88,
        36,
        64,
        96,
        112,
        40,
        72,
        108,
        130,
        48,
        88,
        132,
        156,
        60,
        110,
        160,
        192,
        72,
        130,
        192,
        224,
        80,
        150,
        224,
        264,
        96,
        176,
        260,
        308,
        104,
        198,
        288,
        352,
        120,
        216,
        320,
        384,
        132,
        240,
        360,
        432,
        144,
        280,
        408,
        480,
        168,
        308,
        448,
        532,
        180,
        338,
        504,
        588,
        196,
        364,
        546,
        650,
        224,
        416,
        600,
        700,
        224,
        442,
        644,
        750,
        252,
        476,
        690,
        816,
        270,
        504,
        750,
        900,
        300,
        560,
        810,
        960,
        312,
        588,
        870,
        1050,
        336,
        644,
        952,
        1110,
        360,
        700,
        1020,
        1200,
        390,
        728,
        1050,
        1260,
        420,
        784,
        1140,
        1350,
        450,
        812,
        1200,
        1440,
        480,
        868,
        1290,
        1530,
        510,
        924,
        1350,
        1620,
        540,
        980,
        1440,
        1710,
        570,
        1036,
        1530,
        1800,
        570,
        1064,
        1590,
        1890,
        600,
        1120,
        1680,
        1980,
        630,
        1204,
        1770,
        2100,
        660,
        1260,
        1860,
        2220,
        720,
        1316,
        1950,
        2310,
        750,
        1372,
        2040,
        2430
      ];
      exports.getBlocksCount = function getBlocksCount(version30, errorCorrectionLevel) {
        switch (errorCorrectionLevel) {
          case ECLevel.L:
            return EC_BLOCKS_TABLE[(version30 - 1) * 4 + 0];
          case ECLevel.M:
            return EC_BLOCKS_TABLE[(version30 - 1) * 4 + 1];
          case ECLevel.Q:
            return EC_BLOCKS_TABLE[(version30 - 1) * 4 + 2];
          case ECLevel.H:
            return EC_BLOCKS_TABLE[(version30 - 1) * 4 + 3];
          default:
            return void 0;
        }
      };
      exports.getTotalCodewordsCount = function getTotalCodewordsCount(version30, errorCorrectionLevel) {
        switch (errorCorrectionLevel) {
          case ECLevel.L:
            return EC_CODEWORDS_TABLE[(version30 - 1) * 4 + 0];
          case ECLevel.M:
            return EC_CODEWORDS_TABLE[(version30 - 1) * 4 + 1];
          case ECLevel.Q:
            return EC_CODEWORDS_TABLE[(version30 - 1) * 4 + 2];
          case ECLevel.H:
            return EC_CODEWORDS_TABLE[(version30 - 1) * 4 + 3];
          default:
            return void 0;
        }
      };
    }
  });

  // node_modules/qrcode/lib/core/galois-field.js
  var require_galois_field = __commonJS({
    "node_modules/qrcode/lib/core/galois-field.js"(exports) {
      var EXP_TABLE = new Uint8Array(512);
      var LOG_TABLE = new Uint8Array(256);
      (function initTables() {
        let x4 = 1;
        for (let i7 = 0; i7 < 255; i7++) {
          EXP_TABLE[i7] = x4;
          LOG_TABLE[x4] = i7;
          x4 <<= 1;
          if (x4 & 256) {
            x4 ^= 285;
          }
        }
        for (let i7 = 255; i7 < 512; i7++) {
          EXP_TABLE[i7] = EXP_TABLE[i7 - 255];
        }
      })();
      exports.log = function log(n9) {
        if (n9 < 1)
          throw new Error("log(" + n9 + ")");
        return LOG_TABLE[n9];
      };
      exports.exp = function exp(n9) {
        return EXP_TABLE[n9];
      };
      exports.mul = function mul3(x4, y11) {
        if (x4 === 0 || y11 === 0)
          return 0;
        return EXP_TABLE[LOG_TABLE[x4] + LOG_TABLE[y11]];
      };
    }
  });

  // node_modules/qrcode/lib/core/polynomial.js
  var require_polynomial = __commonJS({
    "node_modules/qrcode/lib/core/polynomial.js"(exports) {
      var GF = require_galois_field();
      exports.mul = function mul3(p1, p22) {
        const coeff = new Uint8Array(p1.length + p22.length - 1);
        for (let i7 = 0; i7 < p1.length; i7++) {
          for (let j7 = 0; j7 < p22.length; j7++) {
            coeff[i7 + j7] ^= GF.mul(p1[i7], p22[j7]);
          }
        }
        return coeff;
      };
      exports.mod = function mod(divident, divisor) {
        let result = new Uint8Array(divident);
        while (result.length - divisor.length >= 0) {
          const coeff = result[0];
          for (let i7 = 0; i7 < divisor.length; i7++) {
            result[i7] ^= GF.mul(divisor[i7], coeff);
          }
          let offset = 0;
          while (offset < result.length && result[offset] === 0)
            offset++;
          result = result.slice(offset);
        }
        return result;
      };
      exports.generateECPolynomial = function generateECPolynomial(degree) {
        let poly = new Uint8Array([1]);
        for (let i7 = 0; i7 < degree; i7++) {
          poly = exports.mul(poly, new Uint8Array([1, GF.exp(i7)]));
        }
        return poly;
      };
    }
  });

  // node_modules/qrcode/lib/core/reed-solomon-encoder.js
  var require_reed_solomon_encoder = __commonJS({
    "node_modules/qrcode/lib/core/reed-solomon-encoder.js"(exports, module) {
      var Polynomial = require_polynomial();
      function ReedSolomonEncoder(degree) {
        this.genPoly = void 0;
        this.degree = degree;
        if (this.degree)
          this.initialize(this.degree);
      }
      ReedSolomonEncoder.prototype.initialize = function initialize(degree) {
        this.degree = degree;
        this.genPoly = Polynomial.generateECPolynomial(this.degree);
      };
      ReedSolomonEncoder.prototype.encode = function encode10(data2) {
        if (!this.genPoly) {
          throw new Error("Encoder not initialized");
        }
        const paddedData = new Uint8Array(data2.length + this.degree);
        paddedData.set(data2);
        const remainder = Polynomial.mod(paddedData, this.genPoly);
        const start = this.degree - remainder.length;
        if (start > 0) {
          const buff = new Uint8Array(this.degree);
          buff.set(remainder, start);
          return buff;
        }
        return remainder;
      };
      module.exports = ReedSolomonEncoder;
    }
  });

  // node_modules/qrcode/lib/core/version-check.js
  var require_version_check = __commonJS({
    "node_modules/qrcode/lib/core/version-check.js"(exports) {
      exports.isValid = function isValid(version30) {
        return !isNaN(version30) && version30 >= 1 && version30 <= 40;
      };
    }
  });

  // node_modules/qrcode/lib/core/regex.js
  var require_regex = __commonJS({
    "node_modules/qrcode/lib/core/regex.js"(exports) {
      var numeric = "[0-9]+";
      var alphanumeric = "[A-Z $%*+\\-./:]+";
      var kanji = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
      kanji = kanji.replace(/u/g, "\\u");
      var byte = "(?:(?![A-Z0-9 $%*+\\-./:]|" + kanji + ")(?:.|[\r\n]))+";
      exports.KANJI = new RegExp(kanji, "g");
      exports.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
      exports.BYTE = new RegExp(byte, "g");
      exports.NUMERIC = new RegExp(numeric, "g");
      exports.ALPHANUMERIC = new RegExp(alphanumeric, "g");
      var TEST_KANJI = new RegExp("^" + kanji + "$");
      var TEST_NUMERIC = new RegExp("^" + numeric + "$");
      var TEST_ALPHANUMERIC = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
      exports.testKanji = function testKanji(str) {
        return TEST_KANJI.test(str);
      };
      exports.testNumeric = function testNumeric(str) {
        return TEST_NUMERIC.test(str);
      };
      exports.testAlphanumeric = function testAlphanumeric(str) {
        return TEST_ALPHANUMERIC.test(str);
      };
    }
  });

  // node_modules/qrcode/lib/core/mode.js
  var require_mode = __commonJS({
    "node_modules/qrcode/lib/core/mode.js"(exports) {
      var VersionCheck = require_version_check();
      var Regex = require_regex();
      exports.NUMERIC = {
        id: "Numeric",
        bit: 1 << 0,
        ccBits: [10, 12, 14]
      };
      exports.ALPHANUMERIC = {
        id: "Alphanumeric",
        bit: 1 << 1,
        ccBits: [9, 11, 13]
      };
      exports.BYTE = {
        id: "Byte",
        bit: 1 << 2,
        ccBits: [8, 16, 16]
      };
      exports.KANJI = {
        id: "Kanji",
        bit: 1 << 3,
        ccBits: [8, 10, 12]
      };
      exports.MIXED = {
        bit: -1
      };
      exports.getCharCountIndicator = function getCharCountIndicator(mode, version30) {
        if (!mode.ccBits)
          throw new Error("Invalid mode: " + mode);
        if (!VersionCheck.isValid(version30)) {
          throw new Error("Invalid version: " + version30);
        }
        if (version30 >= 1 && version30 < 10)
          return mode.ccBits[0];
        else if (version30 < 27)
          return mode.ccBits[1];
        return mode.ccBits[2];
      };
      exports.getBestModeForData = function getBestModeForData(dataStr) {
        if (Regex.testNumeric(dataStr))
          return exports.NUMERIC;
        else if (Regex.testAlphanumeric(dataStr))
          return exports.ALPHANUMERIC;
        else if (Regex.testKanji(dataStr))
          return exports.KANJI;
        else
          return exports.BYTE;
      };
      exports.toString = function toString5(mode) {
        if (mode && mode.id)
          return mode.id;
        throw new Error("Invalid mode");
      };
      exports.isValid = function isValid(mode) {
        return mode && mode.bit && mode.ccBits;
      };
      function fromString3(string2) {
        if (typeof string2 !== "string") {
          throw new Error("Param is not a string");
        }
        const lcStr = string2.toLowerCase();
        switch (lcStr) {
          case "numeric":
            return exports.NUMERIC;
          case "alphanumeric":
            return exports.ALPHANUMERIC;
          case "kanji":
            return exports.KANJI;
          case "byte":
            return exports.BYTE;
          default:
            throw new Error("Unknown mode: " + string2);
        }
      }
      exports.from = function from3(value, defaultValue) {
        if (exports.isValid(value)) {
          return value;
        }
        try {
          return fromString3(value);
        } catch (e9) {
          return defaultValue;
        }
      };
    }
  });

  // node_modules/qrcode/lib/core/version.js
  var require_version = __commonJS({
    "node_modules/qrcode/lib/core/version.js"(exports) {
      var Utils = require_utils3();
      var ECCode = require_error_correction_code();
      var ECLevel = require_error_correction_level();
      var Mode = require_mode();
      var VersionCheck = require_version_check();
      var G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;
      var G18_BCH = Utils.getBCHDigit(G18);
      function getBestVersionForDataLength(mode, length2, errorCorrectionLevel) {
        for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
          if (length2 <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode)) {
            return currentVersion;
          }
        }
        return void 0;
      }
      function getReservedBitsCount(mode, version30) {
        return Mode.getCharCountIndicator(mode, version30) + 4;
      }
      function getTotalBitsFromDataArray(segments, version30) {
        let totalBits = 0;
        segments.forEach(function(data2) {
          const reservedBits = getReservedBitsCount(data2.mode, version30);
          totalBits += reservedBits + data2.getBitsLength();
        });
        return totalBits;
      }
      function getBestVersionForMixedData(segments, errorCorrectionLevel) {
        for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
          const length2 = getTotalBitsFromDataArray(segments, currentVersion);
          if (length2 <= exports.getCapacity(currentVersion, errorCorrectionLevel, Mode.MIXED)) {
            return currentVersion;
          }
        }
        return void 0;
      }
      exports.from = function from3(value, defaultValue) {
        if (VersionCheck.isValid(value)) {
          return parseInt(value, 10);
        }
        return defaultValue;
      };
      exports.getCapacity = function getCapacity(version30, errorCorrectionLevel, mode) {
        if (!VersionCheck.isValid(version30)) {
          throw new Error("Invalid QR Code version");
        }
        if (typeof mode === "undefined")
          mode = Mode.BYTE;
        const totalCodewords = Utils.getSymbolTotalCodewords(version30);
        const ecTotalCodewords = ECCode.getTotalCodewordsCount(version30, errorCorrectionLevel);
        const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
        if (mode === Mode.MIXED)
          return dataTotalCodewordsBits;
        const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode, version30);
        switch (mode) {
          case Mode.NUMERIC:
            return Math.floor(usableBits / 10 * 3);
          case Mode.ALPHANUMERIC:
            return Math.floor(usableBits / 11 * 2);
          case Mode.KANJI:
            return Math.floor(usableBits / 13);
          case Mode.BYTE:
          default:
            return Math.floor(usableBits / 8);
        }
      };
      exports.getBestVersionForData = function getBestVersionForData(data2, errorCorrectionLevel) {
        let seg;
        const ecl = ECLevel.from(errorCorrectionLevel, ECLevel.M);
        if (Array.isArray(data2)) {
          if (data2.length > 1) {
            return getBestVersionForMixedData(data2, ecl);
          }
          if (data2.length === 0) {
            return 1;
          }
          seg = data2[0];
        } else {
          seg = data2;
        }
        return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);
      };
      exports.getEncodedBits = function getEncodedBits(version30) {
        if (!VersionCheck.isValid(version30) || version30 < 7) {
          throw new Error("Invalid QR Code version");
        }
        let d7 = version30 << 12;
        while (Utils.getBCHDigit(d7) - G18_BCH >= 0) {
          d7 ^= G18 << Utils.getBCHDigit(d7) - G18_BCH;
        }
        return version30 << 12 | d7;
      };
    }
  });

  // node_modules/qrcode/lib/core/format-info.js
  var require_format_info = __commonJS({
    "node_modules/qrcode/lib/core/format-info.js"(exports) {
      var Utils = require_utils3();
      var G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;
      var G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;
      var G15_BCH = Utils.getBCHDigit(G15);
      exports.getEncodedBits = function getEncodedBits(errorCorrectionLevel, mask) {
        const data2 = errorCorrectionLevel.bit << 3 | mask;
        let d7 = data2 << 10;
        while (Utils.getBCHDigit(d7) - G15_BCH >= 0) {
          d7 ^= G15 << Utils.getBCHDigit(d7) - G15_BCH;
        }
        return (data2 << 10 | d7) ^ G15_MASK;
      };
    }
  });

  // node_modules/qrcode/lib/core/numeric-data.js
  var require_numeric_data = __commonJS({
    "node_modules/qrcode/lib/core/numeric-data.js"(exports, module) {
      var Mode = require_mode();
      function NumericData(data2) {
        this.mode = Mode.NUMERIC;
        this.data = data2.toString();
      }
      NumericData.getBitsLength = function getBitsLength(length2) {
        return 10 * Math.floor(length2 / 3) + (length2 % 3 ? length2 % 3 * 3 + 1 : 0);
      };
      NumericData.prototype.getLength = function getLength2() {
        return this.data.length;
      };
      NumericData.prototype.getBitsLength = function getBitsLength() {
        return NumericData.getBitsLength(this.data.length);
      };
      NumericData.prototype.write = function write(bitBuffer) {
        let i7, group, value;
        for (i7 = 0; i7 + 3 <= this.data.length; i7 += 3) {
          group = this.data.substr(i7, 3);
          value = parseInt(group, 10);
          bitBuffer.put(value, 10);
        }
        const remainingNum = this.data.length - i7;
        if (remainingNum > 0) {
          group = this.data.substr(i7);
          value = parseInt(group, 10);
          bitBuffer.put(value, remainingNum * 3 + 1);
        }
      };
      module.exports = NumericData;
    }
  });

  // node_modules/qrcode/lib/core/alphanumeric-data.js
  var require_alphanumeric_data = __commonJS({
    "node_modules/qrcode/lib/core/alphanumeric-data.js"(exports, module) {
      var Mode = require_mode();
      var ALPHA_NUM_CHARS = [
        "0",
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "A",
        "B",
        "C",
        "D",
        "E",
        "F",
        "G",
        "H",
        "I",
        "J",
        "K",
        "L",
        "M",
        "N",
        "O",
        "P",
        "Q",
        "R",
        "S",
        "T",
        "U",
        "V",
        "W",
        "X",
        "Y",
        "Z",
        " ",
        "$",
        "%",
        "*",
        "+",
        "-",
        ".",
        "/",
        ":"
      ];
      function AlphanumericData(data2) {
        this.mode = Mode.ALPHANUMERIC;
        this.data = data2;
      }
      AlphanumericData.getBitsLength = function getBitsLength(length2) {
        return 11 * Math.floor(length2 / 2) + 6 * (length2 % 2);
      };
      AlphanumericData.prototype.getLength = function getLength2() {
        return this.data.length;
      };
      AlphanumericData.prototype.getBitsLength = function getBitsLength() {
        return AlphanumericData.getBitsLength(this.data.length);
      };
      AlphanumericData.prototype.write = function write(bitBuffer) {
        let i7;
        for (i7 = 0; i7 + 2 <= this.data.length; i7 += 2) {
          let value = ALPHA_NUM_CHARS.indexOf(this.data[i7]) * 45;
          value += ALPHA_NUM_CHARS.indexOf(this.data[i7 + 1]);
          bitBuffer.put(value, 11);
        }
        if (this.data.length % 2) {
          bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i7]), 6);
        }
      };
      module.exports = AlphanumericData;
    }
  });

  // node_modules/encode-utf8/index.js
  var require_encode_utf8 = __commonJS({
    "node_modules/encode-utf8/index.js"(exports, module) {
      "use strict";
      module.exports = function encodeUtf8(input) {
        var result = [];
        var size3 = input.length;
        for (var index2 = 0; index2 < size3; index2++) {
          var point3 = input.charCodeAt(index2);
          if (point3 >= 55296 && point3 <= 56319 && size3 > index2 + 1) {
            var second = input.charCodeAt(index2 + 1);
            if (second >= 56320 && second <= 57343) {
              point3 = (point3 - 55296) * 1024 + second - 56320 + 65536;
              index2 += 1;
            }
          }
          if (point3 < 128) {
            result.push(point3);
            continue;
          }
          if (point3 < 2048) {
            result.push(point3 >> 6 | 192);
            result.push(point3 & 63 | 128);
            continue;
          }
          if (point3 < 55296 || point3 >= 57344 && point3 < 65536) {
            result.push(point3 >> 12 | 224);
            result.push(point3 >> 6 & 63 | 128);
            result.push(point3 & 63 | 128);
            continue;
          }
          if (point3 >= 65536 && point3 <= 1114111) {
            result.push(point3 >> 18 | 240);
            result.push(point3 >> 12 & 63 | 128);
            result.push(point3 >> 6 & 63 | 128);
            result.push(point3 & 63 | 128);
            continue;
          }
          result.push(239, 191, 189);
        }
        return new Uint8Array(result).buffer;
      };
    }
  });

  // node_modules/qrcode/lib/core/byte-data.js
  var require_byte_data = __commonJS({
    "node_modules/qrcode/lib/core/byte-data.js"(exports, module) {
      var encodeUtf8 = require_encode_utf8();
      var Mode = require_mode();
      function ByteData(data2) {
        this.mode = Mode.BYTE;
        if (typeof data2 === "string") {
          data2 = encodeUtf8(data2);
        }
        this.data = new Uint8Array(data2);
      }
      ByteData.getBitsLength = function getBitsLength(length2) {
        return length2 * 8;
      };
      ByteData.prototype.getLength = function getLength2() {
        return this.data.length;
      };
      ByteData.prototype.getBitsLength = function getBitsLength() {
        return ByteData.getBitsLength(this.data.length);
      };
      ByteData.prototype.write = function(bitBuffer) {
        for (let i7 = 0, l9 = this.data.length; i7 < l9; i7++) {
          bitBuffer.put(this.data[i7], 8);
        }
      };
      module.exports = ByteData;
    }
  });

  // node_modules/qrcode/lib/core/kanji-data.js
  var require_kanji_data = __commonJS({
    "node_modules/qrcode/lib/core/kanji-data.js"(exports, module) {
      var Mode = require_mode();
      var Utils = require_utils3();
      function KanjiData(data2) {
        this.mode = Mode.KANJI;
        this.data = data2;
      }
      KanjiData.getBitsLength = function getBitsLength(length2) {
        return length2 * 13;
      };
      KanjiData.prototype.getLength = function getLength2() {
        return this.data.length;
      };
      KanjiData.prototype.getBitsLength = function getBitsLength() {
        return KanjiData.getBitsLength(this.data.length);
      };
      KanjiData.prototype.write = function(bitBuffer) {
        let i7;
        for (i7 = 0; i7 < this.data.length; i7++) {
          let value = Utils.toSJIS(this.data[i7]);
          if (value >= 33088 && value <= 40956) {
            value -= 33088;
          } else if (value >= 57408 && value <= 60351) {
            value -= 49472;
          } else {
            throw new Error(
              "Invalid SJIS character: " + this.data[i7] + "\nMake sure your charset is UTF-8"
            );
          }
          value = (value >>> 8 & 255) * 192 + (value & 255);
          bitBuffer.put(value, 13);
        }
      };
      module.exports = KanjiData;
    }
  });

  // node_modules/dijkstrajs/dijkstra.js
  var require_dijkstra = __commonJS({
    "node_modules/dijkstrajs/dijkstra.js"(exports, module) {
      "use strict";
      var dijkstra = {
        single_source_shortest_paths: function(graph, s7, d7) {
          var predecessors = {};
          var costs = {};
          costs[s7] = 0;
          var open = dijkstra.PriorityQueue.make();
          open.push(s7, 0);
          var closest, u7, v6, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;
          while (!open.empty()) {
            closest = open.pop();
            u7 = closest.value;
            cost_of_s_to_u = closest.cost;
            adjacent_nodes = graph[u7] || {};
            for (v6 in adjacent_nodes) {
              if (adjacent_nodes.hasOwnProperty(v6)) {
                cost_of_e = adjacent_nodes[v6];
                cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;
                cost_of_s_to_v = costs[v6];
                first_visit = typeof costs[v6] === "undefined";
                if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
                  costs[v6] = cost_of_s_to_u_plus_cost_of_e;
                  open.push(v6, cost_of_s_to_u_plus_cost_of_e);
                  predecessors[v6] = u7;
                }
              }
            }
          }
          if (typeof d7 !== "undefined" && typeof costs[d7] === "undefined") {
            var msg = ["Could not find a path from ", s7, " to ", d7, "."].join("");
            throw new Error(msg);
          }
          return predecessors;
        },
        extract_shortest_path_from_predecessor_list: function(predecessors, d7) {
          var nodes = [];
          var u7 = d7;
          var predecessor;
          while (u7) {
            nodes.push(u7);
            predecessor = predecessors[u7];
            u7 = predecessors[u7];
          }
          nodes.reverse();
          return nodes;
        },
        find_path: function(graph, s7, d7) {
          var predecessors = dijkstra.single_source_shortest_paths(graph, s7, d7);
          return dijkstra.extract_shortest_path_from_predecessor_list(
            predecessors,
            d7
          );
        },
        /**
         * A very naive priority queue implementation.
         */
        PriorityQueue: {
          make: function(opts) {
            var T6 = dijkstra.PriorityQueue, t6 = {}, key2;
            opts = opts || {};
            for (key2 in T6) {
              if (T6.hasOwnProperty(key2)) {
                t6[key2] = T6[key2];
              }
            }
            t6.queue = [];
            t6.sorter = opts.sorter || T6.default_sorter;
            return t6;
          },
          default_sorter: function(a6, b7) {
            return a6.cost - b7.cost;
          },
          /**
           * Add a new item to the queue and ensure the highest priority element
           * is at the front of the queue.
           */
          push: function(value, cost) {
            var item = { value, cost };
            this.queue.push(item);
            this.queue.sort(this.sorter);
          },
          /**
           * Return the highest priority element in the queue.
           */
          pop: function() {
            return this.queue.shift();
          },
          empty: function() {
            return this.queue.length === 0;
          }
        }
      };
      if (typeof module !== "undefined") {
        module.exports = dijkstra;
      }
    }
  });

  // node_modules/qrcode/lib/core/segments.js
  var require_segments = __commonJS({
    "node_modules/qrcode/lib/core/segments.js"(exports) {
      var Mode = require_mode();
      var NumericData = require_numeric_data();
      var AlphanumericData = require_alphanumeric_data();
      var ByteData = require_byte_data();
      var KanjiData = require_kanji_data();
      var Regex = require_regex();
      var Utils = require_utils3();
      var dijkstra = require_dijkstra();
      function getStringByteLength(str) {
        return unescape(encodeURIComponent(str)).length;
      }
      function getSegments(regex, mode, str) {
        const segments = [];
        let result;
        while ((result = regex.exec(str)) !== null) {
          segments.push({
            data: result[0],
            index: result.index,
            mode,
            length: result[0].length
          });
        }
        return segments;
      }
      function getSegmentsFromString(dataStr) {
        const numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr);
        const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr);
        let byteSegs;
        let kanjiSegs;
        if (Utils.isKanjiModeEnabled()) {
          byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr);
          kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr);
        } else {
          byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr);
          kanjiSegs = [];
        }
        const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);
        return segs.sort(function(s1, s22) {
          return s1.index - s22.index;
        }).map(function(obj) {
          return {
            data: obj.data,
            mode: obj.mode,
            length: obj.length
          };
        });
      }
      function getSegmentBitsLength(length2, mode) {
        switch (mode) {
          case Mode.NUMERIC:
            return NumericData.getBitsLength(length2);
          case Mode.ALPHANUMERIC:
            return AlphanumericData.getBitsLength(length2);
          case Mode.KANJI:
            return KanjiData.getBitsLength(length2);
          case Mode.BYTE:
            return ByteData.getBitsLength(length2);
        }
      }
      function mergeSegments(segs) {
        return segs.reduce(function(acc, curr) {
          const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
          if (prevSeg && prevSeg.mode === curr.mode) {
            acc[acc.length - 1].data += curr.data;
            return acc;
          }
          acc.push(curr);
          return acc;
        }, []);
      }
      function buildNodes(segs) {
        const nodes = [];
        for (let i7 = 0; i7 < segs.length; i7++) {
          const seg = segs[i7];
          switch (seg.mode) {
            case Mode.NUMERIC:
              nodes.push([
                seg,
                { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },
                { data: seg.data, mode: Mode.BYTE, length: seg.length }
              ]);
              break;
            case Mode.ALPHANUMERIC:
              nodes.push([
                seg,
                { data: seg.data, mode: Mode.BYTE, length: seg.length }
              ]);
              break;
            case Mode.KANJI:
              nodes.push([
                seg,
                { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
              ]);
              break;
            case Mode.BYTE:
              nodes.push([
                { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
              ]);
          }
        }
        return nodes;
      }
      function buildGraph(nodes, version30) {
        const table = {};
        const graph = { start: {} };
        let prevNodeIds = ["start"];
        for (let i7 = 0; i7 < nodes.length; i7++) {
          const nodeGroup = nodes[i7];
          const currentNodeIds = [];
          for (let j7 = 0; j7 < nodeGroup.length; j7++) {
            const node = nodeGroup[j7];
            const key2 = "" + i7 + j7;
            currentNodeIds.push(key2);
            table[key2] = { node, lastCount: 0 };
            graph[key2] = {};
            for (let n9 = 0; n9 < prevNodeIds.length; n9++) {
              const prevNodeId = prevNodeIds[n9];
              if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {
                graph[prevNodeId][key2] = getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);
                table[prevNodeId].lastCount += node.length;
              } else {
                if (table[prevNodeId])
                  table[prevNodeId].lastCount = node.length;
                graph[prevNodeId][key2] = getSegmentBitsLength(node.length, node.mode) + 4 + Mode.getCharCountIndicator(node.mode, version30);
              }
            }
          }
          prevNodeIds = currentNodeIds;
        }
        for (let n9 = 0; n9 < prevNodeIds.length; n9++) {
          graph[prevNodeIds[n9]].end = 0;
        }
        return { map: graph, table };
      }
      function buildSingleSegment(data2, modesHint) {
        let mode;
        const bestMode = Mode.getBestModeForData(data2);
        mode = Mode.from(modesHint, bestMode);
        if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {
          throw new Error('"' + data2 + '" cannot be encoded with mode ' + Mode.toString(mode) + ".\n Suggested mode is: " + Mode.toString(bestMode));
        }
        if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {
          mode = Mode.BYTE;
        }
        switch (mode) {
          case Mode.NUMERIC:
            return new NumericData(data2);
          case Mode.ALPHANUMERIC:
            return new AlphanumericData(data2);
          case Mode.KANJI:
            return new KanjiData(data2);
          case Mode.BYTE:
            return new ByteData(data2);
        }
      }
      exports.fromArray = function fromArray(array) {
        return array.reduce(function(acc, seg) {
          if (typeof seg === "string") {
            acc.push(buildSingleSegment(seg, null));
          } else if (seg.data) {
            acc.push(buildSingleSegment(seg.data, seg.mode));
          }
          return acc;
        }, []);
      };
      exports.fromString = function fromString3(data2, version30) {
        const segs = getSegmentsFromString(data2, Utils.isKanjiModeEnabled());
        const nodes = buildNodes(segs);
        const graph = buildGraph(nodes, version30);
        const path = dijkstra.find_path(graph.map, "start", "end");
        const optimizedSegs = [];
        for (let i7 = 1; i7 < path.length - 1; i7++) {
          optimizedSegs.push(graph.table[path[i7]].node);
        }
        return exports.fromArray(mergeSegments(optimizedSegs));
      };
      exports.rawSplit = function rawSplit(data2) {
        return exports.fromArray(
          getSegmentsFromString(data2, Utils.isKanjiModeEnabled())
        );
      };
    }
  });

  // node_modules/qrcode/lib/core/qrcode.js
  var require_qrcode = __commonJS({
    "node_modules/qrcode/lib/core/qrcode.js"(exports) {
      var Utils = require_utils3();
      var ECLevel = require_error_correction_level();
      var BitBuffer = require_bit_buffer();
      var BitMatrix = require_bit_matrix();
      var AlignmentPattern = require_alignment_pattern();
      var FinderPattern = require_finder_pattern();
      var MaskPattern = require_mask_pattern();
      var ECCode = require_error_correction_code();
      var ReedSolomonEncoder = require_reed_solomon_encoder();
      var Version = require_version();
      var FormatInfo = require_format_info();
      var Mode = require_mode();
      var Segments = require_segments();
      function setupFinderPattern(matrix, version30) {
        const size3 = matrix.size;
        const pos = FinderPattern.getPositions(version30);
        for (let i7 = 0; i7 < pos.length; i7++) {
          const row = pos[i7][0];
          const col = pos[i7][1];
          for (let r8 = -1; r8 <= 7; r8++) {
            if (row + r8 <= -1 || size3 <= row + r8)
              continue;
            for (let c9 = -1; c9 <= 7; c9++) {
              if (col + c9 <= -1 || size3 <= col + c9)
                continue;
              if (r8 >= 0 && r8 <= 6 && (c9 === 0 || c9 === 6) || c9 >= 0 && c9 <= 6 && (r8 === 0 || r8 === 6) || r8 >= 2 && r8 <= 4 && c9 >= 2 && c9 <= 4) {
                matrix.set(row + r8, col + c9, true, true);
              } else {
                matrix.set(row + r8, col + c9, false, true);
              }
            }
          }
        }
      }
      function setupTimingPattern(matrix) {
        const size3 = matrix.size;
        for (let r8 = 8; r8 < size3 - 8; r8++) {
          const value = r8 % 2 === 0;
          matrix.set(r8, 6, value, true);
          matrix.set(6, r8, value, true);
        }
      }
      function setupAlignmentPattern(matrix, version30) {
        const pos = AlignmentPattern.getPositions(version30);
        for (let i7 = 0; i7 < pos.length; i7++) {
          const row = pos[i7][0];
          const col = pos[i7][1];
          for (let r8 = -2; r8 <= 2; r8++) {
            for (let c9 = -2; c9 <= 2; c9++) {
              if (r8 === -2 || r8 === 2 || c9 === -2 || c9 === 2 || r8 === 0 && c9 === 0) {
                matrix.set(row + r8, col + c9, true, true);
              } else {
                matrix.set(row + r8, col + c9, false, true);
              }
            }
          }
        }
      }
      function setupVersionInfo(matrix, version30) {
        const size3 = matrix.size;
        const bits = Version.getEncodedBits(version30);
        let row, col, mod;
        for (let i7 = 0; i7 < 18; i7++) {
          row = Math.floor(i7 / 3);
          col = i7 % 3 + size3 - 8 - 3;
          mod = (bits >> i7 & 1) === 1;
          matrix.set(row, col, mod, true);
          matrix.set(col, row, mod, true);
        }
      }
      function setupFormatInfo(matrix, errorCorrectionLevel, maskPattern) {
        const size3 = matrix.size;
        const bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern);
        let i7, mod;
        for (i7 = 0; i7 < 15; i7++) {
          mod = (bits >> i7 & 1) === 1;
          if (i7 < 6) {
            matrix.set(i7, 8, mod, true);
          } else if (i7 < 8) {
            matrix.set(i7 + 1, 8, mod, true);
          } else {
            matrix.set(size3 - 15 + i7, 8, mod, true);
          }
          if (i7 < 8) {
            matrix.set(8, size3 - i7 - 1, mod, true);
          } else if (i7 < 9) {
            matrix.set(8, 15 - i7 - 1 + 1, mod, true);
          } else {
            matrix.set(8, 15 - i7 - 1, mod, true);
          }
        }
        matrix.set(size3 - 8, 8, 1, true);
      }
      function setupData(matrix, data2) {
        const size3 = matrix.size;
        let inc = -1;
        let row = size3 - 1;
        let bitIndex = 7;
        let byteIndex = 0;
        for (let col = size3 - 1; col > 0; col -= 2) {
          if (col === 6)
            col--;
          while (true) {
            for (let c9 = 0; c9 < 2; c9++) {
              if (!matrix.isReserved(row, col - c9)) {
                let dark = false;
                if (byteIndex < data2.length) {
                  dark = (data2[byteIndex] >>> bitIndex & 1) === 1;
                }
                matrix.set(row, col - c9, dark);
                bitIndex--;
                if (bitIndex === -1) {
                  byteIndex++;
                  bitIndex = 7;
                }
              }
            }
            row += inc;
            if (row < 0 || size3 <= row) {
              row -= inc;
              inc = -inc;
              break;
            }
          }
        }
      }
      function createData(version30, errorCorrectionLevel, segments) {
        const buffer2 = new BitBuffer();
        segments.forEach(function(data2) {
          buffer2.put(data2.mode.bit, 4);
          buffer2.put(data2.getLength(), Mode.getCharCountIndicator(data2.mode, version30));
          data2.write(buffer2);
        });
        const totalCodewords = Utils.getSymbolTotalCodewords(version30);
        const ecTotalCodewords = ECCode.getTotalCodewordsCount(version30, errorCorrectionLevel);
        const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
        if (buffer2.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
          buffer2.put(0, 4);
        }
        while (buffer2.getLengthInBits() % 8 !== 0) {
          buffer2.putBit(0);
        }
        const remainingByte = (dataTotalCodewordsBits - buffer2.getLengthInBits()) / 8;
        for (let i7 = 0; i7 < remainingByte; i7++) {
          buffer2.put(i7 % 2 ? 17 : 236, 8);
        }
        return createCodewords(buffer2, version30, errorCorrectionLevel);
      }
      function createCodewords(bitBuffer, version30, errorCorrectionLevel) {
        const totalCodewords = Utils.getSymbolTotalCodewords(version30);
        const ecTotalCodewords = ECCode.getTotalCodewordsCount(version30, errorCorrectionLevel);
        const dataTotalCodewords = totalCodewords - ecTotalCodewords;
        const ecTotalBlocks = ECCode.getBlocksCount(version30, errorCorrectionLevel);
        const blocksInGroup2 = totalCodewords % ecTotalBlocks;
        const blocksInGroup1 = ecTotalBlocks - blocksInGroup2;
        const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);
        const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
        const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;
        const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;
        const rs2 = new ReedSolomonEncoder(ecCount);
        let offset = 0;
        const dcData = new Array(ecTotalBlocks);
        const ecData = new Array(ecTotalBlocks);
        let maxDataSize = 0;
        const buffer2 = new Uint8Array(bitBuffer.buffer);
        for (let b7 = 0; b7 < ecTotalBlocks; b7++) {
          const dataSize = b7 < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;
          dcData[b7] = buffer2.slice(offset, offset + dataSize);
          ecData[b7] = rs2.encode(dcData[b7]);
          offset += dataSize;
          maxDataSize = Math.max(maxDataSize, dataSize);
        }
        const data2 = new Uint8Array(totalCodewords);
        let index2 = 0;
        let i7, r8;
        for (i7 = 0; i7 < maxDataSize; i7++) {
          for (r8 = 0; r8 < ecTotalBlocks; r8++) {
            if (i7 < dcData[r8].length) {
              data2[index2++] = dcData[r8][i7];
            }
          }
        }
        for (i7 = 0; i7 < ecCount; i7++) {
          for (r8 = 0; r8 < ecTotalBlocks; r8++) {
            data2[index2++] = ecData[r8][i7];
          }
        }
        return data2;
      }
      function createSymbol(data2, version30, errorCorrectionLevel, maskPattern) {
        let segments;
        if (Array.isArray(data2)) {
          segments = Segments.fromArray(data2);
        } else if (typeof data2 === "string") {
          let estimatedVersion = version30;
          if (!estimatedVersion) {
            const rawSegments = Segments.rawSplit(data2);
            estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel);
          }
          segments = Segments.fromString(data2, estimatedVersion || 40);
        } else {
          throw new Error("Invalid data");
        }
        const bestVersion = Version.getBestVersionForData(segments, errorCorrectionLevel);
        if (!bestVersion) {
          throw new Error("The amount of data is too big to be stored in a QR Code");
        }
        if (!version30) {
          version30 = bestVersion;
        } else if (version30 < bestVersion) {
          throw new Error(
            "\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " + bestVersion + ".\n"
          );
        }
        const dataBits = createData(version30, errorCorrectionLevel, segments);
        const moduleCount = Utils.getSymbolSize(version30);
        const modules = new BitMatrix(moduleCount);
        setupFinderPattern(modules, version30);
        setupTimingPattern(modules);
        setupAlignmentPattern(modules, version30);
        setupFormatInfo(modules, errorCorrectionLevel, 0);
        if (version30 >= 7) {
          setupVersionInfo(modules, version30);
        }
        setupData(modules, dataBits);
        if (isNaN(maskPattern)) {
          maskPattern = MaskPattern.getBestMask(
            modules,
            setupFormatInfo.bind(null, modules, errorCorrectionLevel)
          );
        }
        MaskPattern.applyMask(maskPattern, modules);
        setupFormatInfo(modules, errorCorrectionLevel, maskPattern);
        return {
          modules,
          version: version30,
          errorCorrectionLevel,
          maskPattern,
          segments
        };
      }
      exports.create = function create3(data2, options2) {
        if (typeof data2 === "undefined" || data2 === "") {
          throw new Error("No input text");
        }
        let errorCorrectionLevel = ECLevel.M;
        let version30;
        let mask;
        if (typeof options2 !== "undefined") {
          errorCorrectionLevel = ECLevel.from(options2.errorCorrectionLevel, ECLevel.M);
          version30 = Version.from(options2.version);
          mask = MaskPattern.from(options2.maskPattern);
          if (options2.toSJISFunc) {
            Utils.setToSJISFunction(options2.toSJISFunc);
          }
        }
        return createSymbol(data2, version30, errorCorrectionLevel, mask);
      };
    }
  });

  // node_modules/qrcode/lib/renderer/utils.js
  var require_utils4 = __commonJS({
    "node_modules/qrcode/lib/renderer/utils.js"(exports) {
      function hex2rgba(hex) {
        if (typeof hex === "number") {
          hex = hex.toString();
        }
        if (typeof hex !== "string") {
          throw new Error("Color should be defined as hex string");
        }
        let hexCode = hex.slice().replace("#", "").split("");
        if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
          throw new Error("Invalid hex color: " + hex);
        }
        if (hexCode.length === 3 || hexCode.length === 4) {
          hexCode = Array.prototype.concat.apply([], hexCode.map(function(c9) {
            return [c9, c9];
          }));
        }
        if (hexCode.length === 6)
          hexCode.push("F", "F");
        const hexValue2 = parseInt(hexCode.join(""), 16);
        return {
          r: hexValue2 >> 24 & 255,
          g: hexValue2 >> 16 & 255,
          b: hexValue2 >> 8 & 255,
          a: hexValue2 & 255,
          hex: "#" + hexCode.slice(0, 6).join("")
        };
      }
      exports.getOptions = function getOptions2(options2) {
        if (!options2)
          options2 = {};
        if (!options2.color)
          options2.color = {};
        const margin = typeof options2.margin === "undefined" || options2.margin === null || options2.margin < 0 ? 4 : options2.margin;
        const width = options2.width && options2.width >= 21 ? options2.width : void 0;
        const scale = options2.scale || 4;
        return {
          width,
          scale: width ? 4 : scale,
          margin,
          color: {
            dark: hex2rgba(options2.color.dark || "#000000ff"),
            light: hex2rgba(options2.color.light || "#ffffffff")
          },
          type: options2.type,
          rendererOpts: options2.rendererOpts || {}
        };
      };
      exports.getScale = function getScale(qrSize, opts) {
        return opts.width && opts.width >= qrSize + opts.margin * 2 ? opts.width / (qrSize + opts.margin * 2) : opts.scale;
      };
      exports.getImageWidth = function getImageWidth(qrSize, opts) {
        const scale = exports.getScale(qrSize, opts);
        return Math.floor((qrSize + opts.margin * 2) * scale);
      };
      exports.qrToImageData = function qrToImageData(imgData, qr2, opts) {
        const size3 = qr2.modules.size;
        const data2 = qr2.modules.data;
        const scale = exports.getScale(size3, opts);
        const symbolSize = Math.floor((size3 + opts.margin * 2) * scale);
        const scaledMargin = opts.margin * scale;
        const palette = [opts.color.light, opts.color.dark];
        for (let i7 = 0; i7 < symbolSize; i7++) {
          for (let j7 = 0; j7 < symbolSize; j7++) {
            let posDst = (i7 * symbolSize + j7) * 4;
            let pxColor = opts.color.light;
            if (i7 >= scaledMargin && j7 >= scaledMargin && i7 < symbolSize - scaledMargin && j7 < symbolSize - scaledMargin) {
              const iSrc = Math.floor((i7 - scaledMargin) / scale);
              const jSrc = Math.floor((j7 - scaledMargin) / scale);
              pxColor = palette[data2[iSrc * size3 + jSrc] ? 1 : 0];
            }
            imgData[posDst++] = pxColor.r;
            imgData[posDst++] = pxColor.g;
            imgData[posDst++] = pxColor.b;
            imgData[posDst] = pxColor.a;
          }
        }
      };
    }
  });

  // node_modules/qrcode/lib/renderer/canvas.js
  var require_canvas = __commonJS({
    "node_modules/qrcode/lib/renderer/canvas.js"(exports) {
      var Utils = require_utils4();
      function clearCanvas(ctx, canvas, size3) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (!canvas.style)
          canvas.style = {};
        canvas.height = size3;
        canvas.width = size3;
        canvas.style.height = size3 + "px";
        canvas.style.width = size3 + "px";
      }
      function getCanvasElement() {
        try {
          return document.createElement("canvas");
        } catch (e9) {
          throw new Error("You need to specify a canvas element");
        }
      }
      exports.render = function render(qrData, canvas, options2) {
        let opts = options2;
        let canvasEl = canvas;
        if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
          opts = canvas;
          canvas = void 0;
        }
        if (!canvas) {
          canvasEl = getCanvasElement();
        }
        opts = Utils.getOptions(opts);
        const size3 = Utils.getImageWidth(qrData.modules.size, opts);
        const ctx = canvasEl.getContext("2d");
        const image = ctx.createImageData(size3, size3);
        Utils.qrToImageData(image.data, qrData, opts);
        clearCanvas(ctx, canvasEl, size3);
        ctx.putImageData(image, 0, 0);
        return canvasEl;
      };
      exports.renderToDataURL = function renderToDataURL(qrData, canvas, options2) {
        let opts = options2;
        if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
          opts = canvas;
          canvas = void 0;
        }
        if (!opts)
          opts = {};
        const canvasEl = exports.render(qrData, canvas, opts);
        const type = opts.type || "image/png";
        const rendererOpts = opts.rendererOpts || {};
        return canvasEl.toDataURL(type, rendererOpts.quality);
      };
    }
  });

  // node_modules/qrcode/lib/renderer/svg-tag.js
  var require_svg_tag = __commonJS({
    "node_modules/qrcode/lib/renderer/svg-tag.js"(exports) {
      var Utils = require_utils4();
      function getColorAttrib(color, attrib) {
        const alpha = color.a / 255;
        const str = attrib + '="' + color.hex + '"';
        return alpha < 1 ? str + " " + attrib + '-opacity="' + alpha.toFixed(2).slice(1) + '"' : str;
      }
      function svgCmd(cmd, x4, y11) {
        let str = cmd + x4;
        if (typeof y11 !== "undefined")
          str += " " + y11;
        return str;
      }
      function qrToPath(data2, size3, margin) {
        let path = "";
        let moveBy = 0;
        let newRow = false;
        let lineLength = 0;
        for (let i7 = 0; i7 < data2.length; i7++) {
          const col = Math.floor(i7 % size3);
          const row = Math.floor(i7 / size3);
          if (!col && !newRow)
            newRow = true;
          if (data2[i7]) {
            lineLength++;
            if (!(i7 > 0 && col > 0 && data2[i7 - 1])) {
              path += newRow ? svgCmd("M", col + margin, 0.5 + row + margin) : svgCmd("m", moveBy, 0);
              moveBy = 0;
              newRow = false;
            }
            if (!(col + 1 < size3 && data2[i7 + 1])) {
              path += svgCmd("h", lineLength);
              lineLength = 0;
            }
          } else {
            moveBy++;
          }
        }
        return path;
      }
      exports.render = function render(qrData, options2, cb) {
        const opts = Utils.getOptions(options2);
        const size3 = qrData.modules.size;
        const data2 = qrData.modules.data;
        const qrcodesize = size3 + opts.margin * 2;
        const bg = !opts.color.light.a ? "" : "<path " + getColorAttrib(opts.color.light, "fill") + ' d="M0 0h' + qrcodesize + "v" + qrcodesize + 'H0z"/>';
        const path = "<path " + getColorAttrib(opts.color.dark, "stroke") + ' d="' + qrToPath(data2, size3, opts.margin) + '"/>';
        const viewBox = 'viewBox="0 0 ' + qrcodesize + " " + qrcodesize + '"';
        const width = !opts.width ? "" : 'width="' + opts.width + '" height="' + opts.width + '" ';
        const svgTag = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg + path + "</svg>\n";
        if (typeof cb === "function") {
          cb(null, svgTag);
        }
        return svgTag;
      };
    }
  });

  // node_modules/qrcode/lib/browser.js
  var require_browser4 = __commonJS({
    "node_modules/qrcode/lib/browser.js"(exports) {
      var canPromise = require_can_promise();
      var QRCode = require_qrcode();
      var CanvasRenderer = require_canvas();
      var SvgRenderer = require_svg_tag();
      function renderCanvas(renderFunc, canvas, text, opts, cb) {
        const args = [].slice.call(arguments, 1);
        const argsNum = args.length;
        const isLastArgCb = typeof args[argsNum - 1] === "function";
        if (!isLastArgCb && !canPromise()) {
          throw new Error("Callback required as last argument");
        }
        if (isLastArgCb) {
          if (argsNum < 2) {
            throw new Error("Too few arguments provided");
          }
          if (argsNum === 2) {
            cb = text;
            text = canvas;
            canvas = opts = void 0;
          } else if (argsNum === 3) {
            if (canvas.getContext && typeof cb === "undefined") {
              cb = opts;
              opts = void 0;
            } else {
              cb = opts;
              opts = text;
              text = canvas;
              canvas = void 0;
            }
          }
        } else {
          if (argsNum < 1) {
            throw new Error("Too few arguments provided");
          }
          if (argsNum === 1) {
            text = canvas;
            canvas = opts = void 0;
          } else if (argsNum === 2 && !canvas.getContext) {
            opts = text;
            text = canvas;
            canvas = void 0;
          }
          return new Promise(function(resolve, reject) {
            try {
              const data2 = QRCode.create(text, opts);
              resolve(renderFunc(data2, canvas, opts));
            } catch (e9) {
              reject(e9);
            }
          });
        }
        try {
          const data2 = QRCode.create(text, opts);
          cb(null, renderFunc(data2, canvas, opts));
        } catch (e9) {
          cb(e9);
        }
      }
      exports.create = QRCode.create;
      exports.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);
      exports.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);
      exports.toString = renderCanvas.bind(null, function(data2, _8, opts) {
        return SvgRenderer.render(data2, opts);
      });
    }
  });

  // node_modules/@walletconnect/modal-ui/dist/index.js
  var dist_exports2 = {};
  __export(dist_exports2, {
    WcmModal: () => ae3,
    WcmQrCode: () => j3
  });
  function rt3() {
    var e9;
    const o9 = (e9 = ne2.state.themeMode) != null ? e9 : "dark", r8 = { light: { foreground: { 1: "rgb(20,20,20)", 2: "rgb(121,134,134)", 3: "rgb(158,169,169)" }, background: { 1: "rgb(255,255,255)", 2: "rgb(241,243,243)", 3: "rgb(228,231,231)" }, overlay: "rgba(0,0,0,0.1)" }, dark: { foreground: { 1: "rgb(228,231,231)", 2: "rgb(148,158,158)", 3: "rgb(110,119,119)" }, background: { 1: "rgb(20,20,20)", 2: "rgb(39,42,42)", 3: "rgb(59,64,64)" }, overlay: "rgba(255,255,255,0.1)" } }[o9];
    return { "--wcm-color-fg-1": r8.foreground[1], "--wcm-color-fg-2": r8.foreground[2], "--wcm-color-fg-3": r8.foreground[3], "--wcm-color-bg-1": r8.background[1], "--wcm-color-bg-2": r8.background[2], "--wcm-color-bg-3": r8.background[3], "--wcm-color-overlay": r8.overlay };
  }
  function He3() {
    return { "--wcm-accent-color": "#3396FF", "--wcm-accent-fill-color": "#FFFFFF", "--wcm-z-index": "89", "--wcm-background-color": "#3396FF", "--wcm-background-border-radius": "8px", "--wcm-container-border-radius": "30px", "--wcm-wallet-icon-border-radius": "15px", "--wcm-wallet-icon-large-border-radius": "30px", "--wcm-wallet-icon-small-border-radius": "7px", "--wcm-input-border-radius": "28px", "--wcm-button-border-radius": "10px", "--wcm-notification-border-radius": "36px", "--wcm-secondary-button-border-radius": "28px", "--wcm-icon-button-border-radius": "50%", "--wcm-button-hover-highlight-border-radius": "10px", "--wcm-text-big-bold-size": "20px", "--wcm-text-big-bold-weight": "600", "--wcm-text-big-bold-line-height": "24px", "--wcm-text-big-bold-letter-spacing": "-0.03em", "--wcm-text-big-bold-text-transform": "none", "--wcm-text-xsmall-bold-size": "10px", "--wcm-text-xsmall-bold-weight": "700", "--wcm-text-xsmall-bold-line-height": "12px", "--wcm-text-xsmall-bold-letter-spacing": "0.02em", "--wcm-text-xsmall-bold-text-transform": "uppercase", "--wcm-text-xsmall-regular-size": "12px", "--wcm-text-xsmall-regular-weight": "600", "--wcm-text-xsmall-regular-line-height": "14px", "--wcm-text-xsmall-regular-letter-spacing": "-0.03em", "--wcm-text-xsmall-regular-text-transform": "none", "--wcm-text-small-thin-size": "14px", "--wcm-text-small-thin-weight": "500", "--wcm-text-small-thin-line-height": "16px", "--wcm-text-small-thin-letter-spacing": "-0.03em", "--wcm-text-small-thin-text-transform": "none", "--wcm-text-small-regular-size": "14px", "--wcm-text-small-regular-weight": "600", "--wcm-text-small-regular-line-height": "16px", "--wcm-text-small-regular-letter-spacing": "-0.03em", "--wcm-text-small-regular-text-transform": "none", "--wcm-text-medium-regular-size": "16px", "--wcm-text-medium-regular-weight": "600", "--wcm-text-medium-regular-line-height": "20px", "--wcm-text-medium-regular-letter-spacing": "-0.03em", "--wcm-text-medium-regular-text-transform": "none", "--wcm-font-family": "-apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Roboto, Ubuntu, 'Helvetica Neue', sans-serif", "--wcm-font-feature-settings": "'tnum' on, 'lnum' on, 'case' on", "--wcm-success-color": "rgb(38,181,98)", "--wcm-error-color": "rgb(242, 90, 103)", "--wcm-overlay-background-color": "rgba(0, 0, 0, 0.3)", "--wcm-overlay-backdrop-filter": "none" };
  }
  function Ce2(e9, o9, r8) {
    return e9 === o9 ? false : (e9 - o9 < 0 ? o9 - e9 : e9 - o9) <= r8 + jt3;
  }
  function _t2(e9, o9) {
    const r8 = Array.prototype.slice.call(import_qrcode.default.create(e9, { errorCorrectionLevel: o9 }).modules.data, 0), a6 = Math.sqrt(r8.length);
    return r8.reduce((t6, l9, i7) => (i7 % a6 === 0 ? t6.push([l9]) : t6[t6.length - 1].push(l9)) && t6, []);
  }
  var import_qrcode, et2, Be3, tt2, ot3, Ue3, ve, h8, at3, lt3, it2, F5, T4, nt2, ct2, st2, ue4, ee3, dt3, mt3, ht3, wt4, be, v3, pt3, gt3, vt3, ut3, fe3, bt3, ft4, xt3, yt3, xe, $t2, Ct3, kt3, Ot4, ye4, Wt2, It4, Et3, te5, S8, c7, Mt3, Lt3, Rt3, $e3, oe5, At2, Pt3, Tt3, ze2, ne3, jt3, Ve3, A4, Dt3, Nt3, Zt2, St4, q3, j3, Bt3, Ut2, Ht2, Fe3, ce4, zt3, Vt3, Ft3, qt3, ke3, Qt2, Kt3, Yt3, Oe, re3, Gt3, Xt2, Jt3, _5, L5, eo, to, oo, se3, Q5, ro, ao, qe3, We3, lo, io, no, Qe3, co, so, mo, ho, Ie3, wo, po, go, K4, D6, G5, Z5, vo, uo, bo, fo, Ee2, xo, yo, $o, Co, Me3, ko, Oo, Wo, Io, Le2, Eo, Mo, Lo, Re4, ae3, Ro, Ao, Po, le5, B6, To, jo, _o, Do, Ae2, No, Zo, So, de5, Y2, Bo, Uo, Ho, Pe2, zo, Vo, Fo, Ke2, me4, qo, Qo, Ko, Yo, Te3, Go, Xo, Jo, Ye4, he5, er3, tr3, or3, rr2, je3, ar2, lr3, ir2, _e4, nr3, cr3, sr2, ie3, De3, U4, dr2, mr2, hr3, Ge3, we;
  var init_dist6 = __esm({
    "node_modules/@walletconnect/modal-ui/dist/index.js"() {
      init_lit();
      init_decorators();
      init_class_map2();
      init_dist5();
      init_lit_html();
      init_main_es();
      init_if_defined2();
      import_qrcode = __toESM(require_browser4(), 1);
      et2 = Object.defineProperty;
      Be3 = Object.getOwnPropertySymbols;
      tt2 = Object.prototype.hasOwnProperty;
      ot3 = Object.prototype.propertyIsEnumerable;
      Ue3 = (e9, o9, r8) => o9 in e9 ? et2(e9, o9, { enumerable: true, configurable: true, writable: true, value: r8 }) : e9[o9] = r8;
      ve = (e9, o9) => {
        for (var r8 in o9 || (o9 = {}))
          tt2.call(o9, r8) && Ue3(e9, r8, o9[r8]);
        if (Be3)
          for (var r8 of Be3(o9))
            ot3.call(o9, r8) && Ue3(e9, r8, o9[r8]);
        return e9;
      };
      h8 = { getPreset(e9) {
        return He3()[e9];
      }, setTheme() {
        const e9 = document.querySelector(":root"), { themeVariables: o9 } = ne2.state;
        if (e9) {
          const r8 = ve(ve(ve({}, rt3()), He3()), o9);
          Object.entries(r8).forEach(([a6, t6]) => e9.style.setProperty(a6, t6));
        }
      }, globalCss: i2`*,::after,::before{margin:0;padding:0;box-sizing:border-box;font-style:normal;text-rendering:optimizeSpeed;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;-webkit-tap-highlight-color:transparent;backface-visibility:hidden}button{cursor:pointer;display:flex;justify-content:center;align-items:center;position:relative;border:none;background-color:transparent;transition:all .2s ease}@media (hover:hover) and (pointer:fine){button:active{transition:all .1s ease;transform:scale(.93)}}button::after{content:'';position:absolute;top:0;bottom:0;left:0;right:0;transition:background-color,.2s ease}button:disabled{cursor:not-allowed}button svg,button wcm-text{position:relative;z-index:1}input{border:none;outline:0;appearance:none}img{display:block}::selection{color:var(--wcm-accent-fill-color);background:var(--wcm-accent-color)}` };
      at3 = i2`button{border-radius:var(--wcm-secondary-button-border-radius);height:28px;padding:0 10px;background-color:var(--wcm-accent-color)}button path{fill:var(--wcm-accent-fill-color)}button::after{border-radius:inherit;border:1px solid var(--wcm-color-overlay)}button:disabled::after{background-color:transparent}.wcm-icon-left svg{margin-right:5px}.wcm-icon-right svg{margin-left:5px}button:active::after{background-color:var(--wcm-color-overlay)}.wcm-ghost,.wcm-ghost:active::after,.wcm-outline{background-color:transparent}.wcm-ghost:active{opacity:.5}@media(hover:hover){button:hover::after{background-color:var(--wcm-color-overlay)}.wcm-ghost:hover::after{background-color:transparent}.wcm-ghost:hover{opacity:.5}}button:disabled{background-color:var(--wcm-color-bg-3);pointer-events:none}.wcm-ghost::after{border-color:transparent}.wcm-ghost path{fill:var(--wcm-color-fg-2)}.wcm-outline path{fill:var(--wcm-accent-color)}.wcm-outline:disabled{background-color:transparent;opacity:.5}`;
      lt3 = Object.defineProperty;
      it2 = Object.getOwnPropertyDescriptor;
      F5 = (e9, o9, r8, a6) => {
        for (var t6 = a6 > 1 ? void 0 : a6 ? it2(o9, r8) : o9, l9 = e9.length - 1, i7; l9 >= 0; l9--)
          (i7 = e9[l9]) && (t6 = (a6 ? i7(o9, r8, t6) : i7(t6)) || t6);
        return a6 && t6 && lt3(o9, r8, t6), t6;
      };
      T4 = class extends s5 {
        constructor() {
          super(...arguments), this.disabled = false, this.iconLeft = void 0, this.iconRight = void 0, this.onClick = () => null, this.variant = "default";
        }
        render() {
          const e9 = { "wcm-icon-left": this.iconLeft !== void 0, "wcm-icon-right": this.iconRight !== void 0, "wcm-ghost": this.variant === "ghost", "wcm-outline": this.variant === "outline" };
          let o9 = "inverse";
          return this.variant === "ghost" && (o9 = "secondary"), this.variant === "outline" && (o9 = "accent"), x2`<button class="${o7(e9)}" ?disabled="${this.disabled}" @click="${this.onClick}">${this.iconLeft}<wcm-text variant="small-regular" color="${o9}"><slot></slot></wcm-text>${this.iconRight}</button>`;
        }
      };
      T4.styles = [h8.globalCss, at3], F5([n6({ type: Boolean })], T4.prototype, "disabled", 2), F5([n6()], T4.prototype, "iconLeft", 2), F5([n6()], T4.prototype, "iconRight", 2), F5([n6()], T4.prototype, "onClick", 2), F5([n6()], T4.prototype, "variant", 2), T4 = F5([e5("wcm-button")], T4);
      nt2 = i2`:host{display:inline-block}button{padding:0 15px 1px;height:40px;border-radius:var(--wcm-button-border-radius);color:var(--wcm-accent-fill-color);background-color:var(--wcm-accent-color)}button::after{content:'';top:0;bottom:0;left:0;right:0;position:absolute;background-color:transparent;border-radius:inherit;transition:background-color .2s ease;border:1px solid var(--wcm-color-overlay)}button:active::after{background-color:var(--wcm-color-overlay)}button:disabled{padding-bottom:0;background-color:var(--wcm-color-bg-3);color:var(--wcm-color-fg-3)}.wcm-secondary{color:var(--wcm-accent-color);background-color:transparent}.wcm-secondary::after{display:none}@media(hover:hover){button:hover::after{background-color:var(--wcm-color-overlay)}}`;
      ct2 = Object.defineProperty;
      st2 = Object.getOwnPropertyDescriptor;
      ue4 = (e9, o9, r8, a6) => {
        for (var t6 = a6 > 1 ? void 0 : a6 ? st2(o9, r8) : o9, l9 = e9.length - 1, i7; l9 >= 0; l9--)
          (i7 = e9[l9]) && (t6 = (a6 ? i7(o9, r8, t6) : i7(t6)) || t6);
        return a6 && t6 && ct2(o9, r8, t6), t6;
      };
      ee3 = class extends s5 {
        constructor() {
          super(...arguments), this.disabled = false, this.variant = "primary";
        }
        render() {
          const e9 = { "wcm-secondary": this.variant === "secondary" };
          return x2`<button ?disabled="${this.disabled}" class="${o7(e9)}"><slot></slot></button>`;
        }
      };
      ee3.styles = [h8.globalCss, nt2], ue4([n6({ type: Boolean })], ee3.prototype, "disabled", 2), ue4([n6()], ee3.prototype, "variant", 2), ee3 = ue4([e5("wcm-button-big")], ee3);
      dt3 = i2`:host{background-color:var(--wcm-color-bg-2);border-top:1px solid var(--wcm-color-bg-3)}div{padding:10px 20px;display:inherit;flex-direction:inherit;align-items:inherit;width:inherit;justify-content:inherit}`;
      mt3 = Object.defineProperty;
      ht3 = Object.getOwnPropertyDescriptor;
      wt4 = (e9, o9, r8, a6) => {
        for (var t6 = a6 > 1 ? void 0 : a6 ? ht3(o9, r8) : o9, l9 = e9.length - 1, i7; l9 >= 0; l9--)
          (i7 = e9[l9]) && (t6 = (a6 ? i7(o9, r8, t6) : i7(t6)) || t6);
        return a6 && t6 && mt3(o9, r8, t6), t6;
      };
      be = class extends s5 {
        render() {
          return x2`<div><slot></slot></div>`;
        }
      };
      be.styles = [h8.globalCss, dt3], be = wt4([e5("wcm-info-footer")], be);
      v3 = { CROSS_ICON: b4`<svg width="12" height="12" viewBox="0 0 12 12"><path d="M9.94 11A.75.75 0 1 0 11 9.94L7.414 6.353a.5.5 0 0 1 0-.708L11 2.061A.75.75 0 1 0 9.94 1L6.353 4.586a.5.5 0 0 1-.708 0L2.061 1A.75.75 0 0 0 1 2.06l3.586 3.586a.5.5 0 0 1 0 .708L1 9.939A.75.75 0 1 0 2.06 11l3.586-3.586a.5.5 0 0 1 .708 0L9.939 11Z" fill="#fff"/></svg>`, WALLET_CONNECT_LOGO: b4`<svg width="178" height="29" viewBox="0 0 178 29" id="wcm-wc-logo"><path d="M10.683 7.926c5.284-5.17 13.85-5.17 19.134 0l.636.623a.652.652 0 0 1 0 .936l-2.176 2.129a.343.343 0 0 1-.478 0l-.875-.857c-3.686-3.607-9.662-3.607-13.348 0l-.937.918a.343.343 0 0 1-.479 0l-2.175-2.13a.652.652 0 0 1 0-.936l.698-.683Zm23.633 4.403 1.935 1.895a.652.652 0 0 1 0 .936l-8.73 8.543a.687.687 0 0 1-.956 0L20.37 17.64a.172.172 0 0 0-.239 0l-6.195 6.063a.687.687 0 0 1-.957 0l-8.73-8.543a.652.652 0 0 1 0-.936l1.936-1.895a.687.687 0 0 1 .957 0l6.196 6.064a.172.172 0 0 0 .239 0l6.195-6.064a.687.687 0 0 1 .957 0l6.196 6.064a.172.172 0 0 0 .24 0l6.195-6.064a.687.687 0 0 1 .956 0ZM48.093 20.948l2.338-9.355c.139-.515.258-1.07.416-1.942.12.872.258 1.427.357 1.942l2.022 9.355h4.181l3.528-13.874h-3.21l-1.943 8.523a24.825 24.825 0 0 0-.456 2.457c-.158-.931-.317-1.625-.495-2.438l-1.883-8.542h-4.201l-2.042 8.542a41.204 41.204 0 0 0-.475 2.438 41.208 41.208 0 0 0-.476-2.438l-1.903-8.542h-3.349l3.508 13.874h4.083ZM63.33 21.304c1.585 0 2.596-.654 3.11-1.605-.059.297-.078.595-.078.892v.357h2.655V15.22c0-2.735-1.248-4.32-4.3-4.32-2.636 0-4.36 1.466-4.52 3.487h2.914c.1-.891.734-1.426 1.705-1.426.911 0 1.407.515 1.407 1.11 0 .435-.258.693-1.03.792l-1.388.159c-2.061.257-3.825 1.01-3.825 3.19 0 1.982 1.645 3.092 3.35 3.092Zm.891-2.041c-.773 0-1.348-.436-1.348-1.19 0-.733.655-1.09 1.645-1.268l.674-.119c.575-.118.892-.218 1.09-.396v.912c0 1.228-.892 2.06-2.06 2.06ZM70.398 7.074v13.874h2.874V7.074h-2.874ZM74.934 7.074v13.874h2.874V7.074h-2.874ZM84.08 21.304c2.735 0 4.5-1.546 4.697-3.567h-2.893c-.139.892-.892 1.387-1.804 1.387-1.228 0-2.12-.99-2.14-2.358h6.897v-.555c0-3.21-1.764-5.312-4.816-5.312-2.933 0-4.994 2.062-4.994 5.173 0 3.37 2.12 5.232 5.053 5.232Zm-2.16-6.421c.119-1.11.932-1.922 2.081-1.922 1.11 0 1.883.772 1.903 1.922H81.92ZM94.92 21.146c.633 0 1.248-.1 1.525-.179v-2.18c-.218.04-.475.06-.693.06-1.05 0-1.427-.595-1.427-1.566v-3.805h2.338v-2.24h-2.338V7.788H91.47v3.448H89.37v2.24h2.1v4.201c0 2.3 1.15 3.469 3.45 3.469ZM104.62 21.304c3.924 0 6.302-2.299 6.599-5.608h-3.111c-.238 1.803-1.506 3.032-3.369 3.032-2.2 0-3.746-1.784-3.746-4.796 0-2.953 1.605-4.638 3.805-4.638 1.883 0 2.953 1.15 3.171 2.834h3.191c-.317-3.448-2.854-5.41-6.342-5.41-3.984 0-7.036 2.695-7.036 7.214 0 4.677 2.676 7.372 6.838 7.372ZM117.449 21.304c2.993 0 5.114-1.882 5.114-5.172 0-3.23-2.121-5.233-5.114-5.233-2.972 0-5.093 2.002-5.093 5.233 0 3.29 2.101 5.172 5.093 5.172Zm0-2.22c-1.327 0-2.18-1.09-2.18-2.952 0-1.903.892-2.973 2.18-2.973 1.308 0 2.2 1.07 2.2 2.973 0 1.862-.872 2.953-2.2 2.953ZM126.569 20.948v-5.689c0-1.208.753-2.1 1.823-2.1 1.011 0 1.606.773 1.606 2.06v5.729h2.873v-6.144c0-2.339-1.229-3.905-3.428-3.905-1.526 0-2.458.734-2.953 1.606a5.31 5.31 0 0 0 .079-.892v-.377h-2.874v9.712h2.874ZM137.464 20.948v-5.689c0-1.208.753-2.1 1.823-2.1 1.011 0 1.606.773 1.606 2.06v5.729h2.873v-6.144c0-2.339-1.228-3.905-3.428-3.905-1.526 0-2.458.734-2.953 1.606a5.31 5.31 0 0 0 .079-.892v-.377h-2.874v9.712h2.874ZM149.949 21.304c2.735 0 4.499-1.546 4.697-3.567h-2.893c-.139.892-.892 1.387-1.804 1.387-1.228 0-2.12-.99-2.14-2.358h6.897v-.555c0-3.21-1.764-5.312-4.816-5.312-2.933 0-4.994 2.062-4.994 5.173 0 3.37 2.12 5.232 5.053 5.232Zm-2.16-6.421c.119-1.11.932-1.922 2.081-1.922 1.11 0 1.883.772 1.903 1.922h-3.984ZM160.876 21.304c3.013 0 4.658-1.645 4.975-4.201h-2.874c-.099 1.07-.713 1.982-2.001 1.982-1.309 0-2.2-1.21-2.2-2.993 0-1.942 1.03-2.933 2.259-2.933 1.209 0 1.803.872 1.883 1.882h2.873c-.218-2.358-1.823-4.142-4.776-4.142-2.874 0-5.153 1.903-5.153 5.193 0 3.25 1.923 5.212 5.014 5.212ZM172.067 21.146c.634 0 1.248-.1 1.526-.179v-2.18c-.218.04-.476.06-.694.06-1.05 0-1.427-.595-1.427-1.566v-3.805h2.339v-2.24h-2.339V7.788h-2.854v3.448h-2.1v2.24h2.1v4.201c0 2.3 1.15 3.469 3.449 3.469Z" fill="#fff"/></svg>`, WALLET_CONNECT_ICON: b4`<svg width="28" height="20" viewBox="0 0 28 20"><g clip-path="url(#a)"><path d="M7.386 6.482c3.653-3.576 9.575-3.576 13.228 0l.44.43a.451.451 0 0 1 0 .648L19.55 9.033a.237.237 0 0 1-.33 0l-.606-.592c-2.548-2.496-6.68-2.496-9.228 0l-.648.634a.237.237 0 0 1-.33 0L6.902 7.602a.451.451 0 0 1 0-.647l.483-.473Zm16.338 3.046 1.339 1.31a.451.451 0 0 1 0 .648l-6.035 5.909a.475.475 0 0 1-.662 0L14.083 13.2a.119.119 0 0 0-.166 0l-4.283 4.194a.475.475 0 0 1-.662 0l-6.035-5.91a.451.451 0 0 1 0-.647l1.338-1.31a.475.475 0 0 1 .662 0l4.283 4.194c.046.044.12.044.166 0l4.283-4.194a.475.475 0 0 1 .662 0l4.283 4.194c.046.044.12.044.166 0l4.283-4.194a.475.475 0 0 1 .662 0Z" fill="#000000"/></g><defs><clipPath id="a"><path fill="#ffffff" d="M0 0h28v20H0z"/></clipPath></defs></svg>`, WALLET_CONNECT_ICON_COLORED: b4`<svg width="96" height="96" fill="none"><path fill="#fff" d="M25.322 33.597c12.525-12.263 32.83-12.263 45.355 0l1.507 1.476a1.547 1.547 0 0 1 0 2.22l-5.156 5.048a.814.814 0 0 1-1.134 0l-2.074-2.03c-8.737-8.555-22.903-8.555-31.64 0l-2.222 2.175a.814.814 0 0 1-1.134 0l-5.156-5.049a1.547 1.547 0 0 1 0-2.22l1.654-1.62Zm56.019 10.44 4.589 4.494a1.547 1.547 0 0 1 0 2.22l-20.693 20.26a1.628 1.628 0 0 1-2.267 0L48.283 56.632a.407.407 0 0 0-.567 0L33.03 71.012a1.628 1.628 0 0 1-2.268 0L10.07 50.75a1.547 1.547 0 0 1 0-2.22l4.59-4.494a1.628 1.628 0 0 1 2.267 0l14.687 14.38c.156.153.41.153.567 0l14.685-14.38a1.628 1.628 0 0 1 2.268 0l14.687 14.38c.156.153.41.153.567 0l14.686-14.38a1.628 1.628 0 0 1 2.268 0Z"/><path stroke="#000" d="M25.672 33.954c12.33-12.072 32.325-12.072 44.655 0l1.508 1.476a1.047 1.047 0 0 1 0 1.506l-5.157 5.048a.314.314 0 0 1-.434 0l-2.074-2.03c-8.932-8.746-23.409-8.746-32.34 0l-2.222 2.174a.314.314 0 0 1-.434 0l-5.157-5.048a1.047 1.047 0 0 1 0-1.506l1.655-1.62Zm55.319 10.44 4.59 4.494a1.047 1.047 0 0 1 0 1.506l-20.694 20.26a1.128 1.128 0 0 1-1.568 0l-14.686-14.38a.907.907 0 0 0-1.267 0L32.68 70.655a1.128 1.128 0 0 1-1.568 0L10.42 50.394a1.047 1.047 0 0 1 0-1.506l4.59-4.493a1.128 1.128 0 0 1 1.567 0l14.687 14.379a.907.907 0 0 0 1.266 0l-.35-.357.35.357 14.686-14.38a1.128 1.128 0 0 1 1.568 0l14.687 14.38a.907.907 0 0 0 1.267 0l14.686-14.38a1.128 1.128 0 0 1 1.568 0Z"/></svg>`, BACK_ICON: b4`<svg width="10" height="18" viewBox="0 0 10 18"><path fill-rule="evenodd" clip-rule="evenodd" d="M8.735.179a.75.75 0 0 1 .087 1.057L2.92 8.192a1.25 1.25 0 0 0 0 1.617l5.902 6.956a.75.75 0 1 1-1.144.97L1.776 10.78a2.75 2.75 0 0 1 0-3.559L7.678.265A.75.75 0 0 1 8.735.18Z" fill="#fff"/></svg>`, COPY_ICON: b4`<svg width="24" height="24" fill="none"><path fill="#fff" fill-rule="evenodd" d="M7.01 7.01c.03-1.545.138-2.5.535-3.28A5 5 0 0 1 9.73 1.545C10.8 1 12.2 1 15 1c2.8 0 4.2 0 5.27.545a5 5 0 0 1 2.185 2.185C23 4.8 23 6.2 23 9c0 2.8 0 4.2-.545 5.27a5 5 0 0 1-2.185 2.185c-.78.397-1.735.505-3.28.534l-.001.01c-.03 1.54-.138 2.493-.534 3.27a5 5 0 0 1-2.185 2.186C13.2 23 11.8 23 9 23c-2.8 0-4.2 0-5.27-.545a5 5 0 0 1-2.185-2.185C1 19.2 1 17.8 1 15c0-2.8 0-4.2.545-5.27A5 5 0 0 1 3.73 7.545C4.508 7.149 5.46 7.04 7 7.01h.01ZM15 15.5c-1.425 0-2.403-.001-3.162-.063-.74-.06-1.139-.172-1.427-.319a3.5 3.5 0 0 1-1.53-1.529c-.146-.288-.257-.686-.318-1.427C8.501 11.403 8.5 10.425 8.5 9c0-1.425.001-2.403.063-3.162.06-.74.172-1.139.318-1.427a3.5 3.5 0 0 1 1.53-1.53c.288-.146.686-.257 1.427-.318.759-.062 1.737-.063 3.162-.063 1.425 0 2.403.001 3.162.063.74.06 1.139.172 1.427.318a3.5 3.5 0 0 1 1.53 1.53c.146.288.257.686.318 1.427.062.759.063 1.737.063 3.162 0 1.425-.001 2.403-.063 3.162-.06.74-.172 1.139-.319 1.427a3.5 3.5 0 0 1-1.529 1.53c-.288.146-.686.257-1.427.318-.759.062-1.737.063-3.162.063ZM7 8.511c-.444.009-.825.025-1.162.052-.74.06-1.139.172-1.427.318a3.5 3.5 0 0 0-1.53 1.53c-.146.288-.257.686-.318 1.427-.062.759-.063 1.737-.063 3.162 0 1.425.001 2.403.063 3.162.06.74.172 1.139.318 1.427a3.5 3.5 0 0 0 1.53 1.53c.288.146.686.257 1.427.318.759.062 1.737.063 3.162.063 1.425 0 2.403-.001 3.162-.063.74-.06 1.139-.172 1.427-.319a3.5 3.5 0 0 0 1.53-1.53c.146-.287.257-.685.318-1.426.027-.337.043-.718.052-1.162H15c-2.8 0-4.2 0-5.27-.545a5 5 0 0 1-2.185-2.185C7 13.2 7 11.8 7 9v-.489Z" clip-rule="evenodd"/></svg>`, RETRY_ICON: b4`<svg width="15" height="16" viewBox="0 0 15 16"><path d="M6.464 2.03A.75.75 0 0 0 5.403.97L2.08 4.293a1 1 0 0 0 0 1.414L5.403 9.03a.75.75 0 0 0 1.06-1.06L4.672 6.177a.25.25 0 0 1 .177-.427h2.085a4 4 0 1 1-3.93 4.746c-.077-.407-.405-.746-.82-.746-.414 0-.755.338-.7.748a5.501 5.501 0 1 0 5.45-6.248H4.848a.25.25 0 0 1-.177-.427L6.464 2.03Z" fill="#fff"/></svg>`, DESKTOP_ICON: b4`<svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M0 5.98c0-1.85 0-2.775.394-3.466a3 3 0 0 1 1.12-1.12C2.204 1 3.13 1 4.98 1h6.04c1.85 0 2.775 0 3.466.394a3 3 0 0 1 1.12 1.12C16 3.204 16 4.13 16 5.98v1.04c0 1.85 0 2.775-.394 3.466a3 3 0 0 1-1.12 1.12C13.796 12 12.87 12 11.02 12H4.98c-1.85 0-2.775 0-3.466-.394a3 3 0 0 1-1.12-1.12C0 9.796 0 8.87 0 7.02V5.98ZM4.98 2.5h6.04c.953 0 1.568.001 2.034.043.446.04.608.108.69.154a1.5 1.5 0 0 1 .559.56c.046.08.114.243.154.69.042.465.043 1.08.043 2.033v1.04c0 .952-.001 1.568-.043 2.034-.04.446-.108.608-.154.69a1.499 1.499 0 0 1-.56.559c-.08.046-.243.114-.69.154-.466.042-1.08.043-2.033.043H4.98c-.952 0-1.568-.001-2.034-.043-.446-.04-.608-.108-.69-.154a1.5 1.5 0 0 1-.559-.56c-.046-.08-.114-.243-.154-.69-.042-.465-.043-1.08-.043-2.033V5.98c0-.952.001-1.568.043-2.034.04-.446.108-.608.154-.69a1.5 1.5 0 0 1 .56-.559c.08-.046.243-.114.69-.154.465-.042 1.08-.043 2.033-.043Z" fill="#fff"/><path d="M4 14.25a.75.75 0 0 1 .75-.75h6.5a.75.75 0 0 1 0 1.5h-6.5a.75.75 0 0 1-.75-.75Z" fill="#fff"/></svg>`, MOBILE_ICON: b4`<svg width="16" height="16" viewBox="0 0 16 16"><path d="M6.75 5a1.25 1.25 0 1 0 0-2.5 1.25 1.25 0 0 0 0 2.5Z" fill="#fff"/><path fill-rule="evenodd" clip-rule="evenodd" d="M3 4.98c0-1.85 0-2.775.394-3.466a3 3 0 0 1 1.12-1.12C5.204 0 6.136 0 8 0s2.795 0 3.486.394a3 3 0 0 1 1.12 1.12C13 2.204 13 3.13 13 4.98v6.04c0 1.85 0 2.775-.394 3.466a3 3 0 0 1-1.12 1.12C10.796 16 9.864 16 8 16s-2.795 0-3.486-.394a3 3 0 0 1-1.12-1.12C3 13.796 3 12.87 3 11.02V4.98Zm8.5 0v6.04c0 .953-.001 1.568-.043 2.034-.04.446-.108.608-.154.69a1.499 1.499 0 0 1-.56.559c-.08.045-.242.113-.693.154-.47.042-1.091.043-2.05.043-.959 0-1.58-.001-2.05-.043-.45-.04-.613-.109-.693-.154a1.5 1.5 0 0 1-.56-.56c-.046-.08-.114-.243-.154-.69-.042-.466-.043-1.08-.043-2.033V4.98c0-.952.001-1.568.043-2.034.04-.446.108-.608.154-.69a1.5 1.5 0 0 1 .56-.559c.08-.045.243-.113.693-.154C6.42 1.501 7.041 1.5 8 1.5c.959 0 1.58.001 2.05.043.45.04.613.109.693.154a1.5 1.5 0 0 1 .56.56c.046.08.114.243.154.69.042.465.043 1.08.043 2.033Z" fill="#fff"/></svg>`, ARROW_DOWN_ICON: b4`<svg width="14" height="14" viewBox="0 0 14 14"><path d="M2.28 7.47a.75.75 0 0 0-1.06 1.06l5.25 5.25a.75.75 0 0 0 1.06 0l5.25-5.25a.75.75 0 0 0-1.06-1.06l-3.544 3.543a.25.25 0 0 1-.426-.177V.75a.75.75 0 0 0-1.5 0v10.086a.25.25 0 0 1-.427.176L2.28 7.47Z" fill="#fff"/></svg>`, ARROW_UP_RIGHT_ICON: b4`<svg width="15" height="14" fill="none"><path d="M4.5 1.75A.75.75 0 0 1 5.25 1H12a1.5 1.5 0 0 1 1.5 1.5v6.75a.75.75 0 0 1-1.5 0V4.164a.25.25 0 0 0-.427-.176L4.061 11.5A.75.75 0 0 1 3 10.44l7.513-7.513a.25.25 0 0 0-.177-.427H5.25a.75.75 0 0 1-.75-.75Z" fill="#fff"/></svg>`, ARROW_RIGHT_ICON: b4`<svg width="6" height="14" viewBox="0 0 6 14"><path fill-rule="evenodd" clip-rule="evenodd" d="M2.181 1.099a.75.75 0 0 1 1.024.279l2.433 4.258a2.75 2.75 0 0 1 0 2.729l-2.433 4.257a.75.75 0 1 1-1.303-.744L4.335 7.62a1.25 1.25 0 0 0 0-1.24L1.902 2.122a.75.75 0 0 1 .28-1.023Z" fill="#fff"/></svg>`, QRCODE_ICON: b4`<svg width="25" height="24" viewBox="0 0 25 24"><path d="M23.748 9a.748.748 0 0 0 .748-.752c-.018-2.596-.128-4.07-.784-5.22a6 6 0 0 0-2.24-2.24c-1.15-.656-2.624-.766-5.22-.784a.748.748 0 0 0-.752.748c0 .414.335.749.748.752 1.015.007 1.82.028 2.494.088.995.09 1.561.256 1.988.5.7.398 1.28.978 1.679 1.678.243.427.41.993.498 1.988.061.675.082 1.479.09 2.493a.753.753 0 0 0 .75.749ZM3.527.788C4.677.132 6.152.022 8.747.004A.748.748 0 0 1 9.5.752a.753.753 0 0 1-.749.752c-1.014.007-1.818.028-2.493.088-.995.09-1.561.256-1.988.5-.7.398-1.28.978-1.679 1.678-.243.427-.41.993-.499 1.988-.06.675-.081 1.479-.088 2.493A.753.753 0 0 1 1.252 9a.748.748 0 0 1-.748-.752c.018-2.596.128-4.07.784-5.22a6 6 0 0 1 2.24-2.24ZM1.252 15a.748.748 0 0 0-.748.752c.018 2.596.128 4.07.784 5.22a6 6 0 0 0 2.24 2.24c1.15.656 2.624.766 5.22.784a.748.748 0 0 0 .752-.748.753.753 0 0 0-.749-.752c-1.014-.007-1.818-.028-2.493-.089-.995-.089-1.561-.255-1.988-.498a4.5 4.5 0 0 1-1.679-1.68c-.243-.426-.41-.992-.499-1.987-.06-.675-.081-1.479-.088-2.493A.753.753 0 0 0 1.252 15ZM22.996 15.749a.753.753 0 0 1 .752-.749c.415 0 .751.338.748.752-.018 2.596-.128 4.07-.784 5.22a6 6 0 0 1-2.24 2.24c-1.15.656-2.624.766-5.22.784a.748.748 0 0 1-.752-.748c0-.414.335-.749.748-.752 1.015-.007 1.82-.028 2.494-.089.995-.089 1.561-.255 1.988-.498a4.5 4.5 0 0 0 1.679-1.68c.243-.426.41-.992.498-1.987.061-.675.082-1.479.09-2.493Z" fill="#fff"/><path fill-rule="evenodd" clip-rule="evenodd" d="M7 4a2.5 2.5 0 0 0-2.5 2.5v2A2.5 2.5 0 0 0 7 11h2a2.5 2.5 0 0 0 2.5-2.5v-2A2.5 2.5 0 0 0 9 4H7Zm2 1.5H7a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1ZM13.5 6.5A2.5 2.5 0 0 1 16 4h2a2.5 2.5 0 0 1 2.5 2.5v2A2.5 2.5 0 0 1 18 11h-2a2.5 2.5 0 0 1-2.5-2.5v-2Zm2.5-1h2a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1h-2a1 1 0 0 1-1-1v-2a1 1 0 0 1 1-1ZM7 13a2.5 2.5 0 0 0-2.5 2.5v2A2.5 2.5 0 0 0 7 20h2a2.5 2.5 0 0 0 2.5-2.5v-2A2.5 2.5 0 0 0 9 13H7Zm2 1.5H7a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1Z" fill="#fff"/><path d="M13.5 15.5c0-.465 0-.697.038-.89a2 2 0 0 1 1.572-1.572C15.303 13 15.535 13 16 13v2.5h-2.5ZM18 13c.465 0 .697 0 .89.038a2 2 0 0 1 1.572 1.572c.038.193.038.425.038.89H18V13ZM18 17.5h2.5c0 .465 0 .697-.038.89a2 2 0 0 1-1.572 1.572C18.697 20 18.465 20 18 20v-2.5ZM13.5 17.5H16V20c-.465 0-.697 0-.89-.038a2 2 0 0 1-1.572-1.572c-.038-.193-.038-.425-.038-.89Z" fill="#fff"/></svg>`, SCAN_ICON: b4`<svg width="16" height="16" fill="none"><path fill="#fff" d="M10 15.216c0 .422.347.763.768.74 1.202-.064 2.025-.222 2.71-.613a5.001 5.001 0 0 0 1.865-1.866c.39-.684.549-1.507.613-2.709a.735.735 0 0 0-.74-.768.768.768 0 0 0-.76.732c-.009.157-.02.306-.032.447-.073.812-.206 1.244-.384 1.555-.31.545-.761.996-1.306 1.306-.311.178-.743.311-1.555.384-.141.013-.29.023-.447.032a.768.768 0 0 0-.732.76ZM10 .784c0 .407.325.737.732.76.157.009.306.02.447.032.812.073 1.244.206 1.555.384a3.5 3.5 0 0 1 1.306 1.306c.178.311.311.743.384 1.555.013.142.023.29.032.447a.768.768 0 0 0 .76.732.734.734 0 0 0 .74-.768c-.064-1.202-.222-2.025-.613-2.71A5 5 0 0 0 13.477.658c-.684-.39-1.507-.549-2.709-.613a.735.735 0 0 0-.768.74ZM5.232.044A.735.735 0 0 1 6 .784a.768.768 0 0 1-.732.76c-.157.009-.305.02-.447.032-.812.073-1.244.206-1.555.384A3.5 3.5 0 0 0 1.96 3.266c-.178.311-.311.743-.384 1.555-.013.142-.023.29-.032.447A.768.768 0 0 1 .784 6a.735.735 0 0 1-.74-.768c.064-1.202.222-2.025.613-2.71A5 5 0 0 1 2.523.658C3.207.267 4.03.108 5.233.044ZM5.268 14.456a.768.768 0 0 1 .732.76.734.734 0 0 1-.768.74c-1.202-.064-2.025-.222-2.71-.613a5 5 0 0 1-1.865-1.866c-.39-.684-.549-1.507-.613-2.709A.735.735 0 0 1 .784 10c.407 0 .737.325.76.732.009.157.02.306.032.447.073.812.206 1.244.384 1.555a3.5 3.5 0 0 0 1.306 1.306c.311.178.743.311 1.555.384.142.013.29.023.447.032Z"/></svg>`, CHECKMARK_ICON: b4`<svg width="13" height="12" viewBox="0 0 13 12"><path fill-rule="evenodd" clip-rule="evenodd" d="M12.155.132a.75.75 0 0 1 .232 1.035L5.821 11.535a1 1 0 0 1-1.626.09L.665 7.21a.75.75 0 1 1 1.17-.937L4.71 9.867a.25.25 0 0 0 .406-.023L11.12.364a.75.75 0 0 1 1.035-.232Z" fill="#fff"/></svg>`, SEARCH_ICON: b4`<svg width="20" height="21"><path fill-rule="evenodd" clip-rule="evenodd" d="M12.432 13.992c-.354-.353-.91-.382-1.35-.146a5.5 5.5 0 1 1 2.265-2.265c-.237.441-.208.997.145 1.35l3.296 3.296a.75.75 0 1 1-1.06 1.061l-3.296-3.296Zm.06-5a4 4 0 1 1-8 0 4 4 0 0 1 8 0Z" fill="#949E9E"/></svg>`, WALLET_PLACEHOLDER: b4`<svg width="60" height="60" fill="none" viewBox="0 0 60 60"><g clip-path="url(#q)"><path id="wallet-placeholder-fill" fill="#fff" d="M0 24.9c0-9.251 0-13.877 1.97-17.332a15 15 0 0 1 5.598-5.597C11.023 0 15.648 0 24.9 0h10.2c9.252 0 13.877 0 17.332 1.97a15 15 0 0 1 5.597 5.598C60 11.023 60 15.648 60 24.9v10.2c0 9.252 0 13.877-1.97 17.332a15.001 15.001 0 0 1-5.598 5.597C48.977 60 44.352 60 35.1 60H24.9c-9.251 0-13.877 0-17.332-1.97a15 15 0 0 1-5.597-5.598C0 48.977 0 44.352 0 35.1V24.9Z"/><path id="wallet-placeholder-dash" stroke="#000" stroke-dasharray="4 4" stroke-width="1.5" d="M.04 41.708a231.598 231.598 0 0 1-.039-4.403l.75-.001L.75 35.1v-2.55H0v-5.1h.75V24.9l.001-2.204h-.75c.003-1.617.011-3.077.039-4.404l.75.016c.034-1.65.099-3.08.218-4.343l-.746-.07c.158-1.678.412-3.083.82-4.316l.713.236c.224-.679.497-1.296.827-1.875a14.25 14.25 0 0 1 1.05-1.585L3.076 5.9A15 15 0 0 1 5.9 3.076l.455.596a14.25 14.25 0 0 1 1.585-1.05c.579-.33 1.196-.603 1.875-.827l-.236-.712C10.812.674 12.217.42 13.895.262l.07.746C15.23.89 16.66.824 18.308.79l-.016-.75C19.62.012 21.08.004 22.695.001l.001.75L24.9.75h2.55V0h5.1v.75h2.55l2.204.001v-.75c1.617.003 3.077.011 4.404.039l-.016.75c1.65.034 3.08.099 4.343.218l.07-.746c1.678.158 3.083.412 4.316.82l-.236.713c.679.224 1.296.497 1.875.827a14.24 14.24 0 0 1 1.585 1.05l.455-.596A14.999 14.999 0 0 1 56.924 5.9l-.596.455c.384.502.735 1.032 1.05 1.585.33.579.602 1.196.827 1.875l.712-.236c.409 1.233.663 2.638.822 4.316l-.747.07c.119 1.264.184 2.694.218 4.343l.75-.016c.028 1.327.036 2.787.039 4.403l-.75.001.001 2.204v2.55H60v5.1h-.75v2.55l-.001 2.204h.75a231.431 231.431 0 0 1-.039 4.404l-.75-.016c-.034 1.65-.099 3.08-.218 4.343l.747.07c-.159 1.678-.413 3.083-.822 4.316l-.712-.236a10.255 10.255 0 0 1-.827 1.875 14.242 14.242 0 0 1-1.05 1.585l.596.455a14.997 14.997 0 0 1-2.824 2.824l-.455-.596c-.502.384-1.032.735-1.585 1.05-.579.33-1.196.602-1.875.827l.236.712c-1.233.409-2.638.663-4.316.822l-.07-.747c-1.264.119-2.694.184-4.343.218l.016.75c-1.327.028-2.787.036-4.403.039l-.001-.75-2.204.001h-2.55V60h-5.1v-.75H24.9l-2.204-.001v.75a231.431 231.431 0 0 1-4.404-.039l.016-.75c-1.65-.034-3.08-.099-4.343-.218l-.07.747c-1.678-.159-3.083-.413-4.316-.822l.236-.712a10.258 10.258 0 0 1-1.875-.827 14.252 14.252 0 0 1-1.585-1.05l-.455.596A14.999 14.999 0 0 1 3.076 54.1l.596-.455a14.24 14.24 0 0 1-1.05-1.585 10.259 10.259 0 0 1-.827-1.875l-.712.236C.674 49.188.42 47.783.262 46.105l.746-.07C.89 44.77.824 43.34.79 41.692l-.75.016Z"/><path fill="#fff" fill-rule="evenodd" d="M35.643 32.145c-.297-.743-.445-1.114-.401-1.275a.42.42 0 0 1 .182-.27c.134-.1.463-.1 1.123-.1.742 0 1.499.046 2.236-.05a6 6 0 0 0 5.166-5.166c.051-.39.051-.855.051-1.784 0-.928 0-1.393-.051-1.783a6 6 0 0 0-5.166-5.165c-.39-.052-.854-.052-1.783-.052h-7.72c-4.934 0-7.401 0-9.244 1.051a8 8 0 0 0-2.985 2.986C16.057 22.28 16.003 24.58 16 29 15.998 31.075 16 33.15 16 35.224A7.778 7.778 0 0 0 23.778 43H28.5c1.394 0 2.09 0 2.67-.116a6 6 0 0 0 4.715-4.714c.115-.58.115-1.301.115-2.744 0-1.31 0-1.964-.114-2.49a4.998 4.998 0 0 0-.243-.792Z" clip-rule="evenodd"/><path fill="#9EA9A9" fill-rule="evenodd" d="M37 18h-7.72c-2.494 0-4.266.002-5.647.126-1.361.122-2.197.354-2.854.728a6.5 6.5 0 0 0-2.425 2.426c-.375.657-.607 1.492-.729 2.853-.11 1.233-.123 2.777-.125 4.867 0 .7 0 1.05.097 1.181.096.13.182.181.343.2.163.02.518-.18 1.229-.581a6.195 6.195 0 0 1 3.053-.8H37c.977 0 1.32-.003 1.587-.038a4.5 4.5 0 0 0 3.874-3.874c.036-.268.039-.611.039-1.588 0-.976-.003-1.319-.038-1.587a4.5 4.5 0 0 0-3.875-3.874C38.32 18.004 37.977 18 37 18Zm-7.364 12.5h-7.414a4.722 4.722 0 0 0-4.722 4.723 6.278 6.278 0 0 0 6.278 6.278H28.5c1.466 0 1.98-.008 2.378-.087a4.5 4.5 0 0 0 3.535-3.536c.08-.397.087-.933.087-2.451 0-1.391-.009-1.843-.08-2.17a3.5 3.5 0 0 0-2.676-2.676c-.328-.072-.762-.08-2.108-.08Z" clip-rule="evenodd"/></g><defs><clipPath id="q"><path fill="#fff" d="M0 0h60v60H0z"/></clipPath></defs></svg>`, GLOBE_ICON: b4`<svg width="16" height="16" fill="none" viewBox="0 0 16 16"><path fill="#fff" fill-rule="evenodd" d="M15.5 8a7.5 7.5 0 1 1-15 0 7.5 7.5 0 0 1 15 0Zm-2.113.75c.301 0 .535.264.47.558a6.01 6.01 0 0 1-2.867 3.896c-.203.116-.42-.103-.334-.32.409-1.018.691-2.274.797-3.657a.512.512 0 0 1 .507-.477h1.427Zm.47-2.058c.065.294-.169.558-.47.558H11.96a.512.512 0 0 1-.507-.477c-.106-1.383-.389-2.638-.797-3.656-.087-.217.13-.437.333-.32a6.01 6.01 0 0 1 2.868 3.895Zm-4.402.558c.286 0 .515-.24.49-.525-.121-1.361-.429-2.534-.83-3.393-.279-.6-.549-.93-.753-1.112a.535.535 0 0 0-.724 0c-.204.182-.474.513-.754 1.112-.4.859-.708 2.032-.828 3.393a.486.486 0 0 0 .49.525h2.909Zm-5.415 0c.267 0 .486-.21.507-.477.106-1.383.389-2.638.797-3.656.087-.217-.13-.437-.333-.32a6.01 6.01 0 0 0-2.868 3.895c-.065.294.169.558.47.558H4.04ZM2.143 9.308c-.065-.294.169-.558.47-.558H4.04c.267 0 .486.21.507.477.106 1.383.389 2.639.797 3.657.087.217-.13.436-.333.32a6.01 6.01 0 0 1-2.868-3.896Zm3.913-.033a.486.486 0 0 1 .49-.525h2.909c.286 0 .515.24.49.525-.121 1.361-.428 2.535-.83 3.394-.279.6-.549.93-.753 1.112a.535.535 0 0 1-.724 0c-.204-.182-.474-.513-.754-1.112-.4-.859-.708-2.033-.828-3.394Z" clip-rule="evenodd"/></svg>` };
      pt3 = i2`.wcm-toolbar-placeholder{top:0;bottom:0;left:0;right:0;width:100%;position:absolute;display:block;pointer-events:none;height:100px;border-radius:calc(var(--wcm-background-border-radius) * .9);background-color:var(--wcm-background-color);background-position:center;background-size:cover}.wcm-toolbar{height:38px;display:flex;position:relative;margin:5px 15px 5px 5px;justify-content:space-between;align-items:center}.wcm-toolbar img,.wcm-toolbar svg{height:28px;object-position:left center;object-fit:contain}#wcm-wc-logo path{fill:var(--wcm-accent-fill-color)}button{width:28px;height:28px;border-radius:var(--wcm-icon-button-border-radius);border:0;display:flex;justify-content:center;align-items:center;cursor:pointer;background-color:var(--wcm-color-bg-1);box-shadow:0 0 0 1px var(--wcm-color-overlay)}button:active{background-color:var(--wcm-color-bg-2)}button svg{display:block;object-position:center}button path{fill:var(--wcm-color-fg-1)}.wcm-toolbar div{display:flex}@media(hover:hover){button:hover{background-color:var(--wcm-color-bg-2)}}`;
      gt3 = Object.defineProperty;
      vt3 = Object.getOwnPropertyDescriptor;
      ut3 = (e9, o9, r8, a6) => {
        for (var t6 = a6 > 1 ? void 0 : a6 ? vt3(o9, r8) : o9, l9 = e9.length - 1, i7; l9 >= 0; l9--)
          (i7 = e9[l9]) && (t6 = (a6 ? i7(o9, r8, t6) : i7(t6)) || t6);
        return a6 && t6 && gt3(o9, r8, t6), t6;
      };
      fe3 = class extends s5 {
        render() {
          return x2`<div class="wcm-toolbar-placeholder"></div><div class="wcm-toolbar">${v3.WALLET_CONNECT_LOGO} <button @click="${se2.close}">${v3.CROSS_ICON}</button></div>`;
        }
      };
      fe3.styles = [h8.globalCss, pt3], fe3 = ut3([e5("wcm-modal-backcard")], fe3);
      bt3 = i2`main{padding:20px;padding-top:0;width:100%}`;
      ft4 = Object.defineProperty;
      xt3 = Object.getOwnPropertyDescriptor;
      yt3 = (e9, o9, r8, a6) => {
        for (var t6 = a6 > 1 ? void 0 : a6 ? xt3(o9, r8) : o9, l9 = e9.length - 1, i7; l9 >= 0; l9--)
          (i7 = e9[l9]) && (t6 = (a6 ? i7(o9, r8, t6) : i7(t6)) || t6);
        return a6 && t6 && ft4(o9, r8, t6), t6;
      };
      xe = class extends s5 {
        render() {
          return x2`<main><slot></slot></main>`;
        }
      };
      xe.styles = [h8.globalCss, bt3], xe = yt3([e5("wcm-modal-content")], xe);
      $t2 = i2`footer{padding:10px;display:flex;flex-direction:column;align-items:inherit;justify-content:inherit;border-top:1px solid var(--wcm-color-bg-2)}`;
      Ct3 = Object.defineProperty;
      kt3 = Object.getOwnPropertyDescriptor;
      Ot4 = (e9, o9, r8, a6) => {
        for (var t6 = a6 > 1 ? void 0 : a6 ? kt3(o9, r8) : o9, l9 = e9.length - 1, i7; l9 >= 0; l9--)
          (i7 = e9[l9]) && (t6 = (a6 ? i7(o9, r8, t6) : i7(t6)) || t6);
        return a6 && t6 && Ct3(o9, r8, t6), t6;
      };
      ye4 = class extends s5 {
        render() {
          return x2`<footer><slot></slot></footer>`;
        }
      };
      ye4.styles = [h8.globalCss, $t2], ye4 = Ot4([e5("wcm-modal-footer")], ye4);
      Wt2 = i2`header{display:flex;justify-content:center;align-items:center;padding:20px;position:relative}.wcm-border{border-bottom:1px solid var(--wcm-color-bg-2);margin-bottom:20px}header button{padding:15px 20px}header button:active{opacity:.5}@media(hover:hover){header button:hover{opacity:.5}}.wcm-back-btn{position:absolute;left:0}.wcm-action-btn{position:absolute;right:0}path{fill:var(--wcm-accent-color)}`;
      It4 = Object.defineProperty;
      Et3 = Object.getOwnPropertyDescriptor;
      te5 = (e9, o9, r8, a6) => {
        for (var t6 = a6 > 1 ? void 0 : a6 ? Et3(o9, r8) : o9, l9 = e9.length - 1, i7; l9 >= 0; l9--)
          (i7 = e9[l9]) && (t6 = (a6 ? i7(o9, r8, t6) : i7(t6)) || t6);
        return a6 && t6 && It4(o9, r8, t6), t6;
      };
      S8 = class extends s5 {
        constructor() {
          super(...arguments), this.title = "", this.onAction = void 0, this.actionIcon = void 0, this.border = false;
        }
        backBtnTemplate() {
          return x2`<button class="wcm-back-btn" @click="${T2.goBack}">${v3.BACK_ICON}</button>`;
        }
        actionBtnTemplate() {
          return x2`<button class="wcm-action-btn" @click="${this.onAction}">${this.actionIcon}</button>`;
        }
        render() {
          const e9 = { "wcm-border": this.border }, o9 = T2.state.history.length > 1, r8 = this.title ? x2`<wcm-text variant="big-bold">${this.title}</wcm-text>` : x2`<slot></slot>`;
          return x2`<header class="${o7(e9)}">${o9 ? this.backBtnTemplate() : null} ${r8} ${this.onAction ? this.actionBtnTemplate() : null}</header>`;
        }
      };
      S8.styles = [h8.globalCss, Wt2], te5([n6()], S8.prototype, "title", 2), te5([n6()], S8.prototype, "onAction", 2), te5([n6()], S8.prototype, "actionIcon", 2), te5([n6({ type: Boolean })], S8.prototype, "border", 2), S8 = te5([e5("wcm-modal-header")], S8);
      c7 = { MOBILE_BREAKPOINT: 600, WCM_RECENT_WALLET_DATA: "WCM_RECENT_WALLET_DATA", EXPLORER_WALLET_URL: "https://explorer.walletconnect.com/?type=wallet", getShadowRootElement(e9, o9) {
        const r8 = e9.renderRoot.querySelector(o9);
        if (!r8)
          throw new Error(`${o9} not found`);
        return r8;
      }, getWalletIcon({ id: e9, image_id: o9 }) {
        const { walletImages: r8 } = y6.state;
        return r8 != null && r8[e9] ? r8[e9] : o9 ? te4.getWalletImageUrl(o9) : "";
      }, getWalletName(e9, o9 = false) {
        return o9 && e9.length > 8 ? `${e9.substring(0, 8)}..` : e9;
      }, isMobileAnimation() {
        return window.innerWidth <= c7.MOBILE_BREAKPOINT;
      }, async preloadImage(e9) {
        const o9 = new Promise((r8, a6) => {
          const t6 = new Image();
          t6.onload = r8, t6.onerror = a6, t6.crossOrigin = "anonymous", t6.src = e9;
        });
        return Promise.race([o9, a3.wait(3e3)]);
      }, getErrorMessage(e9) {
        return e9 instanceof Error ? e9.message : "Unknown Error";
      }, debounce(e9, o9 = 500) {
        let r8;
        return (...a6) => {
          function t6() {
            e9(...a6);
          }
          r8 && clearTimeout(r8), r8 = setTimeout(t6, o9);
        };
      }, handleMobileLinking(e9) {
        const { walletConnectUri: o9 } = p3.state, { mobile: r8, name: a6 } = e9, t6 = r8?.native, l9 = r8?.universal;
        c7.setRecentWallet(e9);
        function i7(s7) {
          let $8 = "";
          t6 ? $8 = a3.formatUniversalUrl(t6, s7, a6) : l9 && ($8 = a3.formatNativeUrl(l9, s7, a6)), a3.openHref($8, "_self");
        }
        o9 && i7(o9);
      }, handleAndroidLinking() {
        const { walletConnectUri: e9 } = p3.state;
        e9 && (a3.setWalletConnectAndroidDeepLink(e9), a3.openHref(e9, "_self"));
      }, async handleUriCopy() {
        const { walletConnectUri: e9 } = p3.state;
        if (e9)
          try {
            await navigator.clipboard.writeText(e9), oe4.openToast("Link copied", "success");
          } catch {
            oe4.openToast("Failed to copy", "error");
          }
      }, getCustomImageUrls() {
        const { walletImages: e9 } = y6.state, o9 = Object.values(e9 ?? {});
        return Object.values(o9);
      }, truncate(e9, o9 = 8) {
        return e9.length <= o9 ? e9 : `${e9.substring(0, 4)}...${e9.substring(e9.length - 4)}`;
      }, setRecentWallet(e9) {
        try {
          localStorage.setItem(c7.WCM_RECENT_WALLET_DATA, JSON.stringify(e9));
        } catch {
          console.info("Unable to set recent wallet");
        }
      }, getRecentWallet() {
        try {
          const e9 = localStorage.getItem(c7.WCM_RECENT_WALLET_DATA);
          return e9 ? JSON.parse(e9) : void 0;
        } catch {
          console.info("Unable to get recent wallet");
        }
      }, caseSafeIncludes(e9, o9) {
        return e9.toUpperCase().includes(o9.toUpperCase());
      }, openWalletExplorerUrl() {
        a3.openHref(c7.EXPLORER_WALLET_URL, "_blank");
      }, getCachedRouterWalletPlatforms() {
        const { desktop: e9, mobile: o9 } = a3.getWalletRouterData(), r8 = Boolean(e9?.native), a6 = Boolean(e9?.universal), t6 = Boolean(o9?.native) || Boolean(o9?.universal);
        return { isDesktop: r8, isMobile: t6, isWeb: a6 };
      }, goToConnectingView(e9) {
        T2.setData({ Wallet: e9 });
        const o9 = a3.isMobile(), { isDesktop: r8, isWeb: a6, isMobile: t6 } = c7.getCachedRouterWalletPlatforms();
        o9 ? t6 ? T2.push("MobileConnecting") : a6 ? T2.push("WebConnecting") : T2.push("InstallWallet") : r8 ? T2.push("DesktopConnecting") : a6 ? T2.push("WebConnecting") : t6 ? T2.push("MobileQrcodeConnecting") : T2.push("InstallWallet");
      } };
      Mt3 = i2`.wcm-router{overflow:hidden;will-change:transform}.wcm-content{display:flex;flex-direction:column}`;
      Lt3 = Object.defineProperty;
      Rt3 = Object.getOwnPropertyDescriptor;
      $e3 = (e9, o9, r8, a6) => {
        for (var t6 = a6 > 1 ? void 0 : a6 ? Rt3(o9, r8) : o9, l9 = e9.length - 1, i7; l9 >= 0; l9--)
          (i7 = e9[l9]) && (t6 = (a6 ? i7(o9, r8, t6) : i7(t6)) || t6);
        return a6 && t6 && Lt3(o9, r8, t6), t6;
      };
      oe5 = class extends s5 {
        constructor() {
          super(), this.view = T2.state.view, this.prevView = T2.state.view, this.unsubscribe = void 0, this.oldHeight = "0px", this.resizeObserver = void 0, this.unsubscribe = T2.subscribe((e9) => {
            this.view !== e9.view && this.onChangeRoute();
          });
        }
        firstUpdated() {
          this.resizeObserver = new ResizeObserver(([e9]) => {
            const o9 = `${e9.contentRect.height}px`;
            this.oldHeight !== "0px" && animate2(this.routerEl, { height: [this.oldHeight, o9] }, { duration: 0.2 }), this.oldHeight = o9;
          }), this.resizeObserver.observe(this.contentEl);
        }
        disconnectedCallback() {
          var e9, o9;
          (e9 = this.unsubscribe) == null || e9.call(this), (o9 = this.resizeObserver) == null || o9.disconnect();
        }
        get routerEl() {
          return c7.getShadowRootElement(this, ".wcm-router");
        }
        get contentEl() {
          return c7.getShadowRootElement(this, ".wcm-content");
        }
        viewTemplate() {
          switch (this.view) {
            case "ConnectWallet":
              return x2`<wcm-connect-wallet-view></wcm-connect-wallet-view>`;
            case "DesktopConnecting":
              return x2`<wcm-desktop-connecting-view></wcm-desktop-connecting-view>`;
            case "MobileConnecting":
              return x2`<wcm-mobile-connecting-view></wcm-mobile-connecting-view>`;
            case "WebConnecting":
              return x2`<wcm-web-connecting-view></wcm-web-connecting-view>`;
            case "MobileQrcodeConnecting":
              return x2`<wcm-mobile-qr-connecting-view></wcm-mobile-qr-connecting-view>`;
            case "WalletExplorer":
              return x2`<wcm-wallet-explorer-view></wcm-wallet-explorer-view>`;
            case "Qrcode":
              return x2`<wcm-qrcode-view></wcm-qrcode-view>`;
            case "InstallWallet":
              return x2`<wcm-install-wallet-view></wcm-install-wallet-view>`;
            default:
              return x2`<div>Not Found</div>`;
          }
        }
        async onChangeRoute() {
          await animate2(this.routerEl, { opacity: [1, 0], scale: [1, 1.02] }, { duration: 0.15, delay: 0.1 }).finished, this.view = T2.state.view, animate2(this.routerEl, { opacity: [0, 1], scale: [0.99, 1] }, { duration: 0.37, delay: 0.05 });
        }
        render() {
          return x2`<div class="wcm-router"><div class="wcm-content">${this.viewTemplate()}</div></div>`;
        }
      };
      oe5.styles = [h8.globalCss, Mt3], $e3([t4()], oe5.prototype, "view", 2), $e3([t4()], oe5.prototype, "prevView", 2), oe5 = $e3([e5("wcm-modal-router")], oe5);
      At2 = i2`div{height:36px;width:max-content;display:flex;justify-content:center;align-items:center;padding:9px 15px 11px;position:absolute;top:12px;box-shadow:0 6px 14px -6px rgba(10,16,31,.3),0 10px 32px -4px rgba(10,16,31,.15);z-index:2;left:50%;transform:translateX(-50%);pointer-events:none;backdrop-filter:blur(20px) saturate(1.8);-webkit-backdrop-filter:blur(20px) saturate(1.8);border-radius:var(--wcm-notification-border-radius);border:1px solid var(--wcm-color-overlay);background-color:var(--wcm-color-overlay)}svg{margin-right:5px}@-moz-document url-prefix(){div{background-color:var(--wcm-color-bg-3)}}.wcm-success path{fill:var(--wcm-accent-color)}.wcm-error path{fill:var(--wcm-error-color)}`;
      Pt3 = Object.defineProperty;
      Tt3 = Object.getOwnPropertyDescriptor;
      ze2 = (e9, o9, r8, a6) => {
        for (var t6 = a6 > 1 ? void 0 : a6 ? Tt3(o9, r8) : o9, l9 = e9.length - 1, i7; l9 >= 0; l9--)
          (i7 = e9[l9]) && (t6 = (a6 ? i7(o9, r8, t6) : i7(t6)) || t6);
        return a6 && t6 && Pt3(o9, r8, t6), t6;
      };
      ne3 = class extends s5 {
        constructor() {
          super(), this.open = false, this.unsubscribe = void 0, this.timeout = void 0, this.unsubscribe = oe4.subscribe((e9) => {
            e9.open ? (this.open = true, this.timeout = setTimeout(() => oe4.closeToast(), 2200)) : (this.open = false, clearTimeout(this.timeout));
          });
        }
        disconnectedCallback() {
          var e9;
          (e9 = this.unsubscribe) == null || e9.call(this), clearTimeout(this.timeout), oe4.closeToast();
        }
        render() {
          const { message: e9, variant: o9 } = oe4.state, r8 = { "wcm-success": o9 === "success", "wcm-error": o9 === "error" };
          return this.open ? x2`<div class="${o7(r8)}">${o9 === "success" ? v3.CHECKMARK_ICON : null} ${o9 === "error" ? v3.CROSS_ICON : null}<wcm-text variant="small-regular">${e9}</wcm-text></div>` : null;
        }
      };
      ne3.styles = [h8.globalCss, At2], ze2([t4()], ne3.prototype, "open", 2), ne3 = ze2([e5("wcm-modal-toast")], ne3);
      jt3 = 0.1;
      Ve3 = 2.5;
      A4 = 7;
      Dt3 = { generate(e9, o9, r8) {
        const a6 = "#141414", t6 = "#ffffff", l9 = [], i7 = _t2(e9, "Q"), s7 = o9 / i7.length, $8 = [{ x: 0, y: 0 }, { x: 1, y: 0 }, { x: 0, y: 1 }];
        $8.forEach(({ x: y11, y: u7 }) => {
          const O8 = (i7.length - A4) * s7 * y11, b7 = (i7.length - A4) * s7 * u7, E8 = 0.45;
          for (let M7 = 0; M7 < $8.length; M7 += 1) {
            const V9 = s7 * (A4 - M7 * 2);
            l9.push(b4`<rect fill="${M7 % 2 === 0 ? a6 : t6}" height="${V9}" rx="${V9 * E8}" ry="${V9 * E8}" width="${V9}" x="${O8 + s7 * M7}" y="${b7 + s7 * M7}">`);
          }
        });
        const f7 = Math.floor((r8 + 25) / s7), Ne3 = i7.length / 2 - f7 / 2, Ze4 = i7.length / 2 + f7 / 2 - 1, Se3 = [];
        i7.forEach((y11, u7) => {
          y11.forEach((O8, b7) => {
            if (i7[u7][b7] && !(u7 < A4 && b7 < A4 || u7 > i7.length - (A4 + 1) && b7 < A4 || u7 < A4 && b7 > i7.length - (A4 + 1)) && !(u7 > Ne3 && u7 < Ze4 && b7 > Ne3 && b7 < Ze4)) {
              const E8 = u7 * s7 + s7 / 2, M7 = b7 * s7 + s7 / 2;
              Se3.push([E8, M7]);
            }
          });
        });
        const J5 = {};
        return Se3.forEach(([y11, u7]) => {
          J5[y11] ? J5[y11].push(u7) : J5[y11] = [u7];
        }), Object.entries(J5).map(([y11, u7]) => {
          const O8 = u7.filter((b7) => u7.every((E8) => !Ce2(b7, E8, s7)));
          return [Number(y11), O8];
        }).forEach(([y11, u7]) => {
          u7.forEach((O8) => {
            l9.push(b4`<circle cx="${y11}" cy="${O8}" fill="${a6}" r="${s7 / Ve3}">`);
          });
        }), Object.entries(J5).filter(([y11, u7]) => u7.length > 1).map(([y11, u7]) => {
          const O8 = u7.filter((b7) => u7.some((E8) => Ce2(b7, E8, s7)));
          return [Number(y11), O8];
        }).map(([y11, u7]) => {
          u7.sort((b7, E8) => b7 < E8 ? -1 : 1);
          const O8 = [];
          for (const b7 of u7) {
            const E8 = O8.find((M7) => M7.some((V9) => Ce2(b7, V9, s7)));
            E8 ? E8.push(b7) : O8.push([b7]);
          }
          return [y11, O8.map((b7) => [b7[0], b7[b7.length - 1]])];
        }).forEach(([y11, u7]) => {
          u7.forEach(([O8, b7]) => {
            l9.push(b4`<line x1="${y11}" x2="${y11}" y1="${O8}" y2="${b7}" stroke="${a6}" stroke-width="${s7 / (Ve3 / 2)}" stroke-linecap="round">`);
          });
        }), l9;
      } };
      Nt3 = i2`@keyframes fadeIn{0%{opacity:0}100%{opacity:1}}div{position:relative;user-select:none;display:block;overflow:hidden;aspect-ratio:1/1;animation:fadeIn ease .2s}.wcm-dark{background-color:#fff;border-radius:var(--wcm-container-border-radius);padding:18px;box-shadow:0 2px 5px #000}svg:first-child,wcm-wallet-image{position:absolute;top:50%;left:50%;transform:translateY(-50%) translateX(-50%)}wcm-wallet-image{transform:translateY(-50%) translateX(-50%)}wcm-wallet-image{width:25%;height:25%;border-radius:var(--wcm-wallet-icon-border-radius)}svg:first-child{transform:translateY(-50%) translateX(-50%) scale(.9)}svg:first-child path:first-child{fill:var(--wcm-accent-color)}svg:first-child path:last-child{stroke:var(--wcm-color-overlay)}`;
      Zt2 = Object.defineProperty;
      St4 = Object.getOwnPropertyDescriptor;
      q3 = (e9, o9, r8, a6) => {
        for (var t6 = a6 > 1 ? void 0 : a6 ? St4(o9, r8) : o9, l9 = e9.length - 1, i7; l9 >= 0; l9--)
          (i7 = e9[l9]) && (t6 = (a6 ? i7(o9, r8, t6) : i7(t6)) || t6);
        return a6 && t6 && Zt2(o9, r8, t6), t6;
      };
      j3 = class extends s5 {
        constructor() {
          super(...arguments), this.uri = "", this.size = 0, this.imageId = void 0, this.walletId = void 0, this.imageUrl = void 0;
        }
        svgTemplate() {
          const e9 = ne2.state.themeMode === "light" ? this.size : this.size - 36;
          return b4`<svg height="${e9}" width="${e9}">${Dt3.generate(this.uri, e9, e9 / 4)}</svg>`;
        }
        render() {
          const e9 = { "wcm-dark": ne2.state.themeMode === "dark" };
          return x2`<div style="${`width: ${this.size}px`}" class="${o7(e9)}">${this.walletId || this.imageUrl ? x2`<wcm-wallet-image walletId="${l7(this.walletId)}" imageId="${l7(this.imageId)}" imageUrl="${l7(this.imageUrl)}"></wcm-wallet-image>` : v3.WALLET_CONNECT_ICON_COLORED} ${this.svgTemplate()}</div>`;
        }
      };
      j3.styles = [h8.globalCss, Nt3], q3([n6()], j3.prototype, "uri", 2), q3([n6({ type: Number })], j3.prototype, "size", 2), q3([n6()], j3.prototype, "imageId", 2), q3([n6()], j3.prototype, "walletId", 2), q3([n6()], j3.prototype, "imageUrl", 2), j3 = q3([e5("wcm-qrcode")], j3);
      Bt3 = i2`:host{position:relative;height:28px;width:80%}input{width:100%;height:100%;line-height:28px!important;border-radius:var(--wcm-input-border-radius);font-style:normal;font-family:-apple-system,system-ui,BlinkMacSystemFont,'Segoe UI',Roboto,Ubuntu,'Helvetica Neue',sans-serif;font-feature-settings:'case' on;font-weight:500;font-size:16px;letter-spacing:-.03em;padding:0 10px 0 34px;transition:.2s all ease;color:var(--wcm-color-fg-1);background-color:var(--wcm-color-bg-3);box-shadow:inset 0 0 0 1px var(--wcm-color-overlay);caret-color:var(--wcm-accent-color)}input::placeholder{color:var(--wcm-color-fg-2)}svg{left:10px;top:4px;pointer-events:none;position:absolute;width:20px;height:20px}input:focus-within{box-shadow:inset 0 0 0 1px var(--wcm-accent-color)}path{fill:var(--wcm-color-fg-2)}`;
      Ut2 = Object.defineProperty;
      Ht2 = Object.getOwnPropertyDescriptor;
      Fe3 = (e9, o9, r8, a6) => {
        for (var t6 = a6 > 1 ? void 0 : a6 ? Ht2(o9, r8) : o9, l9 = e9.length - 1, i7; l9 >= 0; l9--)
          (i7 = e9[l9]) && (t6 = (a6 ? i7(o9, r8, t6) : i7(t6)) || t6);
        return a6 && t6 && Ut2(o9, r8, t6), t6;
      };
      ce4 = class extends s5 {
        constructor() {
          super(...arguments), this.onChange = () => null;
        }
        render() {
          return x2`<input type="text" @input="${this.onChange}" placeholder="Search wallets"> ${v3.SEARCH_ICON}`;
        }
      };
      ce4.styles = [h8.globalCss, Bt3], Fe3([n6()], ce4.prototype, "onChange", 2), ce4 = Fe3([e5("wcm-search-input")], ce4);
      zt3 = i2`@keyframes rotate{100%{transform:rotate(360deg)}}@keyframes dash{0%{stroke-dasharray:1,150;stroke-dashoffset:0}50%{stroke-dasharray:90,150;stroke-dashoffset:-35}100%{stroke-dasharray:90,150;stroke-dashoffset:-124}}svg{animation:rotate 2s linear infinite;display:flex;justify-content:center;align-items:center}svg circle{stroke-linecap:round;animation:dash 1.5s ease infinite;stroke:var(--wcm-accent-color)}`;
      Vt3 = Object.defineProperty;
      Ft3 = Object.getOwnPropertyDescriptor;
      qt3 = (e9, o9, r8, a6) => {
        for (var t6 = a6 > 1 ? void 0 : a6 ? Ft3(o9, r8) : o9, l9 = e9.length - 1, i7; l9 >= 0; l9--)
          (i7 = e9[l9]) && (t6 = (a6 ? i7(o9, r8, t6) : i7(t6)) || t6);
        return a6 && t6 && Vt3(o9, r8, t6), t6;
      };
      ke3 = class extends s5 {
        render() {
          return x2`<svg viewBox="0 0 50 50" width="24" height="24"><circle cx="25" cy="25" r="20" fill="none" stroke-width="4" stroke="#fff"/></svg>`;
        }
      };
      ke3.styles = [h8.globalCss, zt3], ke3 = qt3([e5("wcm-spinner")], ke3);
      Qt2 = i2`span{font-style:normal;font-family:var(--wcm-font-family);font-feature-settings:var(--wcm-font-feature-settings)}.wcm-xsmall-bold{font-family:var(--wcm-text-xsmall-bold-font-family);font-weight:var(--wcm-text-xsmall-bold-weight);font-size:var(--wcm-text-xsmall-bold-size);line-height:var(--wcm-text-xsmall-bold-line-height);letter-spacing:var(--wcm-text-xsmall-bold-letter-spacing);text-transform:var(--wcm-text-xsmall-bold-text-transform)}.wcm-xsmall-regular{font-family:var(--wcm-text-xsmall-regular-font-family);font-weight:var(--wcm-text-xsmall-regular-weight);font-size:var(--wcm-text-xsmall-regular-size);line-height:var(--wcm-text-xsmall-regular-line-height);letter-spacing:var(--wcm-text-xsmall-regular-letter-spacing);text-transform:var(--wcm-text-xsmall-regular-text-transform)}.wcm-small-thin{font-family:var(--wcm-text-small-thin-font-family);font-weight:var(--wcm-text-small-thin-weight);font-size:var(--wcm-text-small-thin-size);line-height:var(--wcm-text-small-thin-line-height);letter-spacing:var(--wcm-text-small-thin-letter-spacing);text-transform:var(--wcm-text-small-thin-text-transform)}.wcm-small-regular{font-family:var(--wcm-text-small-regular-font-family);font-weight:var(--wcm-text-small-regular-weight);font-size:var(--wcm-text-small-regular-size);line-height:var(--wcm-text-small-regular-line-height);letter-spacing:var(--wcm-text-small-regular-letter-spacing);text-transform:var(--wcm-text-small-regular-text-transform)}.wcm-medium-regular{font-family:var(--wcm-text-medium-regular-font-family);font-weight:var(--wcm-text-medium-regular-weight);font-size:var(--wcm-text-medium-regular-size);line-height:var(--wcm-text-medium-regular-line-height);letter-spacing:var(--wcm-text-medium-regular-letter-spacing);text-transform:var(--wcm-text-medium-regular-text-transform)}.wcm-big-bold{font-family:var(--wcm-text-big-bold-font-family);font-weight:var(--wcm-text-big-bold-weight);font-size:var(--wcm-text-big-bold-size);line-height:var(--wcm-text-big-bold-line-height);letter-spacing:var(--wcm-text-big-bold-letter-spacing);text-transform:var(--wcm-text-big-bold-text-transform)}:host(*){color:var(--wcm-color-fg-1)}.wcm-color-primary{color:var(--wcm-color-fg-1)}.wcm-color-secondary{color:var(--wcm-color-fg-2)}.wcm-color-tertiary{color:var(--wcm-color-fg-3)}.wcm-color-inverse{color:var(--wcm-accent-fill-color)}.wcm-color-accnt{color:var(--wcm-accent-color)}.wcm-color-error{color:var(--wcm-error-color)}`;
      Kt3 = Object.defineProperty;
      Yt3 = Object.getOwnPropertyDescriptor;
      Oe = (e9, o9, r8, a6) => {
        for (var t6 = a6 > 1 ? void 0 : a6 ? Yt3(o9, r8) : o9, l9 = e9.length - 1, i7; l9 >= 0; l9--)
          (i7 = e9[l9]) && (t6 = (a6 ? i7(o9, r8, t6) : i7(t6)) || t6);
        return a6 && t6 && Kt3(o9, r8, t6), t6;
      };
      re3 = class extends s5 {
        constructor() {
          super(...arguments), this.variant = "medium-regular", this.color = "primary";
        }
        render() {
          const e9 = { "wcm-big-bold": this.variant === "big-bold", "wcm-medium-regular": this.variant === "medium-regular", "wcm-small-regular": this.variant === "small-regular", "wcm-small-thin": this.variant === "small-thin", "wcm-xsmall-regular": this.variant === "xsmall-regular", "wcm-xsmall-bold": this.variant === "xsmall-bold", "wcm-color-primary": this.color === "primary", "wcm-color-secondary": this.color === "secondary", "wcm-color-tertiary": this.color === "tertiary", "wcm-color-inverse": this.color === "inverse", "wcm-color-accnt": this.color === "accent", "wcm-color-error": this.color === "error" };
          return x2`<span><slot class="${o7(e9)}"></slot></span>`;
        }
      };
      re3.styles = [h8.globalCss, Qt2], Oe([n6()], re3.prototype, "variant", 2), Oe([n6()], re3.prototype, "color", 2), re3 = Oe([e5("wcm-text")], re3);
      Gt3 = i2`button{width:100%;height:100%;border-radius:var(--wcm-button-hover-highlight-border-radius);display:flex;align-items:flex-start}button:active{background-color:var(--wcm-color-overlay)}@media(hover:hover){button:hover{background-color:var(--wcm-color-overlay)}}button>div{width:80px;padding:5px 0;display:flex;flex-direction:column;align-items:center}wcm-text{width:100%;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-align:center}wcm-wallet-image{height:60px;width:60px;transition:all .2s ease;border-radius:var(--wcm-wallet-icon-border-radius);margin-bottom:5px}.wcm-sublabel{margin-top:2px}`;
      Xt2 = Object.defineProperty;
      Jt3 = Object.getOwnPropertyDescriptor;
      _5 = (e9, o9, r8, a6) => {
        for (var t6 = a6 > 1 ? void 0 : a6 ? Jt3(o9, r8) : o9, l9 = e9.length - 1, i7; l9 >= 0; l9--)
          (i7 = e9[l9]) && (t6 = (a6 ? i7(o9, r8, t6) : i7(t6)) || t6);
        return a6 && t6 && Xt2(o9, r8, t6), t6;
      };
      L5 = class extends s5 {
        constructor() {
          super(...arguments), this.onClick = () => null, this.name = "", this.walletId = "", this.label = void 0, this.imageId = void 0, this.installed = false, this.recent = false;
        }
        sublabelTemplate() {
          return this.recent ? x2`<wcm-text class="wcm-sublabel" variant="xsmall-bold" color="tertiary">RECENT</wcm-text>` : this.installed ? x2`<wcm-text class="wcm-sublabel" variant="xsmall-bold" color="tertiary">INSTALLED</wcm-text>` : null;
        }
        handleClick() {
          R2.click({ name: "WALLET_BUTTON", walletId: this.walletId }), this.onClick();
        }
        render() {
          var e9;
          return x2`<button @click="${this.handleClick.bind(this)}"><div><wcm-wallet-image walletId="${this.walletId}" imageId="${l7(this.imageId)}"></wcm-wallet-image><wcm-text variant="xsmall-regular">${(e9 = this.label) != null ? e9 : c7.getWalletName(this.name, true)}</wcm-text>${this.sublabelTemplate()}</div></button>`;
        }
      };
      L5.styles = [h8.globalCss, Gt3], _5([n6()], L5.prototype, "onClick", 2), _5([n6()], L5.prototype, "name", 2), _5([n6()], L5.prototype, "walletId", 2), _5([n6()], L5.prototype, "label", 2), _5([n6()], L5.prototype, "imageId", 2), _5([n6({ type: Boolean })], L5.prototype, "installed", 2), _5([n6({ type: Boolean })], L5.prototype, "recent", 2), L5 = _5([e5("wcm-wallet-button")], L5);
      eo = i2`:host{display:block}div{overflow:hidden;position:relative;border-radius:inherit;width:100%;height:100%;background-color:var(--wcm-color-overlay)}svg{position:relative;width:100%;height:100%}div::after{content:'';position:absolute;top:0;bottom:0;left:0;right:0;border-radius:inherit;border:1px solid var(--wcm-color-overlay)}div img{width:100%;height:100%;object-fit:cover;object-position:center}#wallet-placeholder-fill{fill:var(--wcm-color-bg-3)}#wallet-placeholder-dash{stroke:var(--wcm-color-overlay)}`;
      to = Object.defineProperty;
      oo = Object.getOwnPropertyDescriptor;
      se3 = (e9, o9, r8, a6) => {
        for (var t6 = a6 > 1 ? void 0 : a6 ? oo(o9, r8) : o9, l9 = e9.length - 1, i7; l9 >= 0; l9--)
          (i7 = e9[l9]) && (t6 = (a6 ? i7(o9, r8, t6) : i7(t6)) || t6);
        return a6 && t6 && to(o9, r8, t6), t6;
      };
      Q5 = class extends s5 {
        constructor() {
          super(...arguments), this.walletId = "", this.imageId = void 0, this.imageUrl = void 0;
        }
        render() {
          var e9;
          const o9 = (e9 = this.imageUrl) != null && e9.length ? this.imageUrl : c7.getWalletIcon({ id: this.walletId, image_id: this.imageId });
          return x2`${o9.length ? x2`<div><img crossorigin="anonymous" src="${o9}" alt="${this.id}"></div>` : v3.WALLET_PLACEHOLDER}`;
        }
      };
      Q5.styles = [h8.globalCss, eo], se3([n6()], Q5.prototype, "walletId", 2), se3([n6()], Q5.prototype, "imageId", 2), se3([n6()], Q5.prototype, "imageUrl", 2), Q5 = se3([e5("wcm-wallet-image")], Q5);
      ro = Object.defineProperty;
      ao = Object.getOwnPropertyDescriptor;
      qe3 = (e9, o9, r8, a6) => {
        for (var t6 = a6 > 1 ? void 0 : a6 ? ao(o9, r8) : o9, l9 = e9.length - 1, i7; l9 >= 0; l9--)
          (i7 = e9[l9]) && (t6 = (a6 ? i7(o9, r8, t6) : i7(t6)) || t6);
        return a6 && t6 && ro(o9, r8, t6), t6;
      };
      We3 = class extends s5 {
        constructor() {
          super(), this.preload = true, this.preloadData();
        }
        async loadImages(e9) {
          try {
            e9 != null && e9.length && await Promise.all(e9.map(async (o9) => c7.preloadImage(o9)));
          } catch {
            console.info("Unsuccessful attempt at preloading some images", e9);
          }
        }
        async preloadListings() {
          if (y6.state.enableExplorer) {
            await te4.getRecomendedWallets(), p3.setIsDataLoaded(true);
            const { recomendedWallets: e9 } = te4.state, o9 = e9.map((r8) => c7.getWalletIcon(r8));
            await this.loadImages(o9);
          } else
            p3.setIsDataLoaded(true);
        }
        async preloadCustomImages() {
          const e9 = c7.getCustomImageUrls();
          await this.loadImages(e9);
        }
        async preloadData() {
          try {
            this.preload && (this.preload = false, await Promise.all([this.preloadListings(), this.preloadCustomImages()]));
          } catch (e9) {
            console.error(e9), oe4.openToast("Failed preloading", "error");
          }
        }
      };
      qe3([t4()], We3.prototype, "preload", 2), We3 = qe3([e5("wcm-explorer-context")], We3);
      lo = Object.defineProperty;
      io = Object.getOwnPropertyDescriptor;
      no = (e9, o9, r8, a6) => {
        for (var t6 = a6 > 1 ? void 0 : a6 ? io(o9, r8) : o9, l9 = e9.length - 1, i7; l9 >= 0; l9--)
          (i7 = e9[l9]) && (t6 = (a6 ? i7(o9, r8, t6) : i7(t6)) || t6);
        return a6 && t6 && lo(o9, r8, t6), t6;
      };
      Qe3 = class extends s5 {
        constructor() {
          super(), this.unsubscribeTheme = void 0, h8.setTheme(), this.unsubscribeTheme = ne2.subscribe(h8.setTheme);
        }
        disconnectedCallback() {
          var e9;
          (e9 = this.unsubscribeTheme) == null || e9.call(this);
        }
      };
      Qe3 = no([e5("wcm-theme-context")], Qe3);
      co = i2`@keyframes scroll{0%{transform:translate3d(0,0,0)}100%{transform:translate3d(calc(-70px * 9),0,0)}}.wcm-slider{position:relative;overflow-x:hidden;padding:10px 0;margin:0 -20px;width:calc(100% + 40px)}.wcm-track{display:flex;width:calc(70px * 18);animation:scroll 20s linear infinite;opacity:.7}.wcm-track svg{margin:0 5px}wcm-wallet-image{width:60px;height:60px;margin:0 5px;border-radius:var(--wcm-wallet-icon-border-radius)}.wcm-grid{display:grid;grid-template-columns:repeat(4,80px);justify-content:space-between}.wcm-title{display:flex;align-items:center;margin-bottom:10px}.wcm-title svg{margin-right:6px}.wcm-title path{fill:var(--wcm-accent-color)}wcm-modal-footer .wcm-title{padding:0 10px}wcm-button-big{position:absolute;top:50%;left:50%;transform:translateY(-50%) translateX(-50%);filter:drop-shadow(0 0 17px var(--wcm-color-bg-1))}wcm-info-footer{flex-direction:column;align-items:center;display:flex;width:100%;padding:5px 0}wcm-info-footer wcm-text{text-align:center;margin-bottom:15px}#wallet-placeholder-fill{fill:var(--wcm-color-bg-3)}#wallet-placeholder-dash{stroke:var(--wcm-color-overlay)}`;
      so = Object.defineProperty;
      mo = Object.getOwnPropertyDescriptor;
      ho = (e9, o9, r8, a6) => {
        for (var t6 = a6 > 1 ? void 0 : a6 ? mo(o9, r8) : o9, l9 = e9.length - 1, i7; l9 >= 0; l9--)
          (i7 = e9[l9]) && (t6 = (a6 ? i7(o9, r8, t6) : i7(t6)) || t6);
        return a6 && t6 && so(o9, r8, t6), t6;
      };
      Ie3 = class extends s5 {
        onGoToQrcode() {
          T2.push("Qrcode");
        }
        render() {
          const { recomendedWallets: e9 } = te4.state, o9 = [...e9, ...e9], r8 = a3.RECOMMENDED_WALLET_AMOUNT * 2;
          return x2`<wcm-modal-header title="Connect your wallet" .onAction="${this.onGoToQrcode}" .actionIcon="${v3.QRCODE_ICON}"></wcm-modal-header><wcm-modal-content><div class="wcm-title">${v3.MOBILE_ICON}<wcm-text variant="small-regular" color="accent">WalletConnect</wcm-text></div><div class="wcm-slider"><div class="wcm-track">${[...Array(r8)].map((a6, t6) => {
            const l9 = o9[t6 % o9.length];
            return l9 ? x2`<wcm-wallet-image walletId="${l9.id}" imageId="${l9.image_id}"></wcm-wallet-image>` : v3.WALLET_PLACEHOLDER;
          })}</div><wcm-button-big @click="${c7.handleAndroidLinking}"><wcm-text variant="medium-regular" color="inverse">Select Wallet</wcm-text></wcm-button-big></div></wcm-modal-content><wcm-info-footer><wcm-text color="secondary" variant="small-thin">Choose WalletConnect to see supported apps on your device</wcm-text></wcm-info-footer>`;
        }
      };
      Ie3.styles = [h8.globalCss, co], Ie3 = ho([e5("wcm-android-wallet-selection")], Ie3);
      wo = i2`@keyframes loading{to{stroke-dashoffset:0}}@keyframes shake{10%,90%{transform:translate3d(-1px,0,0)}20%,80%{transform:translate3d(1px,0,0)}30%,50%,70%{transform:translate3d(-2px,0,0)}40%,60%{transform:translate3d(2px,0,0)}}:host{display:flex;flex-direction:column;align-items:center}div{position:relative;width:110px;height:110px;display:flex;justify-content:center;align-items:center;margin:40px 0 20px 0;transform:translate3d(0,0,0)}svg{position:absolute;width:110px;height:110px;fill:none;stroke:transparent;stroke-linecap:round;stroke-width:2px;top:0;left:0}use{stroke:var(--wcm-accent-color);animation:loading 1s linear infinite}wcm-wallet-image{border-radius:var(--wcm-wallet-icon-large-border-radius);width:90px;height:90px}wcm-text{margin-bottom:40px}.wcm-error svg{stroke:var(--wcm-error-color)}.wcm-error use{display:none}.wcm-error{animation:shake .4s cubic-bezier(.36,.07,.19,.97) both}.wcm-stale svg,.wcm-stale use{display:none}`;
      po = Object.defineProperty;
      go = Object.getOwnPropertyDescriptor;
      K4 = (e9, o9, r8, a6) => {
        for (var t6 = a6 > 1 ? void 0 : a6 ? go(o9, r8) : o9, l9 = e9.length - 1, i7; l9 >= 0; l9--)
          (i7 = e9[l9]) && (t6 = (a6 ? i7(o9, r8, t6) : i7(t6)) || t6);
        return a6 && t6 && po(o9, r8, t6), t6;
      };
      D6 = class extends s5 {
        constructor() {
          super(...arguments), this.walletId = void 0, this.imageId = void 0, this.isError = false, this.isStale = false, this.label = "";
        }
        svgLoaderTemplate() {
          var e9, o9;
          const r8 = (o9 = (e9 = ne2.state.themeVariables) == null ? void 0 : e9["--wcm-wallet-icon-large-border-radius"]) != null ? o9 : h8.getPreset("--wcm-wallet-icon-large-border-radius");
          let a6 = 0;
          r8.includes("%") ? a6 = 88 / 100 * parseInt(r8, 10) : a6 = parseInt(r8, 10), a6 *= 1.17;
          const t6 = 317 - a6 * 1.57, l9 = 425 - a6 * 1.8;
          return x2`<svg viewBox="0 0 110 110" width="110" height="110"><rect id="wcm-loader" x="2" y="2" width="106" height="106" rx="${a6}"/><use xlink:href="#wcm-loader" stroke-dasharray="106 ${t6}" stroke-dashoffset="${l9}"></use></svg>`;
        }
        render() {
          const e9 = { "wcm-error": this.isError, "wcm-stale": this.isStale };
          return x2`<div class="${o7(e9)}">${this.svgLoaderTemplate()}<wcm-wallet-image walletId="${l7(this.walletId)}" imageId="${l7(this.imageId)}"></wcm-wallet-image></div><wcm-text variant="medium-regular" color="${this.isError ? "error" : "primary"}">${this.isError ? "Connection declined" : this.label}</wcm-text>`;
        }
      };
      D6.styles = [h8.globalCss, wo], K4([n6()], D6.prototype, "walletId", 2), K4([n6()], D6.prototype, "imageId", 2), K4([n6({ type: Boolean })], D6.prototype, "isError", 2), K4([n6({ type: Boolean })], D6.prototype, "isStale", 2), K4([n6()], D6.prototype, "label", 2), D6 = K4([e5("wcm-connector-waiting")], D6);
      G5 = { manualWallets() {
        var e9, o9;
        const { mobileWallets: r8, desktopWallets: a6 } = y6.state, t6 = (e9 = G5.recentWallet()) == null ? void 0 : e9.id, l9 = a3.isMobile() ? r8 : a6, i7 = l9?.filter((s7) => t6 !== s7.id);
        return (o9 = a3.isMobile() ? i7?.map(({ id: s7, name: $8, links: f7 }) => ({ id: s7, name: $8, mobile: f7, links: f7 })) : i7?.map(({ id: s7, name: $8, links: f7 }) => ({ id: s7, name: $8, desktop: f7, links: f7 }))) != null ? o9 : [];
      }, recentWallet() {
        return c7.getRecentWallet();
      }, recomendedWallets(e9 = false) {
        var o9;
        const r8 = e9 || (o9 = G5.recentWallet()) == null ? void 0 : o9.id, { recomendedWallets: a6 } = te4.state;
        return a6.filter((t6) => r8 !== t6.id);
      } };
      Z5 = { onConnecting(e9) {
        c7.goToConnectingView(e9);
      }, manualWalletsTemplate() {
        return G5.manualWallets().map((e9) => x2`<wcm-wallet-button walletId="${e9.id}" name="${e9.name}" .onClick="${() => this.onConnecting(e9)}"></wcm-wallet-button>`);
      }, recomendedWalletsTemplate(e9 = false) {
        return G5.recomendedWallets(e9).map((o9) => x2`<wcm-wallet-button name="${o9.name}" walletId="${o9.id}" imageId="${o9.image_id}" .onClick="${() => this.onConnecting(o9)}"></wcm-wallet-button>`);
      }, recentWalletTemplate() {
        const e9 = G5.recentWallet();
        if (e9)
          return x2`<wcm-wallet-button name="${e9.name}" walletId="${e9.id}" imageId="${l7(e9.image_id)}" .recent="${true}" .onClick="${() => this.onConnecting(e9)}"></wcm-wallet-button>`;
      } };
      vo = i2`.wcm-grid{display:grid;grid-template-columns:repeat(4,80px);justify-content:space-between}.wcm-desktop-title,.wcm-mobile-title{display:flex;align-items:center}.wcm-mobile-title{justify-content:space-between;margin-bottom:20px;margin-top:-10px}.wcm-desktop-title{margin-bottom:10px;padding:0 10px}.wcm-subtitle{display:flex;align-items:center}.wcm-subtitle:last-child path{fill:var(--wcm-color-fg-3)}.wcm-desktop-title svg,.wcm-mobile-title svg{margin-right:6px}.wcm-desktop-title path,.wcm-mobile-title path{fill:var(--wcm-accent-color)}`;
      uo = Object.defineProperty;
      bo = Object.getOwnPropertyDescriptor;
      fo = (e9, o9, r8, a6) => {
        for (var t6 = a6 > 1 ? void 0 : a6 ? bo(o9, r8) : o9, l9 = e9.length - 1, i7; l9 >= 0; l9--)
          (i7 = e9[l9]) && (t6 = (a6 ? i7(o9, r8, t6) : i7(t6)) || t6);
        return a6 && t6 && uo(o9, r8, t6), t6;
      };
      Ee2 = class extends s5 {
        render() {
          const { explorerExcludedWalletIds: e9, enableExplorer: o9 } = y6.state, r8 = e9 !== "ALL" && o9, a6 = Z5.manualWalletsTemplate(), t6 = Z5.recomendedWalletsTemplate();
          let l9 = [Z5.recentWalletTemplate(), ...a6, ...t6];
          l9 = l9.filter(Boolean);
          const i7 = l9.length > 4 || r8;
          let s7 = [];
          i7 ? s7 = l9.slice(0, 3) : s7 = l9;
          const $8 = Boolean(s7.length);
          return x2`<wcm-modal-header .border="${true}" title="Connect your wallet" .onAction="${c7.handleUriCopy}" .actionIcon="${v3.COPY_ICON}"></wcm-modal-header><wcm-modal-content><div class="wcm-mobile-title"><div class="wcm-subtitle">${v3.MOBILE_ICON}<wcm-text variant="small-regular" color="accent">Mobile</wcm-text></div><div class="wcm-subtitle">${v3.SCAN_ICON}<wcm-text variant="small-regular" color="secondary">Scan with your wallet</wcm-text></div></div><wcm-walletconnect-qr></wcm-walletconnect-qr></wcm-modal-content>${$8 ? x2`<wcm-modal-footer><div class="wcm-desktop-title">${v3.DESKTOP_ICON}<wcm-text variant="small-regular" color="accent">Desktop</wcm-text></div><div class="wcm-grid">${s7} ${i7 ? x2`<wcm-view-all-wallets-button></wcm-view-all-wallets-button>` : null}</div></wcm-modal-footer>` : null}`;
        }
      };
      Ee2.styles = [h8.globalCss, vo], Ee2 = fo([e5("wcm-desktop-wallet-selection")], Ee2);
      xo = i2`div{background-color:var(--wcm-color-bg-2);padding:10px 20px 15px 20px;border-top:1px solid var(--wcm-color-bg-3);text-align:center}a{color:var(--wcm-accent-color);text-decoration:none;transition:opacity .2s ease-in-out;display:inline}a:active{opacity:.8}@media(hover:hover){a:hover{opacity:.8}}`;
      yo = Object.defineProperty;
      $o = Object.getOwnPropertyDescriptor;
      Co = (e9, o9, r8, a6) => {
        for (var t6 = a6 > 1 ? void 0 : a6 ? $o(o9, r8) : o9, l9 = e9.length - 1, i7; l9 >= 0; l9--)
          (i7 = e9[l9]) && (t6 = (a6 ? i7(o9, r8, t6) : i7(t6)) || t6);
        return a6 && t6 && yo(o9, r8, t6), t6;
      };
      Me3 = class extends s5 {
        render() {
          const { termsOfServiceUrl: e9, privacyPolicyUrl: o9 } = y6.state;
          return e9 ?? o9 ? x2`<div><wcm-text variant="small-regular" color="secondary">By connecting your wallet to this app, you agree to the app's ${e9 ? x2`<a href="${e9}" target="_blank" rel="noopener noreferrer">Terms of Service</a>` : null} ${e9 && o9 ? "and" : null} ${o9 ? x2`<a href="${o9}" target="_blank" rel="noopener noreferrer">Privacy Policy</a>` : null}</wcm-text></div>` : null;
        }
      };
      Me3.styles = [h8.globalCss, xo], Me3 = Co([e5("wcm-legal-notice")], Me3);
      ko = i2`div{display:grid;grid-template-columns:repeat(4,80px);margin:0 -10px;justify-content:space-between;row-gap:10px}`;
      Oo = Object.defineProperty;
      Wo = Object.getOwnPropertyDescriptor;
      Io = (e9, o9, r8, a6) => {
        for (var t6 = a6 > 1 ? void 0 : a6 ? Wo(o9, r8) : o9, l9 = e9.length - 1, i7; l9 >= 0; l9--)
          (i7 = e9[l9]) && (t6 = (a6 ? i7(o9, r8, t6) : i7(t6)) || t6);
        return a6 && t6 && Oo(o9, r8, t6), t6;
      };
      Le2 = class extends s5 {
        onQrcode() {
          T2.push("Qrcode");
        }
        render() {
          const { explorerExcludedWalletIds: e9, enableExplorer: o9 } = y6.state, r8 = e9 !== "ALL" && o9, a6 = Z5.manualWalletsTemplate(), t6 = Z5.recomendedWalletsTemplate();
          let l9 = [Z5.recentWalletTemplate(), ...a6, ...t6];
          l9 = l9.filter(Boolean);
          const i7 = l9.length > 8 || r8;
          let s7 = [];
          i7 ? s7 = l9.slice(0, 7) : s7 = l9;
          const $8 = Boolean(s7.length);
          return x2`<wcm-modal-header title="Connect your wallet" .onAction="${this.onQrcode}" .actionIcon="${v3.QRCODE_ICON}"></wcm-modal-header>${$8 ? x2`<wcm-modal-content><div>${s7} ${i7 ? x2`<wcm-view-all-wallets-button></wcm-view-all-wallets-button>` : null}</div></wcm-modal-content>` : null}`;
        }
      };
      Le2.styles = [h8.globalCss, ko], Le2 = Io([e5("wcm-mobile-wallet-selection")], Le2);
      Eo = i2`:host{all:initial}.wcm-overlay{top:0;bottom:0;left:0;right:0;position:fixed;z-index:var(--wcm-z-index);overflow:hidden;display:flex;justify-content:center;align-items:center;opacity:0;pointer-events:none;background-color:var(--wcm-overlay-background-color);backdrop-filter:var(--wcm-overlay-backdrop-filter)}@media(max-height:720px) and (orientation:landscape){.wcm-overlay{overflow:scroll;align-items:flex-start;padding:20px 0}}.wcm-active{pointer-events:auto}.wcm-container{position:relative;max-width:360px;width:100%;outline:0;border-radius:var(--wcm-background-border-radius) var(--wcm-background-border-radius) var(--wcm-container-border-radius) var(--wcm-container-border-radius);border:1px solid var(--wcm-color-overlay);overflow:hidden}.wcm-card{width:100%;position:relative;border-radius:var(--wcm-container-border-radius);overflow:hidden;box-shadow:0 6px 14px -6px rgba(10,16,31,.12),0 10px 32px -4px rgba(10,16,31,.1),0 0 0 1px var(--wcm-color-overlay);background-color:var(--wcm-color-bg-1);color:var(--wcm-color-fg-1)}@media(max-width:600px){.wcm-container{max-width:440px;border-radius:var(--wcm-background-border-radius) var(--wcm-background-border-radius) 0 0}.wcm-card{border-radius:var(--wcm-container-border-radius) var(--wcm-container-border-radius) 0 0}.wcm-overlay{align-items:flex-end}}@media(max-width:440px){.wcm-container{border:0}}`;
      Mo = Object.defineProperty;
      Lo = Object.getOwnPropertyDescriptor;
      Re4 = (e9, o9, r8, a6) => {
        for (var t6 = a6 > 1 ? void 0 : a6 ? Lo(o9, r8) : o9, l9 = e9.length - 1, i7; l9 >= 0; l9--)
          (i7 = e9[l9]) && (t6 = (a6 ? i7(o9, r8, t6) : i7(t6)) || t6);
        return a6 && t6 && Mo(o9, r8, t6), t6;
      };
      ae3 = class extends s5 {
        constructor() {
          super(), this.open = false, this.active = false, this.unsubscribeModal = void 0, this.abortController = void 0, this.unsubscribeModal = se2.subscribe((e9) => {
            e9.open ? this.onOpenModalEvent() : this.onCloseModalEvent();
          });
        }
        disconnectedCallback() {
          var e9;
          (e9 = this.unsubscribeModal) == null || e9.call(this);
        }
        get overlayEl() {
          return c7.getShadowRootElement(this, ".wcm-overlay");
        }
        get containerEl() {
          return c7.getShadowRootElement(this, ".wcm-container");
        }
        toggleBodyScroll(e9) {
          if (document.querySelector("body"))
            if (e9) {
              const o9 = document.getElementById("wcm-styles");
              o9?.remove();
            } else
              document.head.insertAdjacentHTML("beforeend", '<style id="wcm-styles">html,body{touch-action:none;overflow:hidden;overscroll-behavior:contain;}</style>');
        }
        onCloseModal(e9) {
          e9.target === e9.currentTarget && se2.close();
        }
        onOpenModalEvent() {
          this.toggleBodyScroll(false), this.addKeyboardEvents(), this.open = true, setTimeout(async () => {
            const e9 = c7.isMobileAnimation() ? { y: ["50vh", "0vh"] } : { scale: [0.98, 1] }, o9 = 0.1, r8 = 0.2;
            await Promise.all([animate2(this.overlayEl, { opacity: [0, 1] }, { delay: o9, duration: r8 }).finished, animate2(this.containerEl, e9, { delay: o9, duration: r8 }).finished]), this.active = true;
          }, 0);
        }
        async onCloseModalEvent() {
          this.toggleBodyScroll(true), this.removeKeyboardEvents();
          const e9 = c7.isMobileAnimation() ? { y: ["0vh", "50vh"] } : { scale: [1, 0.98] }, o9 = 0.2;
          await Promise.all([animate2(this.overlayEl, { opacity: [1, 0] }, { duration: o9 }).finished, animate2(this.containerEl, e9, { duration: o9 }).finished]), this.containerEl.removeAttribute("style"), this.active = false, this.open = false;
        }
        addKeyboardEvents() {
          this.abortController = new AbortController(), window.addEventListener("keydown", (e9) => {
            var o9;
            e9.key === "Escape" ? se2.close() : e9.key === "Tab" && ((o9 = e9.target) != null && o9.tagName.includes("wcm-") || this.containerEl.focus());
          }, this.abortController), this.containerEl.focus();
        }
        removeKeyboardEvents() {
          var e9;
          (e9 = this.abortController) == null || e9.abort(), this.abortController = void 0;
        }
        render() {
          const e9 = { "wcm-overlay": true, "wcm-active": this.active };
          return x2`<wcm-explorer-context></wcm-explorer-context><wcm-theme-context></wcm-theme-context><div id="wcm-modal" class="${o7(e9)}" @click="${this.onCloseModal}" role="alertdialog" aria-modal="true"><div class="wcm-container" tabindex="0">${this.open ? x2`<wcm-modal-backcard></wcm-modal-backcard><div class="wcm-card"><wcm-modal-router></wcm-modal-router><wcm-modal-toast></wcm-modal-toast></div>` : null}</div></div>`;
        }
      };
      ae3.styles = [h8.globalCss, Eo], Re4([t4()], ae3.prototype, "open", 2), Re4([t4()], ae3.prototype, "active", 2), ae3 = Re4([e5("wcm-modal")], ae3);
      Ro = i2`div{display:flex;margin-top:15px}slot{display:inline-block;margin:0 5px}wcm-button{margin:0 5px}`;
      Ao = Object.defineProperty;
      Po = Object.getOwnPropertyDescriptor;
      le5 = (e9, o9, r8, a6) => {
        for (var t6 = a6 > 1 ? void 0 : a6 ? Po(o9, r8) : o9, l9 = e9.length - 1, i7; l9 >= 0; l9--)
          (i7 = e9[l9]) && (t6 = (a6 ? i7(o9, r8, t6) : i7(t6)) || t6);
        return a6 && t6 && Ao(o9, r8, t6), t6;
      };
      B6 = class extends s5 {
        constructor() {
          super(...arguments), this.isMobile = false, this.isDesktop = false, this.isWeb = false, this.isRetry = false;
        }
        onMobile() {
          a3.isMobile() ? T2.replace("MobileConnecting") : T2.replace("MobileQrcodeConnecting");
        }
        onDesktop() {
          T2.replace("DesktopConnecting");
        }
        onWeb() {
          T2.replace("WebConnecting");
        }
        render() {
          return x2`<div>${this.isRetry ? x2`<slot></slot>` : null} ${this.isMobile ? x2`<wcm-button .onClick="${this.onMobile}" .iconLeft="${v3.MOBILE_ICON}" variant="outline">Mobile</wcm-button>` : null} ${this.isDesktop ? x2`<wcm-button .onClick="${this.onDesktop}" .iconLeft="${v3.DESKTOP_ICON}" variant="outline">Desktop</wcm-button>` : null} ${this.isWeb ? x2`<wcm-button .onClick="${this.onWeb}" .iconLeft="${v3.GLOBE_ICON}" variant="outline">Web</wcm-button>` : null}</div>`;
        }
      };
      B6.styles = [h8.globalCss, Ro], le5([n6({ type: Boolean })], B6.prototype, "isMobile", 2), le5([n6({ type: Boolean })], B6.prototype, "isDesktop", 2), le5([n6({ type: Boolean })], B6.prototype, "isWeb", 2), le5([n6({ type: Boolean })], B6.prototype, "isRetry", 2), B6 = le5([e5("wcm-platform-selection")], B6);
      To = i2`button{display:flex;flex-direction:column;padding:5px 10px;border-radius:var(--wcm-button-hover-highlight-border-radius);height:100%;justify-content:flex-start}.wcm-icons{width:60px;height:60px;display:flex;flex-wrap:wrap;padding:7px;border-radius:var(--wcm-wallet-icon-border-radius);justify-content:space-between;align-items:center;margin-bottom:5px;background-color:var(--wcm-color-bg-2);box-shadow:inset 0 0 0 1px var(--wcm-color-overlay)}button:active{background-color:var(--wcm-color-overlay)}@media(hover:hover){button:hover{background-color:var(--wcm-color-overlay)}}.wcm-icons img{width:21px;height:21px;object-fit:cover;object-position:center;border-radius:calc(var(--wcm-wallet-icon-border-radius)/ 2);border:1px solid var(--wcm-color-overlay)}.wcm-icons svg{width:21px;height:21px}.wcm-icons img:nth-child(1),.wcm-icons img:nth-child(2),.wcm-icons svg:nth-child(1),.wcm-icons svg:nth-child(2){margin-bottom:4px}wcm-text{width:100%;text-align:center}#wallet-placeholder-fill{fill:var(--wcm-color-bg-3)}#wallet-placeholder-dash{stroke:var(--wcm-color-overlay)}`;
      jo = Object.defineProperty;
      _o = Object.getOwnPropertyDescriptor;
      Do = (e9, o9, r8, a6) => {
        for (var t6 = a6 > 1 ? void 0 : a6 ? _o(o9, r8) : o9, l9 = e9.length - 1, i7; l9 >= 0; l9--)
          (i7 = e9[l9]) && (t6 = (a6 ? i7(o9, r8, t6) : i7(t6)) || t6);
        return a6 && t6 && jo(o9, r8, t6), t6;
      };
      Ae2 = class extends s5 {
        onClick() {
          T2.push("WalletExplorer");
        }
        render() {
          const { recomendedWallets: e9 } = te4.state, o9 = G5.manualWallets(), r8 = [...e9, ...o9].reverse().slice(0, 4);
          return x2`<button @click="${this.onClick}"><div class="wcm-icons">${r8.map((a6) => {
            const t6 = c7.getWalletIcon(a6);
            if (t6)
              return x2`<img crossorigin="anonymous" src="${t6}">`;
            const l9 = c7.getWalletIcon({ id: a6.id });
            return l9 ? x2`<img crossorigin="anonymous" src="${l9}">` : v3.WALLET_PLACEHOLDER;
          })} ${[...Array(4 - r8.length)].map(() => v3.WALLET_PLACEHOLDER)}</div><wcm-text variant="xsmall-regular">View All</wcm-text></button>`;
        }
      };
      Ae2.styles = [h8.globalCss, To], Ae2 = Do([e5("wcm-view-all-wallets-button")], Ae2);
      No = i2`.wcm-qr-container{width:100%;display:flex;justify-content:center;align-items:center;aspect-ratio:1/1}`;
      Zo = Object.defineProperty;
      So = Object.getOwnPropertyDescriptor;
      de5 = (e9, o9, r8, a6) => {
        for (var t6 = a6 > 1 ? void 0 : a6 ? So(o9, r8) : o9, l9 = e9.length - 1, i7; l9 >= 0; l9--)
          (i7 = e9[l9]) && (t6 = (a6 ? i7(o9, r8, t6) : i7(t6)) || t6);
        return a6 && t6 && Zo(o9, r8, t6), t6;
      };
      Y2 = class extends s5 {
        constructor() {
          super(), this.walletId = "", this.imageId = "", this.uri = "", setTimeout(() => {
            const { walletConnectUri: e9 } = p3.state;
            this.uri = e9;
          }, 0);
        }
        get overlayEl() {
          return c7.getShadowRootElement(this, ".wcm-qr-container");
        }
        render() {
          return x2`<div class="wcm-qr-container">${this.uri ? x2`<wcm-qrcode size="${this.overlayEl.offsetWidth}" uri="${this.uri}" walletId="${l7(this.walletId)}" imageId="${l7(this.imageId)}"></wcm-qrcode>` : x2`<wcm-spinner></wcm-spinner>`}</div>`;
        }
      };
      Y2.styles = [h8.globalCss, No], de5([n6()], Y2.prototype, "walletId", 2), de5([n6()], Y2.prototype, "imageId", 2), de5([t4()], Y2.prototype, "uri", 2), Y2 = de5([e5("wcm-walletconnect-qr")], Y2);
      Bo = Object.defineProperty;
      Uo = Object.getOwnPropertyDescriptor;
      Ho = (e9, o9, r8, a6) => {
        for (var t6 = a6 > 1 ? void 0 : a6 ? Uo(o9, r8) : o9, l9 = e9.length - 1, i7; l9 >= 0; l9--)
          (i7 = e9[l9]) && (t6 = (a6 ? i7(o9, r8, t6) : i7(t6)) || t6);
        return a6 && t6 && Bo(o9, r8, t6), t6;
      };
      Pe2 = class extends s5 {
        viewTemplate() {
          return a3.isAndroid() ? x2`<wcm-android-wallet-selection></wcm-android-wallet-selection>` : a3.isMobile() ? x2`<wcm-mobile-wallet-selection></wcm-mobile-wallet-selection>` : x2`<wcm-desktop-wallet-selection></wcm-desktop-wallet-selection>`;
        }
        render() {
          return x2`${this.viewTemplate()}<wcm-legal-notice></wcm-legal-notice>`;
        }
      };
      Pe2.styles = [h8.globalCss], Pe2 = Ho([e5("wcm-connect-wallet-view")], Pe2);
      zo = i2`wcm-info-footer{flex-direction:column;align-items:center;display:flex;width:100%;padding:5px 0}wcm-text{text-align:center}`;
      Vo = Object.defineProperty;
      Fo = Object.getOwnPropertyDescriptor;
      Ke2 = (e9, o9, r8, a6) => {
        for (var t6 = a6 > 1 ? void 0 : a6 ? Fo(o9, r8) : o9, l9 = e9.length - 1, i7; l9 >= 0; l9--)
          (i7 = e9[l9]) && (t6 = (a6 ? i7(o9, r8, t6) : i7(t6)) || t6);
        return a6 && t6 && Vo(o9, r8, t6), t6;
      };
      me4 = class extends s5 {
        constructor() {
          super(), this.isError = false, this.openDesktopApp();
        }
        onFormatAndRedirect(e9) {
          const { desktop: o9, name: r8 } = a3.getWalletRouterData(), a6 = o9?.native;
          if (a6) {
            const t6 = a3.formatNativeUrl(a6, e9, r8);
            a3.openHref(t6, "_self");
          }
        }
        openDesktopApp() {
          const { walletConnectUri: e9 } = p3.state, o9 = a3.getWalletRouterData();
          c7.setRecentWallet(o9), e9 && this.onFormatAndRedirect(e9);
        }
        render() {
          const { name: e9, id: o9, image_id: r8 } = a3.getWalletRouterData(), { isMobile: a6, isWeb: t6 } = c7.getCachedRouterWalletPlatforms();
          return x2`<wcm-modal-header title="${e9}" .onAction="${c7.handleUriCopy}" .actionIcon="${v3.COPY_ICON}"></wcm-modal-header><wcm-modal-content><wcm-connector-waiting walletId="${o9}" imageId="${l7(r8)}" label="${`Continue in ${e9}...`}" .isError="${this.isError}"></wcm-connector-waiting></wcm-modal-content><wcm-info-footer><wcm-text color="secondary" variant="small-thin">${`Connection can continue loading if ${e9} is not installed on your device`}</wcm-text><wcm-platform-selection .isMobile="${a6}" .isWeb="${t6}" .isRetry="${true}"><wcm-button .onClick="${this.openDesktopApp.bind(this)}" .iconRight="${v3.RETRY_ICON}">Retry</wcm-button></wcm-platform-selection></wcm-info-footer>`;
        }
      };
      me4.styles = [h8.globalCss, zo], Ke2([t4()], me4.prototype, "isError", 2), me4 = Ke2([e5("wcm-desktop-connecting-view")], me4);
      qo = i2`wcm-info-footer{flex-direction:column;align-items:center;display:flex;width:100%;padding:5px 0}wcm-text{text-align:center}wcm-button{margin-top:15px}`;
      Qo = Object.defineProperty;
      Ko = Object.getOwnPropertyDescriptor;
      Yo = (e9, o9, r8, a6) => {
        for (var t6 = a6 > 1 ? void 0 : a6 ? Ko(o9, r8) : o9, l9 = e9.length - 1, i7; l9 >= 0; l9--)
          (i7 = e9[l9]) && (t6 = (a6 ? i7(o9, r8, t6) : i7(t6)) || t6);
        return a6 && t6 && Qo(o9, r8, t6), t6;
      };
      Te3 = class extends s5 {
        onInstall(e9) {
          e9 && a3.openHref(e9, "_blank");
        }
        render() {
          const { name: e9, id: o9, image_id: r8, homepage: a6 } = a3.getWalletRouterData();
          return x2`<wcm-modal-header title="${e9}"></wcm-modal-header><wcm-modal-content><wcm-connector-waiting walletId="${o9}" imageId="${l7(r8)}" label="Not Detected" .isStale="${true}"></wcm-connector-waiting></wcm-modal-content><wcm-info-footer><wcm-text color="secondary" variant="small-thin">${`Download ${e9} to continue. If multiple browser extensions are installed, disable non ${e9} ones and try again`}</wcm-text><wcm-button .onClick="${() => this.onInstall(a6)}" .iconLeft="${v3.ARROW_DOWN_ICON}">Download</wcm-button></wcm-info-footer>`;
        }
      };
      Te3.styles = [h8.globalCss, qo], Te3 = Yo([e5("wcm-install-wallet-view")], Te3);
      Go = i2`wcm-wallet-image{border-radius:var(--wcm-wallet-icon-large-border-radius);width:96px;height:96px;margin-bottom:20px}wcm-info-footer{display:flex;width:100%}.wcm-app-store{justify-content:space-between}.wcm-app-store wcm-wallet-image{margin-right:10px;margin-bottom:0;width:28px;height:28px;border-radius:var(--wcm-wallet-icon-small-border-radius)}.wcm-app-store div{display:flex;align-items:center}.wcm-app-store wcm-button{margin-right:-10px}.wcm-note{flex-direction:column;align-items:center;padding:5px 0}.wcm-note wcm-text{text-align:center}wcm-platform-selection{margin-top:-15px}.wcm-note wcm-text{margin-top:15px}.wcm-note wcm-text span{color:var(--wcm-accent-color)}`;
      Xo = Object.defineProperty;
      Jo = Object.getOwnPropertyDescriptor;
      Ye4 = (e9, o9, r8, a6) => {
        for (var t6 = a6 > 1 ? void 0 : a6 ? Jo(o9, r8) : o9, l9 = e9.length - 1, i7; l9 >= 0; l9--)
          (i7 = e9[l9]) && (t6 = (a6 ? i7(o9, r8, t6) : i7(t6)) || t6);
        return a6 && t6 && Xo(o9, r8, t6), t6;
      };
      he5 = class extends s5 {
        constructor() {
          super(), this.isError = false, this.openMobileApp();
        }
        onFormatAndRedirect(e9, o9 = false) {
          const { mobile: r8, name: a6 } = a3.getWalletRouterData(), t6 = r8?.native, l9 = r8?.universal;
          if (t6 && !o9) {
            const i7 = a3.formatNativeUrl(t6, e9, a6);
            a3.openHref(i7, "_self");
          } else if (l9) {
            const i7 = a3.formatUniversalUrl(l9, e9, a6);
            a3.openHref(i7, "_self");
          }
        }
        openMobileApp(e9 = false) {
          const { walletConnectUri: o9 } = p3.state, r8 = a3.getWalletRouterData();
          c7.setRecentWallet(r8), o9 && this.onFormatAndRedirect(o9, e9);
        }
        onGoToAppStore(e9) {
          e9 && a3.openHref(e9, "_blank");
        }
        render() {
          const { name: e9, id: o9, image_id: r8, app: a6, mobile: t6 } = a3.getWalletRouterData(), { isWeb: l9 } = c7.getCachedRouterWalletPlatforms(), i7 = a6?.ios, s7 = t6?.universal;
          return x2`<wcm-modal-header title="${e9}"></wcm-modal-header><wcm-modal-content><wcm-connector-waiting walletId="${o9}" imageId="${l7(r8)}" label="Tap 'Open' to continue" .isError="${this.isError}"></wcm-connector-waiting></wcm-modal-content><wcm-info-footer class="wcm-note"><wcm-platform-selection .isWeb="${l9}" .isRetry="${true}"><wcm-button .onClick="${() => this.openMobileApp(false)}" .iconRight="${v3.RETRY_ICON}">Retry</wcm-button></wcm-platform-selection>${s7 ? x2`<wcm-text color="secondary" variant="small-thin">Still doesn't work? <span tabindex="0" @click="${() => this.openMobileApp(true)}">Try this alternate link</span></wcm-text>` : null}</wcm-info-footer><wcm-info-footer class="wcm-app-store"><div><wcm-wallet-image walletId="${o9}" imageId="${l7(r8)}"></wcm-wallet-image><wcm-text>${`Get ${e9}`}</wcm-text></div><wcm-button .iconRight="${v3.ARROW_RIGHT_ICON}" .onClick="${() => this.onGoToAppStore(i7)}" variant="ghost">App Store</wcm-button></wcm-info-footer>`;
        }
      };
      he5.styles = [h8.globalCss, Go], Ye4([t4()], he5.prototype, "isError", 2), he5 = Ye4([e5("wcm-mobile-connecting-view")], he5);
      er3 = i2`wcm-info-footer{flex-direction:column;align-items:center;display:flex;width:100%;padding:5px 0}wcm-text{text-align:center}`;
      tr3 = Object.defineProperty;
      or3 = Object.getOwnPropertyDescriptor;
      rr2 = (e9, o9, r8, a6) => {
        for (var t6 = a6 > 1 ? void 0 : a6 ? or3(o9, r8) : o9, l9 = e9.length - 1, i7; l9 >= 0; l9--)
          (i7 = e9[l9]) && (t6 = (a6 ? i7(o9, r8, t6) : i7(t6)) || t6);
        return a6 && t6 && tr3(o9, r8, t6), t6;
      };
      je3 = class extends s5 {
        render() {
          const { name: e9, id: o9, image_id: r8 } = a3.getWalletRouterData(), { isDesktop: a6, isWeb: t6 } = c7.getCachedRouterWalletPlatforms();
          return x2`<wcm-modal-header title="${e9}" .onAction="${c7.handleUriCopy}" .actionIcon="${v3.COPY_ICON}"></wcm-modal-header><wcm-modal-content><wcm-walletconnect-qr walletId="${o9}" imageId="${l7(r8)}"></wcm-walletconnect-qr></wcm-modal-content><wcm-info-footer><wcm-text color="secondary" variant="small-thin">${`Scan this QR Code with your phone's camera or inside ${e9} app`}</wcm-text><wcm-platform-selection .isDesktop="${a6}" .isWeb="${t6}"></wcm-platform-selection></wcm-info-footer>`;
        }
      };
      je3.styles = [h8.globalCss, er3], je3 = rr2([e5("wcm-mobile-qr-connecting-view")], je3);
      ar2 = Object.defineProperty;
      lr3 = Object.getOwnPropertyDescriptor;
      ir2 = (e9, o9, r8, a6) => {
        for (var t6 = a6 > 1 ? void 0 : a6 ? lr3(o9, r8) : o9, l9 = e9.length - 1, i7; l9 >= 0; l9--)
          (i7 = e9[l9]) && (t6 = (a6 ? i7(o9, r8, t6) : i7(t6)) || t6);
        return a6 && t6 && ar2(o9, r8, t6), t6;
      };
      _e4 = class extends s5 {
        render() {
          return x2`<wcm-modal-header title="Scan the code" .onAction="${c7.handleUriCopy}" .actionIcon="${v3.COPY_ICON}"></wcm-modal-header><wcm-modal-content><wcm-walletconnect-qr></wcm-walletconnect-qr></wcm-modal-content>`;
        }
      };
      _e4.styles = [h8.globalCss], _e4 = ir2([e5("wcm-qrcode-view")], _e4);
      nr3 = i2`wcm-modal-content{height:clamp(200px,60vh,600px);display:block;overflow:scroll;scrollbar-width:none;position:relative;margin-top:1px}.wcm-grid{display:grid;grid-template-columns:repeat(4,80px);justify-content:space-between;margin:-15px -10px;padding-top:20px}wcm-modal-content::after,wcm-modal-content::before{content:'';position:fixed;pointer-events:none;z-index:1;width:100%;height:20px;opacity:1}wcm-modal-content::before{box-shadow:0 -1px 0 0 var(--wcm-color-bg-1);background:linear-gradient(var(--wcm-color-bg-1),rgba(255,255,255,0))}wcm-modal-content::after{box-shadow:0 1px 0 0 var(--wcm-color-bg-1);background:linear-gradient(rgba(255,255,255,0),var(--wcm-color-bg-1));top:calc(100% - 20px)}wcm-modal-content::-webkit-scrollbar{display:none}.wcm-placeholder-block{display:flex;justify-content:center;align-items:center;height:100px;overflow:hidden}.wcm-empty,.wcm-loading{display:flex}.wcm-loading .wcm-placeholder-block{height:100%}.wcm-end-reached .wcm-placeholder-block{height:0;opacity:0}.wcm-empty .wcm-placeholder-block{opacity:1;height:100%}wcm-wallet-button{margin:calc((100% - 60px)/ 3) 0}`;
      cr3 = Object.defineProperty;
      sr2 = Object.getOwnPropertyDescriptor;
      ie3 = (e9, o9, r8, a6) => {
        for (var t6 = a6 > 1 ? void 0 : a6 ? sr2(o9, r8) : o9, l9 = e9.length - 1, i7; l9 >= 0; l9--)
          (i7 = e9[l9]) && (t6 = (a6 ? i7(o9, r8, t6) : i7(t6)) || t6);
        return a6 && t6 && cr3(o9, r8, t6), t6;
      };
      De3 = 40;
      U4 = class extends s5 {
        constructor() {
          super(...arguments), this.loading = !te4.state.wallets.listings.length, this.firstFetch = !te4.state.wallets.listings.length, this.search = "", this.endReached = false, this.intersectionObserver = void 0, this.searchDebounce = c7.debounce((e9) => {
            e9.length >= 1 ? (this.firstFetch = true, this.endReached = false, this.search = e9, te4.resetSearch(), this.fetchWallets()) : this.search && (this.search = "", this.endReached = this.isLastPage(), te4.resetSearch());
          });
        }
        firstUpdated() {
          this.createPaginationObserver();
        }
        disconnectedCallback() {
          var e9;
          (e9 = this.intersectionObserver) == null || e9.disconnect();
        }
        get placeholderEl() {
          return c7.getShadowRootElement(this, ".wcm-placeholder-block");
        }
        createPaginationObserver() {
          this.intersectionObserver = new IntersectionObserver(([e9]) => {
            e9.isIntersecting && !(this.search && this.firstFetch) && this.fetchWallets();
          }), this.intersectionObserver.observe(this.placeholderEl);
        }
        isLastPage() {
          const { wallets: e9, search: o9 } = te4.state, { listings: r8, total: a6 } = this.search ? o9 : e9;
          return a6 <= De3 || r8.length >= a6;
        }
        async fetchWallets() {
          var e9;
          const { wallets: o9, search: r8 } = te4.state, { listings: a6, total: t6, page: l9 } = this.search ? r8 : o9;
          if (!this.endReached && (this.firstFetch || t6 > De3 && a6.length < t6))
            try {
              this.loading = true;
              const i7 = (e9 = p3.state.chains) == null ? void 0 : e9.join(","), { listings: s7 } = await te4.getWallets({ page: this.firstFetch ? 1 : l9 + 1, entries: De3, search: this.search, version: 2, chains: i7 }), $8 = s7.map((f7) => c7.getWalletIcon(f7));
              await Promise.all([...$8.map(async (f7) => c7.preloadImage(f7)), a3.wait(300)]), this.endReached = this.isLastPage();
            } catch (i7) {
              console.error(i7), oe4.openToast(c7.getErrorMessage(i7), "error");
            } finally {
              this.loading = false, this.firstFetch = false;
            }
        }
        onConnect(e9) {
          a3.isAndroid() ? c7.handleMobileLinking(e9) : c7.goToConnectingView(e9);
        }
        onSearchChange(e9) {
          const { value: o9 } = e9.target;
          this.searchDebounce(o9);
        }
        render() {
          const { wallets: e9, search: o9 } = te4.state, { listings: r8 } = this.search ? o9 : e9, a6 = this.loading && !r8.length, t6 = this.search.length >= 3;
          let l9 = Z5.manualWalletsTemplate(), i7 = Z5.recomendedWalletsTemplate(true);
          t6 && (l9 = l9.filter(({ values: f7 }) => c7.caseSafeIncludes(f7[0], this.search)), i7 = i7.filter(({ values: f7 }) => c7.caseSafeIncludes(f7[0], this.search)));
          const s7 = !this.loading && !r8.length && !i7.length, $8 = { "wcm-loading": a6, "wcm-end-reached": this.endReached || !this.loading, "wcm-empty": s7 };
          return x2`<wcm-modal-header><wcm-search-input .onChange="${this.onSearchChange.bind(this)}"></wcm-search-input></wcm-modal-header><wcm-modal-content class="${o7($8)}"><div class="wcm-grid">${a6 ? null : l9} ${a6 ? null : i7} ${a6 ? null : r8.map((f7) => x2`${f7 ? x2`<wcm-wallet-button imageId="${f7.image_id}" name="${f7.name}" walletId="${f7.id}" .onClick="${() => this.onConnect(f7)}"></wcm-wallet-button>` : null}`)}</div><div class="wcm-placeholder-block">${s7 ? x2`<wcm-text variant="big-bold" color="secondary">No results found</wcm-text>` : null} ${!s7 && this.loading ? x2`<wcm-spinner></wcm-spinner>` : null}</div></wcm-modal-content>`;
        }
      };
      U4.styles = [h8.globalCss, nr3], ie3([t4()], U4.prototype, "loading", 2), ie3([t4()], U4.prototype, "firstFetch", 2), ie3([t4()], U4.prototype, "search", 2), ie3([t4()], U4.prototype, "endReached", 2), U4 = ie3([e5("wcm-wallet-explorer-view")], U4);
      dr2 = i2`wcm-info-footer{flex-direction:column;align-items:center;display:flex;width:100%;padding:5px 0}wcm-text{text-align:center}`;
      mr2 = Object.defineProperty;
      hr3 = Object.getOwnPropertyDescriptor;
      Ge3 = (e9, o9, r8, a6) => {
        for (var t6 = a6 > 1 ? void 0 : a6 ? hr3(o9, r8) : o9, l9 = e9.length - 1, i7; l9 >= 0; l9--)
          (i7 = e9[l9]) && (t6 = (a6 ? i7(o9, r8, t6) : i7(t6)) || t6);
        return a6 && t6 && mr2(o9, r8, t6), t6;
      };
      we = class extends s5 {
        constructor() {
          super(), this.isError = false, this.openWebWallet();
        }
        onFormatAndRedirect(e9) {
          const { desktop: o9, name: r8 } = a3.getWalletRouterData(), a6 = o9?.universal;
          if (a6) {
            const t6 = a3.formatUniversalUrl(a6, e9, r8);
            a3.openHref(t6, "_blank");
          }
        }
        openWebWallet() {
          const { walletConnectUri: e9 } = p3.state, o9 = a3.getWalletRouterData();
          c7.setRecentWallet(o9), e9 && this.onFormatAndRedirect(e9);
        }
        render() {
          const { name: e9, id: o9, image_id: r8 } = a3.getWalletRouterData(), { isMobile: a6, isDesktop: t6 } = c7.getCachedRouterWalletPlatforms(), l9 = a3.isMobile();
          return x2`<wcm-modal-header title="${e9}" .onAction="${c7.handleUriCopy}" .actionIcon="${v3.COPY_ICON}"></wcm-modal-header><wcm-modal-content><wcm-connector-waiting walletId="${o9}" imageId="${l7(r8)}" label="${`Continue in ${e9}...`}" .isError="${this.isError}"></wcm-connector-waiting></wcm-modal-content><wcm-info-footer><wcm-text color="secondary" variant="small-thin">${`${e9} web app has opened in a new tab. Go there, accept the connection, and come back`}</wcm-text><wcm-platform-selection .isMobile="${a6}" .isDesktop="${l9 ? false : t6}" .isRetry="${true}"><wcm-button .onClick="${this.openWebWallet.bind(this)}" .iconRight="${v3.RETRY_ICON}">Retry</wcm-button></wcm-platform-selection></wcm-info-footer>`;
        }
      };
      we.styles = [h8.globalCss, dr2], Ge3([t4()], we.prototype, "isError", 2), we = Ge3([e5("wcm-web-connecting-view")], we);
    }
  });

  // node_modules/@walletconnect/modal/dist/index.js
  var dist_exports3 = {};
  __export(dist_exports3, {
    WalletConnectModal: () => d5
  });
  var d5;
  var init_dist7 = __esm({
    "node_modules/@walletconnect/modal/dist/index.js"() {
      init_dist5();
      d5 = class {
        constructor(e9) {
          this.openModal = se2.open, this.closeModal = se2.close, this.subscribeModal = se2.subscribe, this.setTheme = ne2.setThemeConfig, ne2.setThemeConfig(e9), y6.setConfig(e9), this.initUi();
        }
        async initUi() {
          if (typeof window < "u") {
            await Promise.resolve().then(() => (init_dist6(), dist_exports2));
            const e9 = document.createElement("wcm-modal");
            document.body.insertAdjacentElement("beforeend", e9), p3.setIsUiLoaded(true);
          }
        }
      };
    }
  });

  // node_modules/@walletconnect/ethereum-provider/dist/index.es.js
  var index_es_exports = {};
  __export(index_es_exports, {
    EthereumProvider: () => G6,
    OPTIONAL_EVENTS: () => _6,
    OPTIONAL_METHODS: () => E6,
    REQUIRED_EVENTS: () => m4,
    REQUIRED_METHODS: () => u5,
    default: () => v4
  });
  function g6(a6) {
    return Number(a6[0].split(":")[1]);
  }
  function f4(a6) {
    return `0x${a6.toString(16)}`;
  }
  function L6(a6) {
    const { chains: t6, optionalChains: s7, methods: i7, optionalMethods: n9, events: e9, optionalEvents: h10, rpcMap: c9 } = a6;
    if (!k(t6))
      throw new Error("Invalid chains");
    const o9 = { chains: t6, methods: i7 || u5, events: e9 || m4, rpcMap: p5({}, t6.length ? { [g6(t6)]: c9[g6(t6)] } : {}) }, r8 = e9?.filter((l9) => !m4.includes(l9)), d7 = i7?.filter((l9) => !u5.includes(l9));
    if (!s7 && !h10 && !n9 && !(r8 != null && r8.length) && !(d7 != null && d7.length))
      return { required: t6.length ? o9 : void 0 };
    const C6 = r8?.length && d7?.length || !s7, I5 = { chains: [...new Set(C6 ? o9.chains.concat(s7 || []) : s7)], methods: [...new Set(o9.methods.concat(n9 != null && n9.length ? n9 : E6))], events: [...new Set(o9.events.concat(h10 != null && h10.length ? h10 : _6))], rpcMap: c9 };
    return { required: t6.length ? o9 : void 0, optional: s7.length ? I5 : void 0 };
  }
  var import_events9, P3, S9, $5, j4, u5, E6, m4, _6, N14, q4, D7, y8, U5, Q6, O6, p5, M5, v4, G6;
  var init_index_es14 = __esm({
    "node_modules/@walletconnect/ethereum-provider/dist/index.es.js"() {
      import_events9 = __toESM(require_events());
      init_index_es();
      init_index_es7();
      P3 = "wc";
      S9 = "ethereum_provider";
      $5 = `${P3}@2:${S9}:`;
      j4 = "https://rpc.walletconnect.com/v1/";
      u5 = ["eth_sendTransaction", "personal_sign"];
      E6 = ["eth_accounts", "eth_requestAccounts", "eth_sendRawTransaction", "eth_sign", "eth_signTransaction", "eth_signTypedData", "eth_signTypedData_v3", "eth_signTypedData_v4", "eth_sendTransaction", "personal_sign", "wallet_switchEthereumChain", "wallet_addEthereumChain", "wallet_getPermissions", "wallet_requestPermissions", "wallet_registerOnboarding", "wallet_watchAsset", "wallet_scanQRCode"];
      m4 = ["chainChanged", "accountsChanged"];
      _6 = ["chainChanged", "accountsChanged", "message", "disconnect", "connect"];
      N14 = Object.defineProperty;
      q4 = Object.defineProperties;
      D7 = Object.getOwnPropertyDescriptors;
      y8 = Object.getOwnPropertySymbols;
      U5 = Object.prototype.hasOwnProperty;
      Q6 = Object.prototype.propertyIsEnumerable;
      O6 = (a6, t6, s7) => t6 in a6 ? N14(a6, t6, { enumerable: true, configurable: true, writable: true, value: s7 }) : a6[t6] = s7;
      p5 = (a6, t6) => {
        for (var s7 in t6 || (t6 = {}))
          U5.call(t6, s7) && O6(a6, s7, t6[s7]);
        if (y8)
          for (var s7 of y8(t6))
            Q6.call(t6, s7) && O6(a6, s7, t6[s7]);
        return a6;
      };
      M5 = (a6, t6) => q4(a6, D7(t6));
      v4 = class {
        constructor() {
          this.events = new import_events9.EventEmitter(), this.namespace = "eip155", this.accounts = [], this.chainId = 1, this.STORAGE_KEY = $5, this.on = (t6, s7) => (this.events.on(t6, s7), this), this.once = (t6, s7) => (this.events.once(t6, s7), this), this.removeListener = (t6, s7) => (this.events.removeListener(t6, s7), this), this.off = (t6, s7) => (this.events.off(t6, s7), this), this.parseAccount = (t6) => this.isCompatibleChainId(t6) ? this.parseAccountId(t6).address : t6, this.signer = {}, this.rpc = {};
        }
        static async init(t6) {
          const s7 = new v4();
          return await s7.initialize(t6), s7;
        }
        async request(t6) {
          return await this.signer.request(t6, this.formatChainId(this.chainId));
        }
        sendAsync(t6, s7) {
          this.signer.sendAsync(t6, s7, this.formatChainId(this.chainId));
        }
        get connected() {
          return this.signer.client ? this.signer.client.core.relayer.connected : false;
        }
        get connecting() {
          return this.signer.client ? this.signer.client.core.relayer.connecting : false;
        }
        async enable() {
          return this.session || await this.connect(), await this.request({ method: "eth_requestAccounts" });
        }
        async connect(t6) {
          if (!this.signer.client)
            throw new Error("Provider not initialized. Call init() first");
          this.loadConnectOpts(t6);
          const { required: s7, optional: i7 } = L6(this.rpc);
          try {
            const n9 = await new Promise(async (h10, c9) => {
              var o9;
              this.rpc.showQrModal && ((o9 = this.modal) == null || o9.subscribeModal((r8) => {
                !r8.open && !this.signer.session && (this.signer.abortPairingAttempt(), c9(new Error("Connection request reset. Please try again.")));
              })), await this.signer.connect(M5(p5({ namespaces: p5({}, s7 && { [this.namespace]: s7 }) }, i7 && { optionalNamespaces: { [this.namespace]: i7 } }), { pairingTopic: t6?.pairingTopic })).then((r8) => {
                h10(r8);
              }).catch((r8) => {
                c9(new Error(r8.message));
              });
            });
            if (!n9)
              return;
            const e9 = Un(n9.namespaces, [this.namespace]);
            this.setChainIds(this.rpc.chains.length ? this.rpc.chains : e9), this.setAccounts(e9), this.events.emit("connect", { chainId: f4(this.chainId) });
          } catch (n9) {
            throw this.signer.logger.error(n9), n9;
          } finally {
            this.modal && this.modal.closeModal();
          }
        }
        async disconnect() {
          this.session && await this.signer.disconnect(), this.reset();
        }
        get isWalletConnect() {
          return true;
        }
        get session() {
          return this.signer.session;
        }
        registerEventListeners() {
          this.signer.on("session_event", (t6) => {
            const { params: s7 } = t6, { event: i7 } = s7;
            i7.name === "accountsChanged" ? (this.accounts = this.parseAccounts(i7.data), this.events.emit("accountsChanged", this.accounts)) : i7.name === "chainChanged" ? this.setChainId(this.formatChainId(i7.data)) : this.events.emit(i7.name, i7.data), this.events.emit("session_event", t6);
          }), this.signer.on("chainChanged", (t6) => {
            const s7 = parseInt(t6);
            this.chainId = s7, this.events.emit("chainChanged", f4(this.chainId)), this.persist();
          }), this.signer.on("session_update", (t6) => {
            this.events.emit("session_update", t6);
          }), this.signer.on("session_delete", (t6) => {
            this.reset(), this.events.emit("session_delete", t6), this.events.emit("disconnect", M5(p5({}, U("USER_DISCONNECTED")), { data: t6.topic, name: "USER_DISCONNECTED" }));
          }), this.signer.on("display_uri", (t6) => {
            var s7, i7;
            this.rpc.showQrModal && ((s7 = this.modal) == null || s7.closeModal(), (i7 = this.modal) == null || i7.openModal({ uri: t6 })), this.events.emit("display_uri", t6);
          });
        }
        switchEthereumChain(t6) {
          this.request({ method: "wallet_switchEthereumChain", params: [{ chainId: t6.toString(16) }] });
        }
        isCompatibleChainId(t6) {
          return typeof t6 == "string" ? t6.startsWith(`${this.namespace}:`) : false;
        }
        formatChainId(t6) {
          return `${this.namespace}:${t6}`;
        }
        parseChainId(t6) {
          return Number(t6.split(":")[1]);
        }
        setChainIds(t6) {
          const s7 = t6.filter((i7) => this.isCompatibleChainId(i7)).map((i7) => this.parseChainId(i7));
          s7.length && (this.chainId = s7[0], this.events.emit("chainChanged", f4(this.chainId)), this.persist());
        }
        setChainId(t6) {
          if (this.isCompatibleChainId(t6)) {
            const s7 = this.parseChainId(t6);
            this.chainId = s7, this.switchEthereumChain(s7);
          }
        }
        parseAccountId(t6) {
          const [s7, i7, n9] = t6.split(":");
          return { chainId: `${s7}:${i7}`, address: n9 };
        }
        setAccounts(t6) {
          this.accounts = t6.filter((s7) => this.parseChainId(this.parseAccountId(s7).chainId) === this.chainId).map((s7) => this.parseAccountId(s7).address), this.events.emit("accountsChanged", this.accounts);
        }
        getRpcConfig(t6) {
          var s7, i7;
          const n9 = (s7 = t6?.chains) != null ? s7 : [], e9 = (i7 = t6?.optionalChains) != null ? i7 : [], h10 = n9.concat(e9);
          if (!h10.length)
            throw new Error("No chains specified in either `chains` or `optionalChains`");
          const c9 = n9.length ? t6?.methods || u5 : [], o9 = n9.length ? t6?.events || m4 : [], r8 = t6?.optionalMethods || [], d7 = t6?.optionalEvents || [], C6 = t6?.rpcMap || this.buildRpcMap(h10, t6.projectId), I5 = t6?.qrModalOptions || void 0;
          return { chains: n9?.map((l9) => this.formatChainId(l9)), optionalChains: e9.map((l9) => this.formatChainId(l9)), methods: c9, events: o9, optionalMethods: r8, optionalEvents: d7, rpcMap: C6, showQrModal: !!(t6 != null && t6.showQrModal), qrModalOptions: I5, projectId: t6.projectId, metadata: t6.metadata };
        }
        buildRpcMap(t6, s7) {
          const i7 = {};
          return t6.forEach((n9) => {
            i7[n9] = this.getRpcUrl(n9, s7);
          }), i7;
        }
        async initialize(t6) {
          if (this.rpc = this.getRpcConfig(t6), this.chainId = this.rpc.chains.length ? g6(this.rpc.chains) : g6(this.rpc.optionalChains), this.signer = await cv.init({ projectId: this.rpc.projectId, metadata: this.rpc.metadata, disableProviderPing: t6.disableProviderPing, relayUrl: t6.relayUrl, storageOptions: t6.storageOptions }), this.registerEventListeners(), await this.loadPersistedSession(), this.rpc.showQrModal) {
            let s7;
            try {
              const { WalletConnectModal: i7 } = await Promise.resolve().then(() => (init_dist7(), dist_exports3));
              s7 = i7;
            } catch {
              throw new Error("To use QR modal, please install @walletconnect/modal package");
            }
            if (s7)
              try {
                this.modal = new s7(p5({ walletConnectVersion: 2, projectId: this.rpc.projectId, standaloneChains: this.rpc.chains }, this.rpc.qrModalOptions));
              } catch (i7) {
                throw this.signer.logger.error(i7), new Error("Could not generate WalletConnectModal Instance");
              }
          }
        }
        loadConnectOpts(t6) {
          if (!t6)
            return;
          const { chains: s7, optionalChains: i7, rpcMap: n9 } = t6;
          s7 && k(s7) && (this.rpc.chains = s7.map((e9) => this.formatChainId(e9)), s7.forEach((e9) => {
            this.rpc.rpcMap[e9] = n9?.[e9] || this.getRpcUrl(e9);
          })), i7 && k(i7) && (this.rpc.optionalChains = [], this.rpc.optionalChains = i7?.map((e9) => this.formatChainId(e9)), i7.forEach((e9) => {
            this.rpc.rpcMap[e9] = n9?.[e9] || this.getRpcUrl(e9);
          }));
        }
        getRpcUrl(t6, s7) {
          var i7;
          return ((i7 = this.rpc.rpcMap) == null ? void 0 : i7[t6]) || `${j4}?chainId=eip155:${t6}&projectId=${s7 || this.rpc.projectId}`;
        }
        async loadPersistedSession() {
          if (!this.session)
            return;
          const t6 = await this.signer.client.core.storage.getItem(`${this.STORAGE_KEY}/chainId`), s7 = this.session.namespaces[`${this.namespace}:${t6}`] ? this.session.namespaces[`${this.namespace}:${t6}`] : this.session.namespaces[this.namespace];
          this.setChainIds(t6 ? [this.formatChainId(t6)] : s7?.accounts), this.setAccounts(s7?.accounts);
        }
        reset() {
          this.chainId = 1, this.accounts = [];
        }
        persist() {
          this.session && this.signer.client.core.storage.setItem(`${this.STORAGE_KEY}/chainId`, this.chainId);
        }
        parseAccounts(t6) {
          return typeof t6 == "string" || t6 instanceof String ? [this.parseAccount(t6)] : t6.map((s7) => this.parseAccount(s7));
        }
      };
      G6 = v4;
    }
  });

  // node_modules/valtio/esm/vanilla.mjs
  function proxy2(initialObject = {}) {
    return defaultProxyFunction2(initialObject);
  }
  function subscribe2(proxyObject, callback, notifyInSync) {
    const proxyState = proxyStateMap2.get(proxyObject);
    if ((import_meta4.env ? import_meta4.env.MODE : void 0) !== "production" && !proxyState) {
      console.warn("Please use proxy object");
    }
    let promise;
    const ops = [];
    const addListener = proxyState[3];
    let isListenerActive = false;
    const listener = (op) => {
      ops.push(op);
      if (notifyInSync) {
        callback(ops.splice(0));
        return;
      }
      if (!promise) {
        promise = Promise.resolve().then(() => {
          promise = void 0;
          if (isListenerActive) {
            callback(ops.splice(0));
          }
        });
      }
    };
    const removeListener = addListener(listener);
    isListenerActive = true;
    return () => {
      isListenerActive = false;
      removeListener();
    };
  }
  function snapshot3(proxyObject, handlePromise) {
    const proxyState = proxyStateMap2.get(proxyObject);
    if ((import_meta4.env ? import_meta4.env.MODE : void 0) !== "production" && !proxyState) {
      console.warn("Please use proxy object");
    }
    const [target, ensureVersion, createSnapshot] = proxyState;
    return createSnapshot(target, ensureVersion(), handlePromise);
  }
  var import_meta4, isObject2, proxyStateMap2, refSet2, buildProxyFunction2, defaultProxyFunction2;
  var init_vanilla2 = __esm({
    "node_modules/valtio/esm/vanilla.mjs"() {
      init_index_modern();
      import_meta4 = {};
      isObject2 = (x4) => typeof x4 === "object" && x4 !== null;
      proxyStateMap2 = /* @__PURE__ */ new WeakMap();
      refSet2 = /* @__PURE__ */ new WeakSet();
      buildProxyFunction2 = (objectIs = Object.is, newProxy = (target, handler) => new Proxy(target, handler), canProxy = (x4) => isObject2(x4) && !refSet2.has(x4) && (Array.isArray(x4) || !(Symbol.iterator in x4)) && !(x4 instanceof WeakMap) && !(x4 instanceof WeakSet) && !(x4 instanceof Error) && !(x4 instanceof Number) && !(x4 instanceof Date) && !(x4 instanceof String) && !(x4 instanceof RegExp) && !(x4 instanceof ArrayBuffer), shouldTrapDefineProperty = (desc) => desc.configurable && desc.enumerable && desc.writable, defaultHandlePromise = (promise) => {
        switch (promise.status) {
          case "fulfilled":
            return promise.value;
          case "rejected":
            throw promise.reason;
          default:
            throw promise;
        }
      }, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version30, handlePromise = defaultHandlePromise) => {
        const cache = snapCache.get(target);
        if ((cache == null ? void 0 : cache[0]) === version30) {
          return cache[1];
        }
        const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
        h5(snap, true);
        snapCache.set(target, [version30, snap]);
        Reflect.ownKeys(target).forEach((key2) => {
          if (Object.getOwnPropertyDescriptor(snap, key2)) {
            return;
          }
          const value = Reflect.get(target, key2);
          const desc = {
            value,
            enumerable: true,
            // This is intentional to avoid copying with proxy-compare.
            // It's still non-writable, so it avoids assigning a value.
            configurable: true
          };
          if (refSet2.has(value)) {
            h5(value, false);
          } else if (value instanceof Promise) {
            delete desc.value;
            desc.get = () => handlePromise(value);
          } else if (proxyStateMap2.has(value)) {
            const [target2, ensureVersion] = proxyStateMap2.get(
              value
            );
            desc.value = createSnapshot(
              target2,
              ensureVersion(),
              handlePromise
            );
          }
          Object.defineProperty(snap, key2, desc);
        });
        return Object.preventExtensions(snap);
      }, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction = (initialObject) => {
        if (!isObject2(initialObject)) {
          throw new Error("object required");
        }
        const found = proxyCache.get(initialObject);
        if (found) {
          return found;
        }
        let version30 = versionHolder[0];
        const listeners = /* @__PURE__ */ new Set();
        const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
          if (version30 !== nextVersion) {
            version30 = nextVersion;
            listeners.forEach((listener) => listener(op, nextVersion));
          }
        };
        let checkVersion = versionHolder[1];
        const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
          if (checkVersion !== nextCheckVersion && !listeners.size) {
            checkVersion = nextCheckVersion;
            propProxyStates.forEach(([propProxyState]) => {
              const propVersion = propProxyState[1](nextCheckVersion);
              if (propVersion > version30) {
                version30 = propVersion;
              }
            });
          }
          return version30;
        };
        const createPropListener = (prop) => (op, nextVersion) => {
          const newOp = [...op];
          newOp[1] = [prop, ...newOp[1]];
          notifyUpdate(newOp, nextVersion);
        };
        const propProxyStates = /* @__PURE__ */ new Map();
        const addPropListener = (prop, propProxyState) => {
          if ((import_meta4.env ? import_meta4.env.MODE : void 0) !== "production" && propProxyStates.has(prop)) {
            throw new Error("prop listener already exists");
          }
          if (listeners.size) {
            const remove = propProxyState[3](createPropListener(prop));
            propProxyStates.set(prop, [propProxyState, remove]);
          } else {
            propProxyStates.set(prop, [propProxyState]);
          }
        };
        const removePropListener = (prop) => {
          var _a2;
          const entry = propProxyStates.get(prop);
          if (entry) {
            propProxyStates.delete(prop);
            (_a2 = entry[1]) == null ? void 0 : _a2.call(entry);
          }
        };
        const addListener = (listener) => {
          listeners.add(listener);
          if (listeners.size === 1) {
            propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
              if ((import_meta4.env ? import_meta4.env.MODE : void 0) !== "production" && prevRemove) {
                throw new Error("remove already exists");
              }
              const remove = propProxyState[3](createPropListener(prop));
              propProxyStates.set(prop, [propProxyState, remove]);
            });
          }
          const removeListener = () => {
            listeners.delete(listener);
            if (listeners.size === 0) {
              propProxyStates.forEach(([propProxyState, remove], prop) => {
                if (remove) {
                  remove();
                  propProxyStates.set(prop, [propProxyState]);
                }
              });
            }
          };
          return removeListener;
        };
        const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
        const trapSet = (hasPrevValue, prevValue, prop, value, setValue) => {
          if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
            return;
          }
          removePropListener(prop);
          if (isObject2(value)) {
            value = y5(value) || value;
          }
          let nextValue = value;
          if (value instanceof Promise) {
            value.then((v6) => {
              value.status = "fulfilled";
              value.value = v6;
              notifyUpdate(["resolve", [prop], v6]);
            }).catch((e9) => {
              value.status = "rejected";
              value.reason = e9;
              notifyUpdate(["reject", [prop], e9]);
            });
          } else {
            if (!proxyStateMap2.has(value) && canProxy(value)) {
              nextValue = proxyFunction(value);
            }
            const childProxyState = !refSet2.has(nextValue) && proxyStateMap2.get(nextValue);
            if (childProxyState) {
              addPropListener(prop, childProxyState);
            }
          }
          setValue(nextValue);
          notifyUpdate(["set", [prop], value, prevValue]);
        };
        const handler = {
          deleteProperty(target, prop) {
            const prevValue = Reflect.get(target, prop);
            removePropListener(prop);
            const deleted = Reflect.deleteProperty(target, prop);
            if (deleted) {
              notifyUpdate(["delete", [prop], prevValue]);
            }
            return deleted;
          },
          set(target, prop, value, receiver) {
            const hasPrevValue = Reflect.has(target, prop);
            const prevValue = Reflect.get(target, prop, receiver);
            trapSet(hasPrevValue, prevValue, prop, value, (nextValue) => {
              Reflect.set(target, prop, nextValue, receiver);
            });
            return true;
          },
          defineProperty(target, prop, desc) {
            if (shouldTrapDefineProperty(desc)) {
              const prevDesc = Reflect.getOwnPropertyDescriptor(target, prop);
              if (!prevDesc || shouldTrapDefineProperty(prevDesc)) {
                trapSet(
                  !!prevDesc && "value" in prevDesc,
                  prevDesc == null ? void 0 : prevDesc.value,
                  prop,
                  desc.value,
                  (nextValue) => {
                    Reflect.defineProperty(target, prop, {
                      ...desc,
                      value: nextValue
                    });
                  }
                );
                return true;
              }
            }
            return Reflect.defineProperty(target, prop, desc);
          }
        };
        const proxyObject = newProxy(baseObject, handler);
        proxyCache.set(initialObject, proxyObject);
        const proxyState = [
          baseObject,
          ensureVersion,
          createSnapshot,
          addListener
        ];
        proxyStateMap2.set(proxyObject, proxyState);
        Reflect.ownKeys(initialObject).forEach((key2) => {
          const desc = Object.getOwnPropertyDescriptor(
            initialObject,
            key2
          );
          if ("value" in desc) {
            proxyObject[key2] = initialObject[key2];
            delete desc.value;
            delete desc.writable;
          }
          Object.defineProperty(baseObject, key2, desc);
        });
        return proxyObject;
      }) => [
        // public functions
        proxyFunction,
        // shared state
        proxyStateMap2,
        refSet2,
        // internal things
        objectIs,
        newProxy,
        canProxy,
        shouldTrapDefineProperty,
        defaultHandlePromise,
        snapCache,
        createSnapshot,
        proxyCache,
        versionHolder
      ];
      [defaultProxyFunction2] = buildProxyFunction2();
    }
  });

  // node_modules/@web3modal/core/dist/index.js
  async function U6(e9, t6) {
    const n9 = Z6({ sdkType: M6, sdkVersion: $6 }, t6), s7 = new URL(e9, D8);
    return s7.searchParams.append("projectId", C4.state.projectId), Object.entries(n9).forEach(([a6, c9]) => {
      c9 && s7.searchParams.append(a6, String(c9));
    }), (await fetch(s7)).json();
  }
  function le6() {
    return typeof matchMedia < "u" && matchMedia("(prefers-color-scheme: dark)").matches;
  }
  var o8, W7, i6, k5, f5, K5, l8, F6, p6, b6, O7, C4, J3, z5, G7, r6, q5, Q7, S10, X5, Y3, T5, Z6, D8, M6, $6, I4, ee4, _7, te6, ne4, x3, se4, R4, u6, de6, E7, P5, L7, pe3, re4, V7, ae4, oe6, B8, ie4, j6, ue5, y10, ge4;
  var init_dist8 = __esm({
    "node_modules/@web3modal/core/dist/index.js"() {
      init_vanilla2();
      o8 = proxy2({ history: ["ConnectWallet"], view: "ConnectWallet", data: void 0 });
      W7 = { state: o8, subscribe(e9) {
        return subscribe2(o8, () => e9(o8));
      }, push(e9, t6) {
        e9 !== o8.view && (o8.view = e9, t6 && (o8.data = t6), o8.history.push(e9));
      }, reset(e9) {
        o8.view = e9, o8.history = [e9];
      }, replace(e9) {
        o8.history.length > 1 && (o8.history[o8.history.length - 1] = e9, o8.view = e9);
      }, goBack() {
        if (o8.history.length > 1) {
          o8.history.pop();
          const [e9] = o8.history.slice(-1);
          o8.view = e9;
        }
      }, setData(e9) {
        o8.data = e9;
      } };
      i6 = { WALLETCONNECT_DEEPLINK_CHOICE: "WALLETCONNECT_DEEPLINK_CHOICE", W3M_VERSION: "W3M_VERSION", W3M_PREFER_INJECTED_URL_FLAG: "w3mPreferInjected", RECOMMENDED_WALLET_AMOUNT: 9, isMobile() {
        return typeof window < "u" ? Boolean(window.matchMedia("(pointer:coarse)").matches || /Android|webOS|iPhone|iPad|iPod|BlackBerry|Opera Mini/u.test(navigator.userAgent)) : false;
      }, isAndroid() {
        return i6.isMobile() && navigator.userAgent.toLowerCase().includes("android");
      }, isIos() {
        const e9 = navigator.userAgent.toLowerCase();
        return i6.isMobile() && (e9.includes("iphone") || e9.includes("ipad"));
      }, isHttpUrl(e9) {
        return e9.startsWith("http://") || e9.startsWith("https://");
      }, isArray(e9) {
        return Array.isArray(e9) && e9.length > 0;
      }, formatNativeUrl(e9, t6, n9) {
        if (i6.isHttpUrl(e9))
          return this.formatUniversalUrl(e9, t6, n9);
        let s7 = e9;
        s7.includes("://") || (s7 = e9.replaceAll("/", "").replaceAll(":", ""), s7 = `${s7}://`), s7.endsWith("/") || (s7 = `${s7}/`), this.setWalletConnectDeepLink(s7, n9);
        const a6 = encodeURIComponent(t6);
        return `${s7}wc?uri=${a6}`;
      }, formatUniversalUrl(e9, t6, n9) {
        if (!i6.isHttpUrl(e9))
          return this.formatNativeUrl(e9, t6, n9);
        let s7 = e9;
        s7.endsWith("/") || (s7 = `${s7}/`), this.setWalletConnectDeepLink(s7, n9);
        const a6 = encodeURIComponent(t6);
        return `${s7}wc?uri=${a6}`;
      }, async wait(e9) {
        return new Promise((t6) => {
          setTimeout(t6, e9);
        });
      }, openHref(e9, t6) {
        window.open(e9, t6, "noreferrer noopener");
      }, setWalletConnectDeepLink(e9, t6) {
        try {
          localStorage.setItem(i6.WALLETCONNECT_DEEPLINK_CHOICE, JSON.stringify({ href: e9, name: t6 }));
        } catch {
          console.info("Unable to set WalletConnect deep link");
        }
      }, setWalletConnectAndroidDeepLink(e9) {
        try {
          const [t6] = e9.split("?");
          localStorage.setItem(i6.WALLETCONNECT_DEEPLINK_CHOICE, JSON.stringify({ href: t6, name: "Android" }));
        } catch {
          console.info("Unable to set WalletConnect android deep link");
        }
      }, removeWalletConnectDeepLink() {
        try {
          localStorage.removeItem(i6.WALLETCONNECT_DEEPLINK_CHOICE);
        } catch {
          console.info("Unable to remove WalletConnect deep link");
        }
      }, setWeb3ModalVersionInStorage() {
        try {
          typeof localStorage < "u" && localStorage.setItem(i6.W3M_VERSION, "2.7.1");
        } catch {
          console.info("Unable to set Web3Modal version in storage");
        }
      }, getWalletRouterData() {
        var e9;
        const t6 = (e9 = W7.state.data) == null ? void 0 : e9.Wallet;
        if (!t6)
          throw new Error('Missing "Wallet" view data');
        return t6;
      }, getSwitchNetworkRouterData() {
        var e9;
        const t6 = (e9 = W7.state.data) == null ? void 0 : e9.SwitchNetwork;
        if (!t6)
          throw new Error('Missing "SwitchNetwork" view data');
        return t6;
      }, isPreferInjectedFlag() {
        return typeof location < "u" ? new URLSearchParams(location.search).has(i6.W3M_PREFER_INJECTED_URL_FLAG) : false;
      } };
      f5 = { ethereumClient: void 0, setEthereumClient(e9) {
        k5 = e9;
      }, client() {
        if (k5)
          return k5;
        throw new Error("ClientCtrl has no client set");
      } };
      K5 = typeof location < "u" && (location.hostname.includes("localhost") || location.protocol.includes("https"));
      l8 = proxy2({ enabled: K5, userSessionId: "", events: [], connectedWalletId: void 0 });
      F6 = { state: l8, subscribe(e9) {
        return subscribe2(l8.events, () => e9(snapshot3(l8.events[l8.events.length - 1])));
      }, initialize() {
        l8.enabled && typeof (crypto == null ? void 0 : crypto.randomUUID) < "u" && (l8.userSessionId = crypto.randomUUID());
      }, setConnectedWalletId(e9) {
        l8.connectedWalletId = e9;
      }, click(e9) {
        if (l8.enabled) {
          const t6 = { type: "CLICK", name: e9.name, userSessionId: l8.userSessionId, timestamp: Date.now(), data: e9 };
          l8.events.push(t6);
        }
      }, track(e9) {
        if (l8.enabled) {
          const t6 = { type: "TRACK", name: e9.name, userSessionId: l8.userSessionId, timestamp: Date.now(), data: e9 };
          l8.events.push(t6);
        }
      }, view(e9) {
        if (l8.enabled) {
          const t6 = { type: "VIEW", name: e9.name, userSessionId: l8.userSessionId, timestamp: Date.now(), data: e9 };
          l8.events.push(t6);
        }
      } };
      p6 = proxy2({ selectedChain: void 0, chains: void 0, isCustomDesktop: false, isCustomMobile: false, isDataLoaded: false, isUiLoaded: false, isPreferInjected: false });
      b6 = { state: p6, subscribe(e9) {
        return subscribe2(p6, () => e9(p6));
      }, setChains(e9) {
        p6.chains = e9;
      }, getSelectedChain() {
        const e9 = f5.client().getNetwork().chain;
        return e9 && (p6.selectedChain = e9), p6.selectedChain;
      }, setSelectedChain(e9) {
        p6.selectedChain = e9;
      }, setIsCustomDesktop(e9) {
        p6.isCustomDesktop = e9;
      }, setIsCustomMobile(e9) {
        p6.isCustomMobile = e9;
      }, setIsDataLoaded(e9) {
        p6.isDataLoaded = e9;
      }, setIsUiLoaded(e9) {
        p6.isUiLoaded = e9;
      }, setIsPreferInjected(e9) {
        p6.isPreferInjected = e9;
      } };
      O7 = proxy2({ projectId: "", mobileWallets: void 0, desktopWallets: void 0, walletImages: void 0, chainImages: void 0, tokenImages: void 0, tokenContracts: void 0, enableNetworkView: false, enableAccountView: true, enableExplorer: true, defaultChain: void 0, explorerExcludedWalletIds: void 0, explorerRecommendedWalletIds: void 0, termsOfServiceUrl: void 0, privacyPolicyUrl: void 0 });
      C4 = { state: O7, subscribe(e9) {
        return subscribe2(O7, () => e9(O7));
      }, setConfig(e9) {
        var t6, n9;
        F6.initialize(), b6.setIsCustomMobile(Boolean((t6 = e9.mobileWallets) == null ? void 0 : t6.length)), b6.setIsCustomDesktop(Boolean((n9 = e9.desktopWallets) == null ? void 0 : n9.length)), b6.setChains(f5.client().chains), b6.setIsPreferInjected(f5.client().isInjectedProviderInstalled() && i6.isPreferInjectedFlag()), e9.defaultChain && b6.setSelectedChain(e9.defaultChain), i6.setWeb3ModalVersionInStorage(), Object.assign(O7, e9);
      } };
      J3 = "eip155";
      z5 = "https://rpc.walletconnect.com";
      G7 = { async getIdentity(e9, t6) {
        const { projectId: n9 } = C4.state, s7 = `${J3}:${t6}`, a6 = `${z5}/v1/identity/${e9}?chainId=${s7}&projectId=${n9}`;
        return (await fetch(a6)).json();
      } };
      r6 = proxy2({ address: void 0, profileName: void 0, profileAvatar: void 0, profileLoading: false, balanceLoading: false, balance: void 0, isConnected: false });
      q5 = { state: r6, subscribe(e9) {
        return subscribe2(r6, () => e9(r6));
      }, getAccount() {
        const e9 = f5.client().getAccount();
        r6.address = e9.address, r6.isConnected = e9.isConnected;
      }, async fetchProfile(e9, t6) {
        var n9;
        try {
          r6.profileLoading = true, r6.profileName = null, r6.profileAvatar = null;
          const s7 = t6 ?? r6.address, a6 = 1, c9 = (n9 = b6.state.chains) == null ? void 0 : n9.find((d7) => d7.id === a6);
          if (s7 && c9) {
            try {
              const d7 = await G7.getIdentity(s7, a6);
              r6.profileName = d7.name, r6.profileAvatar = d7.avatar;
            } catch {
              const m6 = await f5.client().fetchEnsName({ address: s7, chainId: a6 });
              if (r6.profileName = m6, m6) {
                const v6 = await f5.client().fetchEnsAvatar({ name: m6, chainId: a6 });
                r6.profileAvatar = v6;
              }
            }
            r6.profileAvatar && await e9(r6.profileAvatar);
          }
        } finally {
          r6.profileLoading = false;
        }
      }, async fetchBalance(e9) {
        try {
          const { chain: t6 } = f5.client().getNetwork(), { tokenContracts: n9 } = C4.state;
          let s7;
          t6 && n9 && (s7 = n9[t6.id]), r6.balanceLoading = true;
          const a6 = e9 ?? r6.address;
          if (a6) {
            const c9 = await f5.client().fetchBalance({ address: a6, token: s7 });
            r6.balance = { amount: c9.formatted, symbol: c9.symbol };
          }
        } finally {
          r6.balanceLoading = false;
        }
      }, setAddress(e9) {
        r6.address = e9;
      }, setIsConnected(e9) {
        r6.isConnected = e9;
      }, resetBalance() {
        r6.balance = void 0;
      }, resetAccount() {
        r6.address = void 0, r6.isConnected = false, r6.profileName = void 0, r6.profileAvatar = void 0, r6.balance = void 0;
      } };
      Q7 = Object.defineProperty;
      S10 = Object.getOwnPropertySymbols;
      X5 = Object.prototype.hasOwnProperty;
      Y3 = Object.prototype.propertyIsEnumerable;
      T5 = (e9, t6, n9) => t6 in e9 ? Q7(e9, t6, { enumerable: true, configurable: true, writable: true, value: n9 }) : e9[t6] = n9;
      Z6 = (e9, t6) => {
        for (var n9 in t6 || (t6 = {}))
          X5.call(t6, n9) && T5(e9, n9, t6[n9]);
        if (S10)
          for (var n9 of S10(t6))
            Y3.call(t6, n9) && T5(e9, n9, t6[n9]);
        return e9;
      };
      D8 = "https://explorer-api.walletconnect.com";
      M6 = "w3m";
      $6 = "js-2.7.1";
      I4 = { async getDesktopListings(e9) {
        return U6("/w3m/v1/getDesktopListings", e9);
      }, async getMobileListings(e9) {
        return U6("/w3m/v1/getMobileListings", e9);
      }, async getInjectedListings(e9) {
        return U6("/w3m/v1/getInjectedListings", e9);
      }, async getAllListings(e9) {
        return U6("/w3m/v1/getAllListings", e9);
      }, getWalletImageUrl(e9) {
        return `${D8}/w3m/v1/getWalletImage/${e9}?projectId=${C4.state.projectId}&sdkType=${M6}&sdkVersion=${$6}`;
      }, getAssetImageUrl(e9) {
        return `${D8}/w3m/v1/getAssetImage/${e9}?projectId=${C4.state.projectId}&sdkType=${M6}&sdkVersion=${$6}`;
      } };
      ee4 = Object.defineProperty;
      _7 = Object.getOwnPropertySymbols;
      te6 = Object.prototype.hasOwnProperty;
      ne4 = Object.prototype.propertyIsEnumerable;
      x3 = (e9, t6, n9) => t6 in e9 ? ee4(e9, t6, { enumerable: true, configurable: true, writable: true, value: n9 }) : e9[t6] = n9;
      se4 = (e9, t6) => {
        for (var n9 in t6 || (t6 = {}))
          te6.call(t6, n9) && x3(e9, n9, t6[n9]);
        if (_7)
          for (var n9 of _7(t6))
            ne4.call(t6, n9) && x3(e9, n9, t6[n9]);
        return e9;
      };
      R4 = i6.isMobile();
      u6 = proxy2({ wallets: { listings: [], total: 0, page: 1 }, injectedWallets: [], search: { listings: [], total: 0, page: 1 }, recomendedWallets: [] });
      de6 = { state: u6, async getRecomendedWallets() {
        const { explorerRecommendedWalletIds: e9, explorerExcludedWalletIds: t6 } = C4.state;
        if (e9 === "NONE" || t6 === "ALL" && !e9)
          return u6.recomendedWallets;
        if (i6.isArray(e9)) {
          const n9 = { recommendedIds: e9.join(",") }, { listings: s7 } = await I4.getAllListings(n9), a6 = Object.values(s7);
          a6.sort((c9, d7) => {
            const m6 = e9.indexOf(c9.id), v6 = e9.indexOf(d7.id);
            return m6 - v6;
          }), u6.recomendedWallets = a6;
        } else {
          const n9 = i6.isArray(t6), s7 = { page: 1, entries: i6.RECOMMENDED_WALLET_AMOUNT, version: 2, excludedIds: n9 ? t6.join(",") : void 0 }, { listings: a6 } = R4 ? await I4.getMobileListings(s7) : await I4.getDesktopListings(s7);
          u6.recomendedWallets = Object.values(a6);
        }
        return u6.recomendedWallets;
      }, async getWallets(e9) {
        const t6 = se4({}, e9), { explorerRecommendedWalletIds: n9, explorerExcludedWalletIds: s7 } = C4.state, { recomendedWallets: a6 } = u6;
        if (s7 === "ALL")
          return u6.wallets;
        a6.length ? t6.excludedIds = a6.map((N17) => N17.id).join(",") : i6.isArray(n9) && (t6.excludedIds = n9.join(",")), i6.isArray(s7) && (t6.excludedIds = [t6.excludedIds, s7].filter(Boolean).join(","));
        const { page: c9, search: d7 } = e9, { listings: m6, total: v6 } = R4 ? await I4.getMobileListings(t6) : await I4.getDesktopListings(t6), w8 = Object.values(m6), A7 = d7 ? "search" : "wallets";
        return u6[A7] = { listings: [...u6[A7].listings, ...w8], total: v6, page: c9 ?? 1 }, { listings: w8, total: v6 };
      }, async getInjectedWallets() {
        const { listings: e9 } = await I4.getInjectedListings({}), t6 = Object.values(e9);
        return u6.injectedWallets = t6, u6.injectedWallets;
      }, getWalletImageUrl(e9) {
        return I4.getWalletImageUrl(e9);
      }, getAssetImageUrl(e9) {
        return I4.getAssetImageUrl(e9);
      }, resetSearch() {
        u6.search = { listings: [], total: 0, page: 1 };
      } };
      E7 = proxy2({ pairingEnabled: false, pairingUri: "", pairingError: false });
      P5 = { state: E7, subscribe(e9) {
        return subscribe2(E7, () => e9(E7));
      }, setPairingUri(e9) {
        E7.pairingUri = e9;
      }, setPairingError(e9) {
        E7.pairingError = e9;
      }, setPairingEnabled(e9) {
        E7.pairingEnabled = e9;
      } };
      L7 = proxy2({ open: false });
      pe3 = { state: L7, subscribe(e9) {
        return subscribe2(L7, () => e9(L7));
      }, async open(e9) {
        return new Promise((t6) => {
          const { isUiLoaded: n9, isDataLoaded: s7, isPreferInjected: a6, selectedChain: c9 } = b6.state, { isConnected: d7 } = q5.state, { enableNetworkView: m6 } = C4.state;
          if (P5.setPairingEnabled(true), d7 || i6.removeWalletConnectDeepLink(), e9 != null && e9.route)
            W7.reset(e9.route);
          else if (d7)
            W7.reset("Account");
          else if (m6)
            W7.reset("SelectNetwork");
          else if (a6) {
            f5.client().connectConnector("injected", c9?.id).catch((w8) => console.error(w8)), t6();
            return;
          } else
            W7.reset("ConnectWallet");
          const { pairingUri: v6 } = P5.state;
          if (n9 && s7 && (v6 || d7))
            L7.open = true, t6();
          else {
            const w8 = setInterval(() => {
              const A7 = b6.state, N17 = P5.state;
              A7.isUiLoaded && A7.isDataLoaded && (N17.pairingUri || d7) && (clearInterval(w8), L7.open = true, t6());
            }, 200);
          }
        });
      }, close() {
        L7.open = false;
      } };
      re4 = Object.defineProperty;
      V7 = Object.getOwnPropertySymbols;
      ae4 = Object.prototype.hasOwnProperty;
      oe6 = Object.prototype.propertyIsEnumerable;
      B8 = (e9, t6, n9) => t6 in e9 ? re4(e9, t6, { enumerable: true, configurable: true, writable: true, value: n9 }) : e9[t6] = n9;
      ie4 = (e9, t6) => {
        for (var n9 in t6 || (t6 = {}))
          ae4.call(t6, n9) && B8(e9, n9, t6[n9]);
        if (V7)
          for (var n9 of V7(t6))
            oe6.call(t6, n9) && B8(e9, n9, t6[n9]);
        return e9;
      };
      j6 = proxy2({ themeMode: le6() ? "dark" : "light" });
      ue5 = { state: j6, subscribe(e9) {
        return subscribe2(j6, () => e9(j6));
      }, setThemeConfig(e9) {
        const { themeMode: t6, themeVariables: n9 } = e9;
        t6 && (j6.themeMode = t6), n9 && (j6.themeVariables = ie4({}, n9));
      } };
      y10 = proxy2({ open: false, message: "", variant: "success" });
      ge4 = { state: y10, subscribe(e9) {
        return subscribe2(y10, () => e9(y10));
      }, openToast(e9, t6) {
        y10.open = true, y10.message = e9, y10.variant = t6;
      }, closeToast() {
        y10.open = false;
      } };
    }
  });

  // node_modules/lit/index.js
  var init_lit2 = __esm({
    "node_modules/lit/index.js"() {
      init_reactive_element();
      init_lit_html();
      init_lit_element();
      init_is_server();
    }
  });

  // node_modules/lit/decorators.js
  var init_decorators2 = __esm({
    "node_modules/lit/decorators.js"() {
      init_custom_element();
      init_property();
      init_state();
      init_event_options();
      init_query();
      init_query_all();
      init_query_async();
      init_query_assigned_elements();
      init_query_assigned_nodes();
    }
  });

  // node_modules/lit/directives/class-map.js
  var init_class_map3 = __esm({
    "node_modules/lit/directives/class-map.js"() {
      init_class_map();
    }
  });

  // node_modules/lit/directives/if-defined.js
  var init_if_defined3 = __esm({
    "node_modules/lit/directives/if-defined.js"() {
      init_if_defined();
    }
  });

  // node_modules/@web3modal/ui/dist/index.js
  var dist_exports4 = {};
  __export(dist_exports4, {
    W3mAccountButton: () => Ot5,
    W3mConnectButton: () => mt4,
    W3mCoreButton: () => et3,
    W3mModal: () => jt4,
    W3mNetworkSwitch: () => pt4,
    W3mQrCode: () => F7
  });
  function Xe5() {
    var t6;
    const a6 = (t6 = ue5.state.themeMode) != null ? t6 : "dark", o9 = { light: { foreground: { 1: "rgb(20,20,20)", 2: "rgb(121,134,134)", 3: "rgb(158,169,169)" }, background: { 1: "rgb(255,255,255)", 2: "rgb(241,243,243)", 3: "rgb(228,231,231)" }, overlay: "rgba(0,0,0,0.1)" }, dark: { foreground: { 1: "rgb(228,231,231)", 2: "rgb(148,158,158)", 3: "rgb(110,119,119)" }, background: { 1: "rgb(20,20,20)", 2: "rgb(39,42,42)", 3: "rgb(59,64,64)" }, overlay: "rgba(255,255,255,0.1)" } }[a6];
    return { "--w3m-color-fg-1": o9.foreground[1], "--w3m-color-fg-2": o9.foreground[2], "--w3m-color-fg-3": o9.foreground[3], "--w3m-color-bg-1": o9.background[1], "--w3m-color-bg-2": o9.background[2], "--w3m-color-bg-3": o9.background[3], "--w3m-color-overlay": o9.overlay };
  }
  function Ie4() {
    return { "--w3m-accent-color": "#3396FF", "--w3m-accent-fill-color": "#FFFFFF", "--w3m-z-index": "89", "--w3m-background-color": "#3396FF", "--w3m-background-border-radius": "8px", "--w3m-container-border-radius": "30px", "--w3m-wallet-icon-border-radius": "15px", "--w3m-wallet-icon-large-border-radius": "30px", "--w3m-wallet-icon-small-border-radius": "7px", "--w3m-input-border-radius": "28px", "--w3m-button-border-radius": "10px", "--w3m-notification-border-radius": "36px", "--w3m-secondary-button-border-radius": "28px", "--w3m-icon-button-border-radius": "50%", "--w3m-button-hover-highlight-border-radius": "10px", "--w3m-text-big-bold-size": "20px", "--w3m-text-big-bold-weight": "600", "--w3m-text-big-bold-line-height": "24px", "--w3m-text-big-bold-letter-spacing": "-0.03em", "--w3m-text-big-bold-text-transform": "none", "--w3m-text-xsmall-bold-size": "10px", "--w3m-text-xsmall-bold-weight": "700", "--w3m-text-xsmall-bold-line-height": "12px", "--w3m-text-xsmall-bold-letter-spacing": "0.02em", "--w3m-text-xsmall-bold-text-transform": "uppercase", "--w3m-text-xsmall-regular-size": "12px", "--w3m-text-xsmall-regular-weight": "600", "--w3m-text-xsmall-regular-line-height": "14px", "--w3m-text-xsmall-regular-letter-spacing": "-0.03em", "--w3m-text-xsmall-regular-text-transform": "none", "--w3m-text-small-thin-size": "14px", "--w3m-text-small-thin-weight": "500", "--w3m-text-small-thin-line-height": "16px", "--w3m-text-small-thin-letter-spacing": "-0.03em", "--w3m-text-small-thin-text-transform": "none", "--w3m-text-small-regular-size": "14px", "--w3m-text-small-regular-weight": "600", "--w3m-text-small-regular-line-height": "16px", "--w3m-text-small-regular-letter-spacing": "-0.03em", "--w3m-text-small-regular-text-transform": "none", "--w3m-text-medium-regular-size": "16px", "--w3m-text-medium-regular-weight": "600", "--w3m-text-medium-regular-line-height": "20px", "--w3m-text-medium-regular-letter-spacing": "-0.03em", "--w3m-text-medium-regular-text-transform": "none", "--w3m-font-family": "-apple-system, system-ui, BlinkMacSystemFont, 'Segoe UI', Roboto, Ubuntu, 'Helvetica Neue', sans-serif", "--w3m-font-feature-settings": "'tnum' on, 'lnum' on, 'case' on", "--w3m-success-color": "rgb(38,181,98)", "--w3m-error-color": "rgb(242, 90, 103)", "--w3m-overlay-background-color": "rgba(0, 0, 0, 0.3)", "--w3m-overlay-backdrop-filter": "none" };
  }
  function Je5() {
    const { themeVariables: t6 } = ue5.state;
    return { "--w3m-background-image-url": t6 != null && t6["--w3m-background-image-url"] ? `url(${t6["--w3m-background-image-url"]})` : "none" };
  }
  function ae5(t6, a6, o9) {
    return t6 === a6 ? false : (t6 - a6 < 0 ? a6 - t6 : t6 - a6) <= o9 + Ba;
  }
  function Sa2(t6, a6) {
    const o9 = Array.prototype.slice.call(import_qrcode2.default.create(t6, { errorCorrectionLevel: a6 }).modules.data, 0), r8 = Math.sqrt(o9.length);
    return o9.reduce((e9, i7, l9) => (l9 % r8 === 0 ? e9.push([i7]) : e9[e9.length - 1].push(i7)) && e9, []);
  }
  var import_qrcode2, Ke3, ke4, Ye5, Qe4, Oe2, Lt4, p7, ta, ea, aa, bt4, Y4, oa, ra, ia, st3, G8, la, na, sa, Qt3, ft5, ca, da, ma, ha, Xt3, w6, wa, pa, ga, Ee3, Tt4, ua, va, ba2, fa, Jt4, xa2, ya2, Ca, $a, te7, ka, Oa2, Ia2, xt4, Q8, Ea2, Wa, R5, s6, Aa, ja, Ma, ee5, yt4, Pa, La, Ta2, We4, _t3, _a, Na, Ra2, Ct4, X6, Da, Za, Ha, Ae3, Nt4, Ba, je4, U7, Ua, Va, za, Ga, ct3, F7, Fa, qa, Ka, Me4, Rt4, Ya, Qa, Xa, oe7, $t3, Ja, to2, eo2, re5, kt4, ao2, oo2, ro2, Pe3, Dt4, io2, lo2, no2, q6, S11, so2, co2, mo2, Zt3, dt4, ho2, wo2, po2, Le3, go2, uo2, Te4, ie5, vo2, bo2, _e5, le7, fo2, xo2, yo2, Ne2, Co2, $o2, ko2, Oo2, Io2, Re5, De4, Eo2, Wo2, Ao2, ne5, Ot5, jo2, Mo2, Po2, se5, It5, Lo2, To2, _o2, Et4, J4, P6, No2, Ro2, Do2, Zo2, ce5, Ho2, Bo2, So2, Wt3, tt3, Uo2, Vo2, zo2, de7, At3, Go2, Fo2, qo2, Ht3, mt4, Ko2, Yo2, Qo2, ht4, K6, Xo2, Jo2, wt5, et3, tr4, er4, ar3, or4, me5, rr3, ir3, lr4, nr4, he6, sr3, cr4, dr3, mr3, we2, hr4, wr2, pr, pe4, jt4, gr, ur2, vr2, Bt4, pt4, br2, fr2, xr2, St5, gt4, yr, Cr2, $r, at4, V8, kr, Or2, Ir2, Er2, ge5, Wr, Ar2, jr, Ut3, ut4, Mr, Pr2, Lr, Ze3, Vt4, Tr2, _r2, Nr2, ue6, Rr2, Dr, Zr, He4, zt4, Hr, Br, Sr2, Ur, ve2, Vr, zr2, Gr, Fr, be2, qr, Kr, Yr, Be4, Gt4, Qr, Xr, Jr, ti, fe4, ei, ai, oi, Se2, Ft4, ri, ii, li, ni, xe2, si, ci, di, ye5, mi, Fe4, hi, wi, pi, Ue4, gi, ui, Ve4, vi, bi, Ce3, Mt4, fi, xi, yi, ze3, qt4, Ci, $i, ki, Pt4, $e4, ot4, Oi, Ii, Ei, Ge4, Kt4;
  var init_dist9 = __esm({
    "node_modules/@web3modal/ui/dist/index.js"() {
      init_lit2();
      init_decorators2();
      init_dist8();
      init_class_map3();
      init_lit_html();
      init_main_es();
      import_qrcode2 = __toESM(require_browser4(), 1);
      init_if_defined3();
      Ke3 = Object.defineProperty;
      ke4 = Object.getOwnPropertySymbols;
      Ye5 = Object.prototype.hasOwnProperty;
      Qe4 = Object.prototype.propertyIsEnumerable;
      Oe2 = (t6, a6, o9) => a6 in t6 ? Ke3(t6, a6, { enumerable: true, configurable: true, writable: true, value: o9 }) : t6[a6] = o9;
      Lt4 = (t6, a6) => {
        for (var o9 in a6 || (a6 = {}))
          Ye5.call(a6, o9) && Oe2(t6, o9, a6[o9]);
        if (ke4)
          for (var o9 of ke4(a6))
            Qe4.call(a6, o9) && Oe2(t6, o9, a6[o9]);
        return t6;
      };
      p7 = { getPreset(t6) {
        return Ie4()[t6];
      }, setTheme() {
        const t6 = document.querySelector(":root"), { themeVariables: a6 } = ue5.state;
        if (t6) {
          const o9 = Lt4(Lt4(Lt4(Lt4({}, Xe5()), Ie4()), a6), Je5());
          Object.entries(o9).forEach(([r8, e9]) => t6.style.setProperty(r8, e9));
        }
      }, globalCss: i2`*,::after,::before{margin:0;padding:0;box-sizing:border-box;font-style:normal;text-rendering:optimizeSpeed;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;-webkit-tap-highlight-color:transparent;backface-visibility:hidden}button{cursor:pointer;display:flex;justify-content:center;align-items:center;position:relative;border:none;background-color:transparent;transition:all .2s ease}@media (hover:hover) and (pointer:fine){button:active{transition:all .1s ease;transform:scale(.93)}}button::after{content:'';position:absolute;top:0;bottom:0;left:0;right:0;transition:background-color,.2s ease}button:disabled{cursor:not-allowed}button svg,button w3m-text{position:relative;z-index:1}input{border:none;outline:0;appearance:none}img{display:block}::selection{color:var(--w3m-accent-fill-color);background:var(--w3m-accent-color)}` };
      ta = i2`button{display:flex;border-radius:var(--w3m-button-hover-highlight-border-radius);flex-direction:column;justify-content:center;padding:5px;width:100px}button:active{background-color:var(--w3m-color-overlay)}button:disabled{opacity:.7}@media(hover:hover){button:hover{background-color:var(--w3m-color-overlay)}}button>div{display:flex;justify-content:center;align-items:center;width:32px;height:32px;box-shadow:inset 0 0 0 1px var(--w3m-color-overlay);background-color:var(--w3m-accent-color);border-radius:var(--w3m-icon-button-border-radius);margin-bottom:4px}button path{fill:var(--w3m-accent-fill-color)}`;
      ea = Object.defineProperty;
      aa = Object.getOwnPropertyDescriptor;
      bt4 = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? aa(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && ea(a6, o9, e9), e9;
      };
      Y4 = class extends s5 {
        constructor() {
          super(...arguments), this.icon = void 0, this.label = "", this.loading = false, this.onClick = () => null;
        }
        render() {
          return x2`<button data-testid="component-button-box" @click="${this.onClick}" .disabled="${Boolean(this.loading)}"><div>${this.loading ? x2`<w3m-spinner size="${20}" color="fill"></w3m-spinner>` : x2`${this.icon}`}</div><w3m-text variant="xsmall-regular" color="accent">${this.label}</w3m-text></button>`;
        }
      };
      Y4.styles = [p7.globalCss, ta], bt4([n6()], Y4.prototype, "icon", 2), bt4([n6()], Y4.prototype, "label", 2), bt4([n6()], Y4.prototype, "loading", 2), bt4([n6()], Y4.prototype, "onClick", 2), Y4 = bt4([e5("w3m-box-button")], Y4);
      oa = i2`button{border-radius:var(--w3m-secondary-button-border-radius);height:28px;padding:0 10px;background-color:var(--w3m-accent-color)}button path{fill:var(--w3m-accent-fill-color)}button::after{border-radius:inherit;border:1px solid var(--w3m-color-overlay)}button:disabled::after{background-color:transparent}.w3m-icon-left svg{margin-right:5px}.w3m-icon-right svg{margin-left:5px}button:active::after{background-color:var(--w3m-color-overlay)}.w3m-ghost,.w3m-ghost:active::after,.w3m-outline{background-color:transparent}.w3m-ghost:active{opacity:.5}@media(hover:hover){button:hover::after{background-color:var(--w3m-color-overlay)}.w3m-ghost:hover::after{background-color:transparent}.w3m-ghost:hover{opacity:.5}}button:disabled{background-color:var(--w3m-color-bg-3);pointer-events:none}.w3m-ghost::after{border-color:transparent}.w3m-ghost path{fill:var(--w3m-color-fg-2)}.w3m-outline path{fill:var(--w3m-accent-color)}.w3m-outline:disabled{background-color:transparent;opacity:.5}`;
      ra = Object.defineProperty;
      ia = Object.getOwnPropertyDescriptor;
      st3 = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? ia(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && ra(a6, o9, e9), e9;
      };
      G8 = class extends s5 {
        constructor() {
          super(...arguments), this.disabled = false, this.iconLeft = void 0, this.iconRight = void 0, this.onClick = () => null, this.variant = "default";
        }
        render() {
          const t6 = { "w3m-icon-left": this.iconLeft !== void 0, "w3m-icon-right": this.iconRight !== void 0, "w3m-ghost": this.variant === "ghost", "w3m-outline": this.variant === "outline" };
          let a6 = "inverse";
          return this.variant === "ghost" && (a6 = "secondary"), this.variant === "outline" && (a6 = "accent"), x2`<button class="${o7(t6)}" data-testid="component-button" ?disabled="${this.disabled}" @click="${this.onClick}">${this.iconLeft}<w3m-text variant="small-regular" color="${a6}"><slot></slot></w3m-text>${this.iconRight}</button>`;
        }
      };
      G8.styles = [p7.globalCss, oa], st3([n6()], G8.prototype, "disabled", 2), st3([n6()], G8.prototype, "iconLeft", 2), st3([n6()], G8.prototype, "iconRight", 2), st3([n6()], G8.prototype, "onClick", 2), st3([n6()], G8.prototype, "variant", 2), G8 = st3([e5("w3m-button")], G8);
      la = i2`:host{display:inline-block}button{padding:0 15px 1px;height:40px;border-radius:var(--w3m-button-border-radius);color:var(--w3m-accent-fill-color);background-color:var(--w3m-accent-color)}button::after{content:'';top:0;bottom:0;left:0;right:0;position:absolute;background-color:transparent;border-radius:inherit;transition:background-color .2s ease;border:1px solid var(--w3m-color-overlay)}button:active::after{background-color:var(--w3m-color-overlay)}button:disabled{padding-bottom:0;background-color:var(--w3m-color-bg-3);color:var(--w3m-color-fg-3)}.w3m-secondary{color:var(--w3m-accent-color);background-color:transparent}.w3m-secondary::after{display:none}@media(hover:hover){button:hover::after{background-color:var(--w3m-color-overlay)}}`;
      na = Object.defineProperty;
      sa = Object.getOwnPropertyDescriptor;
      Qt3 = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? sa(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && na(a6, o9, e9), e9;
      };
      ft5 = class extends s5 {
        constructor() {
          super(...arguments), this.disabled = false, this.variant = "primary";
        }
        render() {
          const t6 = { "w3m-secondary": this.variant === "secondary" };
          return x2`<button ?disabled="${this.disabled}" data-testid="component-big-button" class="${o7(t6)}"><slot></slot></button>`;
        }
      };
      ft5.styles = [p7.globalCss, la], Qt3([n6()], ft5.prototype, "disabled", 2), Qt3([n6()], ft5.prototype, "variant", 2), ft5 = Qt3([e5("w3m-button-big")], ft5);
      ca = i2`:host{background-color:var(--w3m-color-bg-2);border-top:1px solid var(--w3m-color-bg-3)}div{padding:10px 20px;display:inherit;flex-direction:inherit;align-items:inherit;width:inherit;justify-content:inherit}`;
      da = Object.defineProperty;
      ma = Object.getOwnPropertyDescriptor;
      ha = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? ma(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && da(a6, o9, e9), e9;
      };
      Xt3 = class extends s5 {
        render() {
          return x2`<div><slot></slot></div>`;
        }
      };
      Xt3.styles = [p7.globalCss, ca], Xt3 = ha([e5("w3m-info-footer")], Xt3);
      w6 = { CROSS_ICON: b4`<svg width="12" height="12" viewBox="0 0 12 12"><path d="M9.94 11A.75.75 0 1 0 11 9.94L7.414 6.353a.5.5 0 0 1 0-.708L11 2.061A.75.75 0 1 0 9.94 1L6.353 4.586a.5.5 0 0 1-.708 0L2.061 1A.75.75 0 0 0 1 2.06l3.586 3.586a.5.5 0 0 1 0 .708L1 9.939A.75.75 0 1 0 2.06 11l3.586-3.586a.5.5 0 0 1 .708 0L9.939 11Z" fill="#fff"/></svg>`, WALLET_CONNECT_LOGO: b4`<svg width="178" height="29" viewBox="0 0 178 29" id="w3m-wc-logo"><path d="M10.683 7.926c5.284-5.17 13.85-5.17 19.134 0l.636.623a.652.652 0 0 1 0 .936l-2.176 2.129a.343.343 0 0 1-.478 0l-.875-.857c-3.686-3.607-9.662-3.607-13.348 0l-.937.918a.343.343 0 0 1-.479 0l-2.175-2.13a.652.652 0 0 1 0-.936l.698-.683Zm23.633 4.403 1.935 1.895a.652.652 0 0 1 0 .936l-8.73 8.543a.687.687 0 0 1-.956 0L20.37 17.64a.172.172 0 0 0-.239 0l-6.195 6.063a.687.687 0 0 1-.957 0l-8.73-8.543a.652.652 0 0 1 0-.936l1.936-1.895a.687.687 0 0 1 .957 0l6.196 6.064a.172.172 0 0 0 .239 0l6.195-6.064a.687.687 0 0 1 .957 0l6.196 6.064a.172.172 0 0 0 .24 0l6.195-6.064a.687.687 0 0 1 .956 0ZM48.093 20.948l2.338-9.355c.139-.515.258-1.07.416-1.942.12.872.258 1.427.357 1.942l2.022 9.355h4.181l3.528-13.874h-3.21l-1.943 8.523a24.825 24.825 0 0 0-.456 2.457c-.158-.931-.317-1.625-.495-2.438l-1.883-8.542h-4.201l-2.042 8.542a41.204 41.204 0 0 0-.475 2.438 41.208 41.208 0 0 0-.476-2.438l-1.903-8.542h-3.349l3.508 13.874h4.083ZM63.33 21.304c1.585 0 2.596-.654 3.11-1.605-.059.297-.078.595-.078.892v.357h2.655V15.22c0-2.735-1.248-4.32-4.3-4.32-2.636 0-4.36 1.466-4.52 3.487h2.914c.1-.891.734-1.426 1.705-1.426.911 0 1.407.515 1.407 1.11 0 .435-.258.693-1.03.792l-1.388.159c-2.061.257-3.825 1.01-3.825 3.19 0 1.982 1.645 3.092 3.35 3.092Zm.891-2.041c-.773 0-1.348-.436-1.348-1.19 0-.733.655-1.09 1.645-1.268l.674-.119c.575-.118.892-.218 1.09-.396v.912c0 1.228-.892 2.06-2.06 2.06ZM70.398 7.074v13.874h2.874V7.074h-2.874ZM74.934 7.074v13.874h2.874V7.074h-2.874ZM84.08 21.304c2.735 0 4.5-1.546 4.697-3.567h-2.893c-.139.892-.892 1.387-1.804 1.387-1.228 0-2.12-.99-2.14-2.358h6.897v-.555c0-3.21-1.764-5.312-4.816-5.312-2.933 0-4.994 2.062-4.994 5.173 0 3.37 2.12 5.232 5.053 5.232Zm-2.16-6.421c.119-1.11.932-1.922 2.081-1.922 1.11 0 1.883.772 1.903 1.922H81.92ZM94.92 21.146c.633 0 1.248-.1 1.525-.179v-2.18c-.218.04-.475.06-.693.06-1.05 0-1.427-.595-1.427-1.566v-3.805h2.338v-2.24h-2.338V7.788H91.47v3.448H89.37v2.24h2.1v4.201c0 2.3 1.15 3.469 3.45 3.469ZM104.62 21.304c3.924 0 6.302-2.299 6.599-5.608h-3.111c-.238 1.803-1.506 3.032-3.369 3.032-2.2 0-3.746-1.784-3.746-4.796 0-2.953 1.605-4.638 3.805-4.638 1.883 0 2.953 1.15 3.171 2.834h3.191c-.317-3.448-2.854-5.41-6.342-5.41-3.984 0-7.036 2.695-7.036 7.214 0 4.677 2.676 7.372 6.838 7.372ZM117.449 21.304c2.993 0 5.114-1.882 5.114-5.172 0-3.23-2.121-5.233-5.114-5.233-2.972 0-5.093 2.002-5.093 5.233 0 3.29 2.101 5.172 5.093 5.172Zm0-2.22c-1.327 0-2.18-1.09-2.18-2.952 0-1.903.892-2.973 2.18-2.973 1.308 0 2.2 1.07 2.2 2.973 0 1.862-.872 2.953-2.2 2.953ZM126.569 20.948v-5.689c0-1.208.753-2.1 1.823-2.1 1.011 0 1.606.773 1.606 2.06v5.729h2.873v-6.144c0-2.339-1.229-3.905-3.428-3.905-1.526 0-2.458.734-2.953 1.606a5.31 5.31 0 0 0 .079-.892v-.377h-2.874v9.712h2.874ZM137.464 20.948v-5.689c0-1.208.753-2.1 1.823-2.1 1.011 0 1.606.773 1.606 2.06v5.729h2.873v-6.144c0-2.339-1.228-3.905-3.428-3.905-1.526 0-2.458.734-2.953 1.606a5.31 5.31 0 0 0 .079-.892v-.377h-2.874v9.712h2.874ZM149.949 21.304c2.735 0 4.499-1.546 4.697-3.567h-2.893c-.139.892-.892 1.387-1.804 1.387-1.228 0-2.12-.99-2.14-2.358h6.897v-.555c0-3.21-1.764-5.312-4.816-5.312-2.933 0-4.994 2.062-4.994 5.173 0 3.37 2.12 5.232 5.053 5.232Zm-2.16-6.421c.119-1.11.932-1.922 2.081-1.922 1.11 0 1.883.772 1.903 1.922h-3.984ZM160.876 21.304c3.013 0 4.658-1.645 4.975-4.201h-2.874c-.099 1.07-.713 1.982-2.001 1.982-1.309 0-2.2-1.21-2.2-2.993 0-1.942 1.03-2.933 2.259-2.933 1.209 0 1.803.872 1.883 1.882h2.873c-.218-2.358-1.823-4.142-4.776-4.142-2.874 0-5.153 1.903-5.153 5.193 0 3.25 1.923 5.212 5.014 5.212ZM172.067 21.146c.634 0 1.248-.1 1.526-.179v-2.18c-.218.04-.476.06-.694.06-1.05 0-1.427-.595-1.427-1.566v-3.805h2.339v-2.24h-2.339V7.788h-2.854v3.448h-2.1v2.24h2.1v4.201c0 2.3 1.15 3.469 3.449 3.469Z" fill="#fff"/></svg>`, WALLET_CONNECT_ICON: b4`<svg width="28" height="20" viewBox="0 0 28 20"><g clip-path="url(#a)"><path d="M7.386 6.482c3.653-3.576 9.575-3.576 13.228 0l.44.43a.451.451 0 0 1 0 .648L19.55 9.033a.237.237 0 0 1-.33 0l-.606-.592c-2.548-2.496-6.68-2.496-9.228 0l-.648.634a.237.237 0 0 1-.33 0L6.902 7.602a.451.451 0 0 1 0-.647l.483-.473Zm16.338 3.046 1.339 1.31a.451.451 0 0 1 0 .648l-6.035 5.909a.475.475 0 0 1-.662 0L14.083 13.2a.119.119 0 0 0-.166 0l-4.283 4.194a.475.475 0 0 1-.662 0l-6.035-5.91a.451.451 0 0 1 0-.647l1.338-1.31a.475.475 0 0 1 .662 0l4.283 4.194c.046.044.12.044.166 0l4.283-4.194a.475.475 0 0 1 .662 0l4.283 4.194c.046.044.12.044.166 0l4.283-4.194a.475.475 0 0 1 .662 0Z" fill="#000000"/></g><defs><clipPath id="a"><path fill="#ffffff" d="M0 0h28v20H0z"/></clipPath></defs></svg>`, WALLET_CONNECT_ICON_COLORED: b4`<svg width="96" height="96" fill="none"><path fill="#fff" d="M25.322 33.597c12.525-12.263 32.83-12.263 45.355 0l1.507 1.476a1.547 1.547 0 0 1 0 2.22l-5.156 5.048a.814.814 0 0 1-1.134 0l-2.074-2.03c-8.737-8.555-22.903-8.555-31.64 0l-2.222 2.175a.814.814 0 0 1-1.134 0l-5.156-5.049a1.547 1.547 0 0 1 0-2.22l1.654-1.62Zm56.019 10.44 4.589 4.494a1.547 1.547 0 0 1 0 2.22l-20.693 20.26a1.628 1.628 0 0 1-2.267 0L48.283 56.632a.407.407 0 0 0-.567 0L33.03 71.012a1.628 1.628 0 0 1-2.268 0L10.07 50.75a1.547 1.547 0 0 1 0-2.22l4.59-4.494a1.628 1.628 0 0 1 2.267 0l14.687 14.38c.156.153.41.153.567 0l14.685-14.38a1.628 1.628 0 0 1 2.268 0l14.687 14.38c.156.153.41.153.567 0l14.686-14.38a1.628 1.628 0 0 1 2.268 0Z"/><path stroke="#000" d="M25.672 33.954c12.33-12.072 32.325-12.072 44.655 0l1.508 1.476a1.047 1.047 0 0 1 0 1.506l-5.157 5.048a.314.314 0 0 1-.434 0l-2.074-2.03c-8.932-8.746-23.409-8.746-32.34 0l-2.222 2.174a.314.314 0 0 1-.434 0l-5.157-5.048a1.047 1.047 0 0 1 0-1.506l1.655-1.62Zm55.319 10.44 4.59 4.494a1.047 1.047 0 0 1 0 1.506l-20.694 20.26a1.128 1.128 0 0 1-1.568 0l-14.686-14.38a.907.907 0 0 0-1.267 0L32.68 70.655a1.128 1.128 0 0 1-1.568 0L10.42 50.394a1.047 1.047 0 0 1 0-1.506l4.59-4.493a1.128 1.128 0 0 1 1.567 0l14.687 14.379a.907.907 0 0 0 1.266 0l-.35-.357.35.357 14.686-14.38a1.128 1.128 0 0 1 1.568 0l14.687 14.38a.907.907 0 0 0 1.267 0l14.686-14.38a1.128 1.128 0 0 1 1.568 0Z"/></svg>`, BACK_ICON: b4`<svg width="10" height="18" viewBox="0 0 10 18"><path fill-rule="evenodd" clip-rule="evenodd" d="M8.735.179a.75.75 0 0 1 .087 1.057L2.92 8.192a1.25 1.25 0 0 0 0 1.617l5.902 6.956a.75.75 0 1 1-1.144.97L1.776 10.78a2.75 2.75 0 0 1 0-3.559L7.678.265A.75.75 0 0 1 8.735.18Z" fill="#fff"/></svg>`, COPY_ICON: b4`<svg width="24" height="24" fill="none"><path fill="#fff" fill-rule="evenodd" d="M7.01 7.01c.03-1.545.138-2.5.535-3.28A5 5 0 0 1 9.73 1.545C10.8 1 12.2 1 15 1c2.8 0 4.2 0 5.27.545a5 5 0 0 1 2.185 2.185C23 4.8 23 6.2 23 9c0 2.8 0 4.2-.545 5.27a5 5 0 0 1-2.185 2.185c-.78.397-1.735.505-3.28.534l-.001.01c-.03 1.54-.138 2.493-.534 3.27a5 5 0 0 1-2.185 2.186C13.2 23 11.8 23 9 23c-2.8 0-4.2 0-5.27-.545a5 5 0 0 1-2.185-2.185C1 19.2 1 17.8 1 15c0-2.8 0-4.2.545-5.27A5 5 0 0 1 3.73 7.545C4.508 7.149 5.46 7.04 7 7.01h.01ZM15 15.5c-1.425 0-2.403-.001-3.162-.063-.74-.06-1.139-.172-1.427-.319a3.5 3.5 0 0 1-1.53-1.529c-.146-.288-.257-.686-.318-1.427C8.501 11.403 8.5 10.425 8.5 9c0-1.425.001-2.403.063-3.162.06-.74.172-1.139.318-1.427a3.5 3.5 0 0 1 1.53-1.53c.288-.146.686-.257 1.427-.318.759-.062 1.737-.063 3.162-.063 1.425 0 2.403.001 3.162.063.74.06 1.139.172 1.427.318a3.5 3.5 0 0 1 1.53 1.53c.146.288.257.686.318 1.427.062.759.063 1.737.063 3.162 0 1.425-.001 2.403-.063 3.162-.06.74-.172 1.139-.319 1.427a3.5 3.5 0 0 1-1.529 1.53c-.288.146-.686.257-1.427.318-.759.062-1.737.063-3.162.063ZM7 8.511c-.444.009-.825.025-1.162.052-.74.06-1.139.172-1.427.318a3.5 3.5 0 0 0-1.53 1.53c-.146.288-.257.686-.318 1.427-.062.759-.063 1.737-.063 3.162 0 1.425.001 2.403.063 3.162.06.74.172 1.139.318 1.427a3.5 3.5 0 0 0 1.53 1.53c.288.146.686.257 1.427.318.759.062 1.737.063 3.162.063 1.425 0 2.403-.001 3.162-.063.74-.06 1.139-.172 1.427-.319a3.5 3.5 0 0 0 1.53-1.53c.146-.287.257-.685.318-1.426.027-.337.043-.718.052-1.162H15c-2.8 0-4.2 0-5.27-.545a5 5 0 0 1-2.185-2.185C7 13.2 7 11.8 7 9v-.489Z" clip-rule="evenodd"/></svg>`, RETRY_ICON: b4`<svg width="15" height="16" viewBox="0 0 15 16"><path d="M6.464 2.03A.75.75 0 0 0 5.403.97L2.08 4.293a1 1 0 0 0 0 1.414L5.403 9.03a.75.75 0 0 0 1.06-1.06L4.672 6.177a.25.25 0 0 1 .177-.427h2.085a4 4 0 1 1-3.93 4.746c-.077-.407-.405-.746-.82-.746-.414 0-.755.338-.7.748a5.501 5.501 0 1 0 5.45-6.248H4.848a.25.25 0 0 1-.177-.427L6.464 2.03Z" fill="#fff"/></svg>`, DESKTOP_ICON: b4`<svg width="16" height="16" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M0 5.98c0-1.85 0-2.775.394-3.466a3 3 0 0 1 1.12-1.12C2.204 1 3.13 1 4.98 1h6.04c1.85 0 2.775 0 3.466.394a3 3 0 0 1 1.12 1.12C16 3.204 16 4.13 16 5.98v1.04c0 1.85 0 2.775-.394 3.466a3 3 0 0 1-1.12 1.12C13.796 12 12.87 12 11.02 12H4.98c-1.85 0-2.775 0-3.466-.394a3 3 0 0 1-1.12-1.12C0 9.796 0 8.87 0 7.02V5.98ZM4.98 2.5h6.04c.953 0 1.568.001 2.034.043.446.04.608.108.69.154a1.5 1.5 0 0 1 .559.56c.046.08.114.243.154.69.042.465.043 1.08.043 2.033v1.04c0 .952-.001 1.568-.043 2.034-.04.446-.108.608-.154.69a1.499 1.499 0 0 1-.56.559c-.08.046-.243.114-.69.154-.466.042-1.08.043-2.033.043H4.98c-.952 0-1.568-.001-2.034-.043-.446-.04-.608-.108-.69-.154a1.5 1.5 0 0 1-.559-.56c-.046-.08-.114-.243-.154-.69-.042-.465-.043-1.08-.043-2.033V5.98c0-.952.001-1.568.043-2.034.04-.446.108-.608.154-.69a1.5 1.5 0 0 1 .56-.559c.08-.046.243-.114.69-.154.465-.042 1.08-.043 2.033-.043Z" fill="#fff"/><path d="M4 14.25a.75.75 0 0 1 .75-.75h6.5a.75.75 0 0 1 0 1.5h-6.5a.75.75 0 0 1-.75-.75Z" fill="#fff"/></svg>`, MOBILE_ICON: b4`<svg width="16" height="16" viewBox="0 0 16 16"><path d="M6.75 5a1.25 1.25 0 1 0 0-2.5 1.25 1.25 0 0 0 0 2.5Z" fill="#fff"/><path fill-rule="evenodd" clip-rule="evenodd" d="M3 4.98c0-1.85 0-2.775.394-3.466a3 3 0 0 1 1.12-1.12C5.204 0 6.136 0 8 0s2.795 0 3.486.394a3 3 0 0 1 1.12 1.12C13 2.204 13 3.13 13 4.98v6.04c0 1.85 0 2.775-.394 3.466a3 3 0 0 1-1.12 1.12C10.796 16 9.864 16 8 16s-2.795 0-3.486-.394a3 3 0 0 1-1.12-1.12C3 13.796 3 12.87 3 11.02V4.98Zm8.5 0v6.04c0 .953-.001 1.568-.043 2.034-.04.446-.108.608-.154.69a1.499 1.499 0 0 1-.56.559c-.08.045-.242.113-.693.154-.47.042-1.091.043-2.05.043-.959 0-1.58-.001-2.05-.043-.45-.04-.613-.109-.693-.154a1.5 1.5 0 0 1-.56-.56c-.046-.08-.114-.243-.154-.69-.042-.466-.043-1.08-.043-2.033V4.98c0-.952.001-1.568.043-2.034.04-.446.108-.608.154-.69a1.5 1.5 0 0 1 .56-.559c.08-.045.243-.113.693-.154C6.42 1.501 7.041 1.5 8 1.5c.959 0 1.58.001 2.05.043.45.04.613.109.693.154a1.5 1.5 0 0 1 .56.56c.046.08.114.243.154.69.042.465.043 1.08.043 2.033Z" fill="#fff"/></svg>`, ARROW_DOWN_ICON: b4`<svg width="14" height="14" viewBox="0 0 14 14"><path d="M2.28 7.47a.75.75 0 0 0-1.06 1.06l5.25 5.25a.75.75 0 0 0 1.06 0l5.25-5.25a.75.75 0 0 0-1.06-1.06l-3.544 3.543a.25.25 0 0 1-.426-.177V.75a.75.75 0 0 0-1.5 0v10.086a.25.25 0 0 1-.427.176L2.28 7.47Z" fill="#fff"/></svg>`, ARROW_UP_RIGHT_ICON: b4`<svg width="15" height="14" fill="none"><path d="M4.5 1.75A.75.75 0 0 1 5.25 1H12a1.5 1.5 0 0 1 1.5 1.5v6.75a.75.75 0 0 1-1.5 0V4.164a.25.25 0 0 0-.427-.176L4.061 11.5A.75.75 0 0 1 3 10.44l7.513-7.513a.25.25 0 0 0-.177-.427H5.25a.75.75 0 0 1-.75-.75Z" fill="#fff"/></svg>`, ARROW_RIGHT_ICON: b4`<svg width="6" height="14" viewBox="0 0 6 14"><path fill-rule="evenodd" clip-rule="evenodd" d="M2.181 1.099a.75.75 0 0 1 1.024.279l2.433 4.258a2.75 2.75 0 0 1 0 2.729l-2.433 4.257a.75.75 0 1 1-1.303-.744L4.335 7.62a1.25 1.25 0 0 0 0-1.24L1.902 2.122a.75.75 0 0 1 .28-1.023Z" fill="#fff"/></svg>`, QRCODE_ICON: b4`<svg width="25" height="24" viewBox="0 0 25 24"><path d="M23.748 9a.748.748 0 0 0 .748-.752c-.018-2.596-.128-4.07-.784-5.22a6 6 0 0 0-2.24-2.24c-1.15-.656-2.624-.766-5.22-.784a.748.748 0 0 0-.752.748c0 .414.335.749.748.752 1.015.007 1.82.028 2.494.088.995.09 1.561.256 1.988.5.7.398 1.28.978 1.679 1.678.243.427.41.993.498 1.988.061.675.082 1.479.09 2.493a.753.753 0 0 0 .75.749ZM3.527.788C4.677.132 6.152.022 8.747.004A.748.748 0 0 1 9.5.752a.753.753 0 0 1-.749.752c-1.014.007-1.818.028-2.493.088-.995.09-1.561.256-1.988.5-.7.398-1.28.978-1.679 1.678-.243.427-.41.993-.499 1.988-.06.675-.081 1.479-.088 2.493A.753.753 0 0 1 1.252 9a.748.748 0 0 1-.748-.752c.018-2.596.128-4.07.784-5.22a6 6 0 0 1 2.24-2.24ZM1.252 15a.748.748 0 0 0-.748.752c.018 2.596.128 4.07.784 5.22a6 6 0 0 0 2.24 2.24c1.15.656 2.624.766 5.22.784a.748.748 0 0 0 .752-.748.753.753 0 0 0-.749-.752c-1.014-.007-1.818-.028-2.493-.089-.995-.089-1.561-.255-1.988-.498a4.5 4.5 0 0 1-1.679-1.68c-.243-.426-.41-.992-.499-1.987-.06-.675-.081-1.479-.088-2.493A.753.753 0 0 0 1.252 15ZM22.996 15.749a.753.753 0 0 1 .752-.749c.415 0 .751.338.748.752-.018 2.596-.128 4.07-.784 5.22a6 6 0 0 1-2.24 2.24c-1.15.656-2.624.766-5.22.784a.748.748 0 0 1-.752-.748c0-.414.335-.749.748-.752 1.015-.007 1.82-.028 2.494-.089.995-.089 1.561-.255 1.988-.498a4.5 4.5 0 0 0 1.679-1.68c.243-.426.41-.992.498-1.987.061-.675.082-1.479.09-2.493Z" fill="#fff"/><path fill-rule="evenodd" clip-rule="evenodd" d="M7 4a2.5 2.5 0 0 0-2.5 2.5v2A2.5 2.5 0 0 0 7 11h2a2.5 2.5 0 0 0 2.5-2.5v-2A2.5 2.5 0 0 0 9 4H7Zm2 1.5H7a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1ZM13.5 6.5A2.5 2.5 0 0 1 16 4h2a2.5 2.5 0 0 1 2.5 2.5v2A2.5 2.5 0 0 1 18 11h-2a2.5 2.5 0 0 1-2.5-2.5v-2Zm2.5-1h2a1 1 0 0 1 1 1v2a1 1 0 0 1-1 1h-2a1 1 0 0 1-1-1v-2a1 1 0 0 1 1-1ZM7 13a2.5 2.5 0 0 0-2.5 2.5v2A2.5 2.5 0 0 0 7 20h2a2.5 2.5 0 0 0 2.5-2.5v-2A2.5 2.5 0 0 0 9 13H7Zm2 1.5H7a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-2a1 1 0 0 0-1-1Z" fill="#fff"/><path d="M13.5 15.5c0-.465 0-.697.038-.89a2 2 0 0 1 1.572-1.572C15.303 13 15.535 13 16 13v2.5h-2.5ZM18 13c.465 0 .697 0 .89.038a2 2 0 0 1 1.572 1.572c.038.193.038.425.038.89H18V13ZM18 17.5h2.5c0 .465 0 .697-.038.89a2 2 0 0 1-1.572 1.572C18.697 20 18.465 20 18 20v-2.5ZM13.5 17.5H16V20c-.465 0-.697 0-.89-.038a2 2 0 0 1-1.572-1.572c-.038-.193-.038-.425-.038-.89Z" fill="#fff"/></svg>`, SCAN_ICON: b4`<svg width="16" height="16" fill="none"><path fill="#fff" d="M10 15.216c0 .422.347.763.768.74 1.202-.064 2.025-.222 2.71-.613a5.001 5.001 0 0 0 1.865-1.866c.39-.684.549-1.507.613-2.709a.735.735 0 0 0-.74-.768.768.768 0 0 0-.76.732c-.009.157-.02.306-.032.447-.073.812-.206 1.244-.384 1.555-.31.545-.761.996-1.306 1.306-.311.178-.743.311-1.555.384-.141.013-.29.023-.447.032a.768.768 0 0 0-.732.76ZM10 .784c0 .407.325.737.732.76.157.009.306.02.447.032.812.073 1.244.206 1.555.384a3.5 3.5 0 0 1 1.306 1.306c.178.311.311.743.384 1.555.013.142.023.29.032.447a.768.768 0 0 0 .76.732.734.734 0 0 0 .74-.768c-.064-1.202-.222-2.025-.613-2.71A5 5 0 0 0 13.477.658c-.684-.39-1.507-.549-2.709-.613a.735.735 0 0 0-.768.74ZM5.232.044A.735.735 0 0 1 6 .784a.768.768 0 0 1-.732.76c-.157.009-.305.02-.447.032-.812.073-1.244.206-1.555.384A3.5 3.5 0 0 0 1.96 3.266c-.178.311-.311.743-.384 1.555-.013.142-.023.29-.032.447A.768.768 0 0 1 .784 6a.735.735 0 0 1-.74-.768c.064-1.202.222-2.025.613-2.71A5 5 0 0 1 2.523.658C3.207.267 4.03.108 5.233.044ZM5.268 14.456a.768.768 0 0 1 .732.76.734.734 0 0 1-.768.74c-1.202-.064-2.025-.222-2.71-.613a5 5 0 0 1-1.865-1.866c-.39-.684-.549-1.507-.613-2.709A.735.735 0 0 1 .784 10c.407 0 .737.325.76.732.009.157.02.306.032.447.073.812.206 1.244.384 1.555a3.5 3.5 0 0 0 1.306 1.306c.311.178.743.311 1.555.384.142.013.29.023.447.032Z"/></svg>`, CHECKMARK_ICON: b4`<svg width="13" height="12" viewBox="0 0 13 12"><path fill-rule="evenodd" clip-rule="evenodd" d="M12.155.132a.75.75 0 0 1 .232 1.035L5.821 11.535a1 1 0 0 1-1.626.09L.665 7.21a.75.75 0 1 1 1.17-.937L4.71 9.867a.25.25 0 0 0 .406-.023L11.12.364a.75.75 0 0 1 1.035-.232Z" fill="#fff"/></svg>`, HELP_ETH_IMG: b4`<svg width="60" height="60" fill="none" viewBox="0 0 60 60"><g clip-path="url(#j)"><rect width="60" height="60" rx="30" fill="#987DE8"/><path fill-rule="evenodd" clip-rule="evenodd" d="m15.48 28.367 11.966-19.3c1.174-1.892 3.927-1.892 5.1 0l11.97 19.306a6 6 0 0 1 .9 3.142v.028a6 6 0 0 1-1.154 3.56L33.227 50.208c-1.599 2.188-4.864 2.188-6.461 0L15.733 35.095a6 6 0 0 1-1.154-3.538v-.029a6 6 0 0 1 .9-3.161Z" fill="#fff"/><path d="M30.84 10.112a.992.992 0 0 0-.844-.464V24.5l12.598 5.53c.081-.466-.001-.963-.27-1.398L30.84 10.112Z" fill="#643CDD"/><path d="M29.996 9.648a.991.991 0 0 0-.845.465l-11.489 18.53a1.991 1.991 0 0 0-.264 1.387l12.598-5.53V9.648Z" fill="#BDADEB"/><path d="M29.996 50.544a.994.994 0 0 0 .808-.41l11.235-15.38c.307-.434-.193-.988-.658-.72L31.49 39.71a2.998 2.998 0 0 1-1.494.398v10.437Z" fill="#643CDD"/><path d="M17.966 34.762 29.19 50.134c.2.274.503.41.807.41V40.108a2.998 2.998 0 0 1-1.493-.398l-9.884-5.676c-.468-.27-.971.292-.653.728Z" fill="#BDADEB"/><path d="M42.594 30.03 29.996 24.5v13.138a3 3 0 0 0 1.495-.399l10.149-5.83c.525-.31.856-.823.954-1.38Z" fill="#401AB3"/><path d="M29.996 37.638V24.462l-12.598 5.566c.098.564.437 1.083.974 1.392l10.13 5.82c.462.265.978.398 1.494.398Z" fill="#7C5AE2"/></g><rect class="help-img-highlight" x=".5" y=".5" width="59" height="59" rx="29.5"/><defs><clipPath id="j"><rect width="60" height="60" rx="30" fill="#fff"/></clipPath></defs></svg>`, HELP_PAINTING_IMG: b4`<svg width="60" height="60" fill="none" viewBox="0 0 60 60"><g clip-path="url(#k)"><rect width="60" height="60" rx="3" fill="#C653C6"/><path d="M52.094 47.344c0-4.246-1.436-9.557-5.885-12.4a2.876 2.876 0 0 0-1.615-3.891v-.819a4.037 4.037 0 0 0-1.34-3.007 4.75 4.75 0 0 0-2.41-6.252v-5.506c0-6.248-5.065-11.313-11.313-11.313-6.247 0-11.312 5.065-11.312 11.313v2.152a3.343 3.343 0 0 0-1.18 5.045 4.738 4.738 0 0 0-1.633 3.584 4.73 4.73 0 0 0 .956 2.858 5.218 5.218 0 0 0-2.358 6.815c-3.06 4.129-6.098 8.298-6.098 15.64 0 2.668.364 4.856.731 6.385.184.765.368 1.366.509 1.78a12.721 12.721 0 0 0 .225.611l.015.037.005.011.001.004v.002h.001l.92-.393-.92.394.26.606h38.26l.291-.49-.86-.51.86.51v-.001l.002-.002.002-.005.01-.017.035-.06.127-.225c.108-.195.26-.477.441-.835.363-.714.845-1.732 1.328-2.953.959-2.427 1.945-5.725 1.945-9.068Z" fill="#E87DE8" stroke="#fff" stroke-width="2"/><path fill-rule="evenodd" clip-rule="evenodd" d="M26.5 29.5c-3-.5-5.5-3-5.503-7l.002-7c0-.466 0-.698.026-.893a3 3 0 0 1 2.582-2.582c.195-.026.428-.026.893-.026 2 0 2.5-2.5 2.5-2.5s0 2.5 2.5 2.5c1.398 0 2.097 0 2.648.229a3 3 0 0 1 1.624 1.623c.228.552.228 1.25.228 2.649v6c0 4-3 7-6.5 7 1.35.23 4 0 6.5-2v9.53C34 38.5 31.495 40 28 40s-6-1.5-6-2.97L24 34l2.5 1.5v-6ZM26 47h4.5c2.5 0 3 4 3 5.5h-3l-1-1.5H26v-4Zm-6.25 5.5H24V57h-8c0-1 1-4.5 3.75-4.5Z" fill="#fff"/></g><rect class="help-img-highlight" x=".5" y=".5" width="59" height="59" rx="2.5"/><defs><clipPath id="k"><rect width="60" height="60" rx="3" fill="#fff"/></clipPath></defs></svg>`, HELP_CHART_IMG: b4`<svg width="60" height="60" fill="none" viewBox="0 0 60 60"><g clip-path="url(#l)"><path d="M0 25.01C0 15.76 0 11.133 1.97 7.678a15 15 0 0 1 5.598-5.597C11.023.11 15.648.11 24.9.11h10.2c9.251 0 13.877 0 17.332 1.97a15 15 0 0 1 5.597 5.597C60 11.133 60 15.758 60 25.01v10.2c0 9.252 0 13.877-1.97 17.332a15 15 0 0 1-5.598 5.598c-3.455 1.97-8.08 1.97-17.332 1.97H24.9c-9.251 0-13.877 0-17.332-1.97a14.999 14.999 0 0 1-5.597-5.598C0 49.087 0 44.462 0 35.21v-10.2Z" fill="#1DC956"/><path d="M.5 25.01c0-4.635 0-8.078.244-10.795.244-2.71.726-4.65 1.66-6.289a14.5 14.5 0 0 1 5.412-5.41c1.639-.936 3.579-1.418 6.289-1.661C16.822.61 20.265.61 24.9.61h10.2c4.635 0 8.078 0 10.795.245 2.71.243 4.65.725 6.29 1.66a14.5 14.5 0 0 1 5.41 5.411c.935 1.64 1.417 3.579 1.66 6.29.244 2.717.245 6.16.245 10.794v10.2c0 4.635 0 8.078-.244 10.795-.244 2.71-.726 4.65-1.66 6.29a14.5 14.5 0 0 1-5.412 5.41c-1.639.936-3.579 1.418-6.289 1.661-2.717.244-6.16.244-10.795.244H24.9c-4.635 0-8.078 0-10.795-.244-2.71-.243-4.65-.725-6.29-1.66a14.5 14.5 0 0 1-5.41-5.412C1.47 50.655.988 48.716.745 46.005.5 43.288.5 39.845.5 35.21v-10.2Z" stroke="#fff" stroke-opacity=".1"/><path d="M16.109 60c-3.833-.179-6.41-.645-8.541-1.86a15 15 0 0 1-5.598-5.598C.553 50.057.155 46.967.043 41.985l4.146-1.382a4 4 0 0 0 2.48-2.39l4.654-12.409a2 2 0 0 1 2.505-1.195l2.526.842a2 2 0 0 0 2.422-1.003l2.968-5.938c.81-1.62 3.185-1.415 3.705.32l3.774 12.581a2 2 0 0 0 3.025 1.09l3.342-2.228c.27-.18.49-.422.646-.706l5.297-9.712a2 2 0 0 1 1.428-1.016l4.134-.689a2 2 0 0 1 1.61.437l3.892 3.243a2 2 0 0 0 2.694-.122l4.633-4.632C60 19.28 60 21.88 60 25.01v10.2c0 9.252 0 13.877-1.97 17.332a14.998 14.998 0 0 1-5.598 5.598c-2.131 1.215-4.708 1.681-8.54 1.86H16.108Z" fill="#2BEE6C"/><path d="M.072 43.03a112.37 112.37 0 0 1-.048-2.093l3.85-1.283a3 3 0 0 0 1.86-1.793l4.653-12.408a3 3 0 0 1 3.758-1.793l2.526.842a1 1 0 0 0 1.21-.501l2.97-5.938c1.214-2.43 4.775-2.123 5.556.48l3.774 12.58a1 1 0 0 0 1.513.545l3.341-2.227a1 1 0 0 0 .323-.353l5.298-9.712a3 3 0 0 1 2.14-1.523l4.135-.69a3 3 0 0 1 2.414.655l3.892 3.244a1 1 0 0 0 1.347-.061l5.28-5.28c.046.845.077 1.752.097 2.732l-3.962 3.962a3 3 0 0 1-4.042.183l-3.893-3.243a1 1 0 0 0-.804-.218l-4.135.689a1 1 0 0 0-.714.507l-5.297 9.712c-.233.427-.565.79-.97 1.06l-3.34 2.228a3 3 0 0 1-4.538-1.635l-3.775-12.58c-.26-.868-1.447-.97-1.852-.16l-2.969 5.937a3 3 0 0 1-3.632 1.505l-2.526-.842a1 1 0 0 0-1.252.597L7.606 38.564a5 5 0 0 1-3.1 2.988L.072 43.029Z" fill="#fff"/><path fill-rule="evenodd" clip-rule="evenodd" d="M49.5 19a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0Z" fill="#2BEE6C"/><path d="M47.5 19a3.5 3.5 0 1 1-7 0 3.5 3.5 0 0 1 7 0Z" fill="#fff"/><path d="M45 .283v59.654c-.63.042-1.294.074-2 .098V.185c.706.025 1.37.056 2 .098Z" fill="#fff"/><path class="help-img-highlight" d="M.5 25.01c0-4.635 0-8.078.244-10.795.244-2.71.726-4.65 1.66-6.289a14.5 14.5 0 0 1 5.412-5.41c1.639-.936 3.579-1.418 6.289-1.661C16.822.61 20.265.61 24.9.61h10.2c4.635 0 8.078 0 10.795.245 2.71.243 4.65.725 6.29 1.66a14.5 14.5 0 0 1 5.41 5.411c.935 1.64 1.417 3.579 1.66 6.29.244 2.717.245 6.16.245 10.794v10.2c0 4.635 0 8.078-.244 10.795-.244 2.71-.726 4.65-1.66 6.29a14.5 14.5 0 0 1-5.412 5.41c-1.639.936-3.579 1.418-6.289 1.661-2.717.244-6.16.244-10.795.244H24.9c-4.635 0-8.078 0-10.795-.244-2.71-.243-4.65-.725-6.29-1.66a14.5 14.5 0 0 1-5.41-5.412C1.47 50.655.988 48.716.745 46.005.5 43.288.5 39.845.5 35.21v-10.2Z"/></g><defs><clipPath id="l"><path fill="#fff" d="M0 0h60v60H0z"/></clipPath></defs></svg>`, HELP_KEY_IMG: b4`<svg width="60" height="60" fill="none" viewBox="0 0 60 60"><g clip-path="url(#m)"><path fill="#EB8B47" d="M0 24.9c0-9.252 0-13.878 1.97-17.332A15 15 0 0 1 7.569 1.97C11.023 0 15.648 0 24.9 0h10.2c9.251 0 13.877 0 17.332 1.97a15 15 0 0 1 5.597 5.598C60 11.022 60 15.648 60 24.899v10.2c0 9.252 0 13.878-1.97 17.332a15.001 15.001 0 0 1-5.598 5.598c-3.455 1.97-8.08 1.97-17.332 1.97H24.9c-9.251 0-13.877 0-17.332-1.97a15 15 0 0 1-5.597-5.598C0 48.977 0 44.351 0 35.1V24.9Z"/><path class="help-img-highlight" d="M.5 24.9c0-4.635 0-8.078.244-10.795.244-2.71.726-4.65 1.66-6.29a14.5 14.5 0 0 1 5.412-5.41C9.455 1.468 11.395.986 14.105.743 16.822.5 20.265.5 24.9.5h10.2c4.635 0 8.078 0 10.795.244 2.71.243 4.65.725 6.29 1.66a14.5 14.5 0 0 1 5.41 5.411c.935 1.64 1.417 3.58 1.66 6.29.244 2.717.245 6.16.245 10.794v10.2c0 4.635 0 8.078-.244 10.796-.244 2.71-.726 4.65-1.66 6.289a14.5 14.5 0 0 1-5.412 5.41c-1.639.936-3.579 1.418-6.289 1.661-2.717.244-6.16.244-10.795.244H24.9c-4.635 0-8.078 0-10.795-.244-2.71-.243-4.65-.725-6.29-1.66a14.5 14.5 0 0 1-5.41-5.411c-.935-1.64-1.417-3.58-1.66-6.29C.5 43.178.5 39.734.5 35.1V24.9Z"/><path fill="#FF974C" stroke="#fff" stroke-width="2" d="M39.192 29.192c5.077-5.077 5.077-13.308 0-18.385-5.076-5.077-13.308-5.077-18.384 0-5.077 5.077-5.077 13.308 0 18.385l1.287 1.291c1.137 1.142 1.706 1.712 2.097 2.387.267.462.472.957.608 1.473.2.755.2 1.56.2 3.171V48.75c0 1.077 0 1.615.134 2.119a4 4 0 0 0 .407.984c.262.45.643.831 1.404 1.592l.294.295c.654.654.982.981 1.365 1.086.26.07.533.07.792 0 .383-.105.71-.432 1.365-1.086l3.478-3.479c.655-.654.982-.981 1.087-1.365a1.5 1.5 0 0 0 0-.791c-.105-.384-.432-.711-1.087-1.365l-.478-.479c-.655-.654-.982-.981-1.087-1.365a1.5 1.5 0 0 1 0-.791c.105-.384.432-.711 1.087-1.365l.478-.479c.655-.654.982-.981 1.087-1.365a1.5 1.5 0 0 0 0-.791c-.105-.384-.432-.711-1.087-1.365l-.492-.493c-.65-.65-.974-.974-1.08-1.355a1.5 1.5 0 0 1-.003-.788c.102-.382.425-.71 1.069-1.364l5.46-5.547Z"/><circle cx="30" cy="17" r="4" fill="#EB8B47" stroke="#fff" stroke-width="2"/></g><defs><clipPath id="m"><path fill="#fff" d="M0 0h60v60H0z"/></clipPath></defs></svg>`, HELP_USER_IMG: b4`<svg width="60" height="60" fill="none" viewBox="0 0 60 60"><g clip-path="url(#n)"><rect width="60" height="60" fill="#00ACE6" rx="30"/><path fill="#1AC6FF" stroke="#fff" stroke-width="2" d="M59 73c0 16.016-12.984 29-29 29S1 89.016 1 73c0-16.017 11-29 29-29s29 12.983 29 29ZM18.69 19.902a11 11 0 0 1 9.281-8.692 14.842 14.842 0 0 1 4.058 0 11 11 0 0 1 9.28 8.692c.178.866.322 1.75.44 2.625.132.977.132 1.968 0 2.945a39.467 39.467 0 0 1-.44 2.625 11 11 0 0 1-9.28 8.692 14.862 14.862 0 0 1-4.058 0 11 11 0 0 1-9.28-8.692 39.467 39.467 0 0 1-.44-2.625 11.004 11.004 0 0 1 0-2.945c.118-.876.262-1.759.44-2.625Z"/><circle cx="24.5" cy="23.5" r="1.5" fill="#fff"/><circle cx="35.5" cy="23.5" r="1.5" fill="#fff"/><path stroke="#fff" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m31 20-3 8h4"/></g><rect class="help-img-highlight" width="59" height="59" x=".5" y=".5" rx="29.5"/><defs><clipPath id="n"><rect width="60" height="60" fill="#fff" rx="30"/></clipPath></defs></svg>`, HELP_LOCK_IMG: b4`<svg width="60" height="60" fill="none" viewBox="0 0 60 60"><rect width="60" height="60" fill="#C653C6" rx="3"/><path fill="#fff" d="M20.034 15.216C20 15.607 20 16.07 20 17v2.808c0 1.13 0 1.696-.2 2.11a1.78 1.78 0 0 1-.584.714c-.366.28-1.051.42-2.423.7a7.076 7.076 0 0 0-1.597.511 9.001 9.001 0 0 0-4.353 4.353C10 30.005 10 32.336 10 37c0 4.663 0 6.995.843 8.804a9.001 9.001 0 0 0 4.353 4.353C17.005 51 19.336 51 24 51h12c4.663 0 6.995 0 8.804-.843a9.001 9.001 0 0 0 4.353-4.353C50 43.995 50 41.664 50 37c0-4.663 0-6.995-.843-8.804a9.001 9.001 0 0 0-4.353-4.353 7.076 7.076 0 0 0-1.597-.511c-1.372-.28-2.057-.42-2.423-.7a1.78 1.78 0 0 1-.583-.715C40 21.505 40 20.94 40 19.809V17c0-.929 0-1.393-.034-1.784a9 9 0 0 0-8.182-8.182C31.393 7 30.93 7 30 7s-1.393 0-1.784.034a9 9 0 0 0-8.182 8.182Z"/><path fill="#E87DE8" d="M22 17c0-.929 0-1.393.044-1.784a7 7 0 0 1 6.172-6.172C28.606 9 29.071 9 30 9s1.393 0 1.784.044a7 7 0 0 1 6.172 6.172c.044.39.044.855.044 1.784v4.5a1.5 1.5 0 0 1-3 0V17c0-.93 0-1.394-.077-1.78a4 4 0 0 0-3.143-3.143C31.394 12 30.93 12 30 12s-1.394 0-1.78.077a4 4 0 0 0-3.143 3.143C25 15.606 25 16.07 25 17v4.5a1.5 1.5 0 0 1-3 0V17Z"/><path fill="#E87DE8" fill-rule="evenodd" d="M12 36.62c0-4.317 0-6.476.92-8.088a7 7 0 0 1 2.612-2.612c1.612-.92 3.77-.92 8.088-.92h6.855c.469 0 .703 0 .906.017 2.73.222 4.364 2.438 4.619 4.983.27-2.698 2.111-5 5.015-5A6.985 6.985 0 0 1 48 31.985v5.395c0 4.317 0 6.476-.92 8.088a7 7 0 0 1-2.612 2.612c-1.612.92-3.77.92-8.088.92h-5.855c-.469 0-.703 0-.906-.017-2.73-.222-4.364-2.438-4.619-4.983-.258 2.583-1.943 4.818-4.714 4.99-.155.01-.335.01-.694.01-.55 0-.825 0-1.057-.015a7 7 0 0 1-6.52-6.52C12 42.233 12 41.958 12 41.408V36.62Zm21.24-.273a4 4 0 1 0-6.478 0c.985 1.36 1.479 2.039 1.564 2.229.178.398.176.818.174 1.247V42.5a1.5 1.5 0 0 0 3 0v-2.677c-.002-.429-.004-.85.174-1.247.085-.19.579-.87 1.565-2.229Z" clip-rule="evenodd"/><rect class="help-img-highlight" width="59" height="59" x=".5" y=".5" rx="2.5"/></svg>`, HELP_COMPAS_IMG: b4`<svg width="60" height="60" fill="none" viewBox="0 0 60 60"><rect width="60" height="60" fill="#1DC956" rx="30"/><circle cx="30" cy="29.999" r="3" fill="#fff"/><path fill="#2BEE6C" stroke="#fff" stroke-width="2" d="m45.316 17.9-.88-.425.88.424a7.9 7.9 0 0 1 .026-.053c.093-.192.21-.432.26-.687l-.819-.162.819.162a2 2 0 0 0-.239-1.405c-.132-.224-.32-.412-.472-.562a8.415 8.415 0 0 1-.042-.042l-.042-.042c-.15-.151-.338-.34-.562-.472l-.508.862.508-.862a2 2 0 0 0-1.405-.239c-.255.05-.495.167-.687.26l-.053.026-15.05 7.246-.108.052c-1.131.545-1.843.887-2.456 1.374a6.994 6.994 0 0 0-1.13 1.13c-.487.613-.83 1.325-1.375 2.457l-.051.108-7.247 15.05-.025.053c-.094.192-.21.431-.26.686a2 2 0 0 0 .239 1.406l.855-.505-.856.505c.133.224.321.411.473.562l.042.042.041.042c.15.151.338.34.563.472a2 2 0 0 0 1.405.239l-.195-.981.195.98c.255-.05.494-.166.686-.26l.054-.025-.419-.87.419.87 15.05-7.247.107-.051c1.132-.545 1.844-.888 2.457-1.374a7.002 7.002 0 0 0 1.13-1.13c.487-.614.83-1.325 1.374-2.457l.052-.108 7.246-15.05Z"/><path fill="#1DC956" d="m33.376 32.723-2.669-3.43-14.85 14.849.206.205a1 1 0 0 0 1.141.194l15.105-7.273a3 3 0 0 0 1.067-4.545Z"/><path fill="#86F999" d="m26.624 27.276 2.669 3.43 14.85-14.849-.206-.205a1 1 0 0 0-1.141-.194L27.69 22.731a3 3 0 0 0-1.067 4.545Z"/><circle cx="30" cy="30" r="3" fill="#fff" transform="rotate(45 30 30)"/><rect class="help-img-highlight" width="59" height="59" x=".5" y=".5" rx="29.5"/></svg>`, HELP_NOUN_IMG: b4`<svg width="60" height="60" fill="none" viewBox="0 0 60 60"><rect width="60" height="60" fill="#794CFF" rx="3"/><path fill="#987DE8" stroke="#fff" stroke-width="2" d="M33 22.5v-1H16v5H8.5V36H13v-5h3v7.5h17V31h1v7.5h17v-17H34v5h-1v-4Z"/><path fill="#fff" d="M37.5 25h10v10h-10z"/><path fill="#4019B2" d="M42.5 25h5v10h-5z"/><path fill="#fff" d="M19.5 25h10v10h-10z"/><path fill="#4019B2" d="M24.5 25h5v10h-5z"/><path fill="#fff" d="M12 30.5h4V37h-4v-6.5Z"/><rect class="help-img-highlight" width="59" height="59" x=".5" y=".5" rx="2.5"/></svg>`, HELP_DAO_IMG: b4`<svg width="60" height="60" fill="none" viewBox="0 0 60 60"><g clip-path="url(#o)"><path fill="#EB8B47" d="M0 24.9c0-9.252 0-13.878 1.97-17.332A15 15 0 0 1 7.569 1.97C11.023 0 15.648 0 24.9 0h10.2c9.251 0 13.877 0 17.332 1.97a15 15 0 0 1 5.597 5.598C60 11.022 60 15.648 60 24.899v10.2c0 9.252 0 13.878-1.97 17.332a15.001 15.001 0 0 1-5.598 5.598c-3.455 1.97-8.08 1.97-17.332 1.97H24.9c-9.251 0-13.877 0-17.332-1.97a15 15 0 0 1-5.597-5.598C0 48.977 0 44.351 0 35.1V24.9Z"/><path class="help-img-highlight" d="M.5 24.9c0-4.635 0-8.078.244-10.795.244-2.71.726-4.65 1.66-6.29a14.5 14.5 0 0 1 5.412-5.41C9.455 1.468 11.395.986 14.105.743 16.822.5 20.265.5 24.9.5h10.2c4.635 0 8.078 0 10.795.244 2.71.243 4.65.725 6.29 1.66a14.5 14.5 0 0 1 5.41 5.411c.935 1.64 1.417 3.58 1.66 6.29.244 2.717.245 6.16.245 10.794v10.2c0 4.635 0 8.078-.244 10.796-.244 2.71-.726 4.65-1.66 6.289a14.5 14.5 0 0 1-5.412 5.41c-1.639.936-3.579 1.418-6.289 1.661-2.717.244-6.16.244-10.795.244H24.9c-4.635 0-8.078 0-10.795-.244-2.71-.243-4.65-.725-6.29-1.66a14.5 14.5 0 0 1-5.41-5.411c-.935-1.64-1.417-3.58-1.66-6.29C.5 43.178.5 39.734.5 35.1V24.9Z"/><path fill="#FF974C" stroke="#fff" stroke-width="2" d="M19 52c5.523 0 10-4.477 10-10s-4.477-10-10-10S9 36.477 9 42s4.477 10 10 10Z"/><path fill="#fff" fill-rule="evenodd" d="M42.844 8.326a1 1 0 0 0-1.687 0L28.978 27.463A1 1 0 0 0 29.822 29h24.357a1 1 0 0 0 .843-1.537L42.844 8.326Z" clip-rule="evenodd"/><path fill="#FF974C" fill-rule="evenodd" d="M42.335 11.646c.324.115.571.504 1.066 1.28l7.332 11.523c.562.883.843 1.325.792 1.69a1 1 0 0 1-.342.623c-.28.238-.803.238-1.85.238H34.667c-1.047 0-1.57 0-1.85-.238a1 1 0 0 1-.342-.623c-.051-.365.23-.806.792-1.69l7.332-11.523c.495-.776.742-1.165 1.066-1.28a1 1 0 0 1 .67 0ZM35 27a7 7 0 0 0 7-7 7 7 0 0 0 7 7H35Z" clip-rule="evenodd"/><path fill="#FF974C" stroke="#fff" stroke-width="2" d="M10.106 9.357c-.109.32-.107.682-.106.975V25.668c-.001.293-.003.654.106.975a2 2 0 0 0 1.251 1.25c.32.11.682.108.975.107H19c5.523 0 10-4.477 10-10S24.523 8 19 8h-6.668c-.293-.001-.654-.003-.975.106a2 2 0 0 0-1.25 1.251Z"/><circle cx="19" cy="18" r="4" fill="#EB8B47" stroke="#fff" stroke-width="2"/><circle cx="19" cy="41.999" r="4" fill="#EB8B47" stroke="#fff" stroke-width="2"/></g><defs><clipPath id="o"><path fill="#fff" d="M0 0h60v60H0z"/></clipPath></defs></svg>`, SEARCH_ICON: b4`<svg width="20" height="21"><path fill-rule="evenodd" clip-rule="evenodd" d="M12.432 13.992c-.354-.353-.91-.382-1.35-.146a5.5 5.5 0 1 1 2.265-2.265c-.237.441-.208.997.145 1.35l3.296 3.296a.75.75 0 1 1-1.06 1.061l-3.296-3.296Zm.06-5a4 4 0 1 1-8 0 4 4 0 0 1 8 0Z" fill="#949E9E"/></svg>`, HELP_ICON: b4`<svg width="11" height="17" viewBox="0 0 11 17"><path fill="#fff" d="M5.22 2.97c-1.07 0-2.25.843-2.25 2.25a.75.75 0 0 1-1.5 0c0-2.393 2.019-3.75 3.75-3.75 1.73 0 3.75 1.357 3.75 3.75 0 1.64-1.038 2.466-1.785 3.057-.802.635-1.215.984-1.215 1.693a.75.75 0 1 1-1.5 0c0-1.466.985-2.24 1.681-2.788l.103-.081C7.007 6.504 7.47 6.08 7.47 5.22c0-1.407-1.181-2.25-2.25-2.25ZM5.22 14.97a1.25 1.25 0 1 0 0-2.5 1.25 1.25 0 0 0 0 2.5Z"/></svg>`, WALLET_ICON: b4`<svg width="15" height="14" fill="none" viewBox="0 0 15 14"><path fill="#fff" fill-rule="evenodd" d="M.64 9.2v-3h.001c.009-1.857.07-2.886.525-3.682a4 4 0 0 1 1.492-1.493C3.58.5 4.813.5 7.28.5h3.735c.58 0 .871 0 1.114.04A3 3 0 0 1 14.6 3.011c.04.243.04.533.04 1.114 0 .58 0 .871-.04 1.114a3 3 0 0 1-2.471 2.47c-.243.041-.533.041-1.114.041h-.777c.178.307.302.648.362 1.011.04.243.04.533.04 1.114 0 .58 0 .871-.04 1.114a3 3 0 0 1-2.471 2.47c-.243.041-.533.041-1.114.041H4.507A3.867 3.867 0 0 1 .64 9.633V9.2ZM7.28 2h3.735c.64 0 .779.005.87.02a1.5 1.5 0 0 1 1.235 1.236c.015.09.02.229.02.869s-.005.779-.02.87a1.5 1.5 0 0 1-1.236 1.235c-.09.015-.229.02-.869.02H4.023c-.697 0-1.345.21-1.883.572V6.25h.001c.004-.791.015-1.383.059-1.867.056-.629.157-.926.269-1.122a2.5 2.5 0 0 1 .932-.933c.197-.111.494-.212 1.123-.268C5.173 2 6.019 2 7.28 2Zm-.265 5.75H4.023c-1.04 0-1.883.843-1.883 1.883A2.367 2.367 0 0 0 4.507 12h2.508c.64 0 .779-.005.87-.02a1.5 1.5 0 0 0 1.235-1.236c.015-.09.02-.229.02-.869s-.005-.779-.02-.87A1.5 1.5 0 0 0 7.884 7.77c-.09-.015-.228-.02-.869-.02Z" clip-rule="evenodd"/></svg>`, NETWORK_PLACEHOLDER: b4`<svg width="28" height="28" fill="none" viewBox="0 0 28 28"><mask id="p" width="26" height="28" x="1" y="0" maskUnits="userSpaceOnUse" style="mask-type:alpha"><path fill="#D9D9D9" d="M12 1.172a4 4 0 0 1 4 0l8.124 4.69a4 4 0 0 1 2 3.465v9.381a4 4 0 0 1-2 3.464L16 26.862a4 4 0 0 1-4 0l-8.124-4.69a4 4 0 0 1-2-3.464V9.327a4 4 0 0 1 2-3.464L12 1.173Z"/></mask><g mask="url(#p)"><path id="network-placeholder-fill" fill="#fff" d="M0 0h28v28H0z"/><path id="network-placeholder-dash" stroke="#000" stroke-dasharray="2 2" d="m8.953 2.931 2.032-1.173.25.433 1.015-.586c.269-.155.553-.271.844-.35l-.13-.483a4.003 4.003 0 0 1 2.071 0l-.13.483c.293.079.576.195.845.35l1.016.586.25-.433 2.03 1.173-.25.433 2.032 1.173.25-.433 2.03 1.172-.25.433 1.016.587c.269.155.512.342.725.556l.354-.354a4.003 4.003 0 0 1 1.035 1.794l-.483.129c.078.292.12.596.12.906v1.172h.5v2.346h-.5v2.345h.5v2.345h-.5v1.173c0 .31-.042.614-.12.906l.483.13a4.003 4.003 0 0 1-1.035 1.793l-.354-.354a3.498 3.498 0 0 1-.725.556l-1.015.586.25.434-2.031 1.172-.25-.433-2.031 1.173.25.433-2.031 1.172-.25-.433-1.016.587a3.494 3.494 0 0 1-.844.35l.13.482a4.003 4.003 0 0 1-2.071 0l.13-.483a3.496 3.496 0 0 1-.845-.35l-1.015-.586-.25.433-2.032-1.172.25-.433-2.03-1.173-.25.433L4.89 22.76l.25-.434-1.015-.586a3.498 3.498 0 0 1-.725-.556l-.354.354a4.003 4.003 0 0 1-1.035-1.794l.483-.13a3.497 3.497 0 0 1-.12-.905v-1.173h-.5V15.19h.5v-2.345h-.5v-2.346h.5V9.327c0-.31.042-.614.12-.906l-.483-.13a4.003 4.003 0 0 1 1.035-1.793l.354.354c.213-.214.456-.401.725-.556l1.015-.587-.25-.433 2.031-1.172.25.433 2.031-1.173-.25-.433Z"/><path fill="#798686" stroke="#fff" d="M14.243 13.563 14 13.428l-.243.135-6.388 3.549-.024.013c-.432.24-.79.44-1.053.622-.266.184-.516.405-.636.722a1.5 1.5 0 0 0 0 1.062c.12.317.37.538.636.722.263.183.62.382 1.053.622l.024.013 3.164 1.758.088.049c1.164.646 1.857 1.032 2.607 1.162.51.09 1.033.09 1.544 0 .75-.13 1.443-.516 2.606-1.162l.09-.05 3.163-1.757.024-.013c.432-.24.79-.44 1.053-.622.266-.184.516-.405.636-.722l-.468-.177.468.177a1.5 1.5 0 0 0 0-1.062l-.468.177.468-.177c-.12-.317-.37-.538-.636-.722-.263-.183-.62-.382-1.053-.622l-.024-.013-6.388-3.55Z"/><path fill="#9EA9A9" stroke="#fff" d="M14.243 8.563 14 8.428l-.243.135-6.388 3.549-.024.013c-.432.24-.79.44-1.053.622-.266.184-.516.405-.636.722a1.5 1.5 0 0 0 0 1.062c.12.316.37.537.636.722.263.183.62.382 1.053.622l.024.013 3.164 1.758.088.049c1.164.646 1.857 1.032 2.607 1.162.51.09 1.033.09 1.544 0 .75-.13 1.443-.516 2.606-1.162l.09-.05 3.163-1.757.024-.013c.432-.24.79-.44 1.053-.622.266-.184.516-.405.636-.722l-.468-.177.468.177a1.5 1.5 0 0 0 0-1.062l-.468.177.468-.177c-.12-.316-.37-.537-.636-.722-.263-.183-.62-.382-1.053-.622l-.024-.013-6.388-3.55Z"/><path fill="#C9CFCF" stroke="#fff" d="m22.344 9.53-.468-.176.468.177a1.5 1.5 0 0 0 0-1.062l-.468.177.468-.177c-.12-.317-.37-.537-.636-.722-.263-.183-.62-.382-1.053-.622l-.024-.013-3.163-1.758-.09-.05c-1.163-.645-1.856-1.03-2.606-1.161a4.5 4.5 0 0 0-1.544 0c-.75.13-1.443.516-2.607 1.162l-.088.05-3.164 1.757-.024.013c-.432.24-.79.44-1.053.622-.266.185-.516.405-.636.722a1.5 1.5 0 0 0 0 1.062c.12.317.37.537.636.722.263.183.62.382 1.053.622l.024.013 3.164 1.758.088.049c1.164.646 1.857 1.032 2.607 1.162.51.09 1.033.09 1.544 0 .75-.13 1.443-.516 2.606-1.162l.09-.05 3.163-1.757.024-.013c.432-.24.79-.44 1.053-.622.266-.184.516-.405.636-.722Z"/></g></svg>`, WALLET_PLACEHOLDER: b4`<svg width="60" height="60" fill="none" viewBox="0 0 60 60"><g clip-path="url(#q)"><path id="wallet-placeholder-fill" fill="#fff" d="M0 24.9c0-9.251 0-13.877 1.97-17.332a15 15 0 0 1 5.598-5.597C11.023 0 15.648 0 24.9 0h10.2c9.252 0 13.877 0 17.332 1.97a15 15 0 0 1 5.597 5.598C60 11.023 60 15.648 60 24.9v10.2c0 9.252 0 13.877-1.97 17.332a15.001 15.001 0 0 1-5.598 5.597C48.977 60 44.352 60 35.1 60H24.9c-9.251 0-13.877 0-17.332-1.97a15 15 0 0 1-5.597-5.598C0 48.977 0 44.352 0 35.1V24.9Z"/><path id="wallet-placeholder-dash" stroke="#000" stroke-dasharray="4 4" stroke-width="1.5" d="M.04 41.708a231.598 231.598 0 0 1-.039-4.403l.75-.001L.75 35.1v-2.55H0v-5.1h.75V24.9l.001-2.204h-.75c.003-1.617.011-3.077.039-4.404l.75.016c.034-1.65.099-3.08.218-4.343l-.746-.07c.158-1.678.412-3.083.82-4.316l.713.236c.224-.679.497-1.296.827-1.875a14.25 14.25 0 0 1 1.05-1.585L3.076 5.9A15 15 0 0 1 5.9 3.076l.455.596a14.25 14.25 0 0 1 1.585-1.05c.579-.33 1.196-.603 1.875-.827l-.236-.712C10.812.674 12.217.42 13.895.262l.07.746C15.23.89 16.66.824 18.308.79l-.016-.75C19.62.012 21.08.004 22.695.001l.001.75L24.9.75h2.55V0h5.1v.75h2.55l2.204.001v-.75c1.617.003 3.077.011 4.404.039l-.016.75c1.65.034 3.08.099 4.343.218l.07-.746c1.678.158 3.083.412 4.316.82l-.236.713c.679.224 1.296.497 1.875.827a14.24 14.24 0 0 1 1.585 1.05l.455-.596A14.999 14.999 0 0 1 56.924 5.9l-.596.455c.384.502.735 1.032 1.05 1.585.33.579.602 1.196.827 1.875l.712-.236c.409 1.233.663 2.638.822 4.316l-.747.07c.119 1.264.184 2.694.218 4.343l.75-.016c.028 1.327.036 2.787.039 4.403l-.75.001.001 2.204v2.55H60v5.1h-.75v2.55l-.001 2.204h.75a231.431 231.431 0 0 1-.039 4.404l-.75-.016c-.034 1.65-.099 3.08-.218 4.343l.747.07c-.159 1.678-.413 3.083-.822 4.316l-.712-.236a10.255 10.255 0 0 1-.827 1.875 14.242 14.242 0 0 1-1.05 1.585l.596.455a14.997 14.997 0 0 1-2.824 2.824l-.455-.596c-.502.384-1.032.735-1.585 1.05-.579.33-1.196.602-1.875.827l.236.712c-1.233.409-2.638.663-4.316.822l-.07-.747c-1.264.119-2.694.184-4.343.218l.016.75c-1.327.028-2.787.036-4.403.039l-.001-.75-2.204.001h-2.55V60h-5.1v-.75H24.9l-2.204-.001v.75a231.431 231.431 0 0 1-4.404-.039l.016-.75c-1.65-.034-3.08-.099-4.343-.218l-.07.747c-1.678-.159-3.083-.413-4.316-.822l.236-.712a10.258 10.258 0 0 1-1.875-.827 14.252 14.252 0 0 1-1.585-1.05l-.455.596A14.999 14.999 0 0 1 3.076 54.1l.596-.455a14.24 14.24 0 0 1-1.05-1.585 10.259 10.259 0 0 1-.827-1.875l-.712.236C.674 49.188.42 47.783.262 46.105l.746-.07C.89 44.77.824 43.34.79 41.692l-.75.016Z"/><path fill="#fff" fill-rule="evenodd" d="M35.643 32.145c-.297-.743-.445-1.114-.401-1.275a.42.42 0 0 1 .182-.27c.134-.1.463-.1 1.123-.1.742 0 1.499.046 2.236-.05a6 6 0 0 0 5.166-5.166c.051-.39.051-.855.051-1.784 0-.928 0-1.393-.051-1.783a6 6 0 0 0-5.166-5.165c-.39-.052-.854-.052-1.783-.052h-7.72c-4.934 0-7.401 0-9.244 1.051a8 8 0 0 0-2.985 2.986C16.057 22.28 16.003 24.58 16 29 15.998 31.075 16 33.15 16 35.224A7.778 7.778 0 0 0 23.778 43H28.5c1.394 0 2.09 0 2.67-.116a6 6 0 0 0 4.715-4.714c.115-.58.115-1.301.115-2.744 0-1.31 0-1.964-.114-2.49a4.998 4.998 0 0 0-.243-.792Z" clip-rule="evenodd"/><path fill="#9EA9A9" fill-rule="evenodd" d="M37 18h-7.72c-2.494 0-4.266.002-5.647.126-1.361.122-2.197.354-2.854.728a6.5 6.5 0 0 0-2.425 2.426c-.375.657-.607 1.492-.729 2.853-.11 1.233-.123 2.777-.125 4.867 0 .7 0 1.05.097 1.181.096.13.182.181.343.2.163.02.518-.18 1.229-.581a6.195 6.195 0 0 1 3.053-.8H37c.977 0 1.32-.003 1.587-.038a4.5 4.5 0 0 0 3.874-3.874c.036-.268.039-.611.039-1.588 0-.976-.003-1.319-.038-1.587a4.5 4.5 0 0 0-3.875-3.874C38.32 18.004 37.977 18 37 18Zm-7.364 12.5h-7.414a4.722 4.722 0 0 0-4.722 4.723 6.278 6.278 0 0 0 6.278 6.278H28.5c1.466 0 1.98-.008 2.378-.087a4.5 4.5 0 0 0 3.535-3.536c.08-.397.087-.933.087-2.451 0-1.391-.009-1.843-.08-2.17a3.5 3.5 0 0 0-2.676-2.676c-.328-.072-.762-.08-2.108-.08Z" clip-rule="evenodd"/></g><defs><clipPath id="q"><path fill="#fff" d="M0 0h60v60H0z"/></clipPath></defs></svg>`, TOKEN_PLACEHOLDER: b4`<svg width="60" height="60" viewBox="0 0 60 60" fill="none"><rect id="token-placeholder-fill" width="58" height="58" x="1" y="1" fill="#fff" rx="29"/><path fill="#3B4040" stroke="#fff" stroke-width="2" d="M32 10a2 2 0 0 1 2-2h2a2 2 0 0 1 2 2v5.566c0 .357.192.685.495.875a16.001 16.001 0 0 1 4.256 3.894c.667.88.33 2.113-.627 2.665l-2.494 1.44c-.956.552-2.166.204-2.913-.609a9.12 9.12 0 1 0 .064 12.267c.739-.82 1.945-1.181 2.907-.64l2.509 1.415c.962.542 1.312 1.77.654 2.658a16 16 0 0 1-4.356 4.028c-.303.19-.495.518-.495.875V50a2 2 0 0 1-2 2h-2a2 2 0 0 1-2-2v-2.992c0-.602-.528-1.065-1.13-1.032-.579.032-1.16.032-1.74 0-.602-.032-1.13.43-1.13 1.032V50a2 2 0 0 1-2 2h-2a2 2 0 0 1-2-2v-5.566c0-.357-.192-.685-.495-.875a16 16 0 0 1 0-27.118c.303-.19.495-.517.495-.875V10a2 2 0 0 1 2-2h2a2 2 0 0 1 2 2v2.992c0 .601.528 1.064 1.13 1.032.58-.032 1.161-.032 1.74 0 .602.033 1.13-.43 1.13-1.032V10Z"/><rect id="token-placeholder-dash" width="58" height="58" x="1" y="1" stroke="#000" stroke-dasharray="6 6" stroke-width="2" rx="29"/></svg>`, ACCOUNT_COPY: b4`<svg width="14" height="14" fill="none" viewBox="0 0 14 14"><path fill="#fff" fill-rule="evenodd" d="M4.003 4.005c.012-1.225.074-1.936.391-2.491a3 3 0 0 1 1.12-1.12C6.204 0 7.136 0 9 0s2.795 0 3.486.394a3 3 0 0 1 1.12 1.12C14 2.204 14 3.136 14 5s0 2.795-.394 3.486a3 3 0 0 1-1.12 1.12c-.555.317-1.266.379-2.491.391l.002.003c-.012 1.222-.075 1.932-.391 2.486a3 3 0 0 1-1.12 1.12C7.796 14 6.864 14 5 14s-2.795 0-3.486-.394a3 3 0 0 1-1.12-1.12C0 11.796 0 10.864 0 9s0-2.795.394-3.486a3 3 0 0 1 1.12-1.12c.554-.316 1.264-.379 2.486-.391l.003.002ZM9 8.5c-.959 0-1.58-.001-2.05-.043-.45-.04-.613-.109-.693-.154a1.5 1.5 0 0 1-.56-.56c-.045-.08-.113-.243-.154-.693C5.501 6.58 5.5 5.959 5.5 5c0-.959.001-1.58.043-2.05.04-.45.109-.613.154-.693a1.5 1.5 0 0 1 .56-.56c.08-.045.243-.113.693-.154C7.42 1.501 8.041 1.5 9 1.5c.959 0 1.58.001 2.05.043.45.04.613.109.693.154a1.5 1.5 0 0 1 .56.56c.045.08.113.243.154.693.042.47.043 1.091.043 2.05 0 .959-.001 1.58-.043 2.05-.04.45-.109.613-.154.693a1.5 1.5 0 0 1-.56.56c-.08.045-.242.113-.693.154-.47.042-1.091.043-2.05.043ZM4 5.503a13.77 13.77 0 0 0-1.05.04c-.45.04-.613.109-.693.154a1.5 1.5 0 0 0-.56.56c-.045.08-.113.243-.154.693C1.501 7.42 1.5 8.041 1.5 9c0 .959.001 1.58.043 2.05.04.45.109.613.154.693a1.5 1.5 0 0 0 .56.56c.08.045.243.113.693.154.47.042 1.091.043 2.05.043.959 0 1.58-.001 2.05-.043.45-.04.613-.109.693-.154a1.5 1.5 0 0 0 .56-.56c.045-.08.113-.242.154-.693.025-.283.035-.619.04-1.05-1.534-.003-2.358-.037-2.983-.394a3 3 0 0 1-1.12-1.12c-.357-.625-.39-1.449-.394-2.983Z" clip-rule="evenodd"/></svg>`, ACCOUNT_DISCONNECT: b4`<svg width="16" height="14" fill="none" viewBox="0 0 16 14"><path fill="#fff" d="M9.677 1.5h-2.61c-1.261 0-2.107.001-2.757.06-.629.056-.926.157-1.122.268a2.5 2.5 0 0 0-.933.933c-.112.196-.212.493-.269 1.122-.058.65-.06 1.496-.06 2.757v.72c0 1.26.002 2.107.06 2.756.057.63.157.927.27 1.123a2.5 2.5 0 0 0 .932.933c.196.111.493.212 1.122.268.65.059 1.496.06 2.757.06h2.61a.75.75 0 1 1 0 1.5h-2.61c-2.467 0-3.7 0-4.622-.525a4 4 0 0 1-1.493-1.493C.427 11.06.427 9.827.427 7.36v-.72c0-2.467 0-3.7.525-4.622A4 4 0 0 1 2.445.525C3.366 0 4.6 0 7.067 0h2.61a.75.75 0 1 1 0 1.5Z"/><path fill="#fff" d="M10.896 11.03a.75.75 0 0 1 0-1.06l1.793-1.793a.25.25 0 0 0-.176-.427H8.177a.75.75 0 0 1 0-1.5h4.336a.25.25 0 0 0 .176-.427L10.896 4.03a.75.75 0 0 1 1.061-1.06l3.323 3.323a1 1 0 0 1 0 1.414l-3.323 3.323a.75.75 0 0 1-1.06 0Z"/></svg>`, GLOBE_ICON: b4`<svg width="16" height="16" fill="none" viewBox="0 0 16 16"><path fill="#fff" fill-rule="evenodd" d="M15.5 8a7.5 7.5 0 1 1-15 0 7.5 7.5 0 0 1 15 0Zm-2.113.75c.301 0 .535.264.47.558a6.01 6.01 0 0 1-2.867 3.896c-.203.116-.42-.103-.334-.32.409-1.018.691-2.274.797-3.657a.512.512 0 0 1 .507-.477h1.427Zm.47-2.058c.065.294-.169.558-.47.558H11.96a.512.512 0 0 1-.507-.477c-.106-1.383-.389-2.638-.797-3.656-.087-.217.13-.437.333-.32a6.01 6.01 0 0 1 2.868 3.895Zm-4.402.558c.286 0 .515-.24.49-.525-.121-1.361-.429-2.534-.83-3.393-.279-.6-.549-.93-.753-1.112a.535.535 0 0 0-.724 0c-.204.182-.474.513-.754 1.112-.4.859-.708 2.032-.828 3.393a.486.486 0 0 0 .49.525h2.909Zm-5.415 0c.267 0 .486-.21.507-.477.106-1.383.389-2.638.797-3.656.087-.217-.13-.437-.333-.32a6.01 6.01 0 0 0-2.868 3.895c-.065.294.169.558.47.558H4.04ZM2.143 9.308c-.065-.294.169-.558.47-.558H4.04c.267 0 .486.21.507.477.106 1.383.389 2.639.797 3.657.087.217-.13.436-.333.32a6.01 6.01 0 0 1-2.868-3.896Zm3.913-.033a.486.486 0 0 1 .49-.525h2.909c.286 0 .515.24.49.525-.121 1.361-.428 2.535-.83 3.394-.279.6-.549.93-.753 1.112a.535.535 0 0 1-.724 0c-.204-.182-.474-.513-.754-1.112-.4-.859-.708-2.033-.828-3.394Z" clip-rule="evenodd"/></svg>` };
      wa = i2`.w3m-toolbar-placeholder{top:0;bottom:0;left:0;right:0;width:100%;position:absolute;display:block;pointer-events:none;height:100px;border-radius:calc(var(--w3m-background-border-radius) * .9);background-color:var(--w3m-background-color);background-image:var(--w3m-background-image-url);background-position:center;background-size:cover}.w3m-toolbar{height:38px;display:flex;position:relative;margin:5px 15px 5px 5px;justify-content:space-between;align-items:center}.w3m-toolbar img,.w3m-toolbar svg{height:28px;object-position:left center;object-fit:contain}#w3m-wc-logo path{fill:var(--w3m-accent-fill-color)}button{width:28px;height:28px;border-radius:var(--w3m-icon-button-border-radius);border:0;display:flex;justify-content:center;align-items:center;cursor:pointer;background-color:var(--w3m-color-bg-1);box-shadow:0 0 0 1px var(--w3m-color-overlay)}button:active{background-color:var(--w3m-color-bg-2)}button svg{display:block;object-position:center}button path{fill:var(--w3m-color-fg-1)}.w3m-toolbar div{display:flex}.w3m-toolbar div button:first-child{margin-right:16px}.w3m-help-active button:first-child{background-color:var(--w3m-color-fg-1)}.w3m-help-active button:first-child path{fill:var(--w3m-color-bg-1)}@media(hover:hover){button:hover{background-color:var(--w3m-color-bg-2)}}`;
      pa = Object.defineProperty;
      ga = Object.getOwnPropertyDescriptor;
      Ee3 = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? ga(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && pa(a6, o9, e9), e9;
      };
      Tt4 = class extends s5 {
        constructor() {
          super(), this.isHelp = false, this.unsubscribeRouter = void 0, this.unsubscribeRouter = W7.subscribe((t6) => {
            this.isHelp = t6.view === "Help";
          });
        }
        disconnectedCallback() {
          var t6;
          (t6 = this.unsubscribeRouter) == null || t6.call(this);
        }
        onHelp() {
          W7.push("Help");
        }
        logoTemplate() {
          var t6;
          const a6 = (t6 = ue5.state.themeVariables) == null ? void 0 : t6["--w3m-logo-image-url"];
          return a6 ? x2`<img crossorigin="anonymous" src="${a6}" data-testid="component-modal-backcard">` : w6.WALLET_CONNECT_LOGO;
        }
        render() {
          const t6 = { "w3m-help-active": this.isHelp };
          return x2`<div class="w3m-toolbar-placeholder"></div><div class="w3m-toolbar">${this.logoTemplate()}<div class="${o7(t6)}"><button @click="${this.onHelp}">${w6.HELP_ICON}</button> <button @click="${pe3.close}">${w6.CROSS_ICON}</button></div></div>`;
        }
      };
      Tt4.styles = [p7.globalCss, wa], Ee3([t4()], Tt4.prototype, "isHelp", 2), Tt4 = Ee3([e5("w3m-modal-backcard")], Tt4);
      ua = i2`main{padding:20px;padding-top:0;width:100%}`;
      va = Object.defineProperty;
      ba2 = Object.getOwnPropertyDescriptor;
      fa = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? ba2(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && va(a6, o9, e9), e9;
      };
      Jt4 = class extends s5 {
        render() {
          return x2`<main data-testid="component-modal-content"><slot></slot></main>`;
        }
      };
      Jt4.styles = [p7.globalCss, ua], Jt4 = fa([e5("w3m-modal-content")], Jt4);
      xa2 = i2`footer{padding:10px;display:flex;flex-direction:column;align-items:inherit;justify-content:inherit;border-top:1px solid var(--w3m-color-bg-2)}`;
      ya2 = Object.defineProperty;
      Ca = Object.getOwnPropertyDescriptor;
      $a = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? Ca(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && ya2(a6, o9, e9), e9;
      };
      te7 = class extends s5 {
        render() {
          return x2`<footer data-testid="component-modal-footer"><slot></slot></footer>`;
        }
      };
      te7.styles = [p7.globalCss, xa2], te7 = $a([e5("w3m-modal-footer")], te7);
      ka = i2`header{display:flex;justify-content:center;align-items:center;padding:20px;position:relative}.w3m-border{border-bottom:1px solid var(--w3m-color-bg-2);margin-bottom:20px}header button{padding:15px 20px}header button:active{opacity:.5}@media(hover:hover){header button:hover{opacity:.5}}.w3m-back-btn{position:absolute;left:0}.w3m-action-btn{position:absolute;right:0}path{fill:var(--w3m-accent-color)}`;
      Oa2 = Object.defineProperty;
      Ia2 = Object.getOwnPropertyDescriptor;
      xt4 = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? Ia2(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && Oa2(a6, o9, e9), e9;
      };
      Q8 = class extends s5 {
        constructor() {
          super(...arguments), this.title = "", this.onAction = void 0, this.actionIcon = void 0, this.border = false;
        }
        backBtnTemplate() {
          return x2`<button class="w3m-back-btn" data-testid="component-header-back-button" @click="${W7.goBack}">${w6.BACK_ICON}</button>`;
        }
        actionBtnTemplate() {
          return x2`<button class="w3m-action-btn" data-testid="component-header-action-button" @click="${this.onAction}">${this.actionIcon}</button>`;
        }
        render() {
          const t6 = { "w3m-border": this.border }, a6 = W7.state.history.length > 1, o9 = this.title ? x2`<w3m-text variant="big-bold">${this.title}</w3m-text>` : x2`<slot></slot>`;
          return x2`<header class="${o7(t6)}">${a6 ? this.backBtnTemplate() : null} ${o9} ${this.onAction ? this.actionBtnTemplate() : null}</header>`;
        }
      };
      Q8.styles = [p7.globalCss, ka], xt4([n6()], Q8.prototype, "title", 2), xt4([n6()], Q8.prototype, "onAction", 2), xt4([n6()], Q8.prototype, "actionIcon", 2), xt4([n6()], Q8.prototype, "border", 2), Q8 = xt4([e5("w3m-modal-header")], Q8);
      Ea2 = { 1: "692ed6ba-e569-459a-556a-776476829e00", 42161: "600a9a04-c1b9-42ca-6785-9b4b6ff85200", 43114: "30c46e53-e989-45fb-4549-be3bd4eb3b00", 56: "93564157-2e8e-4ce7-81df-b264dbee9b00", 250: "06b26297-fe0c-4733-5d6b-ffa5498aac00", 10: "ab9c186a-c52f-464b-2906-ca59d760a400", 137: "41d04d42-da3b-4453-8506-668cc0727900", 100: "02b53f6a-e3d4-479e-1cb4-21178987d100", 9001: "f926ff41-260d-4028-635e-91913fc28e00", 324: "b310f07f-4ef7-49f3-7073-2a0a39685800", 314: "5a73b3dd-af74-424e-cae0-0de859ee9400", 4689: "34e68754-e536-40da-c153-6ef2e7188a00", 1088: "3897a66d-40b9-4833-162f-a2c90531c900", 1284: "161038da-44ae-4ec7-1208-0ea569454b00", 1285: "f1d73bb6-5450-4e18-38f7-fb6484264a00" };
      Wa = { ETH: { icon: "692ed6ba-e569-459a-556a-776476829e00" }, WETH: { icon: "692ed6ba-e569-459a-556a-776476829e00" }, AVAX: { icon: "30c46e53-e989-45fb-4549-be3bd4eb3b00" }, FTM: { icon: "06b26297-fe0c-4733-5d6b-ffa5498aac00" }, BNB: { icon: "93564157-2e8e-4ce7-81df-b264dbee9b00" }, MATIC: { icon: "41d04d42-da3b-4453-8506-668cc0727900" }, OP: { icon: "ab9c186a-c52f-464b-2906-ca59d760a400" }, xDAI: { icon: "02b53f6a-e3d4-479e-1cb4-21178987d100" }, EVMOS: { icon: "f926ff41-260d-4028-635e-91913fc28e00" }, METIS: { icon: "3897a66d-40b9-4833-162f-a2c90531c900" }, IOTX: { icon: "34e68754-e536-40da-c153-6ef2e7188a00" } };
      R5 = { externalWallets() {
        let t6 = f5.client().getConnectors();
        return t6 = t6.filter((a6) => a6.id !== "injected"), t6;
      }, manualWallets() {
        var t6, a6;
        const { mobileWallets: o9, desktopWallets: r8 } = C4.state, e9 = (t6 = R5.recentWallet()) == null ? void 0 : t6.id, i7 = i6.isMobile() ? o9 : r8, l9 = i7?.filter((d7) => e9 !== d7.id);
        return (a6 = i6.isMobile() ? l9?.map(({ id: d7, name: v6, links: x4 }) => ({ id: d7, name: v6, mobile: x4, links: x4 })) : l9?.map(({ id: d7, name: v6, links: x4 }) => ({ id: d7, name: v6, desktop: x4, links: x4 }))) != null ? a6 : [];
      }, installedInjectedWallets() {
        if (!f5.client().isInjectedProviderInstalled())
          return [];
        const { namespace: t6 } = f5.client(), { injectedWallets: a6 } = de6.state;
        let o9 = a6.filter(({ injected: r8 }) => Boolean(r8.some((e9) => f5.client().safeCheckInjectedProvider(e9.injected_id) && e9.namespace === t6)));
        return o9.length > 1 && (o9 = o9.filter(({ injected: r8 }) => {
          const e9 = r8.map(({ injected_id: i7 }) => i7);
          return Boolean(e9.every((i7) => i7 !== "isMetaMask"));
        })), o9.length ? o9 : [{ name: "Browser", id: "browser", image_id: void 0 }];
      }, injectedWallets() {
        const { explorerExcludedWalletIds: t6, explorerRecommendedWalletIds: a6 } = C4.state, o9 = i6.isMobile();
        if (t6 === "ALL" || o9)
          return [];
        const { namespace: r8 } = f5.client(), { injectedWallets: e9 } = de6.state;
        return e9.filter(({ id: i7, injected: l9 }) => {
          const d7 = i6.isArray(t6) ? t6 : [], v6 = i6.isArray(a6) ? a6 : [];
          return Boolean(l9.some((x4) => x4.namespace === r8 && !d7.includes(i7) && !v6.includes(i7)));
        });
      }, recentWallet() {
        return s6.getRecentWallet();
      }, recomendedWallets(t6 = false) {
        var a6;
        const o9 = R5.installedInjectedWallets().map(({ id: l9 }) => l9), r8 = t6 || (a6 = R5.recentWallet()) == null ? void 0 : a6.id, e9 = [...o9, r8], { recomendedWallets: i7 } = de6.state;
        return i7.filter((l9) => !e9.includes(l9.id));
      } };
      s6 = { MOBILE_BREAKPOINT: 600, W3M_RECENT_WALLET_INFO: "W3M_RECENT_WALLET_INFO", EXPLORER_WALLET_URL: "https://explorer.walletconnect.com/?type=wallet", WAGMI_WALLET: "wagmi.wallet", getShadowRootElement(t6, a6) {
        const o9 = t6.renderRoot.querySelector(a6);
        if (!o9)
          throw new Error(`${a6} not found`);
        return o9;
      }, getWalletIcon({ id: t6, image_id: a6 }) {
        const { walletImages: o9 } = C4.state;
        return o9 != null && o9[t6] ? o9[t6] : a6 ? de6.getWalletImageUrl(a6) : "";
      }, getWalletName(t6, a6 = false) {
        return a6 && t6.length > 8 ? `${t6.substring(0, 8)}..` : t6;
      }, getChainIcon(t6) {
        var a6;
        const o9 = Ea2[t6], { projectId: r8, chainImages: e9 } = C4.state;
        return (a6 = e9?.[t6]) != null ? a6 : r8 && o9 ? de6.getAssetImageUrl(o9) : "";
      }, getTokenIcon(t6) {
        var a6, o9;
        const r8 = (a6 = Wa[t6]) == null ? void 0 : a6.icon, { projectId: e9, tokenImages: i7 } = C4.state;
        return (o9 = i7?.[t6]) != null ? o9 : e9 && r8 ? de6.getAssetImageUrl(r8) : "";
      }, isMobileAnimation() {
        return window.innerWidth <= s6.MOBILE_BREAKPOINT;
      }, async preloadImage(t6) {
        const a6 = new Promise((o9, r8) => {
          const e9 = new Image();
          e9.onload = o9, e9.onerror = r8, e9.crossOrigin = "anonymous", e9.src = t6;
        });
        return Promise.race([a6, i6.wait(3e3)]);
      }, getErrorMessage(t6) {
        return t6 instanceof Error ? t6.message : "Unknown Error";
      }, debounce(t6, a6 = 500) {
        let o9;
        return (...r8) => {
          function e9() {
            t6(...r8);
          }
          o9 && clearTimeout(o9), o9 = setTimeout(e9, a6);
        };
      }, handleMobileLinking(t6) {
        const { pairingUri: a6 } = P5.state, { mobile: o9, name: r8 } = t6, e9 = o9?.native, i7 = o9?.universal;
        s6.setRecentWallet(t6);
        function l9(d7) {
          let v6 = "";
          e9 ? v6 = i6.formatUniversalUrl(e9, d7, r8) : i7 && (v6 = i6.formatNativeUrl(i7, d7, r8)), i6.openHref(v6, "_self");
        }
        l9(a6);
      }, handleAndroidLinking() {
        const { pairingUri: t6 } = P5.state;
        i6.setWalletConnectAndroidDeepLink(t6), i6.openHref(t6, "_self");
      }, async handleUriCopy() {
        try {
          const { pairingUri: t6 } = P5.state;
          await navigator.clipboard.writeText(t6), ge4.openToast("Link copied", "success");
        } catch {
          ge4.openToast("Failed to copy", "error");
        }
      }, async handleConnectorConnection(t6, a6) {
        try {
          const { selectedChain: o9 } = b6.state;
          await f5.client().connectConnector(t6, o9?.id), pe3.close();
        } catch (o9) {
          console.error(o9), a6 ? a6() : ge4.openToast(s6.getErrorMessage(o9), "error");
        }
      }, getCustomImageUrls() {
        const { chainImages: t6, walletImages: a6 } = C4.state, o9 = Object.values(t6 ?? {}), r8 = Object.values(a6 ?? {});
        return Object.values([...o9, ...r8]);
      }, truncate(t6, a6 = 8) {
        return t6.length <= a6 ? t6 : `${t6.substring(0, 4)}...${t6.substring(t6.length - 4)}`;
      }, generateAvatarColors(t6) {
        var a6;
        const o9 = (a6 = t6.match(/.{1,7}/g)) == null ? void 0 : a6.splice(0, 5), r8 = [];
        o9?.forEach((i7) => {
          let l9 = 0;
          for (let v6 = 0; v6 < i7.length; v6 += 1)
            l9 = i7.charCodeAt(v6) + ((l9 << 5) - l9), l9 = l9 & l9;
          const d7 = [0, 0, 0];
          for (let v6 = 0; v6 < 3; v6 += 1) {
            const x4 = l9 >> v6 * 8 & 255;
            d7[v6] = x4;
          }
          r8.push(`rgb(${d7[0]}, ${d7[1]}, ${d7[2]})`);
        });
        const e9 = document.querySelector(":root");
        if (e9) {
          const i7 = { "--w3m-color-av-1": r8[0], "--w3m-color-av-2": r8[1], "--w3m-color-av-3": r8[2], "--w3m-color-av-4": r8[3], "--w3m-color-av-5": r8[4] };
          Object.entries(i7).forEach(([l9, d7]) => e9.style.setProperty(l9, d7));
        }
      }, setRecentWallet(t6) {
        try {
          localStorage.setItem(s6.W3M_RECENT_WALLET_INFO, JSON.stringify(t6));
        } catch {
          console.info("Unable to set recent wallet");
        }
      }, getRecentWallet() {
        try {
          const t6 = localStorage.getItem(s6.W3M_RECENT_WALLET_INFO);
          return t6 ? JSON.parse(t6) : void 0;
        } catch {
          console.info("Unable to get recent wallet");
        }
      }, caseSafeIncludes(t6, a6) {
        return t6.toUpperCase().includes(a6.toUpperCase());
      }, openWalletExplorerUrl() {
        i6.openHref(s6.EXPLORER_WALLET_URL, "_blank");
      }, getCachedRouterWalletPlatforms() {
        const { id: t6, desktop: a6, mobile: o9, injected: r8 } = i6.getWalletRouterData(), e9 = R5.installedInjectedWallets(), i7 = Boolean(r8?.length), l9 = e9.some((H5) => H5.id === t6), d7 = Boolean(a6?.native), v6 = Boolean(a6?.universal), x4 = Boolean(o9?.native) || Boolean(o9?.universal);
        return { isInjectedInstalled: l9, isInjected: i7, isDesktop: d7, isMobile: x4, isWeb: v6 };
      }, goToConnectingView(t6) {
        W7.setData({ Wallet: t6 });
        const a6 = i6.isMobile(), { isDesktop: o9, isWeb: r8, isMobile: e9, isInjectedInstalled: i7 } = s6.getCachedRouterWalletPlatforms();
        a6 ? i7 ? W7.push("InjectedConnecting") : e9 ? W7.push("MobileConnecting") : r8 ? W7.push("WebConnecting") : W7.push("InstallWallet") : i7 ? W7.push("InjectedConnecting") : o9 ? W7.push("DesktopConnecting") : r8 ? W7.push("WebConnecting") : e9 ? W7.push("MobileQrcodeConnecting") : W7.push("InstallWallet");
      }, getWagmiWalletType() {
        return localStorage.getItem(s6.WAGMI_WALLET);
      } };
      Aa = i2`.w3m-router{overflow:hidden;will-change:transform}.w3m-content{display:flex;flex-direction:column}`;
      ja = Object.defineProperty;
      Ma = Object.getOwnPropertyDescriptor;
      ee5 = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? Ma(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && ja(a6, o9, e9), e9;
      };
      yt4 = class extends s5 {
        constructor() {
          super(), this.view = W7.state.view, this.prevView = W7.state.view, this.unsubscribe = void 0, this.oldHeight = "0px", this.resizeObserver = void 0, this.unsubscribe = W7.subscribe((t6) => {
            this.view !== t6.view && this.onChangeRoute();
          });
        }
        firstUpdated() {
          this.resizeObserver = new ResizeObserver(([t6]) => {
            const a6 = `${t6.contentRect.height}px`;
            this.oldHeight !== "0px" && animate2(this.routerEl, { height: [this.oldHeight, a6] }, { duration: 0.2 }), this.oldHeight = a6;
          }), this.resizeObserver.observe(this.contentEl);
        }
        disconnectedCallback() {
          var t6, a6;
          (t6 = this.unsubscribe) == null || t6.call(this), (a6 = this.resizeObserver) == null || a6.disconnect();
        }
        get routerEl() {
          return s6.getShadowRootElement(this, ".w3m-router");
        }
        get contentEl() {
          return s6.getShadowRootElement(this, ".w3m-content");
        }
        viewTemplate() {
          switch (this.view) {
            case "ConnectWallet":
              return x2`<w3m-connect-wallet-view></w3m-connect-wallet-view>`;
            case "SelectNetwork":
              return x2`<w3m-select-network-view></w3m-select-network-view>`;
            case "InjectedConnecting":
              return x2`<w3m-injected-connecting-view></w3m-injected-connecting-view>`;
            case "DesktopConnecting":
              return x2`<w3m-desktop-connecting-view></w3m-desktop-connecting-view>`;
            case "MobileConnecting":
              return x2`<w3m-mobile-connecting-view></w3m-mobile-connecting-view>`;
            case "WebConnecting":
              return x2`<w3m-web-connecting-view></w3m-web-connecting-view>`;
            case "MobileQrcodeConnecting":
              return x2`<w3m-mobile-qr-connecting-view></w3m-mobile-qr-connecting-view>`;
            case "GetWallet":
              return x2`<w3m-get-wallet-view></w3m-get-wallet-view>`;
            case "WalletExplorer":
              return x2`<w3m-wallet-explorer-view></w3m-wallet-explorer-view>`;
            case "Qrcode":
              return x2`<w3m-qrcode-view></w3m-qrcode-view>`;
            case "Help":
              return x2`<w3m-help-view></w3m-help-view>`;
            case "Account":
              return x2`<w3m-account-view></w3m-account-view>`;
            case "SwitchNetwork":
              return x2`<w3m-switch-network-view></w3m-switch-network-view>`;
            case "InstallWallet":
              return x2`<w3m-install-wallet-view></w3m-install-wallet-view>`;
            default:
              return x2`<div>Not Found</div>`;
          }
        }
        async onChangeRoute() {
          await animate2(this.routerEl, { opacity: [1, 0], scale: [1, 1.02] }, { duration: 0.15, delay: 0.1 }).finished, this.view = W7.state.view, animate2(this.routerEl, { opacity: [0, 1], scale: [0.99, 1] }, { duration: 0.37, delay: 0.05 });
        }
        render() {
          return x2`<div class="w3m-router"><div class="w3m-content">${this.viewTemplate()}</div></div>`;
        }
      };
      yt4.styles = [p7.globalCss, Aa], ee5([t4()], yt4.prototype, "view", 2), ee5([t4()], yt4.prototype, "prevView", 2), yt4 = ee5([e5("w3m-modal-router")], yt4);
      Pa = i2`div{height:36px;width:max-content;display:flex;justify-content:center;align-items:center;padding:9px 15px 11px;position:absolute;top:12px;box-shadow:0 6px 14px -6px rgba(10,16,31,.3),0 10px 32px -4px rgba(10,16,31,.15);z-index:2;left:50%;transform:translateX(-50%);pointer-events:none;backdrop-filter:blur(20px) saturate(1.8);-webkit-backdrop-filter:blur(20px) saturate(1.8);border-radius:var(--w3m-notification-border-radius);border:1px solid var(--w3m-color-overlay);background-color:var(--w3m-color-overlay)}svg{margin-right:5px}@-moz-document url-prefix(){div{background-color:var(--w3m-color-bg-3)}}.w3m-success path{fill:var(--w3m-accent-color)}.w3m-error path{fill:var(--w3m-error-color)}`;
      La = Object.defineProperty;
      Ta2 = Object.getOwnPropertyDescriptor;
      We4 = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? Ta2(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && La(a6, o9, e9), e9;
      };
      _t3 = class extends s5 {
        constructor() {
          super(), this.open = false, this.unsubscribe = void 0, this.timeout = void 0, this.unsubscribe = ge4.subscribe((t6) => {
            t6.open ? (this.open = true, this.timeout = setTimeout(() => ge4.closeToast(), 2200)) : (this.open = false, clearTimeout(this.timeout));
          });
        }
        disconnectedCallback() {
          var t6;
          (t6 = this.unsubscribe) == null || t6.call(this), clearTimeout(this.timeout), ge4.closeToast();
        }
        render() {
          const { message: t6, variant: a6 } = ge4.state, o9 = { "w3m-success": a6 === "success", "w3m-error": a6 === "error" };
          return this.open ? x2`<div data-testid="component-modal-toast" class="${o7(o9)}">${a6 === "success" ? w6.CHECKMARK_ICON : null} ${a6 === "error" ? w6.CROSS_ICON : null}<w3m-text variant="small-regular">${t6}</w3m-text></div>` : null;
        }
      };
      _t3.styles = [p7.globalCss, Pa], We4([t4()], _t3.prototype, "open", 2), _t3 = We4([e5("w3m-modal-toast")], _t3);
      _a = i2`button{padding:5px;border-radius:var(--w3m-button-hover-highlight-border-radius);display:flex;flex-direction:column;align-items:center;justify-content:center;width:80px;height:90px;position:relative}w3m-network-image{width:54px;height:59px}w3m-text{width:100%;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-align:center;margin-top:5px}button:active{background-color:var(--w3m-color-overlay)}.w3m-unsupported{opacity:.3}@media(hover:hover){button:hover{background-color:var(--w3m-color-overlay)}}`;
      Na = Object.defineProperty;
      Ra2 = Object.getOwnPropertyDescriptor;
      Ct4 = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? Ra2(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && Na(a6, o9, e9), e9;
      };
      X6 = class extends s5 {
        constructor() {
          super(...arguments), this.onClick = () => null, this.name = "", this.chainId = "", this.unsupported = false;
        }
        render() {
          const t6 = { "w3m-unsupported": this.unsupported };
          return x2`<button data-testid="component-network-button" @click="${this.onClick}" class="${o7(t6)}"><w3m-network-image chainId="${this.chainId}"></w3m-network-image><w3m-text variant="xsmall-regular">${this.name}</w3m-text></button>`;
        }
      };
      X6.styles = [p7.globalCss, _a], Ct4([n6()], X6.prototype, "onClick", 2), Ct4([n6()], X6.prototype, "name", 2), Ct4([n6()], X6.prototype, "chainId", 2), Ct4([n6()], X6.prototype, "unsupported", 2), X6 = Ct4([e5("w3m-network-button")], X6);
      Da = i2`@keyframes loading{to{stroke-dashoffset:0}}:host{width:inherit;height:inherit;position:relative}path{stroke:var(--w3m-color-overlay)}svg{width:100%;height:100%;margin:0}#network-placeholder-fill{fill:var(--w3m-color-bg-3)}#network-placeholder-dash{stroke:var(--w3m-color-overlay)}image{clip-path:path('M17.033 4.964c3.852-2.262 5.778-3.393 7.84-3.77a11.807 11.807 0 0 1 4.254 0c2.062.377 3.988 1.508 7.84 3.77l6.066 3.562c3.852 2.263 5.777 3.394 7.13 5.022a12.268 12.268 0 0 1 2.127 3.747c.71 2.006.71 4.268.71 8.793v7.124c0 4.525 0 6.787-.71 8.793a12.268 12.268 0 0 1-2.126 3.747c-1.354 1.628-3.28 2.76-7.131 5.022l-6.066 3.562c-3.852 2.262-5.778 3.393-7.84 3.771a11.814 11.814 0 0 1-4.254 0c-2.062-.378-3.988-1.509-7.84-3.77l-6.066-3.563c-3.852-2.263-5.778-3.394-7.13-5.022a12.268 12.268 0 0 1-2.127-3.747C1 40 1 37.737 1 33.212v-7.124c0-4.525 0-6.787.71-8.793a12.268 12.268 0 0 1 2.127-3.747c1.352-1.628 3.278-2.76 7.13-5.022l6.066-3.562Z')}`;
      Za = Object.defineProperty;
      Ha = Object.getOwnPropertyDescriptor;
      Ae3 = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? Ha(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && Za(a6, o9, e9), e9;
      };
      Nt4 = class extends s5 {
        constructor() {
          super(...arguments), this.chainId = "";
        }
        render() {
          const t6 = s6.getChainIcon(this.chainId);
          return t6 ? x2`<svg width="54" height="59" viewBox="0 0 54 59" fill="none" data-testid="component-network-logo-svg"><image href="${t6}"/><image href="${t6}" width="54" height="59"/><path d="M17.22 5.295c3.877-2.277 5.737-3.363 7.72-3.726a11.44 11.44 0 0 1 4.12 0c1.983.363 3.844 1.45 7.72 3.726l6.065 3.562c3.876 2.276 5.731 3.372 7.032 4.938a11.896 11.896 0 0 1 2.06 3.63c.683 1.928.688 4.11.688 8.663v7.124c0 4.553-.005 6.735-.688 8.664a11.896 11.896 0 0 1-2.06 3.63c-1.3 1.565-3.156 2.66-7.032 4.937l-6.065 3.563c-3.877 2.276-5.737 3.362-7.72 3.725a11.46 11.46 0 0 1-4.12 0c-1.983-.363-3.844-1.449-7.72-3.726l-6.065-3.562c-3.876-2.276-5.731-3.372-7.032-4.938a11.885 11.885 0 0 1-2.06-3.63c-.682-1.928-.688-4.11-.688-8.663v-7.124c0-4.553.006-6.735.688-8.664a11.885 11.885 0 0 1 2.06-3.63c1.3-1.565 3.156-2.66 7.032-4.937l6.065-3.562Z"/></svg>` : x2`${w6.NETWORK_PLACEHOLDER}`;
        }
      };
      Nt4.styles = [p7.globalCss, Da], Ae3([n6()], Nt4.prototype, "chainId", 2), Nt4 = Ae3([e5("w3m-network-image")], Nt4);
      Ba = 0.1;
      je4 = 2.5;
      U7 = 7;
      Ua = { generate(t6, a6, o9) {
        const r8 = "#141414", e9 = "#ffffff", i7 = [], l9 = Sa2(t6, "Q"), d7 = a6 / l9.length, v6 = [{ x: 0, y: 0 }, { x: 1, y: 0 }, { x: 0, y: 1 }];
        v6.forEach(({ x: E8, y: C6 }) => {
          const T6 = (l9.length - U7) * d7 * E8, k6 = (l9.length - U7) * d7 * C6, N17 = 0.45;
          for (let B10 = 0; B10 < v6.length; B10 += 1) {
            const nt3 = d7 * (U7 - B10 * 2);
            i7.push(b4`<rect fill="${B10 % 2 === 0 ? r8 : e9}" height="${nt3}" rx="${nt3 * N17}" ry="${nt3 * N17}" width="${nt3}" x="${T6 + d7 * B10}" y="${k6 + d7 * B10}">`);
          }
        });
        const x4 = Math.floor((o9 + 25) / d7), H5 = l9.length / 2 - x4 / 2, Z7 = l9.length / 2 + x4 / 2 - 1, _8 = [];
        l9.forEach((E8, C6) => {
          E8.forEach((T6, k6) => {
            if (l9[C6][k6] && !(C6 < U7 && k6 < U7 || C6 > l9.length - (U7 + 1) && k6 < U7 || C6 < U7 && k6 > l9.length - (U7 + 1)) && !(C6 > H5 && C6 < Z7 && k6 > H5 && k6 < Z7)) {
              const N17 = C6 * d7 + d7 / 2, B10 = k6 * d7 + d7 / 2;
              _8.push([N17, B10]);
            }
          });
        });
        const vt4 = {};
        return _8.forEach(([E8, C6]) => {
          vt4[E8] ? vt4[E8].push(C6) : vt4[E8] = [C6];
        }), Object.entries(vt4).map(([E8, C6]) => {
          const T6 = C6.filter((k6) => C6.every((N17) => !ae5(k6, N17, d7)));
          return [Number(E8), T6];
        }).forEach(([E8, C6]) => {
          C6.forEach((T6) => {
            i7.push(b4`<circle cx="${E8}" cy="${T6}" fill="${r8}" r="${d7 / je4}">`);
          });
        }), Object.entries(vt4).filter(([E8, C6]) => C6.length > 1).map(([E8, C6]) => {
          const T6 = C6.filter((k6) => C6.some((N17) => ae5(k6, N17, d7)));
          return [Number(E8), T6];
        }).map(([E8, C6]) => {
          C6.sort((k6, N17) => k6 < N17 ? -1 : 1);
          const T6 = [];
          for (const k6 of C6) {
            const N17 = T6.find((B10) => B10.some((nt3) => ae5(k6, nt3, d7)));
            N17 ? N17.push(k6) : T6.push([k6]);
          }
          return [E8, T6.map((k6) => [k6[0], k6[k6.length - 1]])];
        }).forEach(([E8, C6]) => {
          C6.forEach(([T6, k6]) => {
            i7.push(b4`<line x1="${E8}" x2="${E8}" y1="${T6}" y2="${k6}" stroke="${r8}" stroke-width="${d7 / (je4 / 2)}" stroke-linecap="round">`);
          });
        }), i7;
      } };
      Va = i2`@keyframes fadeIn{0%{opacity:0}100%{opacity:1}}div{position:relative;user-select:none;display:block;overflow:hidden;aspect-ratio:1/1;animation:fadeIn ease .2s}.w3m-dark{background-color:#fff;border-radius:var(--w3m-container-border-radius);padding:18px;box-shadow:0 2px 5px #000}svg:first-child,w3m-wallet-image{position:absolute;top:50%;left:50%;transform:translateY(-50%) translateX(-50%)}w3m-wallet-image{transform:translateY(-50%) translateX(-50%)}w3m-wallet-image{width:25%;height:25%;border-radius:var(--w3m-wallet-icon-border-radius)}svg:first-child{transform:translateY(-50%) translateX(-50%) scale(.9)}svg:first-child path:first-child{fill:var(--w3m-accent-color)}svg:first-child path:last-child{stroke:var(--w3m-color-overlay)}`;
      za = Object.defineProperty;
      Ga = Object.getOwnPropertyDescriptor;
      ct3 = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? Ga(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && za(a6, o9, e9), e9;
      };
      F7 = class extends s5 {
        constructor() {
          super(...arguments), this.uri = "", this.size = 0, this.imageId = void 0, this.walletId = void 0, this.imageUrl = void 0;
        }
        svgTemplate() {
          const t6 = ue5.state.themeMode === "light" ? this.size : this.size - 36;
          return b4`<svg height="${t6}" width="${t6}" data-testid="component-qrcode-svg">${Ua.generate(this.uri, t6, t6 / 4)}</svg>`;
        }
        render() {
          const t6 = { "w3m-dark": ue5.state.themeMode === "dark" };
          return x2`<div style="${`width: ${this.size}px`}" class="${o7(t6)}">${this.walletId || this.imageUrl ? x2`<w3m-wallet-image walletId="${this.walletId}" imageId="${this.imageId}" imageUrl="${this.imageUrl}"></w3m-wallet-image>` : w6.WALLET_CONNECT_ICON_COLORED} ${this.svgTemplate()}</div>`;
        }
      };
      F7.styles = [p7.globalCss, Va], ct3([n6()], F7.prototype, "uri", 2), ct3([n6({ type: Number })], F7.prototype, "size", 2), ct3([n6()], F7.prototype, "imageId", 2), ct3([n6()], F7.prototype, "walletId", 2), ct3([n6()], F7.prototype, "imageUrl", 2), F7 = ct3([e5("w3m-qrcode")], F7);
      Fa = i2`:host{position:relative;height:28px;width:80%}input{width:100%;height:100%;line-height:28px!important;border-radius:var(--w3m-input-border-radius);font-style:normal;font-family:-apple-system,system-ui,BlinkMacSystemFont,'Segoe UI',Roboto,Ubuntu,'Helvetica Neue',sans-serif;font-feature-settings:'case' on;font-weight:500;font-size:16px;letter-spacing:-.03em;padding:0 10px 0 34px;transition:.2s all ease;color:var(--w3m-color-fg-1);background-color:var(--w3m-color-bg-3);box-shadow:inset 0 0 0 1px var(--w3m-color-overlay);caret-color:var(--w3m-accent-color)}input::placeholder{color:var(--w3m-color-fg-2)}svg{left:10px;top:4px;pointer-events:none;position:absolute;width:20px;height:20px}input:focus-within{box-shadow:inset 0 0 0 1px var(--w3m-accent-color)}path{fill:var(--w3m-color-fg-2)}`;
      qa = Object.defineProperty;
      Ka = Object.getOwnPropertyDescriptor;
      Me4 = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? Ka(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && qa(a6, o9, e9), e9;
      };
      Rt4 = class extends s5 {
        constructor() {
          super(...arguments), this.onChange = () => null;
        }
        render() {
          return x2`<input type="text" @input="${this.onChange}" placeholder="Search wallets" data-testid="component-search-input"> ${w6.SEARCH_ICON}`;
        }
      };
      Rt4.styles = [p7.globalCss, Fa], Me4([n6()], Rt4.prototype, "onChange", 2), Rt4 = Me4([e5("w3m-search-input")], Rt4);
      Ya = i2`@keyframes rotate{100%{transform:rotate(360deg)}}@keyframes dash{0%{stroke-dasharray:1,150;stroke-dashoffset:0}50%{stroke-dasharray:90,150;stroke-dashoffset:-35}100%{stroke-dasharray:90,150;stroke-dashoffset:-124}}:host{width:100%;height:100%;display:flex;justify-content:center;align-items:center}svg{animation:rotate 2s linear infinite;display:flex;justify-content:center;align-items:center}svg circle{stroke-linecap:round;animation:dash 1.5s ease infinite}.accent{stroke:var(--w3m-accent-color)}.fill{stroke:var(--w3m-accent-fill-color)}`;
      Qa = Object.defineProperty;
      Xa = Object.getOwnPropertyDescriptor;
      oe7 = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? Xa(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && Qa(a6, o9, e9), e9;
      };
      $t3 = class extends s5 {
        constructor() {
          super(...arguments), this.color = "accent", this.size = 24;
        }
        render() {
          return x2`<svg viewBox="0 0 50 50" width="${this.size}" height="${this.size}" data-testid="component-spinner-svg"><circle class="${this.color}" cx="25" cy="25" r="20" fill="none" stroke-width="4" stroke="#fff"/></svg>`;
        }
      };
      $t3.styles = [p7.globalCss, Ya], oe7([n6()], $t3.prototype, "color", 2), oe7([n6({ type: Number })], $t3.prototype, "size", 2), $t3 = oe7([e5("w3m-spinner")], $t3);
      Ja = i2`span{font-style:normal;font-family:var(--w3m-font-family);font-feature-settings:var(--w3m-font-feature-settings)}.w3m-xsmall-bold{font-family:var(--w3m-text-xsmall-bold-font-family);font-weight:var(--w3m-text-xsmall-bold-weight);font-size:var(--w3m-text-xsmall-bold-size);line-height:var(--w3m-text-xsmall-bold-line-height);letter-spacing:var(--w3m-text-xsmall-bold-letter-spacing);text-transform:var(--w3m-text-xsmall-bold-text-transform)}.w3m-xsmall-regular{font-family:var(--w3m-text-xsmall-regular-font-family);font-weight:var(--w3m-text-xsmall-regular-weight);font-size:var(--w3m-text-xsmall-regular-size);line-height:var(--w3m-text-xsmall-regular-line-height);letter-spacing:var(--w3m-text-xsmall-regular-letter-spacing);text-transform:var(--w3m-text-xsmall-regular-text-transform)}.w3m-small-thin{font-family:var(--w3m-text-small-thin-font-family);font-weight:var(--w3m-text-small-thin-weight);font-size:var(--w3m-text-small-thin-size);line-height:var(--w3m-text-small-thin-line-height);letter-spacing:var(--w3m-text-small-thin-letter-spacing);text-transform:var(--w3m-text-small-thin-text-transform)}.w3m-small-regular{font-family:var(--w3m-text-small-regular-font-family);font-weight:var(--w3m-text-small-regular-weight);font-size:var(--w3m-text-small-regular-size);line-height:var(--w3m-text-small-regular-line-height);letter-spacing:var(--w3m-text-small-regular-letter-spacing);text-transform:var(--w3m-text-small-regular-text-transform)}.w3m-medium-regular{font-family:var(--w3m-text-medium-regular-font-family);font-weight:var(--w3m-text-medium-regular-weight);font-size:var(--w3m-text-medium-regular-size);line-height:var(--w3m-text-medium-regular-line-height);letter-spacing:var(--w3m-text-medium-regular-letter-spacing);text-transform:var(--w3m-text-medium-regular-text-transform)}.w3m-big-bold{font-family:var(--w3m-text-big-bold-font-family);font-weight:var(--w3m-text-big-bold-weight);font-size:var(--w3m-text-big-bold-size);line-height:var(--w3m-text-big-bold-line-height);letter-spacing:var(--w3m-text-big-bold-letter-spacing);text-transform:var(--w3m-text-big-bold-text-transform)}:host(*){color:var(--w3m-color-fg-1)}.w3m-color-primary{color:var(--w3m-color-fg-1)}.w3m-color-secondary{color:var(--w3m-color-fg-2)}.w3m-color-tertiary{color:var(--w3m-color-fg-3)}.w3m-color-inverse{color:var(--w3m-accent-fill-color)}.w3m-color-accnt{color:var(--w3m-accent-color)}.w3m-color-error{color:var(--w3m-error-color)}`;
      to2 = Object.defineProperty;
      eo2 = Object.getOwnPropertyDescriptor;
      re5 = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? eo2(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && to2(a6, o9, e9), e9;
      };
      kt4 = class extends s5 {
        constructor() {
          super(...arguments), this.variant = "medium-regular", this.color = "primary";
        }
        render() {
          const t6 = { "w3m-big-bold": this.variant === "big-bold", "w3m-medium-regular": this.variant === "medium-regular", "w3m-small-regular": this.variant === "small-regular", "w3m-small-thin": this.variant === "small-thin", "w3m-xsmall-regular": this.variant === "xsmall-regular", "w3m-xsmall-bold": this.variant === "xsmall-bold", "w3m-color-primary": this.color === "primary", "w3m-color-secondary": this.color === "secondary", "w3m-color-tertiary": this.color === "tertiary", "w3m-color-inverse": this.color === "inverse", "w3m-color-accnt": this.color === "accent", "w3m-color-error": this.color === "error" };
          return x2`<span data-testid="component-text"><slot class="${o7(t6)}"></slot></span>`;
        }
      };
      kt4.styles = [p7.globalCss, Ja], re5([n6()], kt4.prototype, "variant", 2), re5([n6()], kt4.prototype, "color", 2), kt4 = re5([e5("w3m-text")], kt4);
      ao2 = i2`div{overflow:hidden;position:relative;border-radius:50%}div::after{content:'';position:absolute;top:0;bottom:0;left:0;right:0;border-radius:50%;border:1px solid var(--w3m-color-overlay)}div img{width:100%;height:100%;object-fit:cover;object-position:center}svg{width:100%;height:100%}#token-placeholder-fill{fill:var(--w3m-color-bg-3)}#token-placeholder-dash{stroke:var(--w3m-color-overlay)}`;
      oo2 = Object.defineProperty;
      ro2 = Object.getOwnPropertyDescriptor;
      Pe3 = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? ro2(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && oo2(a6, o9, e9), e9;
      };
      Dt4 = class extends s5 {
        constructor() {
          super(...arguments), this.symbol = void 0;
        }
        render() {
          var t6;
          const a6 = s6.getTokenIcon((t6 = this.symbol) != null ? t6 : "");
          return a6 ? x2`<div><img crossorigin="anonymous" src="${a6}" alt="${this.id}" data-testid="component-token-image"></div>` : w6.TOKEN_PLACEHOLDER;
        }
      };
      Dt4.styles = [p7.globalCss, ao2], Pe3([n6()], Dt4.prototype, "symbol", 2), Dt4 = Pe3([e5("w3m-token-image")], Dt4);
      io2 = i2`button{width:100%;height:100%;border-radius:var(--w3m-button-hover-highlight-border-radius);display:flex;align-items:flex-start}button:active{background-color:var(--w3m-color-overlay)}@media(hover:hover){button:hover{background-color:var(--w3m-color-overlay)}}button>div{width:80px;padding:5px 0;display:flex;flex-direction:column;align-items:center}w3m-text{width:100%;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-align:center}w3m-wallet-image{height:60px;width:60px;transition:all .2s ease;border-radius:var(--w3m-wallet-icon-border-radius);margin-bottom:5px}.w3m-sublabel{margin-top:2px}`;
      lo2 = Object.defineProperty;
      no2 = Object.getOwnPropertyDescriptor;
      q6 = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? no2(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && lo2(a6, o9, e9), e9;
      };
      S11 = class extends s5 {
        constructor() {
          super(...arguments), this.onClick = () => null, this.name = "", this.walletId = "", this.label = void 0, this.imageId = void 0, this.installed = false, this.recent = false;
        }
        sublabelTemplate() {
          return this.recent ? x2`<w3m-text class="w3m-sublabel" variant="xsmall-bold" color="tertiary">RECENT</w3m-text>` : this.installed ? x2`<w3m-text class="w3m-sublabel" variant="xsmall-bold" color="tertiary">INSTALLED</w3m-text>` : null;
        }
        handleClick() {
          F6.click({ name: "WALLET_BUTTON", walletId: this.walletId }), this.onClick();
        }
        render() {
          var t6;
          return x2`<button @click="${this.handleClick.bind(this)}" data-testid="component-wallet-button-${this.name.toLowerCase()}"><div><w3m-wallet-image walletId="${this.walletId}" imageId="${this.imageId}"></w3m-wallet-image><w3m-text variant="xsmall-regular">${(t6 = this.label) != null ? t6 : s6.getWalletName(this.name, true)}</w3m-text>${this.sublabelTemplate()}</div></button>`;
        }
      };
      S11.styles = [p7.globalCss, io2], q6([n6()], S11.prototype, "onClick", 2), q6([n6()], S11.prototype, "name", 2), q6([n6()], S11.prototype, "walletId", 2), q6([n6()], S11.prototype, "label", 2), q6([n6()], S11.prototype, "imageId", 2), q6([n6()], S11.prototype, "installed", 2), q6([n6()], S11.prototype, "recent", 2), S11 = q6([e5("w3m-wallet-button")], S11);
      so2 = i2`:host{display:block}div{overflow:hidden;position:relative;border-radius:inherit;width:100%;height:100%;background-color:var(--w3m-color-overlay)}svg{position:relative;width:100%;height:100%}div::after{content:'';position:absolute;top:0;bottom:0;left:0;right:0;border-radius:inherit;border:1px solid var(--w3m-color-overlay)}div img{width:100%;height:100%;object-fit:cover;object-position:center}#wallet-placeholder-fill{fill:var(--w3m-color-bg-3)}#wallet-placeholder-dash{stroke:var(--w3m-color-overlay)}`;
      co2 = Object.defineProperty;
      mo2 = Object.getOwnPropertyDescriptor;
      Zt3 = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? mo2(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && co2(a6, o9, e9), e9;
      };
      dt4 = class extends s5 {
        constructor() {
          super(...arguments), this.walletId = "", this.imageId = void 0, this.imageUrl = void 0;
        }
        render() {
          var t6;
          const a6 = (t6 = this.imageUrl) != null && t6.length ? this.imageUrl : s6.getWalletIcon({ id: this.walletId, image_id: this.imageId });
          return x2`${a6.length ? x2`<div><img crossorigin="anonymous" src="${a6}" alt="${this.id}"></div>` : w6.WALLET_PLACEHOLDER}`;
        }
      };
      dt4.styles = [p7.globalCss, so2], Zt3([n6()], dt4.prototype, "walletId", 2), Zt3([n6()], dt4.prototype, "imageId", 2), Zt3([n6()], dt4.prototype, "imageUrl", 2), dt4 = Zt3([e5("w3m-wallet-image")], dt4);
      ho2 = Object.defineProperty;
      wo2 = Object.getOwnPropertyDescriptor;
      po2 = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? wo2(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && ho2(a6, o9, e9), e9;
      };
      Le3 = class extends s5 {
        constructor() {
          super(), this.unwatchAccount = void 0, q5.getAccount(), this.fetchProfile(), this.fetchBalance(), this.unwatchAccount = f5.client().watchAccount((t6) => {
            const { address: a6, isConnected: o9 } = q5.state;
            t6.isConnected && t6.address !== a6 && (this.fetchProfile(t6.address), this.fetchBalance(t6.address), q5.setAddress(t6.address)), t6.isConnected || q5.resetAccount(), o9 !== t6.isConnected && pe3.close(), !o9 && t6.isConnected ? F6.track({ name: "ACCOUNT_CONNECTED" }) : o9 && !t6.isConnected && F6.track({ name: "ACCOUNT_DISCONNECTED" }), q5.setIsConnected(t6.isConnected);
          });
        }
        disconnectedCallback() {
          var t6;
          (t6 = this.unwatchAccount) == null || t6.call(this);
        }
        async fetchProfile(t6) {
          var a6;
          const o9 = (a6 = b6.state.chains) == null ? void 0 : a6.find((r8) => r8.id === 1);
          if (C4.state.enableAccountView && o9)
            try {
              await q5.fetchProfile(s6.preloadImage, t6);
            } catch (r8) {
              console.error(r8), ge4.openToast(s6.getErrorMessage(r8), "error");
            }
        }
        async fetchBalance(t6) {
          if (C4.state.enableAccountView)
            try {
              await q5.fetchBalance(t6);
            } catch (a6) {
              console.error(a6), ge4.openToast(s6.getErrorMessage(a6), "error");
            }
        }
      };
      Le3 = po2([e5("w3m-account-context")], Le3);
      go2 = Object.defineProperty;
      uo2 = Object.getOwnPropertyDescriptor;
      Te4 = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? uo2(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && go2(a6, o9, e9), e9;
      };
      ie5 = class extends s5 {
        constructor() {
          super(), this.preload = true, this.preloadData();
        }
        async loadImages(t6) {
          try {
            t6 != null && t6.length && await Promise.all(t6.map(async (a6) => s6.preloadImage(a6)));
          } catch {
            console.info("Unsuccessful attempt at preloading some images", t6);
          }
        }
        async preloadListings() {
          var t6;
          if (C4.state.enableExplorer) {
            const { chains: a6 } = b6.state;
            await Promise.all([de6.getRecomendedWallets(), de6.getInjectedWallets()]), b6.setIsDataLoaded(true);
            const { recomendedWallets: o9 } = de6.state, r8 = R5.installedInjectedWallets(), e9 = (t6 = a6?.map((d7) => s6.getChainIcon(d7.id))) != null ? t6 : [], i7 = o9.map((d7) => s6.getWalletIcon(d7)), l9 = r8.map((d7) => s6.getWalletIcon(d7));
            await this.loadImages([...e9, ...i7, ...l9]);
          } else
            b6.setIsDataLoaded(true);
        }
        async preloadCustomImages() {
          const t6 = s6.getCustomImageUrls();
          await this.loadImages(t6);
        }
        async preloadData() {
          try {
            this.preload && (this.preload = false, await Promise.all([this.preloadListings(), this.preloadCustomImages()]));
          } catch (t6) {
            console.error(t6), ge4.openToast("Failed preloading", "error");
          }
        }
      };
      Te4([t4()], ie5.prototype, "preload", 2), ie5 = Te4([e5("w3m-explorer-context")], ie5);
      vo2 = Object.defineProperty;
      bo2 = Object.getOwnPropertyDescriptor;
      _e5 = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? bo2(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && vo2(a6, o9, e9), e9;
      };
      le7 = class extends s5 {
        constructor() {
          super(), this.activeChainId = void 0, this.unwatchNetwork = void 0;
          const t6 = b6.getSelectedChain();
          this.activeChainId = t6?.id, this.unwatchNetwork = f5.client().watchNetwork((a6) => {
            const o9 = a6.chain;
            o9 && this.activeChainId !== o9.id && (b6.setSelectedChain(o9), this.activeChainId = o9.id, q5.resetBalance(), this.fetchBalance());
          });
        }
        disconnectedCallback() {
          var t6;
          (t6 = this.unwatchNetwork) == null || t6.call(this);
        }
        async fetchBalance() {
          if (C4.state.enableAccountView)
            try {
              await q5.fetchBalance();
            } catch (t6) {
              console.error(t6), ge4.openToast(s6.getErrorMessage(t6), "error");
            }
        }
      };
      _e5([t4()], le7.prototype, "activeChainId", 2), le7 = _e5([e5("w3m-network-context")], le7);
      fo2 = Object.defineProperty;
      xo2 = Object.getOwnPropertyDescriptor;
      yo2 = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? xo2(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && fo2(a6, o9, e9), e9;
      };
      Ne2 = class extends s5 {
        constructor() {
          super(), this.unsubscribeTheme = void 0, p7.setTheme(), this.unsubscribeTheme = ue5.subscribe(p7.setTheme), this.preloadThemeImages();
        }
        disconnectedCallback() {
          var t6;
          (t6 = this.unsubscribeTheme) == null || t6.call(this);
        }
        async preloadThemeImages() {
          try {
            const { themeVariables: t6 } = ue5.state, a6 = [t6?.["--w3m-background-image-url"], t6?.["--w3m-logo-image-url"]].filter(Boolean);
            a6.length && await Promise.all(a6.map(async (o9) => s6.preloadImage(o9)));
          } catch {
            console.info("Unsuccessful attempt at preloading some images");
          }
        }
      };
      Ne2 = yo2([e5("w3m-theme-context")], Ne2);
      Co2 = Object.defineProperty;
      $o2 = Object.getOwnPropertyDescriptor;
      ko2 = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? $o2(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && Co2(a6, o9, e9), e9;
      };
      Oo2 = 24e4;
      Io2 = 1e3;
      De4 = class extends s5 {
        constructor() {
          super(), this.unwatchOptions = void 0, this.unwatchAccount = void 0, this.unwatchWcConnection = void 0, this.timeout = void 0, this.isGenerated = false, this.selectedChainId = (Re5 = b6.state.selectedChain) == null ? void 0 : Re5.id, this.isAccountConnected = q5.state.isConnected, this.lastRetry = Date.now(), this.unwatchOptions = b6.subscribe((t6) => {
            var a6, o9;
            ((a6 = t6.selectedChain) == null ? void 0 : a6.id) !== this.selectedChainId && (this.selectedChainId = (o9 = t6.selectedChain) == null ? void 0 : o9.id, this.connectAndWait());
          }), this.unwatchAccount = q5.subscribe((t6) => {
            (this.isAccountConnected !== t6.isConnected || !this.isGenerated) && (this.isAccountConnected = t6.isConnected, this.connectAndWait());
          }), this.unwatchWcConnection = P5.subscribe((t6) => {
            t6.pairingEnabled && !this.isGenerated && this.connectAndWait();
          });
        }
        disconnectedCallback() {
          var t6, a6, o9;
          (t6 = this.unwatchOptions) == null || t6.call(this), (a6 = this.unwatchAccount) == null || a6.call(this), (o9 = this.unwatchWcConnection) == null || o9.call(this);
        }
        async connectAndWait() {
          const { pairingEnabled: t6 } = P5.state;
          if (clearTimeout(this.timeout), !this.isAccountConnected && t6) {
            this.isGenerated = true, this.timeout = setTimeout(this.connectAndWait.bind(this), Oo2);
            try {
              const { selectedChain: a6 } = b6.state;
              await f5.client().connectWalletConnect((o9) => P5.setPairingUri(o9), a6?.id);
            } catch (a6) {
              console.error(a6), P5.setPairingError(true), ge4.openToast("Connection request declined", "error"), Date.now() - this.lastRetry >= Io2 && (this.lastRetry = Date.now(), this.connectAndWait());
            }
          }
        }
      };
      De4 = ko2([e5("w3m-wc-connection-context")], De4);
      Eo2 = i2`:host{all:initial}div{display:flex;align-items:center;background-color:var(--w3m-color-overlay);box-shadow:inset 0 0 0 1px var(--w3m-color-overlay);border-radius:var(--w3m-button-border-radius);padding:4px 4px 4px 8px}div button{border-radius:var(--w3m-secondary-button-border-radius);padding:4px 8px;padding-left:4px;height:auto;margin-left:10px;color:var(--w3m-accent-fill-color);background-color:var(--w3m-accent-color)}.w3m-no-avatar{padding-left:8px}button::after{content:'';top:0;bottom:0;left:0;right:0;position:absolute;background-color:transparent;border-radius:inherit;transition:background-color .2s ease;border:1px solid var(--w3m-color-overlay)}button:hover::after{background-color:var(--w3m-color-overlay)}w3m-avatar{margin-right:6px}w3m-button-big w3m-avatar{margin-left:-5px}`;
      Wo2 = Object.defineProperty;
      Ao2 = Object.getOwnPropertyDescriptor;
      ne5 = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? Ao2(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && Wo2(a6, o9, e9), e9;
      };
      Ot5 = class extends s5 {
        constructor() {
          super(), this.balance = "hide", this.avatar = "show";
        }
        onOpen() {
          F6.click({ name: "ACCOUNT_BUTTON" }), pe3.open({ route: "Account" });
        }
        accountTemplate() {
          const t6 = this.avatar === "show";
          return x2`${t6 ? x2`<w3m-avatar data-testid="partial-account-avatar"></w3m-avatar>` : null}<w3m-address-text data-testid="partial-account-address"></w3m-address-text>`;
        }
        render() {
          const t6 = this.balance === "show", a6 = { "w3m-no-avatar": this.avatar === "hide" };
          return t6 ? x2`<div><w3m-balance data-testid="partial-account-balance"></w3m-balance><button @click="${this.onOpen}" class="${o7(a6)}" data-testid="partial-account-open-button">${this.accountTemplate()}</button></div>` : x2`<w3m-button-big @click="${this.onOpen}" data-testid="partial-account-open-button">${this.accountTemplate()}</w3m-button-big>`;
        }
      };
      Ot5.styles = [p7.globalCss, Eo2], ne5([n6()], Ot5.prototype, "balance", 2), ne5([n6()], Ot5.prototype, "avatar", 2), Ot5 = ne5([e5("w3m-account-button")], Ot5);
      jo2 = i2`button{display:flex;border-radius:var(--w3m-button-hover-highlight-border-radius);flex-direction:column;justify-content:center;padding:5px;width:100px}button:active{background-color:var(--w3m-color-overlay)}@media(hover:hover){button:hover{background-color:var(--w3m-color-overlay)}}button:disabled{pointer-events:none}w3m-network-image{width:32px;height:32px}w3m-text{margin-top:4px}`;
      Mo2 = Object.defineProperty;
      Po2 = Object.getOwnPropertyDescriptor;
      se5 = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? Po2(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && Mo2(a6, o9, e9), e9;
      };
      It5 = class extends s5 {
        constructor() {
          super(), this.chainId = 0, this.label = "", this.unsubscribeNetwork = void 0;
          const { selectedChain: t6 } = b6.state;
          this.chainId = t6?.id, this.label = t6?.name, this.unsubscribeNetwork = b6.subscribe(({ selectedChain: a6 }) => {
            this.chainId = a6?.id, this.label = a6?.name;
          });
        }
        disconnectedCallback() {
          var t6;
          (t6 = this.unsubscribeNetwork) == null || t6.call(this);
        }
        onClick() {
          W7.push("SelectNetwork");
        }
        render() {
          const { chains: t6, selectedChain: a6 } = b6.state, o9 = t6?.map((i7) => i7.id), r8 = a6 && o9?.includes(a6.id), e9 = t6 && t6.length <= 1 && r8;
          return x2`<button @click="${this.onClick}" ?disabled="${e9}"><w3m-network-image chainId="${l7(this.chainId)}"></w3m-network-image><w3m-text variant="xsmall-regular" color="accent">${this.label}</w3m-text></button>`;
        }
      };
      It5.styles = [p7.globalCss, jo2], se5([t4()], It5.prototype, "chainId", 2), se5([t4()], It5.prototype, "label", 2), It5 = se5([e5("w3m-account-network-button")], It5);
      Lo2 = i2`@keyframes slide{0%{background-position:0 0}100%{background-position:200px 0}}w3m-text{padding:1px 0}.w3m-loading{background:linear-gradient(270deg,var(--w3m-color-fg-1) 36.33%,var(--w3m-color-fg-3) 42.07%,var(--w3m-color-fg-1) 83.3%);background-size:200px 100%;background-clip:text;-webkit-background-clip:text;-webkit-text-fill-color:transparent;animation-name:slide;animation-duration:1.5s;animation-iteration-count:infinite;animation-timing-function:linear}`;
      To2 = Object.defineProperty;
      _o2 = Object.getOwnPropertyDescriptor;
      Et4 = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? _o2(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && To2(a6, o9, e9), e9;
      };
      J4 = class extends s5 {
        constructor() {
          super(), this.address = void 0, this.name = void 0, this.loading = true, this.variant = "button", this.unsubscribeAccount = void 0, this.address = q5.state.address, this.name = q5.state.profileName, this.loading = Boolean(q5.state.profileLoading), this.unsubscribeAccount = q5.subscribe(({ address: t6, profileName: a6, profileLoading: o9 }) => {
            this.address = t6, this.name = a6, this.loading = Boolean(o9);
          });
        }
        disconnectedCallback() {
          var t6;
          (t6 = this.unsubscribeAccount) == null || t6.call(this);
        }
        render() {
          var t6;
          const a6 = this.variant === "button", o9 = { "w3m-loading": this.loading };
          return x2`<w3m-text class="${o7(o9)}" data-testid="partial-address-text" variant="${a6 ? "medium-regular" : "big-bold"}" color="${a6 ? "inverse" : "primary"}">${this.name ? this.name : s6.truncate((t6 = this.address) != null ? t6 : "")}</w3m-text>`;
        }
      };
      J4.styles = [p7.globalCss, Lo2], Et4([t4()], J4.prototype, "address", 2), Et4([t4()], J4.prototype, "name", 2), Et4([t4()], J4.prototype, "loading", 2), Et4([n6()], J4.prototype, "variant", 2), J4 = Et4([e5("w3m-address-text")], J4);
      P6 = { onConnecting(t6) {
        s6.goToConnectingView(t6);
      }, onExternal(t6) {
        s6.handleConnectorConnection(t6);
      }, manualWalletsTemplate() {
        return R5.manualWallets().map((t6) => x2`<w3m-wallet-button walletId="${t6.id}" name="${t6.name}" .onClick="${() => this.onConnecting(t6)}"></w3m-wallet-button>`);
      }, recomendedWalletsTemplate(t6 = false) {
        return R5.recomendedWallets(t6).map((a6) => x2`<w3m-wallet-button name="${a6.name}" walletId="${a6.id}" imageId="${a6.image_id}" .onClick="${() => this.onConnecting(a6)}"></w3m-wallet-button>`);
      }, externalWalletsTemplate() {
        return R5.externalWallets().map((t6) => x2`<w3m-wallet-button name="${t6.name}" walletId="${t6.id}" .onClick="${() => this.onExternal(t6.id)}"></w3m-wallet-button>`);
      }, recentWalletTemplate() {
        const t6 = R5.recentWallet();
        if (t6)
          return x2`<w3m-wallet-button name="${t6.name}" walletId="${t6.id}" imageId="${t6.image_id}" .recent="${true}" .onClick="${() => this.onConnecting(t6)}"></w3m-wallet-button>`;
      }, installedInjectedWalletsTemplate() {
        return R5.installedInjectedWallets().map((t6) => x2`<w3m-wallet-button .installed="${true}" name="${t6.name}" walletId="${t6.id}" imageId="${t6.image_id}" .onClick="${() => this.onConnecting(t6)}"></w3m-wallet-button>`);
      }, injectedWalletsTemplate() {
        return R5.injectedWallets().map((t6) => x2`<w3m-wallet-button name="${t6.name}" walletId="${t6.id}" imageId="${t6.image_id}" .onClick="${() => this.onConnecting(t6)}"></w3m-wallet-button>`);
      } };
      No2 = i2`@keyframes scroll{0%{transform:translate3d(0,0,0)}100%{transform:translate3d(calc(-70px * 9),0,0)}}.w3m-slider{position:relative;overflow-x:hidden;padding:10px 0;margin:0 -20px;width:calc(100% + 40px)}.w3m-track{display:flex;width:calc(70px * 18);animation:scroll 20s linear infinite;opacity:.7}.w3m-track svg{margin:0 5px}w3m-wallet-image{width:60px;height:60px;margin:0 5px;border-radius:var(--w3m-wallet-icon-border-radius)}.w3m-grid{display:grid;grid-template-columns:repeat(4,80px);justify-content:space-between}.w3m-title{display:flex;align-items:center;margin-bottom:10px}.w3m-title svg{margin-right:6px}.w3m-title path{fill:var(--w3m-accent-color)}w3m-modal-footer .w3m-title{padding:0 10px}w3m-button-big{position:absolute;top:50%;left:50%;transform:translateY(-50%) translateX(-50%);filter:drop-shadow(0 0 17px var(--w3m-color-bg-1))}w3m-info-footer{flex-direction:column;align-items:center;display:flex;width:100%;padding:5px 0}w3m-info-footer w3m-text{text-align:center;margin-bottom:15px}#wallet-placeholder-fill{fill:var(--w3m-color-bg-3)}#wallet-placeholder-dash{stroke:var(--w3m-color-overlay)}`;
      Ro2 = Object.defineProperty;
      Do2 = Object.getOwnPropertyDescriptor;
      Zo2 = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? Do2(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && Ro2(a6, o9, e9), e9;
      };
      ce5 = class extends s5 {
        onGoToQrcode() {
          W7.push("Qrcode");
        }
        onGetWallet() {
          W7.push("GetWallet");
        }
        render() {
          const { recomendedWallets: t6 } = de6.state, a6 = [...t6, ...t6], o9 = P6.externalWalletsTemplate(), r8 = P6.installedInjectedWalletsTemplate(), e9 = [...r8, ...o9].length > 0, i7 = i6.RECOMMENDED_WALLET_AMOUNT * 2;
          return x2`<w3m-modal-header title="Connect your wallet" .onAction="${this.onGoToQrcode}" .actionIcon="${w6.QRCODE_ICON}"></w3m-modal-header><w3m-modal-content><div class="w3m-title">${w6.MOBILE_ICON}<w3m-text variant="small-regular" color="accent">WalletConnect</w3m-text></div><div class="w3m-slider"><div class="w3m-track">${[...Array(i7)].map((l9, d7) => {
            const v6 = a6[d7 % a6.length];
            return v6 ? x2`<w3m-wallet-image walletId="${v6.id}" imageId="${v6.image_id}"></w3m-wallet-image>` : w6.WALLET_PLACEHOLDER;
          })}</div><w3m-button-big @click="${s6.handleAndroidLinking}" data-testid="partial-android-wallet-button"><w3m-text variant="medium-regular" color="inverse">Select Wallet</w3m-text></w3m-button-big></div></w3m-modal-content>${e9 ? x2`<w3m-modal-footer data-testid="partial-android-footer"><div class="w3m-title">${w6.WALLET_ICON}<w3m-text variant="small-regular" color="accent">Other</w3m-text></div><div class="w3m-grid">${r8} ${o9}</div></w3m-modal-footer>` : null}<w3m-info-footer><w3m-text color="secondary" variant="small-thin">${`Choose WalletConnect to see supported apps on your device${e9 ? ", or select from other options" : ""}`}</w3m-text><w3m-button variant="outline" .iconRight="${w6.ARROW_UP_RIGHT_ICON}" .onClick="${() => this.onGetWallet()}" data-testid="partial-android-nowallet-button">I don't have a wallet</w3m-button></w3m-info-footer>`;
        }
      };
      ce5.styles = [p7.globalCss, No2], ce5 = Zo2([e5("w3m-android-wallet-selection")], ce5);
      Ho2 = i2`@keyframes slide{0%{transform:translateX(-50px)}100%{transform:translateX(200px)}}.w3m-placeholder,img{border-radius:50%;box-shadow:inset 0 0 0 1px var(--w3m-color-overlay);display:block;position:relative;overflow:hidden!important;background-color:var(--w3m-color-av-1);background-image:radial-gradient(at 66% 77%,var(--w3m-color-av-2) 0,transparent 50%),radial-gradient(at 29% 97%,var(--w3m-color-av-3) 0,transparent 50%),radial-gradient(at 99% 86%,var(--w3m-color-av-4) 0,transparent 50%),radial-gradient(at 29% 88%,var(--w3m-color-av-5) 0,transparent 50%);transform:translateZ(0)}.w3m-loader{width:50px;height:100%;background:linear-gradient(270deg,transparent 0,rgba(255,255,255,.4) 30%,transparent 100%);animation-name:slide;animation-duration:1.5s;transform:translateX(-50px);animation-iteration-count:infinite;animation-timing-function:linear;animation-delay:.55s}.w3m-small{width:24px;height:24px}.w3m-medium{width:60px;height:60px}`;
      Bo2 = Object.defineProperty;
      So2 = Object.getOwnPropertyDescriptor;
      Wt3 = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? So2(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && Bo2(a6, o9, e9), e9;
      };
      tt3 = class extends s5 {
        constructor() {
          super(), this.address = void 0, this.avatar = void 0, this.loading = true, this.size = "small", this.unsubscribeAccount = void 0, this.address = q5.state.address, this.avatar = q5.state.profileAvatar, this.loading = Boolean(q5.state.profileLoading), this.unsubscribeAccount = q5.subscribe(({ address: t6, profileAvatar: a6, profileLoading: o9 }) => {
            this.address = t6, this.avatar = a6, this.loading = Boolean(o9);
          });
        }
        disconnectedCallback() {
          var t6;
          (t6 = this.unsubscribeAccount) == null || t6.call(this);
        }
        render() {
          const t6 = { "w3m-placeholder": true, "w3m-small": this.size === "small", "w3m-medium": this.size === "medium" };
          return this.avatar ? x2`<img crossorigin="anonymous" class="${o7(t6)}" src="${this.avatar}" data-testid="partial-avatar-image">` : this.address ? (s6.generateAvatarColors(this.address), x2`<div class="${o7(t6)}">${this.loading ? x2`<div class="w3m-loader"></div>` : null}</div>`) : null;
        }
      };
      tt3.styles = [p7.globalCss, Ho2], Wt3([t4()], tt3.prototype, "address", 2), Wt3([t4()], tt3.prototype, "avatar", 2), Wt3([t4()], tt3.prototype, "loading", 2), Wt3([n6()], tt3.prototype, "size", 2), tt3 = Wt3([e5("w3m-avatar")], tt3);
      Uo2 = i2`div{display:flex;align-items:center}w3m-token-image{width:28px;height:28px;margin-right:6px}`;
      Vo2 = Object.defineProperty;
      zo2 = Object.getOwnPropertyDescriptor;
      de7 = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? zo2(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && Vo2(a6, o9, e9), e9;
      };
      At3 = class extends s5 {
        constructor() {
          var t6, a6;
          super(), this.symbol = void 0, this.amount = void 0, this.unsubscribeAccount = void 0, this.symbol = (t6 = q5.state.balance) == null ? void 0 : t6.symbol, this.amount = (a6 = q5.state.balance) == null ? void 0 : a6.amount, this.unsubscribeAccount = q5.subscribe(({ balance: o9 }) => {
            this.symbol = o9?.symbol, this.amount = o9?.amount;
          });
        }
        disconnectedCallback() {
          var t6;
          (t6 = this.unsubscribeAccount) == null || t6.call(this);
        }
        render() {
          let t6 = "_._";
          return this.amount === "0.0" ? t6 = "0" : typeof this.amount == "string" && this.amount.length > 6 ? t6 = this.amount.substring(0, 6) : typeof this.amount == "string" && (t6 = this.amount), x2`<div><w3m-token-image symbol="${l7(this.symbol)}" data-testid="partial-balance-token-image"></w3m-token-image><w3m-text variant="medium-regular" color="primary" data-testid="partial-balance-token-text">${t6} ${this.symbol}</w3m-text></div>`;
        }
      };
      At3.styles = [p7.globalCss, Uo2], de7([t4()], At3.prototype, "symbol", 2), de7([t4()], At3.prototype, "amount", 2), At3 = de7([e5("w3m-balance")], At3);
      Go2 = i2`:host{all:initial}svg{width:28px;height:20px;margin:-1px 3px 0 -5px}svg path{fill:var(--w3m-accent-fill-color)}button:disabled svg path{fill:var(--w3m-color-fg-3)}w3m-spinner{margin:0 10px 0 0}`;
      Fo2 = Object.defineProperty;
      qo2 = Object.getOwnPropertyDescriptor;
      Ht3 = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? qo2(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && Fo2(a6, o9, e9), e9;
      };
      mt4 = class extends s5 {
        constructor() {
          super(), this.loading = false, this.label = "Connect Wallet", this.icon = "show", this.modalUnsub = void 0, this.modalUnsub = pe3.subscribe((t6) => {
            t6.open && (this.loading = true), t6.open || (this.loading = false);
          });
        }
        disconnectedCallback() {
          var t6;
          (t6 = this.modalUnsub) == null || t6.call(this);
        }
        iconTemplate() {
          return this.icon === "show" ? w6.WALLET_CONNECT_ICON : null;
        }
        onClick() {
          q5.state.isConnected ? this.onDisconnect() : this.onConnect();
        }
        async onConnect() {
          this.loading = true, F6.click({ name: "CONNECT_BUTTON" }), await pe3.open(), pe3.state.open || (this.loading = false);
        }
        async onDisconnect() {
          F6.click({ name: "DISCONNECT_BUTTON" }), await f5.client().disconnect();
        }
        render() {
          return x2`<w3m-button-big .disabled="${this.loading}" @click="${this.onClick}" data-testid="partial-connect-button">${this.loading ? x2`<w3m-spinner data-testid="partial-connect-spinner"></w3m-spinner><w3m-text variant="medium-regular" color="accent" data-testid="partial-connect-text">Connecting...</w3m-text>` : x2`${this.iconTemplate()}<w3m-text variant="medium-regular" color="inverse" data-testid="partial-connect-text">${this.label}</w3m-text>`}</w3m-button-big>`;
        }
      };
      mt4.styles = [p7.globalCss, Go2], Ht3([t4()], mt4.prototype, "loading", 2), Ht3([n6()], mt4.prototype, "label", 2), Ht3([n6()], mt4.prototype, "icon", 2), mt4 = Ht3([e5("w3m-connect-button")], mt4);
      Ko2 = i2`@keyframes loading{to{stroke-dashoffset:0}}@keyframes shake{10%,90%{transform:translate3d(-1px,0,0)}20%,80%{transform:translate3d(1px,0,0)}30%,50%,70%{transform:translate3d(-2px,0,0)}40%,60%{transform:translate3d(2px,0,0)}}:host{display:flex;flex-direction:column;align-items:center}div{position:relative;width:110px;height:110px;display:flex;justify-content:center;align-items:center;margin:40px 0 20px 0;transform:translate3d(0,0,0)}svg{position:absolute;width:110px;height:110px;fill:none;stroke:transparent;stroke-linecap:round;stroke-width:2px;top:0;left:0}use{stroke:var(--w3m-accent-color);animation:loading 1s linear infinite}w3m-wallet-image{border-radius:var(--w3m-wallet-icon-large-border-radius);width:90px;height:90px}w3m-text{margin-bottom:40px}.w3m-error svg{stroke:var(--w3m-error-color)}.w3m-error use{display:none}.w3m-error{animation:shake .4s cubic-bezier(.36,.07,.19,.97) both}.w3m-stale svg,.w3m-stale use{display:none}`;
      Yo2 = Object.defineProperty;
      Qo2 = Object.getOwnPropertyDescriptor;
      ht4 = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? Qo2(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && Yo2(a6, o9, e9), e9;
      };
      K6 = class extends s5 {
        constructor() {
          super(...arguments), this.walletId = void 0, this.imageId = void 0, this.isError = false, this.isStale = false, this.label = "";
        }
        svgLoaderTemplate() {
          var t6, a6;
          const o9 = (a6 = (t6 = ue5.state.themeVariables) == null ? void 0 : t6["--w3m-wallet-icon-large-border-radius"]) != null ? a6 : p7.getPreset("--w3m-wallet-icon-large-border-radius");
          let r8 = 0;
          o9.includes("%") ? r8 = 88 / 100 * parseInt(o9, 10) : r8 = parseInt(o9, 10), r8 *= 1.17;
          const e9 = 317 - r8 * 1.57, i7 = 425 - r8 * 1.8;
          return x2`<svg viewBox="0 0 110 110" width="110" height="110"><rect id="w3m-loader" x="2" y="2" width="106" height="106" rx="${r8}"/><use xlink:href="#w3m-loader" stroke-dasharray="106 ${e9}" stroke-dashoffset="${i7}"></use></svg>`;
        }
        render() {
          const t6 = { "w3m-error": this.isError, "w3m-stale": this.isStale };
          return x2`<div class="${o7(t6)}">${this.svgLoaderTemplate()}<w3m-wallet-image walletId="${l7(this.walletId)}" imageId="${l7(this.imageId)}" data-useid="partial-connector-wallet-image"></w3m-wallet-image></div><w3m-text variant="medium-regular" color="${this.isError ? "error" : "primary"}" data-useid="partial-connector-error-text">${this.isError ? "Connection declined" : this.label}</w3m-text>`;
        }
      };
      K6.styles = [p7.globalCss, Ko2], ht4([n6()], K6.prototype, "walletId", 2), ht4([n6()], K6.prototype, "imageId", 2), ht4([n6()], K6.prototype, "isError", 2), ht4([n6()], K6.prototype, "isStale", 2), ht4([n6()], K6.prototype, "label", 2), K6 = ht4([e5("w3m-connector-waiting")], K6);
      Xo2 = Object.defineProperty;
      Jo2 = Object.getOwnPropertyDescriptor;
      wt5 = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? Jo2(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && Xo2(a6, o9, e9), e9;
      };
      et3 = class extends s5 {
        constructor() {
          super(), this.isConnected = false, this.label = "Connect Wallet", this.icon = "show", this.avatar = "show", this.balance = "hide", this.unsubscribeAccount = void 0, this.isConnected = q5.state.isConnected, this.unsubscribeAccount = q5.subscribe(({ isConnected: t6 }) => {
            this.isConnected = t6;
          });
        }
        disconnectedCallback() {
          var t6;
          (t6 = this.unsubscribeAccount) == null || t6.call(this);
        }
        render() {
          const { enableAccountView: t6 } = C4.state, a6 = this.balance, o9 = this.label, r8 = this.icon, e9 = this.avatar;
          return this.isConnected && t6 ? x2`<w3m-account-button .balance="${a6}" .avatar="${e9}" data-testid="partial-core-account-button"></w3m-account-button>` : x2`<w3m-connect-button label="${l7(this.isConnected ? "Disconnect" : o9)}" .icon="${r8}" data-testid="partial-core-connect-button"></w3m-connect-button>`;
        }
      };
      wt5([t4()], et3.prototype, "isConnected", 2), wt5([n6()], et3.prototype, "label", 2), wt5([n6()], et3.prototype, "icon", 2), wt5([n6()], et3.prototype, "avatar", 2), wt5([n6()], et3.prototype, "balance", 2), et3 = wt5([e5("w3m-core-button")], et3);
      tr4 = i2`.w3m-grid{display:grid;grid-template-columns:repeat(4,80px);justify-content:space-between}.w3m-desktop-title,.w3m-mobile-title{display:flex;align-items:center}.w3m-mobile-title{justify-content:space-between;margin-bottom:20px;margin-top:-10px}.w3m-desktop-title{margin-bottom:10px;padding:0 10px}.w3m-subtitle{display:flex;align-items:center}.w3m-subtitle:last-child path{fill:var(--w3m-color-fg-3)}.w3m-desktop-title svg,.w3m-mobile-title svg{margin-right:6px}.w3m-desktop-title path,.w3m-mobile-title path{fill:var(--w3m-accent-color)}`;
      er4 = Object.defineProperty;
      ar3 = Object.getOwnPropertyDescriptor;
      or4 = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? ar3(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && er4(a6, o9, e9), e9;
      };
      me5 = class extends s5 {
        render() {
          const { explorerExcludedWalletIds: t6, enableExplorer: a6 } = C4.state, o9 = t6 !== "ALL" && a6, r8 = P6.manualWalletsTemplate(), e9 = P6.recomendedWalletsTemplate(), i7 = P6.externalWalletsTemplate(), l9 = P6.recentWalletTemplate();
          let d7 = [...P6.installedInjectedWalletsTemplate(), l9, ...i7, ...r8, ...e9];
          d7 = d7.filter(Boolean);
          const v6 = d7.length > 4 || o9;
          let x4 = [];
          v6 ? x4 = d7.slice(0, 3) : x4 = d7;
          const H5 = Boolean(x4.length);
          return x2`<w3m-modal-header .border="${true}" title="Connect your wallet" .onAction="${s6.handleUriCopy}" .actionIcon="${w6.COPY_ICON}" data-testid="partial-desktop-wallet-selection-header"></w3m-modal-header><w3m-modal-content data-testid="partial-desktop-wallet-selection-content"><div class="w3m-mobile-title"><div class="w3m-subtitle">${w6.MOBILE_ICON}<w3m-text variant="small-regular" color="accent">Mobile</w3m-text></div><div class="w3m-subtitle">${w6.SCAN_ICON}<w3m-text variant="small-regular" color="secondary">Scan with your wallet</w3m-text></div></div><w3m-walletconnect-qr></w3m-walletconnect-qr></w3m-modal-content>${H5 ? x2`<w3m-modal-footer data-testid="partial-desktop-wallet-selection-footer"><div class="w3m-desktop-title">${w6.DESKTOP_ICON}<w3m-text variant="small-regular" color="accent">Desktop</w3m-text></div><div class="w3m-grid">${x4} ${v6 ? x2`<w3m-view-all-wallets-button></w3m-view-all-wallets-button>` : null}</div></w3m-modal-footer>` : null}`;
        }
      };
      me5.styles = [p7.globalCss, tr4], me5 = or4([e5("w3m-desktop-wallet-selection")], me5);
      rr3 = i2`div{background-color:var(--w3m-color-bg-2);padding:10px 20px 15px 20px;border-top:1px solid var(--w3m-color-bg-3);text-align:center}a{color:var(--w3m-accent-color);text-decoration:none;transition:opacity .2s ease-in-out;display:inline}a:active{opacity:.8}@media(hover:hover){a:hover{opacity:.8}}`;
      ir3 = Object.defineProperty;
      lr4 = Object.getOwnPropertyDescriptor;
      nr4 = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? lr4(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && ir3(a6, o9, e9), e9;
      };
      he6 = class extends s5 {
        render() {
          const { termsOfServiceUrl: t6, privacyPolicyUrl: a6 } = C4.state;
          return t6 ?? a6 ? x2`<div><w3m-text variant="small-regular" color="secondary">By connecting your wallet to this app, you agree to the app's ${t6 ? x2`<a href="${t6}" target="_blank" rel="noopener noreferrer">Terms of Service</a>` : null} ${t6 && a6 ? "and" : null} ${a6 ? x2`<a href="${a6}" target="_blank" rel="noopener noreferrer">Privacy Policy</a>` : null}</w3m-text></div>` : null;
        }
      };
      he6.styles = [p7.globalCss, rr3], he6 = nr4([e5("w3m-legal-notice")], he6);
      sr3 = i2`div{display:grid;grid-template-columns:repeat(4,80px);margin:0 -10px;justify-content:space-between;row-gap:10px}`;
      cr4 = Object.defineProperty;
      dr3 = Object.getOwnPropertyDescriptor;
      mr3 = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? dr3(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && cr4(a6, o9, e9), e9;
      };
      we2 = class extends s5 {
        onQrcode() {
          W7.push("Qrcode");
        }
        render() {
          const { explorerExcludedWalletIds: t6, enableExplorer: a6 } = C4.state, o9 = t6 !== "ALL" && a6, r8 = P6.manualWalletsTemplate(), e9 = P6.recomendedWalletsTemplate(), i7 = P6.externalWalletsTemplate(), l9 = P6.recentWalletTemplate();
          let d7 = [...P6.installedInjectedWalletsTemplate(), l9, ...i7, ...r8, ...e9];
          d7 = d7.filter(Boolean);
          const v6 = d7.length > 8 || o9;
          let x4 = [];
          v6 ? x4 = d7.slice(0, 7) : x4 = d7;
          const H5 = Boolean(x4.length);
          return x2`<w3m-modal-header title="Connect your wallet" .onAction="${this.onQrcode}" .actionIcon="${w6.QRCODE_ICON}" data-testid="partial-mobile-wallet-selection-header"></w3m-modal-header>${H5 ? x2`<w3m-modal-content data-testid="partial-mobile-wallet-selection-content"><div>${x4} ${v6 ? x2`<w3m-view-all-wallets-button></w3m-view-all-wallets-button>` : null}</div></w3m-modal-content>` : null}`;
        }
      };
      we2.styles = [p7.globalCss, sr3], we2 = mr3([e5("w3m-mobile-wallet-selection")], we2);
      hr4 = i2`:host{all:initial}.w3m-overlay{top:0;bottom:0;left:0;right:0;position:fixed;z-index:var(--w3m-z-index);overflow:hidden;display:flex;justify-content:center;align-items:center;opacity:0;pointer-events:none;background-color:var(--w3m-overlay-background-color);backdrop-filter:var(--w3m-overlay-backdrop-filter)}@media(max-height:720px) and (orientation:landscape){.w3m-overlay{overflow:scroll;align-items:flex-start;padding:20px 0}}.w3m-active{pointer-events:auto}.w3m-container{position:relative;max-width:360px;width:100%;outline:0;border-radius:var(--w3m-background-border-radius) var(--w3m-background-border-radius) var(--w3m-container-border-radius) var(--w3m-container-border-radius);border:1px solid var(--w3m-color-overlay);overflow:hidden}.w3m-card{width:100%;position:relative;border-radius:var(--w3m-container-border-radius);overflow:hidden;box-shadow:0 6px 14px -6px rgba(10,16,31,.12),0 10px 32px -4px rgba(10,16,31,.1),0 0 0 1px var(--w3m-color-overlay);background-color:var(--w3m-color-bg-1);color:var(--w3m-color-fg-1)}@media(max-width:600px){.w3m-container{max-width:440px;border-radius:var(--w3m-background-border-radius) var(--w3m-background-border-radius) 0 0}.w3m-card{border-radius:var(--w3m-container-border-radius) var(--w3m-container-border-radius) 0 0}.w3m-overlay{align-items:flex-end}}@media(max-width:440px){.w3m-container{border:0}}`;
      wr2 = Object.defineProperty;
      pr = Object.getOwnPropertyDescriptor;
      pe4 = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? pr(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && wr2(a6, o9, e9), e9;
      };
      jt4 = class extends s5 {
        constructor() {
          super(), this.open = false, this.active = false, this.unsubscribeModal = void 0, this.abortController = void 0, this.unsubscribeModal = pe3.subscribe((t6) => {
            t6.open ? this.onOpenModalEvent() : this.onCloseModalEvent();
          });
        }
        disconnectedCallback() {
          var t6;
          (t6 = this.unsubscribeModal) == null || t6.call(this);
        }
        get overlayEl() {
          return s6.getShadowRootElement(this, ".w3m-overlay");
        }
        get containerEl() {
          return s6.getShadowRootElement(this, ".w3m-container");
        }
        toggleBodyScroll(t6) {
          if (document.querySelector("body"))
            if (t6) {
              const a6 = document.getElementById("w3m-styles");
              a6?.remove();
            } else
              document.head.insertAdjacentHTML("beforeend", '<style id="w3m-styles">html,body{touch-action:none;overflow:hidden;overscroll-behavior:contain;}</style>');
        }
        onCloseModal(t6) {
          t6.target === t6.currentTarget && pe3.close();
        }
        onOpenModalEvent() {
          this.toggleBodyScroll(false), this.addKeyboardEvents(), this.open = true, setTimeout(async () => {
            const t6 = s6.isMobileAnimation() ? { y: ["50vh", "0vh"] } : { scale: [0.98, 1] }, a6 = 0.1, o9 = 0.2;
            await Promise.all([animate2(this.overlayEl, { opacity: [0, 1] }, { delay: a6, duration: o9 }).finished, animate2(this.containerEl, t6, { delay: a6, duration: o9 }).finished]), this.active = true;
          }, 0);
        }
        async onCloseModalEvent() {
          this.toggleBodyScroll(true), this.removeKeyboardEvents();
          const t6 = s6.isMobileAnimation() ? { y: ["0vh", "50vh"] } : { scale: [1, 0.98] }, a6 = 0.2;
          await Promise.all([animate2(this.overlayEl, { opacity: [1, 0] }, { duration: a6 }).finished, animate2(this.containerEl, t6, { duration: a6 }).finished]), this.containerEl.removeAttribute("style"), this.active = false, this.open = false;
        }
        addKeyboardEvents() {
          this.abortController = new AbortController(), window.addEventListener("keydown", (t6) => {
            var a6;
            t6.key === "Escape" ? pe3.close() : t6.key === "Tab" && ((a6 = t6.target) != null && a6.tagName.includes("W3M-") || this.containerEl.focus());
          }, this.abortController), this.containerEl.focus();
        }
        removeKeyboardEvents() {
          var t6;
          (t6 = this.abortController) == null || t6.abort(), this.abortController = void 0;
        }
        render() {
          const t6 = { "w3m-overlay": true, "w3m-active": this.active };
          return x2`<w3m-explorer-context data-id="partial-modal-explorer-context"></w3m-explorer-context><w3m-theme-context data-id="partial-modal-theme-context"></w3m-theme-context><w3m-wc-connection-context data-id="partial-modal-connection-context"></w3m-wc-connection-context><w3m-account-context data-id="partial-modal-account-context"></w3m-account-context><w3m-network-context data-id="partial-modal-network-context"></w3m-network-context><div id="w3m-modal" class="${o7(t6)}" @click="${this.onCloseModal}" role="alertdialog" aria-modal="true"><div class="w3m-container" tabindex="0">${this.open ? x2`<w3m-modal-backcard></w3m-modal-backcard><div class="w3m-card"><w3m-modal-router></w3m-modal-router><w3m-modal-toast></w3m-modal-toast></div>` : null}</div></div>`;
        }
      };
      jt4.styles = [p7.globalCss, hr4], pe4([t4()], jt4.prototype, "open", 2), pe4([t4()], jt4.prototype, "active", 2), jt4 = pe4([e5("w3m-modal")], jt4);
      gr = i2`:host{all:initial}w3m-network-image{margin-left:-6px;margin-right:6px;width:28px;height:28px}`;
      ur2 = Object.defineProperty;
      vr2 = Object.getOwnPropertyDescriptor;
      Bt4 = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? vr2(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && ur2(a6, o9, e9), e9;
      };
      pt4 = class extends s5 {
        constructor() {
          super(), this.chainId = "", this.label = "", this.wrongNetwork = false, this.unsubscribeNetwork = void 0;
          const { selectedChain: t6 } = b6.state;
          this.onSetChainData(t6), this.unsubscribeNetwork = b6.subscribe(({ selectedChain: a6 }) => {
            this.onSetChainData(a6);
          });
        }
        disconnectedCallback() {
          var t6;
          (t6 = this.unsubscribeNetwork) == null || t6.call(this);
        }
        onSetChainData(t6) {
          if (t6) {
            const { chains: a6 } = b6.state, o9 = a6?.map((r8) => r8.id);
            this.chainId = t6.id.toString(), this.wrongNetwork = !(o9 != null && o9.includes(t6.id)), this.label = this.wrongNetwork ? "Wrong Network" : t6.name;
          }
        }
        onClick() {
          F6.click({ name: "NETWORK_BUTTON" }), pe3.open({ route: "SelectNetwork" });
        }
        render() {
          var t6;
          const { chains: a6 } = b6.state, o9 = a6 && a6.length > 1;
          return x2`<w3m-button-big @click="${this.onClick}" ?disabled="${!o9}" data-testid="partial-network-switch-button"><w3m-network-image chainId="${l7(this.chainId)}" data-testid="partial-network-switch-image"></w3m-network-image><w3m-text variant="medium-regular" color="inverse" data-testid="partial-network-switch-text">${(t6 = this.label) != null && t6.length ? this.label : "Select Network"}</w3m-text></w3m-button-big>`;
        }
      };
      pt4.styles = [p7.globalCss, gr], Bt4([t4()], pt4.prototype, "chainId", 2), Bt4([t4()], pt4.prototype, "label", 2), Bt4([t4()], pt4.prototype, "wrongNetwork", 2), pt4 = Bt4([e5("w3m-network-switch")], pt4);
      br2 = i2`@keyframes loading{to{stroke-dashoffset:0}}@keyframes shake{10%,90%{transform:translate3d(-1px,0,0)}20%,80%{transform:translate3d(1px,0,0)}30%,50%,70%{transform:translate3d(-2px,0,0)}40%,60%{transform:translate3d(2px,0,0)}}:host{display:flex;flex-direction:column;align-items:center}div{position:relative;width:110px;height:110px;display:flex;justify-content:center;align-items:center;margin:40px 0 20px 0;transform:translate3d(0,0,0)}svg{position:absolute;width:110px;height:110px;fill:none;stroke:transparent;stroke-linecap:round;stroke-width:1px;top:0;left:0}use{stroke:var(--w3m-accent-color);animation:loading 1s linear infinite}w3m-network-image{width:92px;height:92px}w3m-text{margin-bottom:40px}.w3m-error svg{stroke:var(--w3m-error-color)}.w3m-error use{display:none}.w3m-error{animation:shake .4s cubic-bezier(.36,.07,.19,.97) both}`;
      fr2 = Object.defineProperty;
      xr2 = Object.getOwnPropertyDescriptor;
      St5 = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? xr2(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && fr2(a6, o9, e9), e9;
      };
      gt4 = class extends s5 {
        constructor() {
          super(...arguments), this.chainId = void 0, this.isError = false, this.label = "";
        }
        svgLoaderTemplate() {
          return x2`<svg width="54" height="59" viewBox="0 0 54 59" fill="none" class="w3m-loader" data-testid="partial-network-waiting-svg"><path id="w3m-loader-path" d="M17.22 5.295c3.877-2.277 5.737-3.363 7.72-3.726a11.44 11.44 0 0 1 4.12 0c1.983.363 3.844 1.45 7.72 3.726l6.065 3.562c3.876 2.276 5.731 3.372 7.032 4.938a11.896 11.896 0 0 1 2.06 3.63c.683 1.928.688 4.11.688 8.663v7.124c0 4.553-.005 6.735-.688 8.664a11.896 11.896 0 0 1-2.06 3.63c-1.3 1.565-3.156 2.66-7.032 4.937l-6.065 3.563c-3.877 2.276-5.737 3.362-7.72 3.725a11.46 11.46 0 0 1-4.12 0c-1.983-.363-3.844-1.449-7.72-3.726l-6.065-3.562c-3.876-2.276-5.731-3.372-7.032-4.938a11.885 11.885 0 0 1-2.06-3.63c-.682-1.928-.688-4.11-.688-8.663v-7.124c0-4.553.006-6.735.688-8.664a11.885 11.885 0 0 1 2.06-3.63c1.3-1.565 3.156-2.66 7.032-4.937l6.065-3.562Z"/><use xlink:href="#w3m-loader-path" stroke-dasharray="54 118" stroke-dashoffset="172"></use></svg>`;
        }
        render() {
          const t6 = { "w3m-error": this.isError };
          return x2`<div class="${o7(t6)}">${this.svgLoaderTemplate()}<w3m-network-image chainId="${l7(this.chainId)}" data-testid="partial-network-waiting-image"></w3m-network-image></div><w3m-text variant="medium-regular" color="${this.isError ? "error" : "primary"}" data-testid="partial-network-waiting-text">${this.isError ? "Switch declined" : this.label}</w3m-text>`;
        }
      };
      gt4.styles = [p7.globalCss, br2], St5([n6()], gt4.prototype, "chainId", 2), St5([n6()], gt4.prototype, "isError", 2), St5([n6()], gt4.prototype, "label", 2), gt4 = St5([e5("w3m-network-waiting")], gt4);
      yr = i2`div{display:flex;margin-top:15px}slot{display:inline-block;margin:0 5px}w3m-button{margin:0 5px}`;
      Cr2 = Object.defineProperty;
      $r = Object.getOwnPropertyDescriptor;
      at4 = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? $r(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && Cr2(a6, o9, e9), e9;
      };
      V8 = class extends s5 {
        constructor() {
          super(...arguments), this.isMobile = false, this.isInjected = false, this.isInjectedInstalled = false, this.isDesktop = false, this.isWeb = false, this.isRetry = false;
        }
        onMobile() {
          i6.isMobile() ? W7.replace("MobileConnecting") : W7.replace("MobileQrcodeConnecting");
        }
        onInjected() {
          this.isInjectedInstalled ? W7.replace("InjectedConnecting") : W7.replace("InstallWallet");
        }
        onDesktop() {
          W7.replace("DesktopConnecting");
        }
        onWeb() {
          W7.replace("WebConnecting");
        }
        render() {
          return x2`<div>${this.isRetry ? x2`<slot></slot>` : null} ${this.isMobile ? x2`<w3m-button .onClick="${this.onMobile}" .iconLeft="${w6.MOBILE_ICON}" variant="outline">Mobile</w3m-button>` : null} ${this.isInjected ? x2`<w3m-button .onClick="${this.onInjected}" .iconLeft="${w6.WALLET_ICON}" variant="outline">Browser</w3m-button>` : null} ${this.isDesktop ? x2`<w3m-button .onClick="${this.onDesktop}" .iconLeft="${w6.DESKTOP_ICON}" variant="outline">Desktop</w3m-button>` : null} ${this.isWeb ? x2`<w3m-button .onClick="${this.onWeb}" .iconLeft="${w6.GLOBE_ICON}" variant="outline">Web</w3m-button>` : null}</div>`;
        }
      };
      V8.styles = [p7.globalCss, yr], at4([n6()], V8.prototype, "isMobile", 2), at4([n6()], V8.prototype, "isInjected", 2), at4([n6()], V8.prototype, "isInjectedInstalled", 2), at4([n6()], V8.prototype, "isDesktop", 2), at4([n6()], V8.prototype, "isWeb", 2), at4([n6()], V8.prototype, "isRetry", 2), V8 = at4([e5("w3m-platform-selection")], V8);
      kr = i2`button{display:flex;flex-direction:column;padding:5px 10px;border-radius:var(--w3m-button-hover-highlight-border-radius);height:100%;justify-content:flex-start}.w3m-icons{width:60px;height:60px;display:flex;flex-wrap:wrap;padding:7px;border-radius:var(--w3m-wallet-icon-border-radius);justify-content:space-between;align-items:center;margin-bottom:5px;background-color:var(--w3m-color-bg-2);box-shadow:inset 0 0 0 1px var(--w3m-color-overlay)}button:active{background-color:var(--w3m-color-overlay)}@media(hover:hover){button:hover{background-color:var(--w3m-color-overlay)}}.w3m-icons img{width:21px;height:21px;object-fit:cover;object-position:center;border-radius:calc(var(--w3m-wallet-icon-border-radius)/ 2);border:1px solid var(--w3m-color-overlay)}.w3m-icons svg{width:21px;height:21px}.w3m-icons img:nth-child(1),.w3m-icons img:nth-child(2),.w3m-icons svg:nth-child(1),.w3m-icons svg:nth-child(2){margin-bottom:4px}w3m-text{width:100%;text-align:center}#wallet-placeholder-fill{fill:var(--w3m-color-bg-3)}#wallet-placeholder-dash{stroke:var(--w3m-color-overlay)}`;
      Or2 = Object.defineProperty;
      Ir2 = Object.getOwnPropertyDescriptor;
      Er2 = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? Ir2(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && Or2(a6, o9, e9), e9;
      };
      ge5 = class extends s5 {
        onClick() {
          W7.push("WalletExplorer");
        }
        render() {
          const { recomendedWallets: t6 } = de6.state, a6 = R5.manualWallets(), o9 = [...t6, ...a6].reverse().slice(0, 4);
          return x2`<button @click="${this.onClick}" data-testid="partial-all-wallets-button"><div class="w3m-icons">${o9.map((r8) => {
            const e9 = s6.getWalletIcon(r8);
            if (e9)
              return x2`<img crossorigin="anonymous" src="${e9}">`;
            const i7 = s6.getWalletIcon({ id: r8.id });
            return i7 ? x2`<img crossorigin="anonymous" src="${i7}">` : w6.WALLET_PLACEHOLDER;
          })} ${[...Array(4 - o9.length)].map(() => w6.WALLET_PLACEHOLDER)}</div><w3m-text variant="xsmall-regular">View All</w3m-text></button>`;
        }
      };
      ge5.styles = [p7.globalCss, kr], ge5 = Er2([e5("w3m-view-all-wallets-button")], ge5);
      Wr = i2`.w3m-qr-container{width:100%;display:flex;justify-content:center;align-items:center;aspect-ratio:1/1}`;
      Ar2 = Object.defineProperty;
      jr = Object.getOwnPropertyDescriptor;
      Ut3 = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? jr(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && Ar2(a6, o9, e9), e9;
      };
      ut4 = class extends s5 {
        constructor() {
          super(), this.walletId = "", this.imageId = "", this.uri = "", this.unwatchWcConnection = void 0, setTimeout(() => {
            const { pairingUri: t6 } = P5.state;
            this.uri = t6;
          }, 0), this.unwatchWcConnection = P5.subscribe((t6) => {
            t6.pairingUri && (this.uri = t6.pairingUri);
          });
        }
        disconnectedCallback() {
          var t6;
          (t6 = this.unwatchWcConnection) == null || t6.call(this);
        }
        get overlayEl() {
          return s6.getShadowRootElement(this, ".w3m-qr-container");
        }
        render() {
          return x2`<div class="w3m-qr-container">${this.uri ? x2`<w3m-qrcode size="${this.overlayEl.offsetWidth}" uri="${this.uri}" walletId="${this.walletId}" imageId="${this.imageId}" data-testid="partial-qr-code"></w3m-qrcode>` : x2`<w3m-spinner data-testid="partial-qr-spinner"></w3m-spinner>`}</div>`;
        }
      };
      ut4.styles = [p7.globalCss, Wr], Ut3([n6()], ut4.prototype, "walletId", 2), Ut3([n6()], ut4.prototype, "imageId", 2), Ut3([t4()], ut4.prototype, "uri", 2), ut4 = Ut3([e5("w3m-walletconnect-qr")], ut4);
      Mr = i2`.w3m-profile{display:flex;justify-content:space-between;align-items:flex-start;padding-top:20px}.w3m-connection-badge{background-color:var(--w3m-color-bg-2);box-shadow:inset 0 0 0 1px var(--w3m-color-overlay);padding:6px 10px 6px 26px;position:relative;border-radius:28px}.w3m-connection-badge::before{content:'';position:absolute;width:10px;height:10px;left:10px;background-color:var(--w3m-success-color);border-radius:50%;top:50%;margin-top:-5px;box-shadow:0 1px 4px 1px var(--w3m-success-color),inset 0 0 0 1px var(--w3m-color-overlay)}.w3m-footer{display:flex;justify-content:space-between}w3m-address-text{margin-top:10px;display:block}.w3m-balance{border-top:1px solid var(--w3m-color-bg-2);padding:11px 20px}`;
      Pr2 = Object.defineProperty;
      Lr = Object.getOwnPropertyDescriptor;
      Ze3 = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? Lr(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && Pr2(a6, o9, e9), e9;
      };
      Vt4 = class extends s5 {
        constructor() {
          super(...arguments), this.loading = false;
        }
        async onDisconnect() {
          this.loading || (this.loading = true, await f5.client().disconnect(), this.loading = false);
        }
        async onCopyAddress() {
          var t6;
          try {
            await navigator.clipboard.writeText((t6 = q5.state.address) != null ? t6 : ""), ge4.openToast("Address copied", "success");
          } catch {
            ge4.openToast("Failed to copy", "error");
          }
        }
        render() {
          return x2`<w3m-modal-content data-testid="view-account-content"><div class="w3m-profile"><div class="w3m-info"><w3m-avatar size="medium" data-testid="view-account-avatar"></w3m-avatar><w3m-address-text variant="modal" data-testid="view-account-address-text"></w3m-address-text></div><div class="w3m-connection-badge"><w3m-text variant="small-regular" color="secondary" data-testid="view-account-connection-badge">Connected</w3m-text></div></div></w3m-modal-content><div class="w3m-balance"><w3m-balance data-testid="view-account-balance"></w3m-balance></div><w3m-modal-footer data-testid="view-account-footer"><div class="w3m-footer"><w3m-account-network-button data-testid="view-account-network-button"></w3m-account-network-button><w3m-box-button label="Copy Address" .onClick="${this.onCopyAddress}" .icon="${w6.ACCOUNT_COPY}" data-testid="view-account-copy-button"></w3m-box-button><w3m-box-button label="Disconnect" .loading="${this.loading}" .onClick="${this.onDisconnect}" .icon="${w6.ACCOUNT_DISCONNECT}" data-testid="view-account-disconnect-button"></w3m-box-button></div></w3m-modal-footer>`;
        }
      };
      Vt4.styles = [p7.globalCss, Mr], Ze3([t4()], Vt4.prototype, "loading", 2), Vt4 = Ze3([e5("w3m-account-view")], Vt4);
      Tr2 = Object.defineProperty;
      _r2 = Object.getOwnPropertyDescriptor;
      Nr2 = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? _r2(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && Tr2(a6, o9, e9), e9;
      };
      ue6 = class extends s5 {
        viewTemplate() {
          return i6.isAndroid() ? x2`<w3m-android-wallet-selection></w3m-android-wallet-selection>` : i6.isMobile() ? x2`<w3m-mobile-wallet-selection></w3m-mobile-wallet-selection>` : x2`<w3m-desktop-wallet-selection></w3m-desktop-wallet-selection>`;
        }
        render() {
          return x2`${this.viewTemplate()}<w3m-legal-notice></w3m-legal-notice>`;
        }
      };
      ue6.styles = [p7.globalCss], ue6 = Nr2([e5("w3m-connect-wallet-view")], ue6);
      Rr2 = i2`w3m-info-footer{flex-direction:column;align-items:center;display:flex;width:100%;padding:5px 0}w3m-text{text-align:center}`;
      Dr = Object.defineProperty;
      Zr = Object.getOwnPropertyDescriptor;
      He4 = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? Zr(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && Dr(a6, o9, e9), e9;
      };
      zt4 = class extends s5 {
        constructor() {
          super(), this.isError = false, this.unwatchConnection = void 0, this.openDesktopApp(), this.unwatchConnection = P5.subscribe((t6) => {
            this.isError = t6.pairingError;
          });
        }
        disconnectedCallback() {
          var t6;
          (t6 = this.unwatchConnection) == null || t6.call(this);
        }
        onFormatAndRedirect(t6) {
          const { desktop: a6, name: o9 } = i6.getWalletRouterData(), r8 = a6?.native;
          if (r8) {
            const e9 = i6.formatNativeUrl(r8, t6, o9);
            i6.openHref(e9, "_self");
          }
        }
        openDesktopApp() {
          P5.setPairingError(false);
          const { pairingUri: t6 } = P5.state, a6 = i6.getWalletRouterData();
          s6.setRecentWallet(a6), this.onFormatAndRedirect(t6);
        }
        render() {
          const { name: t6, id: a6, image_id: o9 } = i6.getWalletRouterData(), { isMobile: r8, isInjected: e9, isWeb: i7 } = s6.getCachedRouterWalletPlatforms();
          return x2`<w3m-modal-header title="${t6}" .onAction="${s6.handleUriCopy}" .actionIcon="${w6.COPY_ICON}" data-testid="view-desktop-connecting-header"></w3m-modal-header><w3m-modal-content><w3m-connector-waiting walletId="${a6}" imageId="${o9}" label="${`Continue in ${t6}...`}" .isError="${this.isError}" data-testid="view-desktop-connecting-waiting"></w3m-connector-waiting></w3m-modal-content><w3m-info-footer data-testid="view-desktop-connecting-footer"><w3m-text color="secondary" variant="small-thin">${`Connection can continue loading if ${t6} is not installed on your device`}</w3m-text><w3m-platform-selection .isMobile="${r8}" .isInjected="${e9}" .isWeb="${i7}" .isRetry="${true}"><w3m-button .onClick="${this.openDesktopApp.bind(this)}" .iconRight="${w6.RETRY_ICON}" data-testid="view-desktop-connecting-retry-button">Retry</w3m-button></w3m-platform-selection></w3m-info-footer>`;
        }
      };
      zt4.styles = [p7.globalCss, Rr2], He4([t4()], zt4.prototype, "isError", 2), zt4 = He4([e5("w3m-desktop-connecting-view")], zt4);
      Hr = i2`.w3m-info-text{margin:5px 0 15px;max-width:320px;text-align:center}.w3m-wallet-item{margin:0 -20px 0 0;padding-right:20px;display:flex;align-items:center;border-bottom:1px solid var(--w3m-color-bg-2)}.w3m-wallet-item:last-child{margin-bottom:-20px;border-bottom:0}.w3m-wallet-content{margin-left:20px;height:60px;display:flex;flex:1;align-items:center;justify-content:space-between}.w3m-footer-actions{display:flex;flex-direction:column;align-items:center;padding:20px 0;border-top:1px solid var(--w3m-color-bg-2)}w3m-wallet-image{display:block;width:40px;height:40px;border-radius:10px}`;
      Br = Object.defineProperty;
      Sr2 = Object.getOwnPropertyDescriptor;
      Ur = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? Sr2(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && Br(a6, o9, e9), e9;
      };
      ve2 = class extends s5 {
        onGet(t6) {
          i6.openHref(t6, "_blank");
        }
        render() {
          const t6 = de6.state.recomendedWallets.slice(0, 5), a6 = R5.manualWallets().slice(0, 5), o9 = t6.length, r8 = a6.length;
          return x2`<w3m-modal-header title="Get a wallet" data-testid="view-get-wallet-header"></w3m-modal-header><w3m-modal-content data-testid="view-get-wallet-content">${o9 ? t6.map((e9) => x2`<div class="w3m-wallet-item" data-testid="view-get-wallet-${e9.id}"><w3m-wallet-image walletId="${e9.id}" imageId="${e9.image_id}"></w3m-wallet-image><div class="w3m-wallet-content"><w3m-text variant="medium-regular">${e9.name}</w3m-text><w3m-button .iconRight="${w6.ARROW_RIGHT_ICON}" .onClick="${() => this.onGet(e9.homepage)}" data-testid="view-get-wallet-button-${e9.id}">Get</w3m-button></div></div>`) : null} ${r8 ? a6.map((e9) => x2`<div class="w3m-wallet-item" data-testid="view-get-wallet-${e9.id}"><w3m-wallet-image walletId="${e9.id}"></w3m-wallet-image><div class="w3m-wallet-content"><w3m-text variant="medium-regular">${e9.name}</w3m-text><w3m-button .iconRight="${w6.ARROW_RIGHT_ICON}" .onClick="${() => this.onGet(e9.links.universal)}" data-testid="view-get-wallet-button-${e9.id}">Get</w3m-button></div></div>`) : null}</w3m-modal-content><div class="w3m-footer-actions"><w3m-text variant="medium-regular">Not what you're looking for?</w3m-text><w3m-text variant="small-thin" color="secondary" class="w3m-info-text">With hundreds of wallets out there, there's something for everyone</w3m-text><w3m-button .onClick="${s6.openWalletExplorerUrl}" .iconRight="${w6.ARROW_UP_RIGHT_ICON}" data-testid="view-get-wallet-explorer-button">Explore Wallets</w3m-button></div>`;
        }
      };
      ve2.styles = [p7.globalCss, Hr], ve2 = Ur([e5("w3m-get-wallet-view")], ve2);
      Vr = i2`.w3m-footer-actions{display:flex;justify-content:center}.w3m-footer-actions w3m-button{margin:0 5px}.w3m-info-container{display:flex;flex-direction:column;justify-content:center;align-items:center;margin-bottom:20px}.w3m-info-container:last-child{margin-bottom:0}.w3m-info-text{margin-top:5px;text-align:center}.w3m-images svg{margin:0 2px 5px;width:55px;height:55px}.help-img-highlight{stroke:var(--w3m-color-overlay)}`;
      zr2 = Object.defineProperty;
      Gr = Object.getOwnPropertyDescriptor;
      Fr = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? Gr(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && zr2(a6, o9, e9), e9;
      };
      be2 = class extends s5 {
        constructor() {
          super(...arguments), this.learnUrl = "https://ethereum.org/en/wallets/";
        }
        onGet() {
          C4.state.enableExplorer ? W7.push("GetWallet") : s6.openWalletExplorerUrl();
        }
        onLearnMore() {
          i6.openHref(this.learnUrl, "_blank");
        }
        render() {
          return x2`<w3m-modal-header title="What is a wallet?"></w3m-modal-header><w3m-modal-content><div class="w3m-info-container"><div class="w3m-images">${w6.HELP_CHART_IMG} ${w6.HELP_PAINTING_IMG} ${w6.HELP_ETH_IMG}</div><w3m-text variant="medium-regular">A home for your digital assets</w3m-text><w3m-text variant="small-thin" color="secondary" class="w3m-info-text">A wallet lets you store, send and receive digital assets like cryptocurrencies and NFTs.</w3m-text></div><div class="w3m-info-container"><div class="w3m-images">${w6.HELP_KEY_IMG} ${w6.HELP_USER_IMG} ${w6.HELP_LOCK_IMG}</div><w3m-text variant="medium-regular">One login for all of web3</w3m-text><w3m-text variant="small-thin" color="secondary" class="w3m-info-text">Log in to any app by connecting your wallet. Say goodbye to countless passwords!</w3m-text></div><div class="w3m-info-container"><div class="w3m-images">${w6.HELP_COMPAS_IMG} ${w6.HELP_NOUN_IMG} ${w6.HELP_DAO_IMG}</div><w3m-text variant="medium-regular">Your gateway to a new web</w3m-text><w3m-text variant="small-thin" color="secondary" class="w3m-info-text">With your wallet, you can explore and interact with DeFi, NFTs, DAOs, and much more.</w3m-text></div><div class="w3m-footer-actions"><w3m-button .onClick="${this.onGet.bind(this)}" .iconLeft="${w6.WALLET_ICON}">Get a Wallet</w3m-button><w3m-button .onClick="${this.onLearnMore.bind(this)}" .iconRight="${w6.ARROW_UP_RIGHT_ICON}">Learn More</w3m-button></div></w3m-modal-content>`;
        }
      };
      be2.styles = [p7.globalCss, Vr], be2 = Fr([e5("w3m-help-view")], be2);
      qr = i2`w3m-info-footer{flex-direction:column;align-items:center;display:flex;width:100%;padding:5px 0}w3m-text{text-align:center}`;
      Kr = Object.defineProperty;
      Yr = Object.getOwnPropertyDescriptor;
      Be4 = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? Yr(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && Kr(a6, o9, e9), e9;
      };
      Gt4 = class extends s5 {
        constructor() {
          super(), this.isError = false, this.connector = f5.client().getConnectorById("injected"), this.openInjectedApp();
        }
        async openInjectedApp() {
          const { ready: t6 } = this.connector;
          t6 && (this.isError = false, await s6.handleConnectorConnection("injected", () => {
            this.isError = true;
          }));
        }
        render() {
          const { name: t6, id: a6, image_id: o9 } = i6.getWalletRouterData(), { isMobile: r8, isDesktop: e9, isWeb: i7 } = s6.getCachedRouterWalletPlatforms();
          return x2`<w3m-modal-header title="${t6}" data-testid="view-injected-header"></w3m-modal-header><w3m-modal-content data-testid="view-injected-content"><w3m-connector-waiting walletId="${a6}" imageId="${o9}" label="${`Continue in ${t6}...`}" .isError="${this.isError}"></w3m-connector-waiting></w3m-modal-content><w3m-info-footer data-testid="view-injected-footer"><w3m-text color="secondary" variant="small-thin">Connection can be declined if multiple wallets are installed or previous request is still active</w3m-text><w3m-platform-selection .isMobile="${r8}" .isDesktop="${e9}" .isWeb="${i7}" .isRetry="${true}"><w3m-button .onClick="${this.openInjectedApp.bind(this)}" .disabled="${!this.isError}" .iconRight="${w6.RETRY_ICON}">Retry</w3m-button></w3m-platform-selection></w3m-info-footer>`;
        }
      };
      Gt4.styles = [p7.globalCss, qr], Be4([t4()], Gt4.prototype, "isError", 2), Gt4 = Be4([e5("w3m-injected-connecting-view")], Gt4);
      Qr = i2`w3m-info-footer{flex-direction:column;align-items:center;display:flex;width:100%;padding:5px 0}w3m-text{text-align:center}w3m-button{margin-top:15px}`;
      Xr = Object.defineProperty;
      Jr = Object.getOwnPropertyDescriptor;
      ti = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? Jr(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && Xr(a6, o9, e9), e9;
      };
      fe4 = class extends s5 {
        onInstall(t6) {
          t6 && i6.openHref(t6, "_blank");
        }
        render() {
          const { name: t6, id: a6, image_id: o9, homepage: r8 } = i6.getWalletRouterData();
          return x2`<w3m-modal-header title="${t6}" data-testid="view-install-wallet-header"></w3m-modal-header><w3m-modal-content data-testid="view-install-wallet-content"><w3m-connector-waiting walletId="${a6}" imageId="${o9}" label="Not Detected" .isStale="${true}"></w3m-connector-waiting></w3m-modal-content><w3m-info-footer data-testid="view-install-wallet-footer"><w3m-text color="secondary" variant="small-thin">${`Download ${t6} to continue. If multiple browser extensions are installed, disable non ${t6} ones and try again`}</w3m-text><w3m-button .onClick="${() => this.onInstall(r8)}" .iconLeft="${w6.ARROW_DOWN_ICON}" data-testid="view-install-wallet-download-button">Download</w3m-button></w3m-info-footer>`;
        }
      };
      fe4.styles = [p7.globalCss, Qr], fe4 = ti([e5("w3m-install-wallet-view")], fe4);
      ei = i2`w3m-wallet-image{border-radius:var(--w3m-wallet-icon-large-border-radius);width:96px;height:96px;margin-bottom:20px}w3m-info-footer{display:flex;width:100%}.w3m-app-store{justify-content:space-between}.w3m-app-store w3m-wallet-image{margin-right:10px;margin-bottom:0;width:28px;height:28px;border-radius:var(--w3m-wallet-icon-small-border-radius)}.w3m-app-store div{display:flex;align-items:center}.w3m-app-store w3m-button{margin-right:-10px}.w3m-note{flex-direction:column;align-items:center;padding:5px 0}.w3m-note w3m-text{text-align:center}w3m-platform-selection{margin-top:-15px}.w3m-note w3m-text{margin-top:15px}.w3m-note w3m-text span{color:var(--w3m-accent-color)}`;
      ai = Object.defineProperty;
      oi = Object.getOwnPropertyDescriptor;
      Se2 = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? oi(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && ai(a6, o9, e9), e9;
      };
      Ft4 = class extends s5 {
        constructor() {
          super(), this.isError = false, this.unwatchConnection = void 0, this.openMobileApp(), this.unwatchConnection = P5.subscribe((t6) => {
            this.isError = t6.pairingError;
          });
        }
        disconnectedCallback() {
          var t6;
          (t6 = this.unwatchConnection) == null || t6.call(this);
        }
        onFormatAndRedirect(t6, a6 = false) {
          const { mobile: o9, name: r8 } = i6.getWalletRouterData(), e9 = o9?.native, i7 = o9?.universal;
          if (e9 && !a6) {
            const l9 = i6.formatNativeUrl(e9, t6, r8);
            i6.openHref(l9, "_self");
          } else if (i7) {
            const l9 = i6.formatUniversalUrl(i7, t6, r8);
            i6.openHref(l9, "_self");
          }
        }
        openMobileApp(t6 = false) {
          P5.setPairingError(false);
          const { pairingUri: a6 } = P5.state, o9 = i6.getWalletRouterData();
          s6.setRecentWallet(o9), this.onFormatAndRedirect(a6, t6);
        }
        onGoToAppStore(t6) {
          t6 && i6.openHref(t6, "_blank");
        }
        render() {
          const { name: t6, id: a6, image_id: o9, app: r8, mobile: e9 } = i6.getWalletRouterData(), { isWeb: i7 } = s6.getCachedRouterWalletPlatforms(), l9 = r8?.ios, d7 = e9?.universal;
          return x2`<w3m-modal-header title="${t6}" data-testid="view-mobile-connecting-header"></w3m-modal-header><w3m-modal-content data-testid="view-mobile-connecting-content"><w3m-connector-waiting walletId="${a6}" imageId="${o9}" label="Tap 'Open' to continue" .isError="${this.isError}"></w3m-connector-waiting></w3m-modal-content><w3m-info-footer class="w3m-note" data-testid="view-mobile-connecting-footer"><w3m-platform-selection .isWeb="${i7}" .isRetry="${true}"><w3m-button .onClick="${() => this.openMobileApp(false)}" .iconRight="${w6.RETRY_ICON}">Retry</w3m-button></w3m-platform-selection>${d7 ? x2`<w3m-text color="secondary" variant="small-thin">Still doesn't work? <span tabindex="0" @click="${() => this.openMobileApp(true)}">Try this alternate link</span></w3m-text>` : null}</w3m-info-footer><w3m-info-footer class="w3m-app-store" data-testid="view-mobile-connecting-footer"><div><w3m-wallet-image walletId="${a6}" imageId="${o9}"></w3m-wallet-image><w3m-text>${`Get ${t6}`}</w3m-text></div><w3m-button .iconRight="${w6.ARROW_RIGHT_ICON}" .onClick="${() => this.onGoToAppStore(l9)}" variant="ghost" data-testid="view-mobile-connecting-app-store-button">App Store</w3m-button></w3m-info-footer>`;
        }
      };
      Ft4.styles = [p7.globalCss, ei], Se2([t4()], Ft4.prototype, "isError", 2), Ft4 = Se2([e5("w3m-mobile-connecting-view")], Ft4);
      ri = i2`w3m-info-footer{flex-direction:column;align-items:center;display:flex;width:100%;padding:5px 0}w3m-text{text-align:center}`;
      ii = Object.defineProperty;
      li = Object.getOwnPropertyDescriptor;
      ni = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? li(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && ii(a6, o9, e9), e9;
      };
      xe2 = class extends s5 {
        render() {
          const { name: t6, id: a6, image_id: o9 } = i6.getWalletRouterData(), { isInjected: r8, isDesktop: e9, isWeb: i7 } = s6.getCachedRouterWalletPlatforms();
          return x2`<w3m-modal-header title="${t6}" .onAction="${s6.handleUriCopy}" .actionIcon="${w6.COPY_ICON}" data-testid="view-mobile-qr-connecting-header"></w3m-modal-header><w3m-modal-content data-testid="view-mobile-qr-connecting-content"><w3m-walletconnect-qr walletId="${a6}" imageId="${o9}"></w3m-walletconnect-qr></w3m-modal-content><w3m-info-footer data-testid="view-mobile-qr-connecting-footer"><w3m-text color="secondary" variant="small-thin">${`Scan this QR Code with your phone's camera or inside ${t6} app`}</w3m-text><w3m-platform-selection .isDesktop="${e9}" .isInjected="${r8}" .isWeb="${i7}"></w3m-platform-selection></w3m-info-footer>`;
        }
      };
      xe2.styles = [p7.globalCss, ri], xe2 = ni([e5("w3m-mobile-qr-connecting-view")], xe2);
      si = Object.defineProperty;
      ci = Object.getOwnPropertyDescriptor;
      di = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? ci(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && si(a6, o9, e9), e9;
      };
      ye5 = class extends s5 {
        render() {
          return x2`<w3m-modal-header title="Scan the code" .onAction="${s6.handleUriCopy}" .actionIcon="${w6.COPY_ICON}"></w3m-modal-header><w3m-modal-content><w3m-walletconnect-qr></w3m-walletconnect-qr></w3m-modal-content>`;
        }
      };
      ye5.styles = [p7.globalCss], ye5 = di([e5("w3m-qrcode-view")], ye5);
      mi = i2`div{display:grid;grid-template-columns:repeat(4,80px);margin:-5px -10px;justify-content:space-between}w3m-info-footer{flex-direction:column;align-items:center;display:flex;width:100%;padding:5px 0}w3m-info-footer w3m-text{text-align:center}`;
      Fe4 = Object.defineProperty;
      hi = Object.defineProperties;
      wi = Object.getOwnPropertyDescriptor;
      pi = Object.getOwnPropertyDescriptors;
      Ue4 = Object.getOwnPropertySymbols;
      gi = Object.prototype.hasOwnProperty;
      ui = Object.prototype.propertyIsEnumerable;
      Ve4 = (t6, a6, o9) => a6 in t6 ? Fe4(t6, a6, { enumerable: true, configurable: true, writable: true, value: o9 }) : t6[a6] = o9;
      vi = (t6, a6) => {
        for (var o9 in a6 || (a6 = {}))
          gi.call(a6, o9) && Ve4(t6, o9, a6[o9]);
        if (Ue4)
          for (var o9 of Ue4(a6))
            ui.call(a6, o9) && Ve4(t6, o9, a6[o9]);
        return t6;
      };
      bi = (t6, a6) => hi(t6, pi(a6));
      Ce3 = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? wi(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && Fe4(a6, o9, e9), e9;
      };
      Mt4 = class extends s5 {
        constructor() {
          super(), this.connectedChains = "ALL", this.isUnsupportedChains = false, this.getConnectedChainIds();
        }
        async getConnectedChainIds() {
          this.connectedChains = await f5.client().getConnectedChainIds();
        }
        async onSelectChain(t6) {
          try {
            const { selectedChain: a6, isPreferInjected: o9 } = b6.state, { isConnected: r8 } = q5.state;
            r8 ? a6?.id === t6.id ? W7.reset("Account") : s6.getWagmiWalletType() === '"walletConnect"' ? (await f5.client().switchNetwork({ chainId: t6.id }), W7.reset("Account")) : W7.push("SwitchNetwork", { SwitchNetwork: t6 }) : o9 ? (b6.setSelectedChain(t6), pe3.close()) : (b6.setSelectedChain(t6), W7.push("ConnectWallet"));
          } catch (a6) {
            console.error(a6), ge4.openToast("Unsupported chain", "error");
          }
        }
        isUnsuportedChainId(t6) {
          return typeof this.connectedChains == "string" && this.connectedChains !== "ALL" ? (this.isUnsupportedChains = true, true) : Array.isArray(this.connectedChains) && !this.connectedChains.includes(String(t6)) ? (this.isUnsupportedChains = true, true) : false;
        }
        render() {
          const { chains: t6 } = b6.state, a6 = t6?.map((r8) => bi(vi({}, r8), { unsupported: this.isUnsuportedChainId(r8.id) })), o9 = a6?.sort((r8, e9) => Number(r8.unsupported) - Number(e9.unsupported));
          return x2`<w3m-modal-header title="Select network" data-testid="view-select-network-header"></w3m-modal-header><w3m-modal-content data-testid="view-select-network-content"><div>${o9?.map((r8) => x2`<w3m-network-button name="${r8.name}" chainId="${r8.id}" .unsupported="${r8.unsupported}" .onClick="${async () => this.onSelectChain(r8)}" data-testid="view-select-network-button-${r8.id}">${r8.name}</w3m-network-button>`)}</div></w3m-modal-content>${this.isUnsupportedChains ? x2`<w3m-info-footer><w3m-text color="secondary" variant="small-thin">Your connected wallet may not support some of the networks available for this dapp</w3m-text></w3m-info-footer>` : null}`;
        }
      };
      Mt4.styles = [p7.globalCss, mi], Ce3([t4()], Mt4.prototype, "connectedChains", 2), Ce3([t4()], Mt4.prototype, "isUnsupportedChains", 2), Mt4 = Ce3([e5("w3m-select-network-view")], Mt4);
      fi = i2`w3m-info-footer{flex-direction:column;align-items:center;display:flex;width:100%;padding:5px 0}w3m-text{text-align:center}w3m-button{margin-top:15px}`;
      xi = Object.defineProperty;
      yi = Object.getOwnPropertyDescriptor;
      ze3 = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? yi(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && xi(a6, o9, e9), e9;
      };
      qt4 = class extends s5 {
        constructor() {
          super(), this.isError = false, this.onSwitchNetwork();
        }
        async onSwitchNetwork() {
          try {
            this.isError = false;
            const t6 = i6.getSwitchNetworkRouterData();
            await f5.client().switchNetwork({ chainId: t6.id }), b6.setSelectedChain(t6), W7.reset("Account");
          } catch {
            this.isError = true;
          }
        }
        render() {
          const { id: t6, name: a6 } = i6.getSwitchNetworkRouterData();
          return x2`<w3m-modal-header title="${`Connect to ${a6}`}" data-testid="view-switch-network-header"></w3m-modal-header><w3m-modal-content data-testid="view-switch-network-content"><w3m-network-waiting chainId="${t6}" label="Approve in your wallet" .isError="${this.isError}"></w3m-network-waiting></w3m-modal-content><w3m-info-footer data-testid="view-switch-network-footer"><w3m-text color="secondary" variant="small-thin">Switch can be declined if chain is not supported by a wallet or previous request is still active</w3m-text><w3m-button .onClick="${this.onSwitchNetwork.bind(this)}" .disabled="${!this.isError}" .iconRight="${w6.RETRY_ICON}" data-testid="view-switch-network-retry-button">Try Again</w3m-button></w3m-info-footer>`;
        }
      };
      qt4.styles = [p7.globalCss, fi], ze3([t4()], qt4.prototype, "isError", 2), qt4 = ze3([e5("w3m-switch-network-view")], qt4);
      Ci = i2`w3m-modal-content{height:clamp(200px,60vh,600px);display:block;overflow:scroll;scrollbar-width:none;position:relative;margin-top:1px}.w3m-grid{display:grid;grid-template-columns:repeat(4,80px);justify-content:space-between;margin:-15px -10px;padding-top:20px}w3m-modal-content::after,w3m-modal-content::before{content:'';position:fixed;pointer-events:none;z-index:1;width:100%;height:20px;opacity:1}w3m-modal-content::before{box-shadow:0 -1px 0 0 var(--w3m-color-bg-1);background:linear-gradient(var(--w3m-color-bg-1),rgba(255,255,255,0))}w3m-modal-content::after{box-shadow:0 1px 0 0 var(--w3m-color-bg-1);background:linear-gradient(rgba(255,255,255,0),var(--w3m-color-bg-1));top:calc(100% - 20px)}w3m-modal-content::-webkit-scrollbar{display:none}.w3m-placeholder-block{display:flex;justify-content:center;align-items:center;height:100px;overflow:hidden}.w3m-empty,.w3m-loading{display:flex}.w3m-loading .w3m-placeholder-block{height:100%}.w3m-end-reached .w3m-placeholder-block{height:0;opacity:0}.w3m-empty .w3m-placeholder-block{opacity:1;height:100%}w3m-wallet-button{margin:calc((100% - 60px)/ 3) 0}`;
      $i = Object.defineProperty;
      ki = Object.getOwnPropertyDescriptor;
      Pt4 = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? ki(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && $i(a6, o9, e9), e9;
      };
      $e4 = 40;
      ot4 = class extends s5 {
        constructor() {
          super(...arguments), this.loading = !de6.state.wallets.listings.length, this.firstFetch = !de6.state.wallets.listings.length, this.search = "", this.endReached = false, this.intersectionObserver = void 0, this.searchDebounce = s6.debounce((t6) => {
            t6.length >= 1 ? (this.firstFetch = true, this.endReached = false, this.search = t6, de6.resetSearch(), this.fetchWallets()) : this.search && (this.search = "", this.endReached = this.isLastPage(), de6.resetSearch());
          });
        }
        firstUpdated() {
          this.createPaginationObserver();
        }
        disconnectedCallback() {
          var t6;
          (t6 = this.intersectionObserver) == null || t6.disconnect();
        }
        get placeholderEl() {
          return s6.getShadowRootElement(this, ".w3m-placeholder-block");
        }
        createPaginationObserver() {
          this.intersectionObserver = new IntersectionObserver(([t6]) => {
            t6.isIntersecting && !(this.search && this.firstFetch) && this.fetchWallets();
          }), this.intersectionObserver.observe(this.placeholderEl);
        }
        isLastPage() {
          const { wallets: t6, search: a6 } = de6.state, { listings: o9, total: r8 } = this.search ? a6 : t6;
          return r8 <= $e4 || o9.length >= r8;
        }
        async fetchWallets() {
          const { wallets: t6, search: a6, injectedWallets: o9 } = de6.state, { listings: r8, total: e9, page: i7 } = this.search ? a6 : t6;
          if (!this.endReached && (this.firstFetch || e9 > $e4 && r8.length < e9))
            try {
              this.loading = true;
              const { listings: l9 } = await de6.getWallets({ page: this.firstFetch ? 1 : i7 + 1, entries: $e4, search: this.search, version: 2 }), d7 = l9.map((x4) => s6.getWalletIcon(x4)), v6 = o9.map((x4) => s6.getWalletIcon(x4));
              await Promise.all([...d7.map(async (x4) => s6.preloadImage(x4)), ...v6.map(async (x4) => s6.preloadImage(x4)), i6.wait(300)]), this.endReached = this.isLastPage();
            } catch (l9) {
              console.error(l9), ge4.openToast(s6.getErrorMessage(l9), "error");
            } finally {
              this.loading = false, this.firstFetch = false;
            }
        }
        onConnect(t6) {
          i6.isAndroid() ? s6.handleMobileLinking(t6) : s6.goToConnectingView(t6);
        }
        onSearchChange(t6) {
          const { value: a6 } = t6.target;
          this.searchDebounce(a6);
        }
        render() {
          const { wallets: t6, search: a6 } = de6.state, { listings: o9 } = this.search ? a6 : t6, r8 = this.loading && !o9.length, e9 = this.search.length >= 3;
          let i7 = P6.injectedWalletsTemplate(), l9 = P6.manualWalletsTemplate(), d7 = P6.recomendedWalletsTemplate(true);
          e9 && (i7 = i7.filter(({ values: Z7 }) => s6.caseSafeIncludes(Z7[0], this.search)), l9 = l9.filter(({ values: Z7 }) => s6.caseSafeIncludes(Z7[0], this.search)), d7 = d7.filter(({ values: Z7 }) => s6.caseSafeIncludes(Z7[0], this.search))), i7 = i7.filter((Z7) => !d7.find((_8) => s6.caseSafeIncludes(Z7.values[0], _8.values[0])));
          const v6 = !this.loading && !o9.length && !i7.length && !d7.length, x4 = Math.max(i7.length, o9.length), H5 = { "w3m-loading": r8, "w3m-end-reached": this.endReached || !this.loading, "w3m-empty": v6 };
          return x2`<w3m-modal-header data-testid="view-wallet-explorer-header"><w3m-search-input .onChange="${this.onSearchChange.bind(this)}"></w3m-search-input></w3m-modal-header><w3m-modal-content class="${o7(H5)}" data-testid="view-wallet-explorer-content"><div class="w3m-grid">${r8 ? null : d7} ${r8 ? null : [...Array(x4)].map((Z7, _8) => x2`${l9[_8]} ${i7[_8]} ${o9[_8] ? x2`<w3m-wallet-button imageId="${o9[_8].image_id}" name="${o9[_8].name}" walletId="${o9[_8].id}" .onClick="${() => this.onConnect(o9[_8])}" data-testid="view-wallet-explorer-button-${o9[_8].id}"></w3m-wallet-button>` : null}`)}</div><div class="w3m-placeholder-block">${v6 ? x2`<w3m-text variant="big-bold" color="secondary">No results found</w3m-text>` : null} ${!v6 && this.loading ? x2`<w3m-spinner></w3m-spinner>` : null}</div></w3m-modal-content>`;
        }
      };
      ot4.styles = [p7.globalCss, Ci], Pt4([t4()], ot4.prototype, "loading", 2), Pt4([t4()], ot4.prototype, "firstFetch", 2), Pt4([t4()], ot4.prototype, "search", 2), Pt4([t4()], ot4.prototype, "endReached", 2), ot4 = Pt4([e5("w3m-wallet-explorer-view")], ot4);
      Oi = i2`w3m-info-footer{flex-direction:column;align-items:center;display:flex;width:100%;padding:5px 0}w3m-text{text-align:center}`;
      Ii = Object.defineProperty;
      Ei = Object.getOwnPropertyDescriptor;
      Ge4 = (t6, a6, o9, r8) => {
        for (var e9 = r8 > 1 ? void 0 : r8 ? Ei(a6, o9) : a6, i7 = t6.length - 1, l9; i7 >= 0; i7--)
          (l9 = t6[i7]) && (e9 = (r8 ? l9(a6, o9, e9) : l9(e9)) || e9);
        return r8 && e9 && Ii(a6, o9, e9), e9;
      };
      Kt4 = class extends s5 {
        constructor() {
          super(), this.isError = false, this.unwatchConnection = void 0, this.openWebWallet(), this.unwatchConnection = P5.subscribe((t6) => {
            this.isError = t6.pairingError;
          });
        }
        disconnectedCallback() {
          var t6;
          (t6 = this.unwatchConnection) == null || t6.call(this);
        }
        onFormatAndRedirect(t6) {
          const { desktop: a6, name: o9 } = i6.getWalletRouterData(), r8 = a6?.universal;
          if (r8) {
            const e9 = i6.formatUniversalUrl(r8, t6, o9);
            i6.openHref(e9, "_blank");
          }
        }
        openWebWallet() {
          P5.setPairingError(false);
          const { pairingUri: t6 } = P5.state, a6 = i6.getWalletRouterData();
          s6.setRecentWallet(a6), this.onFormatAndRedirect(t6);
        }
        render() {
          const { name: t6, id: a6, image_id: o9 } = i6.getWalletRouterData(), { isMobile: r8, isInjected: e9, isDesktop: i7 } = s6.getCachedRouterWalletPlatforms(), l9 = i6.isMobile();
          return x2`<w3m-modal-header title="${t6}" .onAction="${s6.handleUriCopy}" .actionIcon="${w6.COPY_ICON}" data-testid="view-web-connecting-header"></w3m-modal-header><w3m-modal-content data-testid="view-web-connecting-content"><w3m-connector-waiting walletId="${a6}" imageId="${o9}" label="${`Continue in ${t6}...`}" .isError="${this.isError}" data-testid="view-web-connecting-waiting"></w3m-connector-waiting></w3m-modal-content><w3m-info-footer data-testid="view-web-connecting-footer"><w3m-text color="secondary" variant="small-thin">${`${t6} web app has opened in a new tab. Go there, accept the connection, and come back`}</w3m-text><w3m-platform-selection .isMobile="${r8}" .isInjected="${l9 ? false : e9}" .isDesktop="${l9 ? false : i7}" .isRetry="${true}"><w3m-button .onClick="${this.openWebWallet.bind(this)}" .iconRight="${w6.RETRY_ICON}" data-testid="view-web-connecting-retry-button">Retry</w3m-button></w3m-platform-selection></w3m-info-footer>`;
        }
      };
      Kt4.styles = [p7.globalCss, Oi], Ge4([t4()], Kt4.prototype, "isError", 2), Kt4 = Ge4([e5("w3m-web-connecting-view")], Kt4);
    }
  });

  // node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
  var require_use_sync_external_store_shim_development = __commonJS({
    "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
          }
          var React43 = require_react();
          var ReactSharedInternals = React43.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
          function error(format2) {
            {
              {
                for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                  args[_key2 - 1] = arguments[_key2];
                }
                printWarning("error", format2, args);
              }
            }
          }
          function printWarning(level, format2, args) {
            {
              var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
              var stack = ReactDebugCurrentFrame.getStackAddendum();
              if (stack !== "") {
                format2 += "%s";
                args = args.concat([stack]);
              }
              var argsWithFormat = args.map(function(item) {
                return String(item);
              });
              argsWithFormat.unshift("Warning: " + format2);
              Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
          }
          function is2(x4, y11) {
            return x4 === y11 && (x4 !== 0 || 1 / x4 === 1 / y11) || x4 !== x4 && y11 !== y11;
          }
          var objectIs = typeof Object.is === "function" ? Object.is : is2;
          var useState4 = React43.useState, useEffect11 = React43.useEffect, useLayoutEffect = React43.useLayoutEffect, useDebugValue2 = React43.useDebugValue;
          var didWarnOld18Alpha = false;
          var didWarnUncachedGetSnapshot = false;
          function useSyncExternalStore3(subscribe3, getSnapshot, getServerSnapshot) {
            {
              if (!didWarnOld18Alpha) {
                if (React43.startTransition !== void 0) {
                  didWarnOld18Alpha = true;
                  error("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.");
                }
              }
            }
            var value = getSnapshot();
            {
              if (!didWarnUncachedGetSnapshot) {
                var cachedValue = getSnapshot();
                if (!objectIs(value, cachedValue)) {
                  error("The result of getSnapshot should be cached to avoid an infinite loop");
                  didWarnUncachedGetSnapshot = true;
                }
              }
            }
            var _useState = useState4({
              inst: {
                value,
                getSnapshot
              }
            }), inst = _useState[0].inst, forceUpdate = _useState[1];
            useLayoutEffect(function() {
              inst.value = value;
              inst.getSnapshot = getSnapshot;
              if (checkIfSnapshotChanged(inst)) {
                forceUpdate({
                  inst
                });
              }
            }, [subscribe3, value, getSnapshot]);
            useEffect11(function() {
              if (checkIfSnapshotChanged(inst)) {
                forceUpdate({
                  inst
                });
              }
              var handleStoreChange = function() {
                if (checkIfSnapshotChanged(inst)) {
                  forceUpdate({
                    inst
                  });
                }
              };
              return subscribe3(handleStoreChange);
            }, [subscribe3]);
            useDebugValue2(value);
            return value;
          }
          function checkIfSnapshotChanged(inst) {
            var latestGetSnapshot = inst.getSnapshot;
            var prevValue = inst.value;
            try {
              var nextValue = latestGetSnapshot();
              return !objectIs(prevValue, nextValue);
            } catch (error2) {
              return true;
            }
          }
          function useSyncExternalStore$12(subscribe3, getSnapshot, getServerSnapshot) {
            return getSnapshot();
          }
          var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
          var isServerEnvironment = !canUseDOM;
          var shim = isServerEnvironment ? useSyncExternalStore$12 : useSyncExternalStore3;
          var useSyncExternalStore$2 = React43.useSyncExternalStore !== void 0 ? React43.useSyncExternalStore : shim;
          exports.useSyncExternalStore = useSyncExternalStore$2;
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
          }
        })();
      }
    }
  });

  // node_modules/use-sync-external-store/shim/index.js
  var require_shim = __commonJS({
    "node_modules/use-sync-external-store/shim/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_use_sync_external_store_shim_development();
      }
    }
  });

  // node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js
  var require_with_selector_development = __commonJS({
    "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
          }
          var React43 = require_react();
          var shim = require_shim();
          function is2(x4, y11) {
            return x4 === y11 && (x4 !== 0 || 1 / x4 === 1 / y11) || x4 !== x4 && y11 !== y11;
          }
          var objectIs = typeof Object.is === "function" ? Object.is : is2;
          var useSyncExternalStore3 = shim.useSyncExternalStore;
          var useRef4 = React43.useRef, useEffect11 = React43.useEffect, useMemo7 = React43.useMemo, useDebugValue2 = React43.useDebugValue;
          function useSyncExternalStoreWithSelector5(subscribe3, getSnapshot, getServerSnapshot, selector, isEqual) {
            var instRef = useRef4(null);
            var inst;
            if (instRef.current === null) {
              inst = {
                hasValue: false,
                value: null
              };
              instRef.current = inst;
            } else {
              inst = instRef.current;
            }
            var _useMemo = useMemo7(function() {
              var hasMemo = false;
              var memoizedSnapshot;
              var memoizedSelection;
              var memoizedSelector = function(nextSnapshot) {
                if (!hasMemo) {
                  hasMemo = true;
                  memoizedSnapshot = nextSnapshot;
                  var _nextSelection = selector(nextSnapshot);
                  if (isEqual !== void 0) {
                    if (inst.hasValue) {
                      var currentSelection = inst.value;
                      if (isEqual(currentSelection, _nextSelection)) {
                        memoizedSelection = currentSelection;
                        return currentSelection;
                      }
                    }
                  }
                  memoizedSelection = _nextSelection;
                  return _nextSelection;
                }
                var prevSnapshot = memoizedSnapshot;
                var prevSelection = memoizedSelection;
                if (objectIs(prevSnapshot, nextSnapshot)) {
                  return prevSelection;
                }
                var nextSelection = selector(nextSnapshot);
                if (isEqual !== void 0 && isEqual(prevSelection, nextSelection)) {
                  return prevSelection;
                }
                memoizedSnapshot = nextSnapshot;
                memoizedSelection = nextSelection;
                return nextSelection;
              };
              var maybeGetServerSnapshot = getServerSnapshot === void 0 ? null : getServerSnapshot;
              var getSnapshotWithSelector = function() {
                return memoizedSelector(getSnapshot());
              };
              var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? void 0 : function() {
                return memoizedSelector(maybeGetServerSnapshot());
              };
              return [getSnapshotWithSelector, getServerSnapshotWithSelector];
            }, [getSnapshot, getServerSnapshot, selector, isEqual]), getSelection = _useMemo[0], getServerSelection = _useMemo[1];
            var value = useSyncExternalStore3(subscribe3, getSelection, getServerSelection);
            useEffect11(function() {
              inst.hasValue = true;
              inst.value = value;
            }, [value]);
            useDebugValue2(value);
            return value;
          }
          exports.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector5;
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
          }
        })();
      }
    }
  });

  // node_modules/use-sync-external-store/shim/with-selector.js
  var require_with_selector = __commonJS({
    "node_modules/use-sync-external-store/shim/with-selector.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_with_selector_development();
      }
    }
  });

  // node_modules/requires-port/index.js
  var require_requires_port = __commonJS({
    "node_modules/requires-port/index.js"(exports, module) {
      "use strict";
      module.exports = function required(port, protocol2) {
        protocol2 = protocol2.split(":")[0];
        port = +port;
        if (!port)
          return false;
        switch (protocol2) {
          case "http":
          case "ws":
            return port !== 80;
          case "https":
          case "wss":
            return port !== 443;
          case "ftp":
            return port !== 21;
          case "gopher":
            return port !== 70;
          case "file":
            return false;
        }
        return port !== 0;
      };
    }
  });

  // node_modules/querystringify/index.js
  var require_querystringify = __commonJS({
    "node_modules/querystringify/index.js"(exports) {
      "use strict";
      var has = Object.prototype.hasOwnProperty;
      var undef;
      function decode8(input) {
        try {
          return decodeURIComponent(input.replace(/\+/g, " "));
        } catch (e9) {
          return null;
        }
      }
      function encode10(input) {
        try {
          return encodeURIComponent(input);
        } catch (e9) {
          return null;
        }
      }
      function querystring(query) {
        var parser2 = /([^=?#&]+)=?([^&]*)/g, result = {}, part;
        while (part = parser2.exec(query)) {
          var key2 = decode8(part[1]), value = decode8(part[2]);
          if (key2 === null || value === null || key2 in result)
            continue;
          result[key2] = value;
        }
        return result;
      }
      function querystringify(obj, prefix) {
        prefix = prefix || "";
        var pairs = [], value, key2;
        if ("string" !== typeof prefix)
          prefix = "?";
        for (key2 in obj) {
          if (has.call(obj, key2)) {
            value = obj[key2];
            if (!value && (value === null || value === undef || isNaN(value))) {
              value = "";
            }
            key2 = encode10(key2);
            value = encode10(value);
            if (key2 === null || value === null)
              continue;
            pairs.push(key2 + "=" + value);
          }
        }
        return pairs.length ? prefix + pairs.join("&") : "";
      }
      exports.stringify = querystringify;
      exports.parse = querystring;
    }
  });

  // node_modules/url-parse/index.js
  var require_url_parse = __commonJS({
    "node_modules/url-parse/index.js"(exports, module) {
      "use strict";
      var required = require_requires_port();
      var qs2 = require_querystringify();
      var controlOrWhitespace = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/;
      var CRHTLF = /[\n\r\t]/g;
      var slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//;
      var port = /:\d+$/;
      var protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i;
      var windowsDriveLetter = /^[a-zA-Z]:/;
      function trimLeft(str) {
        return (str ? str : "").toString().replace(controlOrWhitespace, "");
      }
      var rules = [
        ["#", "hash"],
        // Extract from the back.
        ["?", "query"],
        // Extract from the back.
        function sanitize(address, url) {
          return isSpecial(url.protocol) ? address.replace(/\\/g, "/") : address;
        },
        ["/", "pathname"],
        // Extract from the back.
        ["@", "auth", 1],
        // Extract from the front.
        [NaN, "host", void 0, 1, 1],
        // Set left over value.
        [/:(\d*)$/, "port", void 0, 1],
        // RegExp the back.
        [NaN, "hostname", void 0, 1, 1]
        // Set left over.
      ];
      var ignore = { hash: 1, query: 1 };
      function lolcation(loc) {
        var globalVar;
        if (typeof window !== "undefined")
          globalVar = window;
        else if (typeof global !== "undefined")
          globalVar = global;
        else if (typeof self !== "undefined")
          globalVar = self;
        else
          globalVar = {};
        var location2 = globalVar.location || {};
        loc = loc || location2;
        var finaldestination = {}, type = typeof loc, key2;
        if ("blob:" === loc.protocol) {
          finaldestination = new Url(unescape(loc.pathname), {});
        } else if ("string" === type) {
          finaldestination = new Url(loc, {});
          for (key2 in ignore)
            delete finaldestination[key2];
        } else if ("object" === type) {
          for (key2 in loc) {
            if (key2 in ignore)
              continue;
            finaldestination[key2] = loc[key2];
          }
          if (finaldestination.slashes === void 0) {
            finaldestination.slashes = slashes.test(loc.href);
          }
        }
        return finaldestination;
      }
      function isSpecial(scheme) {
        return scheme === "file:" || scheme === "ftp:" || scheme === "http:" || scheme === "https:" || scheme === "ws:" || scheme === "wss:";
      }
      function extractProtocol(address, location2) {
        address = trimLeft(address);
        address = address.replace(CRHTLF, "");
        location2 = location2 || {};
        var match = protocolre.exec(address);
        var protocol2 = match[1] ? match[1].toLowerCase() : "";
        var forwardSlashes = !!match[2];
        var otherSlashes = !!match[3];
        var slashesCount = 0;
        var rest;
        if (forwardSlashes) {
          if (otherSlashes) {
            rest = match[2] + match[3] + match[4];
            slashesCount = match[2].length + match[3].length;
          } else {
            rest = match[2] + match[4];
            slashesCount = match[2].length;
          }
        } else {
          if (otherSlashes) {
            rest = match[3] + match[4];
            slashesCount = match[3].length;
          } else {
            rest = match[4];
          }
        }
        if (protocol2 === "file:") {
          if (slashesCount >= 2) {
            rest = rest.slice(2);
          }
        } else if (isSpecial(protocol2)) {
          rest = match[4];
        } else if (protocol2) {
          if (forwardSlashes) {
            rest = rest.slice(2);
          }
        } else if (slashesCount >= 2 && isSpecial(location2.protocol)) {
          rest = match[4];
        }
        return {
          protocol: protocol2,
          slashes: forwardSlashes || isSpecial(protocol2),
          slashesCount,
          rest
        };
      }
      function resolve(relative, base4) {
        if (relative === "")
          return base4;
        var path = (base4 || "/").split("/").slice(0, -1).concat(relative.split("/")), i7 = path.length, last = path[i7 - 1], unshift = false, up = 0;
        while (i7--) {
          if (path[i7] === ".") {
            path.splice(i7, 1);
          } else if (path[i7] === "..") {
            path.splice(i7, 1);
            up++;
          } else if (up) {
            if (i7 === 0)
              unshift = true;
            path.splice(i7, 1);
            up--;
          }
        }
        if (unshift)
          path.unshift("");
        if (last === "." || last === "..")
          path.push("");
        return path.join("/");
      }
      function Url(address, location2, parser2) {
        address = trimLeft(address);
        address = address.replace(CRHTLF, "");
        if (!(this instanceof Url)) {
          return new Url(address, location2, parser2);
        }
        var relative, extracted, parse4, instruction, index2, key2, instructions = rules.slice(), type = typeof location2, url = this, i7 = 0;
        if ("object" !== type && "string" !== type) {
          parser2 = location2;
          location2 = null;
        }
        if (parser2 && "function" !== typeof parser2)
          parser2 = qs2.parse;
        location2 = lolcation(location2);
        extracted = extractProtocol(address || "", location2);
        relative = !extracted.protocol && !extracted.slashes;
        url.slashes = extracted.slashes || relative && location2.slashes;
        url.protocol = extracted.protocol || location2.protocol || "";
        address = extracted.rest;
        if (extracted.protocol === "file:" && (extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) || !extracted.slashes && (extracted.protocol || extracted.slashesCount < 2 || !isSpecial(url.protocol))) {
          instructions[3] = [/(.*)/, "pathname"];
        }
        for (; i7 < instructions.length; i7++) {
          instruction = instructions[i7];
          if (typeof instruction === "function") {
            address = instruction(address, url);
            continue;
          }
          parse4 = instruction[0];
          key2 = instruction[1];
          if (parse4 !== parse4) {
            url[key2] = address;
          } else if ("string" === typeof parse4) {
            index2 = parse4 === "@" ? address.lastIndexOf(parse4) : address.indexOf(parse4);
            if (~index2) {
              if ("number" === typeof instruction[2]) {
                url[key2] = address.slice(0, index2);
                address = address.slice(index2 + instruction[2]);
              } else {
                url[key2] = address.slice(index2);
                address = address.slice(0, index2);
              }
            }
          } else if (index2 = parse4.exec(address)) {
            url[key2] = index2[1];
            address = address.slice(0, index2.index);
          }
          url[key2] = url[key2] || (relative && instruction[3] ? location2[key2] || "" : "");
          if (instruction[4])
            url[key2] = url[key2].toLowerCase();
        }
        if (parser2)
          url.query = parser2(url.query);
        if (relative && location2.slashes && url.pathname.charAt(0) !== "/" && (url.pathname !== "" || location2.pathname !== "")) {
          url.pathname = resolve(url.pathname, location2.pathname);
        }
        if (url.pathname.charAt(0) !== "/" && isSpecial(url.protocol)) {
          url.pathname = "/" + url.pathname;
        }
        if (!required(url.port, url.protocol)) {
          url.host = url.hostname;
          url.port = "";
        }
        url.username = url.password = "";
        if (url.auth) {
          index2 = url.auth.indexOf(":");
          if (~index2) {
            url.username = url.auth.slice(0, index2);
            url.username = encodeURIComponent(decodeURIComponent(url.username));
            url.password = url.auth.slice(index2 + 1);
            url.password = encodeURIComponent(decodeURIComponent(url.password));
          } else {
            url.username = encodeURIComponent(decodeURIComponent(url.auth));
          }
          url.auth = url.password ? url.username + ":" + url.password : url.username;
        }
        url.origin = url.protocol !== "file:" && isSpecial(url.protocol) && url.host ? url.protocol + "//" + url.host : "null";
        url.href = url.toString();
      }
      function set2(part, value, fn2) {
        var url = this;
        switch (part) {
          case "query":
            if ("string" === typeof value && value.length) {
              value = (fn2 || qs2.parse)(value);
            }
            url[part] = value;
            break;
          case "port":
            url[part] = value;
            if (!required(value, url.protocol)) {
              url.host = url.hostname;
              url[part] = "";
            } else if (value) {
              url.host = url.hostname + ":" + value;
            }
            break;
          case "hostname":
            url[part] = value;
            if (url.port)
              value += ":" + url.port;
            url.host = value;
            break;
          case "host":
            url[part] = value;
            if (port.test(value)) {
              value = value.split(":");
              url.port = value.pop();
              url.hostname = value.join(":");
            } else {
              url.hostname = value;
              url.port = "";
            }
            break;
          case "protocol":
            url.protocol = value.toLowerCase();
            url.slashes = !fn2;
            break;
          case "pathname":
          case "hash":
            if (value) {
              var char = part === "pathname" ? "/" : "#";
              url[part] = value.charAt(0) !== char ? char + value : value;
            } else {
              url[part] = value;
            }
            break;
          case "username":
          case "password":
            url[part] = encodeURIComponent(value);
            break;
          case "auth":
            var index2 = value.indexOf(":");
            if (~index2) {
              url.username = value.slice(0, index2);
              url.username = encodeURIComponent(decodeURIComponent(url.username));
              url.password = value.slice(index2 + 1);
              url.password = encodeURIComponent(decodeURIComponent(url.password));
            } else {
              url.username = encodeURIComponent(decodeURIComponent(value));
            }
        }
        for (var i7 = 0; i7 < rules.length; i7++) {
          var ins = rules[i7];
          if (ins[4])
            url[ins[1]] = url[ins[1]].toLowerCase();
        }
        url.auth = url.password ? url.username + ":" + url.password : url.username;
        url.origin = url.protocol !== "file:" && isSpecial(url.protocol) && url.host ? url.protocol + "//" + url.host : "null";
        url.href = url.toString();
        return url;
      }
      function toString5(stringify5) {
        if (!stringify5 || "function" !== typeof stringify5)
          stringify5 = qs2.stringify;
        var query, url = this, host = url.host, protocol2 = url.protocol;
        if (protocol2 && protocol2.charAt(protocol2.length - 1) !== ":")
          protocol2 += ":";
        var result = protocol2 + (url.protocol && url.slashes || isSpecial(url.protocol) ? "//" : "");
        if (url.username) {
          result += url.username;
          if (url.password)
            result += ":" + url.password;
          result += "@";
        } else if (url.password) {
          result += ":" + url.password;
          result += "@";
        } else if (url.protocol !== "file:" && isSpecial(url.protocol) && !host && url.pathname !== "/") {
          result += "@";
        }
        if (host[host.length - 1] === ":" || port.test(url.hostname) && !url.port) {
          host += ":";
        }
        result += host + url.pathname;
        query = "object" === typeof url.query ? stringify5(url.query) : url.query;
        if (query)
          result += "?" !== query.charAt(0) ? "?" + query : query;
        if (url.hash)
          result += url.hash;
        return result;
      }
      Url.prototype = { set: set2, toString: toString5 };
      Url.extractProtocol = extractProtocol;
      Url.location = lolcation;
      Url.trimLeft = trimLeft;
      Url.qs = qs2;
      module.exports = Url;
    }
  });

  // (disabled):node_modules/buffer/index.js
  var require_buffer = __commonJS({
    "(disabled):node_modules/buffer/index.js"() {
    }
  });

  // node_modules/bn.js/lib/bn.js
  var require_bn = __commonJS({
    "node_modules/bn.js/lib/bn.js"(exports, module) {
      (function(module2, exports2) {
        "use strict";
        function assert3(val, msg) {
          if (!val)
            throw new Error(msg || "Assertion failed");
        }
        function inherits2(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
        function BN3(number2, base4, endian) {
          if (BN3.isBN(number2)) {
            return number2;
          }
          this.negative = 0;
          this.words = null;
          this.length = 0;
          this.red = null;
          if (number2 !== null) {
            if (base4 === "le" || base4 === "be") {
              endian = base4;
              base4 = 10;
            }
            this._init(number2 || 0, base4 || 10, endian || "be");
          }
        }
        if (typeof module2 === "object") {
          module2.exports = BN3;
        } else {
          exports2.BN = BN3;
        }
        BN3.BN = BN3;
        BN3.wordSize = 26;
        var Buffer2;
        try {
          if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
            Buffer2 = window.Buffer;
          } else {
            Buffer2 = require_buffer().Buffer;
          }
        } catch (e9) {
        }
        BN3.isBN = function isBN(num) {
          if (num instanceof BN3) {
            return true;
          }
          return num !== null && typeof num === "object" && num.constructor.wordSize === BN3.wordSize && Array.isArray(num.words);
        };
        BN3.max = function max(left, right) {
          if (left.cmp(right) > 0)
            return left;
          return right;
        };
        BN3.min = function min(left, right) {
          if (left.cmp(right) < 0)
            return left;
          return right;
        };
        BN3.prototype._init = function init2(number2, base4, endian) {
          if (typeof number2 === "number") {
            return this._initNumber(number2, base4, endian);
          }
          if (typeof number2 === "object") {
            return this._initArray(number2, base4, endian);
          }
          if (base4 === "hex") {
            base4 = 16;
          }
          assert3(base4 === (base4 | 0) && base4 >= 2 && base4 <= 36);
          number2 = number2.toString().replace(/\s+/g, "");
          var start = 0;
          if (number2[0] === "-") {
            start++;
            this.negative = 1;
          }
          if (start < number2.length) {
            if (base4 === 16) {
              this._parseHex(number2, start, endian);
            } else {
              this._parseBase(number2, base4, start);
              if (endian === "le") {
                this._initArray(this.toArray(), base4, endian);
              }
            }
          }
        };
        BN3.prototype._initNumber = function _initNumber(number2, base4, endian) {
          if (number2 < 0) {
            this.negative = 1;
            number2 = -number2;
          }
          if (number2 < 67108864) {
            this.words = [number2 & 67108863];
            this.length = 1;
          } else if (number2 < 4503599627370496) {
            this.words = [
              number2 & 67108863,
              number2 / 67108864 & 67108863
            ];
            this.length = 2;
          } else {
            assert3(number2 < 9007199254740992);
            this.words = [
              number2 & 67108863,
              number2 / 67108864 & 67108863,
              1
            ];
            this.length = 3;
          }
          if (endian !== "le")
            return;
          this._initArray(this.toArray(), base4, endian);
        };
        BN3.prototype._initArray = function _initArray(number2, base4, endian) {
          assert3(typeof number2.length === "number");
          if (number2.length <= 0) {
            this.words = [0];
            this.length = 1;
            return this;
          }
          this.length = Math.ceil(number2.length / 3);
          this.words = new Array(this.length);
          for (var i7 = 0; i7 < this.length; i7++) {
            this.words[i7] = 0;
          }
          var j7, w8;
          var off = 0;
          if (endian === "be") {
            for (i7 = number2.length - 1, j7 = 0; i7 >= 0; i7 -= 3) {
              w8 = number2[i7] | number2[i7 - 1] << 8 | number2[i7 - 2] << 16;
              this.words[j7] |= w8 << off & 67108863;
              this.words[j7 + 1] = w8 >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j7++;
              }
            }
          } else if (endian === "le") {
            for (i7 = 0, j7 = 0; i7 < number2.length; i7 += 3) {
              w8 = number2[i7] | number2[i7 + 1] << 8 | number2[i7 + 2] << 16;
              this.words[j7] |= w8 << off & 67108863;
              this.words[j7 + 1] = w8 >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j7++;
              }
            }
          }
          return this._strip();
        };
        function parseHex4Bits(string2, index2) {
          var c9 = string2.charCodeAt(index2);
          if (c9 >= 48 && c9 <= 57) {
            return c9 - 48;
          } else if (c9 >= 65 && c9 <= 70) {
            return c9 - 55;
          } else if (c9 >= 97 && c9 <= 102) {
            return c9 - 87;
          } else {
            assert3(false, "Invalid character in " + string2);
          }
        }
        function parseHexByte(string2, lowerBound, index2) {
          var r8 = parseHex4Bits(string2, index2);
          if (index2 - 1 >= lowerBound) {
            r8 |= parseHex4Bits(string2, index2 - 1) << 4;
          }
          return r8;
        }
        BN3.prototype._parseHex = function _parseHex(number2, start, endian) {
          this.length = Math.ceil((number2.length - start) / 6);
          this.words = new Array(this.length);
          for (var i7 = 0; i7 < this.length; i7++) {
            this.words[i7] = 0;
          }
          var off = 0;
          var j7 = 0;
          var w8;
          if (endian === "be") {
            for (i7 = number2.length - 1; i7 >= start; i7 -= 2) {
              w8 = parseHexByte(number2, start, i7) << off;
              this.words[j7] |= w8 & 67108863;
              if (off >= 18) {
                off -= 18;
                j7 += 1;
                this.words[j7] |= w8 >>> 26;
              } else {
                off += 8;
              }
            }
          } else {
            var parseLength = number2.length - start;
            for (i7 = parseLength % 2 === 0 ? start + 1 : start; i7 < number2.length; i7 += 2) {
              w8 = parseHexByte(number2, start, i7) << off;
              this.words[j7] |= w8 & 67108863;
              if (off >= 18) {
                off -= 18;
                j7 += 1;
                this.words[j7] |= w8 >>> 26;
              } else {
                off += 8;
              }
            }
          }
          this._strip();
        };
        function parseBase(str, start, end, mul3) {
          var r8 = 0;
          var b7 = 0;
          var len = Math.min(str.length, end);
          for (var i7 = start; i7 < len; i7++) {
            var c9 = str.charCodeAt(i7) - 48;
            r8 *= mul3;
            if (c9 >= 49) {
              b7 = c9 - 49 + 10;
            } else if (c9 >= 17) {
              b7 = c9 - 17 + 10;
            } else {
              b7 = c9;
            }
            assert3(c9 >= 0 && b7 < mul3, "Invalid character");
            r8 += b7;
          }
          return r8;
        }
        BN3.prototype._parseBase = function _parseBase(number2, base4, start) {
          this.words = [0];
          this.length = 1;
          for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base4) {
            limbLen++;
          }
          limbLen--;
          limbPow = limbPow / base4 | 0;
          var total = number2.length - start;
          var mod = total % limbLen;
          var end = Math.min(total, total - mod) + start;
          var word = 0;
          for (var i7 = start; i7 < end; i7 += limbLen) {
            word = parseBase(number2, i7, i7 + limbLen, base4);
            this.imuln(limbPow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          if (mod !== 0) {
            var pow = 1;
            word = parseBase(number2, i7, number2.length, base4);
            for (i7 = 0; i7 < mod; i7++) {
              pow *= base4;
            }
            this.imuln(pow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          this._strip();
        };
        BN3.prototype.copy = function copy(dest) {
          dest.words = new Array(this.length);
          for (var i7 = 0; i7 < this.length; i7++) {
            dest.words[i7] = this.words[i7];
          }
          dest.length = this.length;
          dest.negative = this.negative;
          dest.red = this.red;
        };
        function move(dest, src2) {
          dest.words = src2.words;
          dest.length = src2.length;
          dest.negative = src2.negative;
          dest.red = src2.red;
        }
        BN3.prototype._move = function _move(dest) {
          move(dest, this);
        };
        BN3.prototype.clone = function clone() {
          var r8 = new BN3(null);
          this.copy(r8);
          return r8;
        };
        BN3.prototype._expand = function _expand(size3) {
          while (this.length < size3) {
            this.words[this.length++] = 0;
          }
          return this;
        };
        BN3.prototype._strip = function strip() {
          while (this.length > 1 && this.words[this.length - 1] === 0) {
            this.length--;
          }
          return this._normSign();
        };
        BN3.prototype._normSign = function _normSign() {
          if (this.length === 1 && this.words[0] === 0) {
            this.negative = 0;
          }
          return this;
        };
        if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
          try {
            BN3.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect4;
          } catch (e9) {
            BN3.prototype.inspect = inspect4;
          }
        } else {
          BN3.prototype.inspect = inspect4;
        }
        function inspect4() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        }
        var zeros2 = [
          "",
          "0",
          "00",
          "000",
          "0000",
          "00000",
          "000000",
          "0000000",
          "00000000",
          "000000000",
          "0000000000",
          "00000000000",
          "000000000000",
          "0000000000000",
          "00000000000000",
          "000000000000000",
          "0000000000000000",
          "00000000000000000",
          "000000000000000000",
          "0000000000000000000",
          "00000000000000000000",
          "000000000000000000000",
          "0000000000000000000000",
          "00000000000000000000000",
          "000000000000000000000000",
          "0000000000000000000000000"
        ];
        var groupSizes = [
          0,
          0,
          25,
          16,
          12,
          11,
          10,
          9,
          8,
          8,
          7,
          7,
          7,
          7,
          6,
          6,
          6,
          6,
          6,
          6,
          6,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5
        ];
        var groupBases = [
          0,
          0,
          33554432,
          43046721,
          16777216,
          48828125,
          60466176,
          40353607,
          16777216,
          43046721,
          1e7,
          19487171,
          35831808,
          62748517,
          7529536,
          11390625,
          16777216,
          24137569,
          34012224,
          47045881,
          64e6,
          4084101,
          5153632,
          6436343,
          7962624,
          9765625,
          11881376,
          14348907,
          17210368,
          20511149,
          243e5,
          28629151,
          33554432,
          39135393,
          45435424,
          52521875,
          60466176
        ];
        BN3.prototype.toString = function toString5(base4, padding2) {
          base4 = base4 || 10;
          padding2 = padding2 | 0 || 1;
          var out;
          if (base4 === 16 || base4 === "hex") {
            out = "";
            var off = 0;
            var carry = 0;
            for (var i7 = 0; i7 < this.length; i7++) {
              var w8 = this.words[i7];
              var word = ((w8 << off | carry) & 16777215).toString(16);
              carry = w8 >>> 24 - off & 16777215;
              off += 2;
              if (off >= 26) {
                off -= 26;
                i7--;
              }
              if (carry !== 0 || i7 !== this.length - 1) {
                out = zeros2[6 - word.length] + word + out;
              } else {
                out = word + out;
              }
            }
            if (carry !== 0) {
              out = carry.toString(16) + out;
            }
            while (out.length % padding2 !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          if (base4 === (base4 | 0) && base4 >= 2 && base4 <= 36) {
            var groupSize = groupSizes[base4];
            var groupBase = groupBases[base4];
            out = "";
            var c9 = this.clone();
            c9.negative = 0;
            while (!c9.isZero()) {
              var r8 = c9.modrn(groupBase).toString(base4);
              c9 = c9.idivn(groupBase);
              if (!c9.isZero()) {
                out = zeros2[groupSize - r8.length] + r8 + out;
              } else {
                out = r8 + out;
              }
            }
            if (this.isZero()) {
              out = "0" + out;
            }
            while (out.length % padding2 !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          assert3(false, "Base should be between 2 and 36");
        };
        BN3.prototype.toNumber = function toNumber() {
          var ret = this.words[0];
          if (this.length === 2) {
            ret += this.words[1] * 67108864;
          } else if (this.length === 3 && this.words[2] === 1) {
            ret += 4503599627370496 + this.words[1] * 67108864;
          } else if (this.length > 2) {
            assert3(false, "Number can only safely store up to 53 bits");
          }
          return this.negative !== 0 ? -ret : ret;
        };
        BN3.prototype.toJSON = function toJSON3() {
          return this.toString(16, 2);
        };
        if (Buffer2) {
          BN3.prototype.toBuffer = function toBuffer(endian, length2) {
            return this.toArrayLike(Buffer2, endian, length2);
          };
        }
        BN3.prototype.toArray = function toArray2(endian, length2) {
          return this.toArrayLike(Array, endian, length2);
        };
        var allocate = function allocate2(ArrayType, size3) {
          if (ArrayType.allocUnsafe) {
            return ArrayType.allocUnsafe(size3);
          }
          return new ArrayType(size3);
        };
        BN3.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length2) {
          this._strip();
          var byteLength = this.byteLength();
          var reqLength = length2 || Math.max(1, byteLength);
          assert3(byteLength <= reqLength, "byte array longer than desired length");
          assert3(reqLength > 0, "Requested array length <= 0");
          var res = allocate(ArrayType, reqLength);
          var postfix = endian === "le" ? "LE" : "BE";
          this["_toArrayLike" + postfix](res, byteLength);
          return res;
        };
        BN3.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
          var position = 0;
          var carry = 0;
          for (var i7 = 0, shift = 0; i7 < this.length; i7++) {
            var word = this.words[i7] << shift | carry;
            res[position++] = word & 255;
            if (position < res.length) {
              res[position++] = word >> 8 & 255;
            }
            if (position < res.length) {
              res[position++] = word >> 16 & 255;
            }
            if (shift === 6) {
              if (position < res.length) {
                res[position++] = word >> 24 & 255;
              }
              carry = 0;
              shift = 0;
            } else {
              carry = word >>> 24;
              shift += 2;
            }
          }
          if (position < res.length) {
            res[position++] = carry;
            while (position < res.length) {
              res[position++] = 0;
            }
          }
        };
        BN3.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
          var position = res.length - 1;
          var carry = 0;
          for (var i7 = 0, shift = 0; i7 < this.length; i7++) {
            var word = this.words[i7] << shift | carry;
            res[position--] = word & 255;
            if (position >= 0) {
              res[position--] = word >> 8 & 255;
            }
            if (position >= 0) {
              res[position--] = word >> 16 & 255;
            }
            if (shift === 6) {
              if (position >= 0) {
                res[position--] = word >> 24 & 255;
              }
              carry = 0;
              shift = 0;
            } else {
              carry = word >>> 24;
              shift += 2;
            }
          }
          if (position >= 0) {
            res[position--] = carry;
            while (position >= 0) {
              res[position--] = 0;
            }
          }
        };
        if (Math.clz32) {
          BN3.prototype._countBits = function _countBits(w8) {
            return 32 - Math.clz32(w8);
          };
        } else {
          BN3.prototype._countBits = function _countBits(w8) {
            var t6 = w8;
            var r8 = 0;
            if (t6 >= 4096) {
              r8 += 13;
              t6 >>>= 13;
            }
            if (t6 >= 64) {
              r8 += 7;
              t6 >>>= 7;
            }
            if (t6 >= 8) {
              r8 += 4;
              t6 >>>= 4;
            }
            if (t6 >= 2) {
              r8 += 2;
              t6 >>>= 2;
            }
            return r8 + t6;
          };
        }
        BN3.prototype._zeroBits = function _zeroBits(w8) {
          if (w8 === 0)
            return 26;
          var t6 = w8;
          var r8 = 0;
          if ((t6 & 8191) === 0) {
            r8 += 13;
            t6 >>>= 13;
          }
          if ((t6 & 127) === 0) {
            r8 += 7;
            t6 >>>= 7;
          }
          if ((t6 & 15) === 0) {
            r8 += 4;
            t6 >>>= 4;
          }
          if ((t6 & 3) === 0) {
            r8 += 2;
            t6 >>>= 2;
          }
          if ((t6 & 1) === 0) {
            r8++;
          }
          return r8;
        };
        BN3.prototype.bitLength = function bitLength() {
          var w8 = this.words[this.length - 1];
          var hi2 = this._countBits(w8);
          return (this.length - 1) * 26 + hi2;
        };
        function toBitArray(num) {
          var w8 = new Array(num.bitLength());
          for (var bit = 0; bit < w8.length; bit++) {
            var off = bit / 26 | 0;
            var wbit = bit % 26;
            w8[bit] = num.words[off] >>> wbit & 1;
          }
          return w8;
        }
        BN3.prototype.zeroBits = function zeroBits() {
          if (this.isZero())
            return 0;
          var r8 = 0;
          for (var i7 = 0; i7 < this.length; i7++) {
            var b7 = this._zeroBits(this.words[i7]);
            r8 += b7;
            if (b7 !== 26)
              break;
          }
          return r8;
        };
        BN3.prototype.byteLength = function byteLength() {
          return Math.ceil(this.bitLength() / 8);
        };
        BN3.prototype.toTwos = function toTwos(width) {
          if (this.negative !== 0) {
            return this.abs().inotn(width).iaddn(1);
          }
          return this.clone();
        };
        BN3.prototype.fromTwos = function fromTwos(width) {
          if (this.testn(width - 1)) {
            return this.notn(width).iaddn(1).ineg();
          }
          return this.clone();
        };
        BN3.prototype.isNeg = function isNeg() {
          return this.negative !== 0;
        };
        BN3.prototype.neg = function neg3() {
          return this.clone().ineg();
        };
        BN3.prototype.ineg = function ineg() {
          if (!this.isZero()) {
            this.negative ^= 1;
          }
          return this;
        };
        BN3.prototype.iuor = function iuor(num) {
          while (this.length < num.length) {
            this.words[this.length++] = 0;
          }
          for (var i7 = 0; i7 < num.length; i7++) {
            this.words[i7] = this.words[i7] | num.words[i7];
          }
          return this._strip();
        };
        BN3.prototype.ior = function ior(num) {
          assert3((this.negative | num.negative) === 0);
          return this.iuor(num);
        };
        BN3.prototype.or = function or5(num) {
          if (this.length > num.length)
            return this.clone().ior(num);
          return num.clone().ior(this);
        };
        BN3.prototype.uor = function uor(num) {
          if (this.length > num.length)
            return this.clone().iuor(num);
          return num.clone().iuor(this);
        };
        BN3.prototype.iuand = function iuand(num) {
          var b7;
          if (this.length > num.length) {
            b7 = num;
          } else {
            b7 = this;
          }
          for (var i7 = 0; i7 < b7.length; i7++) {
            this.words[i7] = this.words[i7] & num.words[i7];
          }
          this.length = b7.length;
          return this._strip();
        };
        BN3.prototype.iand = function iand(num) {
          assert3((this.negative | num.negative) === 0);
          return this.iuand(num);
        };
        BN3.prototype.and = function and(num) {
          if (this.length > num.length)
            return this.clone().iand(num);
          return num.clone().iand(this);
        };
        BN3.prototype.uand = function uand(num) {
          if (this.length > num.length)
            return this.clone().iuand(num);
          return num.clone().iuand(this);
        };
        BN3.prototype.iuxor = function iuxor(num) {
          var a6;
          var b7;
          if (this.length > num.length) {
            a6 = this;
            b7 = num;
          } else {
            a6 = num;
            b7 = this;
          }
          for (var i7 = 0; i7 < b7.length; i7++) {
            this.words[i7] = a6.words[i7] ^ b7.words[i7];
          }
          if (this !== a6) {
            for (; i7 < a6.length; i7++) {
              this.words[i7] = a6.words[i7];
            }
          }
          this.length = a6.length;
          return this._strip();
        };
        BN3.prototype.ixor = function ixor(num) {
          assert3((this.negative | num.negative) === 0);
          return this.iuxor(num);
        };
        BN3.prototype.xor = function xor2(num) {
          if (this.length > num.length)
            return this.clone().ixor(num);
          return num.clone().ixor(this);
        };
        BN3.prototype.uxor = function uxor(num) {
          if (this.length > num.length)
            return this.clone().iuxor(num);
          return num.clone().iuxor(this);
        };
        BN3.prototype.inotn = function inotn(width) {
          assert3(typeof width === "number" && width >= 0);
          var bytesNeeded = Math.ceil(width / 26) | 0;
          var bitsLeft = width % 26;
          this._expand(bytesNeeded);
          if (bitsLeft > 0) {
            bytesNeeded--;
          }
          for (var i7 = 0; i7 < bytesNeeded; i7++) {
            this.words[i7] = ~this.words[i7] & 67108863;
          }
          if (bitsLeft > 0) {
            this.words[i7] = ~this.words[i7] & 67108863 >> 26 - bitsLeft;
          }
          return this._strip();
        };
        BN3.prototype.notn = function notn(width) {
          return this.clone().inotn(width);
        };
        BN3.prototype.setn = function setn(bit, val) {
          assert3(typeof bit === "number" && bit >= 0);
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          this._expand(off + 1);
          if (val) {
            this.words[off] = this.words[off] | 1 << wbit;
          } else {
            this.words[off] = this.words[off] & ~(1 << wbit);
          }
          return this._strip();
        };
        BN3.prototype.iadd = function iadd(num) {
          var r8;
          if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r8 = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
          } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r8 = this.isub(num);
            num.negative = 1;
            return r8._normSign();
          }
          var a6, b7;
          if (this.length > num.length) {
            a6 = this;
            b7 = num;
          } else {
            a6 = num;
            b7 = this;
          }
          var carry = 0;
          for (var i7 = 0; i7 < b7.length; i7++) {
            r8 = (a6.words[i7] | 0) + (b7.words[i7] | 0) + carry;
            this.words[i7] = r8 & 67108863;
            carry = r8 >>> 26;
          }
          for (; carry !== 0 && i7 < a6.length; i7++) {
            r8 = (a6.words[i7] | 0) + carry;
            this.words[i7] = r8 & 67108863;
            carry = r8 >>> 26;
          }
          this.length = a6.length;
          if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
          } else if (a6 !== this) {
            for (; i7 < a6.length; i7++) {
              this.words[i7] = a6.words[i7];
            }
          }
          return this;
        };
        BN3.prototype.add = function add4(num) {
          var res;
          if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
          } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
          }
          if (this.length > num.length)
            return this.clone().iadd(num);
          return num.clone().iadd(this);
        };
        BN3.prototype.isub = function isub(num) {
          if (num.negative !== 0) {
            num.negative = 0;
            var r8 = this.iadd(num);
            num.negative = 1;
            return r8._normSign();
          } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
          }
          var cmp = this.cmp(num);
          if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
          }
          var a6, b7;
          if (cmp > 0) {
            a6 = this;
            b7 = num;
          } else {
            a6 = num;
            b7 = this;
          }
          var carry = 0;
          for (var i7 = 0; i7 < b7.length; i7++) {
            r8 = (a6.words[i7] | 0) - (b7.words[i7] | 0) + carry;
            carry = r8 >> 26;
            this.words[i7] = r8 & 67108863;
          }
          for (; carry !== 0 && i7 < a6.length; i7++) {
            r8 = (a6.words[i7] | 0) + carry;
            carry = r8 >> 26;
            this.words[i7] = r8 & 67108863;
          }
          if (carry === 0 && i7 < a6.length && a6 !== this) {
            for (; i7 < a6.length; i7++) {
              this.words[i7] = a6.words[i7];
            }
          }
          this.length = Math.max(this.length, i7);
          if (a6 !== this) {
            this.negative = 1;
          }
          return this._strip();
        };
        BN3.prototype.sub = function sub(num) {
          return this.clone().isub(num);
        };
        function smallMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          var len = self2.length + num.length | 0;
          out.length = len;
          len = len - 1 | 0;
          var a6 = self2.words[0] | 0;
          var b7 = num.words[0] | 0;
          var r8 = a6 * b7;
          var lo3 = r8 & 67108863;
          var carry = r8 / 67108864 | 0;
          out.words[0] = lo3;
          for (var k6 = 1; k6 < len; k6++) {
            var ncarry = carry >>> 26;
            var rword = carry & 67108863;
            var maxJ = Math.min(k6, num.length - 1);
            for (var j7 = Math.max(0, k6 - self2.length + 1); j7 <= maxJ; j7++) {
              var i7 = k6 - j7 | 0;
              a6 = self2.words[i7] | 0;
              b7 = num.words[j7] | 0;
              r8 = a6 * b7 + rword;
              ncarry += r8 / 67108864 | 0;
              rword = r8 & 67108863;
            }
            out.words[k6] = rword | 0;
            carry = ncarry | 0;
          }
          if (carry !== 0) {
            out.words[k6] = carry | 0;
          } else {
            out.length--;
          }
          return out._strip();
        }
        var comb10MulTo = function comb10MulTo2(self2, num, out) {
          var a6 = self2.words;
          var b7 = num.words;
          var o9 = out.words;
          var c9 = 0;
          var lo3;
          var mid;
          var hi2;
          var a0 = a6[0] | 0;
          var al0 = a0 & 8191;
          var ah0 = a0 >>> 13;
          var a1 = a6[1] | 0;
          var al1 = a1 & 8191;
          var ah1 = a1 >>> 13;
          var a22 = a6[2] | 0;
          var al2 = a22 & 8191;
          var ah2 = a22 >>> 13;
          var a32 = a6[3] | 0;
          var al3 = a32 & 8191;
          var ah3 = a32 >>> 13;
          var a42 = a6[4] | 0;
          var al4 = a42 & 8191;
          var ah4 = a42 >>> 13;
          var a52 = a6[5] | 0;
          var al5 = a52 & 8191;
          var ah5 = a52 >>> 13;
          var a62 = a6[6] | 0;
          var al6 = a62 & 8191;
          var ah6 = a62 >>> 13;
          var a7 = a6[7] | 0;
          var al7 = a7 & 8191;
          var ah7 = a7 >>> 13;
          var a8 = a6[8] | 0;
          var al8 = a8 & 8191;
          var ah8 = a8 >>> 13;
          var a9 = a6[9] | 0;
          var al9 = a9 & 8191;
          var ah9 = a9 >>> 13;
          var b0 = b7[0] | 0;
          var bl0 = b0 & 8191;
          var bh0 = b0 >>> 13;
          var b1 = b7[1] | 0;
          var bl1 = b1 & 8191;
          var bh1 = b1 >>> 13;
          var b22 = b7[2] | 0;
          var bl2 = b22 & 8191;
          var bh2 = b22 >>> 13;
          var b32 = b7[3] | 0;
          var bl3 = b32 & 8191;
          var bh3 = b32 >>> 13;
          var b42 = b7[4] | 0;
          var bl4 = b42 & 8191;
          var bh4 = b42 >>> 13;
          var b52 = b7[5] | 0;
          var bl5 = b52 & 8191;
          var bh5 = b52 >>> 13;
          var b62 = b7[6] | 0;
          var bl6 = b62 & 8191;
          var bh6 = b62 >>> 13;
          var b72 = b7[7] | 0;
          var bl7 = b72 & 8191;
          var bh7 = b72 >>> 13;
          var b8 = b7[8] | 0;
          var bl8 = b8 & 8191;
          var bh8 = b8 >>> 13;
          var b9 = b7[9] | 0;
          var bl9 = b9 & 8191;
          var bh9 = b9 >>> 13;
          out.negative = self2.negative ^ num.negative;
          out.length = 19;
          lo3 = Math.imul(al0, bl0);
          mid = Math.imul(al0, bh0);
          mid = mid + Math.imul(ah0, bl0) | 0;
          hi2 = Math.imul(ah0, bh0);
          var w0 = (c9 + lo3 | 0) + ((mid & 8191) << 13) | 0;
          c9 = (hi2 + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
          w0 &= 67108863;
          lo3 = Math.imul(al1, bl0);
          mid = Math.imul(al1, bh0);
          mid = mid + Math.imul(ah1, bl0) | 0;
          hi2 = Math.imul(ah1, bh0);
          lo3 = lo3 + Math.imul(al0, bl1) | 0;
          mid = mid + Math.imul(al0, bh1) | 0;
          mid = mid + Math.imul(ah0, bl1) | 0;
          hi2 = hi2 + Math.imul(ah0, bh1) | 0;
          var w1 = (c9 + lo3 | 0) + ((mid & 8191) << 13) | 0;
          c9 = (hi2 + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
          w1 &= 67108863;
          lo3 = Math.imul(al2, bl0);
          mid = Math.imul(al2, bh0);
          mid = mid + Math.imul(ah2, bl0) | 0;
          hi2 = Math.imul(ah2, bh0);
          lo3 = lo3 + Math.imul(al1, bl1) | 0;
          mid = mid + Math.imul(al1, bh1) | 0;
          mid = mid + Math.imul(ah1, bl1) | 0;
          hi2 = hi2 + Math.imul(ah1, bh1) | 0;
          lo3 = lo3 + Math.imul(al0, bl2) | 0;
          mid = mid + Math.imul(al0, bh2) | 0;
          mid = mid + Math.imul(ah0, bl2) | 0;
          hi2 = hi2 + Math.imul(ah0, bh2) | 0;
          var w22 = (c9 + lo3 | 0) + ((mid & 8191) << 13) | 0;
          c9 = (hi2 + (mid >>> 13) | 0) + (w22 >>> 26) | 0;
          w22 &= 67108863;
          lo3 = Math.imul(al3, bl0);
          mid = Math.imul(al3, bh0);
          mid = mid + Math.imul(ah3, bl0) | 0;
          hi2 = Math.imul(ah3, bh0);
          lo3 = lo3 + Math.imul(al2, bl1) | 0;
          mid = mid + Math.imul(al2, bh1) | 0;
          mid = mid + Math.imul(ah2, bl1) | 0;
          hi2 = hi2 + Math.imul(ah2, bh1) | 0;
          lo3 = lo3 + Math.imul(al1, bl2) | 0;
          mid = mid + Math.imul(al1, bh2) | 0;
          mid = mid + Math.imul(ah1, bl2) | 0;
          hi2 = hi2 + Math.imul(ah1, bh2) | 0;
          lo3 = lo3 + Math.imul(al0, bl3) | 0;
          mid = mid + Math.imul(al0, bh3) | 0;
          mid = mid + Math.imul(ah0, bl3) | 0;
          hi2 = hi2 + Math.imul(ah0, bh3) | 0;
          var w32 = (c9 + lo3 | 0) + ((mid & 8191) << 13) | 0;
          c9 = (hi2 + (mid >>> 13) | 0) + (w32 >>> 26) | 0;
          w32 &= 67108863;
          lo3 = Math.imul(al4, bl0);
          mid = Math.imul(al4, bh0);
          mid = mid + Math.imul(ah4, bl0) | 0;
          hi2 = Math.imul(ah4, bh0);
          lo3 = lo3 + Math.imul(al3, bl1) | 0;
          mid = mid + Math.imul(al3, bh1) | 0;
          mid = mid + Math.imul(ah3, bl1) | 0;
          hi2 = hi2 + Math.imul(ah3, bh1) | 0;
          lo3 = lo3 + Math.imul(al2, bl2) | 0;
          mid = mid + Math.imul(al2, bh2) | 0;
          mid = mid + Math.imul(ah2, bl2) | 0;
          hi2 = hi2 + Math.imul(ah2, bh2) | 0;
          lo3 = lo3 + Math.imul(al1, bl3) | 0;
          mid = mid + Math.imul(al1, bh3) | 0;
          mid = mid + Math.imul(ah1, bl3) | 0;
          hi2 = hi2 + Math.imul(ah1, bh3) | 0;
          lo3 = lo3 + Math.imul(al0, bl4) | 0;
          mid = mid + Math.imul(al0, bh4) | 0;
          mid = mid + Math.imul(ah0, bl4) | 0;
          hi2 = hi2 + Math.imul(ah0, bh4) | 0;
          var w42 = (c9 + lo3 | 0) + ((mid & 8191) << 13) | 0;
          c9 = (hi2 + (mid >>> 13) | 0) + (w42 >>> 26) | 0;
          w42 &= 67108863;
          lo3 = Math.imul(al5, bl0);
          mid = Math.imul(al5, bh0);
          mid = mid + Math.imul(ah5, bl0) | 0;
          hi2 = Math.imul(ah5, bh0);
          lo3 = lo3 + Math.imul(al4, bl1) | 0;
          mid = mid + Math.imul(al4, bh1) | 0;
          mid = mid + Math.imul(ah4, bl1) | 0;
          hi2 = hi2 + Math.imul(ah4, bh1) | 0;
          lo3 = lo3 + Math.imul(al3, bl2) | 0;
          mid = mid + Math.imul(al3, bh2) | 0;
          mid = mid + Math.imul(ah3, bl2) | 0;
          hi2 = hi2 + Math.imul(ah3, bh2) | 0;
          lo3 = lo3 + Math.imul(al2, bl3) | 0;
          mid = mid + Math.imul(al2, bh3) | 0;
          mid = mid + Math.imul(ah2, bl3) | 0;
          hi2 = hi2 + Math.imul(ah2, bh3) | 0;
          lo3 = lo3 + Math.imul(al1, bl4) | 0;
          mid = mid + Math.imul(al1, bh4) | 0;
          mid = mid + Math.imul(ah1, bl4) | 0;
          hi2 = hi2 + Math.imul(ah1, bh4) | 0;
          lo3 = lo3 + Math.imul(al0, bl5) | 0;
          mid = mid + Math.imul(al0, bh5) | 0;
          mid = mid + Math.imul(ah0, bl5) | 0;
          hi2 = hi2 + Math.imul(ah0, bh5) | 0;
          var w52 = (c9 + lo3 | 0) + ((mid & 8191) << 13) | 0;
          c9 = (hi2 + (mid >>> 13) | 0) + (w52 >>> 26) | 0;
          w52 &= 67108863;
          lo3 = Math.imul(al6, bl0);
          mid = Math.imul(al6, bh0);
          mid = mid + Math.imul(ah6, bl0) | 0;
          hi2 = Math.imul(ah6, bh0);
          lo3 = lo3 + Math.imul(al5, bl1) | 0;
          mid = mid + Math.imul(al5, bh1) | 0;
          mid = mid + Math.imul(ah5, bl1) | 0;
          hi2 = hi2 + Math.imul(ah5, bh1) | 0;
          lo3 = lo3 + Math.imul(al4, bl2) | 0;
          mid = mid + Math.imul(al4, bh2) | 0;
          mid = mid + Math.imul(ah4, bl2) | 0;
          hi2 = hi2 + Math.imul(ah4, bh2) | 0;
          lo3 = lo3 + Math.imul(al3, bl3) | 0;
          mid = mid + Math.imul(al3, bh3) | 0;
          mid = mid + Math.imul(ah3, bl3) | 0;
          hi2 = hi2 + Math.imul(ah3, bh3) | 0;
          lo3 = lo3 + Math.imul(al2, bl4) | 0;
          mid = mid + Math.imul(al2, bh4) | 0;
          mid = mid + Math.imul(ah2, bl4) | 0;
          hi2 = hi2 + Math.imul(ah2, bh4) | 0;
          lo3 = lo3 + Math.imul(al1, bl5) | 0;
          mid = mid + Math.imul(al1, bh5) | 0;
          mid = mid + Math.imul(ah1, bl5) | 0;
          hi2 = hi2 + Math.imul(ah1, bh5) | 0;
          lo3 = lo3 + Math.imul(al0, bl6) | 0;
          mid = mid + Math.imul(al0, bh6) | 0;
          mid = mid + Math.imul(ah0, bl6) | 0;
          hi2 = hi2 + Math.imul(ah0, bh6) | 0;
          var w62 = (c9 + lo3 | 0) + ((mid & 8191) << 13) | 0;
          c9 = (hi2 + (mid >>> 13) | 0) + (w62 >>> 26) | 0;
          w62 &= 67108863;
          lo3 = Math.imul(al7, bl0);
          mid = Math.imul(al7, bh0);
          mid = mid + Math.imul(ah7, bl0) | 0;
          hi2 = Math.imul(ah7, bh0);
          lo3 = lo3 + Math.imul(al6, bl1) | 0;
          mid = mid + Math.imul(al6, bh1) | 0;
          mid = mid + Math.imul(ah6, bl1) | 0;
          hi2 = hi2 + Math.imul(ah6, bh1) | 0;
          lo3 = lo3 + Math.imul(al5, bl2) | 0;
          mid = mid + Math.imul(al5, bh2) | 0;
          mid = mid + Math.imul(ah5, bl2) | 0;
          hi2 = hi2 + Math.imul(ah5, bh2) | 0;
          lo3 = lo3 + Math.imul(al4, bl3) | 0;
          mid = mid + Math.imul(al4, bh3) | 0;
          mid = mid + Math.imul(ah4, bl3) | 0;
          hi2 = hi2 + Math.imul(ah4, bh3) | 0;
          lo3 = lo3 + Math.imul(al3, bl4) | 0;
          mid = mid + Math.imul(al3, bh4) | 0;
          mid = mid + Math.imul(ah3, bl4) | 0;
          hi2 = hi2 + Math.imul(ah3, bh4) | 0;
          lo3 = lo3 + Math.imul(al2, bl5) | 0;
          mid = mid + Math.imul(al2, bh5) | 0;
          mid = mid + Math.imul(ah2, bl5) | 0;
          hi2 = hi2 + Math.imul(ah2, bh5) | 0;
          lo3 = lo3 + Math.imul(al1, bl6) | 0;
          mid = mid + Math.imul(al1, bh6) | 0;
          mid = mid + Math.imul(ah1, bl6) | 0;
          hi2 = hi2 + Math.imul(ah1, bh6) | 0;
          lo3 = lo3 + Math.imul(al0, bl7) | 0;
          mid = mid + Math.imul(al0, bh7) | 0;
          mid = mid + Math.imul(ah0, bl7) | 0;
          hi2 = hi2 + Math.imul(ah0, bh7) | 0;
          var w72 = (c9 + lo3 | 0) + ((mid & 8191) << 13) | 0;
          c9 = (hi2 + (mid >>> 13) | 0) + (w72 >>> 26) | 0;
          w72 &= 67108863;
          lo3 = Math.imul(al8, bl0);
          mid = Math.imul(al8, bh0);
          mid = mid + Math.imul(ah8, bl0) | 0;
          hi2 = Math.imul(ah8, bh0);
          lo3 = lo3 + Math.imul(al7, bl1) | 0;
          mid = mid + Math.imul(al7, bh1) | 0;
          mid = mid + Math.imul(ah7, bl1) | 0;
          hi2 = hi2 + Math.imul(ah7, bh1) | 0;
          lo3 = lo3 + Math.imul(al6, bl2) | 0;
          mid = mid + Math.imul(al6, bh2) | 0;
          mid = mid + Math.imul(ah6, bl2) | 0;
          hi2 = hi2 + Math.imul(ah6, bh2) | 0;
          lo3 = lo3 + Math.imul(al5, bl3) | 0;
          mid = mid + Math.imul(al5, bh3) | 0;
          mid = mid + Math.imul(ah5, bl3) | 0;
          hi2 = hi2 + Math.imul(ah5, bh3) | 0;
          lo3 = lo3 + Math.imul(al4, bl4) | 0;
          mid = mid + Math.imul(al4, bh4) | 0;
          mid = mid + Math.imul(ah4, bl4) | 0;
          hi2 = hi2 + Math.imul(ah4, bh4) | 0;
          lo3 = lo3 + Math.imul(al3, bl5) | 0;
          mid = mid + Math.imul(al3, bh5) | 0;
          mid = mid + Math.imul(ah3, bl5) | 0;
          hi2 = hi2 + Math.imul(ah3, bh5) | 0;
          lo3 = lo3 + Math.imul(al2, bl6) | 0;
          mid = mid + Math.imul(al2, bh6) | 0;
          mid = mid + Math.imul(ah2, bl6) | 0;
          hi2 = hi2 + Math.imul(ah2, bh6) | 0;
          lo3 = lo3 + Math.imul(al1, bl7) | 0;
          mid = mid + Math.imul(al1, bh7) | 0;
          mid = mid + Math.imul(ah1, bl7) | 0;
          hi2 = hi2 + Math.imul(ah1, bh7) | 0;
          lo3 = lo3 + Math.imul(al0, bl8) | 0;
          mid = mid + Math.imul(al0, bh8) | 0;
          mid = mid + Math.imul(ah0, bl8) | 0;
          hi2 = hi2 + Math.imul(ah0, bh8) | 0;
          var w8 = (c9 + lo3 | 0) + ((mid & 8191) << 13) | 0;
          c9 = (hi2 + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
          w8 &= 67108863;
          lo3 = Math.imul(al9, bl0);
          mid = Math.imul(al9, bh0);
          mid = mid + Math.imul(ah9, bl0) | 0;
          hi2 = Math.imul(ah9, bh0);
          lo3 = lo3 + Math.imul(al8, bl1) | 0;
          mid = mid + Math.imul(al8, bh1) | 0;
          mid = mid + Math.imul(ah8, bl1) | 0;
          hi2 = hi2 + Math.imul(ah8, bh1) | 0;
          lo3 = lo3 + Math.imul(al7, bl2) | 0;
          mid = mid + Math.imul(al7, bh2) | 0;
          mid = mid + Math.imul(ah7, bl2) | 0;
          hi2 = hi2 + Math.imul(ah7, bh2) | 0;
          lo3 = lo3 + Math.imul(al6, bl3) | 0;
          mid = mid + Math.imul(al6, bh3) | 0;
          mid = mid + Math.imul(ah6, bl3) | 0;
          hi2 = hi2 + Math.imul(ah6, bh3) | 0;
          lo3 = lo3 + Math.imul(al5, bl4) | 0;
          mid = mid + Math.imul(al5, bh4) | 0;
          mid = mid + Math.imul(ah5, bl4) | 0;
          hi2 = hi2 + Math.imul(ah5, bh4) | 0;
          lo3 = lo3 + Math.imul(al4, bl5) | 0;
          mid = mid + Math.imul(al4, bh5) | 0;
          mid = mid + Math.imul(ah4, bl5) | 0;
          hi2 = hi2 + Math.imul(ah4, bh5) | 0;
          lo3 = lo3 + Math.imul(al3, bl6) | 0;
          mid = mid + Math.imul(al3, bh6) | 0;
          mid = mid + Math.imul(ah3, bl6) | 0;
          hi2 = hi2 + Math.imul(ah3, bh6) | 0;
          lo3 = lo3 + Math.imul(al2, bl7) | 0;
          mid = mid + Math.imul(al2, bh7) | 0;
          mid = mid + Math.imul(ah2, bl7) | 0;
          hi2 = hi2 + Math.imul(ah2, bh7) | 0;
          lo3 = lo3 + Math.imul(al1, bl8) | 0;
          mid = mid + Math.imul(al1, bh8) | 0;
          mid = mid + Math.imul(ah1, bl8) | 0;
          hi2 = hi2 + Math.imul(ah1, bh8) | 0;
          lo3 = lo3 + Math.imul(al0, bl9) | 0;
          mid = mid + Math.imul(al0, bh9) | 0;
          mid = mid + Math.imul(ah0, bl9) | 0;
          hi2 = hi2 + Math.imul(ah0, bh9) | 0;
          var w9 = (c9 + lo3 | 0) + ((mid & 8191) << 13) | 0;
          c9 = (hi2 + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
          w9 &= 67108863;
          lo3 = Math.imul(al9, bl1);
          mid = Math.imul(al9, bh1);
          mid = mid + Math.imul(ah9, bl1) | 0;
          hi2 = Math.imul(ah9, bh1);
          lo3 = lo3 + Math.imul(al8, bl2) | 0;
          mid = mid + Math.imul(al8, bh2) | 0;
          mid = mid + Math.imul(ah8, bl2) | 0;
          hi2 = hi2 + Math.imul(ah8, bh2) | 0;
          lo3 = lo3 + Math.imul(al7, bl3) | 0;
          mid = mid + Math.imul(al7, bh3) | 0;
          mid = mid + Math.imul(ah7, bl3) | 0;
          hi2 = hi2 + Math.imul(ah7, bh3) | 0;
          lo3 = lo3 + Math.imul(al6, bl4) | 0;
          mid = mid + Math.imul(al6, bh4) | 0;
          mid = mid + Math.imul(ah6, bl4) | 0;
          hi2 = hi2 + Math.imul(ah6, bh4) | 0;
          lo3 = lo3 + Math.imul(al5, bl5) | 0;
          mid = mid + Math.imul(al5, bh5) | 0;
          mid = mid + Math.imul(ah5, bl5) | 0;
          hi2 = hi2 + Math.imul(ah5, bh5) | 0;
          lo3 = lo3 + Math.imul(al4, bl6) | 0;
          mid = mid + Math.imul(al4, bh6) | 0;
          mid = mid + Math.imul(ah4, bl6) | 0;
          hi2 = hi2 + Math.imul(ah4, bh6) | 0;
          lo3 = lo3 + Math.imul(al3, bl7) | 0;
          mid = mid + Math.imul(al3, bh7) | 0;
          mid = mid + Math.imul(ah3, bl7) | 0;
          hi2 = hi2 + Math.imul(ah3, bh7) | 0;
          lo3 = lo3 + Math.imul(al2, bl8) | 0;
          mid = mid + Math.imul(al2, bh8) | 0;
          mid = mid + Math.imul(ah2, bl8) | 0;
          hi2 = hi2 + Math.imul(ah2, bh8) | 0;
          lo3 = lo3 + Math.imul(al1, bl9) | 0;
          mid = mid + Math.imul(al1, bh9) | 0;
          mid = mid + Math.imul(ah1, bl9) | 0;
          hi2 = hi2 + Math.imul(ah1, bh9) | 0;
          var w10 = (c9 + lo3 | 0) + ((mid & 8191) << 13) | 0;
          c9 = (hi2 + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
          w10 &= 67108863;
          lo3 = Math.imul(al9, bl2);
          mid = Math.imul(al9, bh2);
          mid = mid + Math.imul(ah9, bl2) | 0;
          hi2 = Math.imul(ah9, bh2);
          lo3 = lo3 + Math.imul(al8, bl3) | 0;
          mid = mid + Math.imul(al8, bh3) | 0;
          mid = mid + Math.imul(ah8, bl3) | 0;
          hi2 = hi2 + Math.imul(ah8, bh3) | 0;
          lo3 = lo3 + Math.imul(al7, bl4) | 0;
          mid = mid + Math.imul(al7, bh4) | 0;
          mid = mid + Math.imul(ah7, bl4) | 0;
          hi2 = hi2 + Math.imul(ah7, bh4) | 0;
          lo3 = lo3 + Math.imul(al6, bl5) | 0;
          mid = mid + Math.imul(al6, bh5) | 0;
          mid = mid + Math.imul(ah6, bl5) | 0;
          hi2 = hi2 + Math.imul(ah6, bh5) | 0;
          lo3 = lo3 + Math.imul(al5, bl6) | 0;
          mid = mid + Math.imul(al5, bh6) | 0;
          mid = mid + Math.imul(ah5, bl6) | 0;
          hi2 = hi2 + Math.imul(ah5, bh6) | 0;
          lo3 = lo3 + Math.imul(al4, bl7) | 0;
          mid = mid + Math.imul(al4, bh7) | 0;
          mid = mid + Math.imul(ah4, bl7) | 0;
          hi2 = hi2 + Math.imul(ah4, bh7) | 0;
          lo3 = lo3 + Math.imul(al3, bl8) | 0;
          mid = mid + Math.imul(al3, bh8) | 0;
          mid = mid + Math.imul(ah3, bl8) | 0;
          hi2 = hi2 + Math.imul(ah3, bh8) | 0;
          lo3 = lo3 + Math.imul(al2, bl9) | 0;
          mid = mid + Math.imul(al2, bh9) | 0;
          mid = mid + Math.imul(ah2, bl9) | 0;
          hi2 = hi2 + Math.imul(ah2, bh9) | 0;
          var w11 = (c9 + lo3 | 0) + ((mid & 8191) << 13) | 0;
          c9 = (hi2 + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
          w11 &= 67108863;
          lo3 = Math.imul(al9, bl3);
          mid = Math.imul(al9, bh3);
          mid = mid + Math.imul(ah9, bl3) | 0;
          hi2 = Math.imul(ah9, bh3);
          lo3 = lo3 + Math.imul(al8, bl4) | 0;
          mid = mid + Math.imul(al8, bh4) | 0;
          mid = mid + Math.imul(ah8, bl4) | 0;
          hi2 = hi2 + Math.imul(ah8, bh4) | 0;
          lo3 = lo3 + Math.imul(al7, bl5) | 0;
          mid = mid + Math.imul(al7, bh5) | 0;
          mid = mid + Math.imul(ah7, bl5) | 0;
          hi2 = hi2 + Math.imul(ah7, bh5) | 0;
          lo3 = lo3 + Math.imul(al6, bl6) | 0;
          mid = mid + Math.imul(al6, bh6) | 0;
          mid = mid + Math.imul(ah6, bl6) | 0;
          hi2 = hi2 + Math.imul(ah6, bh6) | 0;
          lo3 = lo3 + Math.imul(al5, bl7) | 0;
          mid = mid + Math.imul(al5, bh7) | 0;
          mid = mid + Math.imul(ah5, bl7) | 0;
          hi2 = hi2 + Math.imul(ah5, bh7) | 0;
          lo3 = lo3 + Math.imul(al4, bl8) | 0;
          mid = mid + Math.imul(al4, bh8) | 0;
          mid = mid + Math.imul(ah4, bl8) | 0;
          hi2 = hi2 + Math.imul(ah4, bh8) | 0;
          lo3 = lo3 + Math.imul(al3, bl9) | 0;
          mid = mid + Math.imul(al3, bh9) | 0;
          mid = mid + Math.imul(ah3, bl9) | 0;
          hi2 = hi2 + Math.imul(ah3, bh9) | 0;
          var w12 = (c9 + lo3 | 0) + ((mid & 8191) << 13) | 0;
          c9 = (hi2 + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
          w12 &= 67108863;
          lo3 = Math.imul(al9, bl4);
          mid = Math.imul(al9, bh4);
          mid = mid + Math.imul(ah9, bl4) | 0;
          hi2 = Math.imul(ah9, bh4);
          lo3 = lo3 + Math.imul(al8, bl5) | 0;
          mid = mid + Math.imul(al8, bh5) | 0;
          mid = mid + Math.imul(ah8, bl5) | 0;
          hi2 = hi2 + Math.imul(ah8, bh5) | 0;
          lo3 = lo3 + Math.imul(al7, bl6) | 0;
          mid = mid + Math.imul(al7, bh6) | 0;
          mid = mid + Math.imul(ah7, bl6) | 0;
          hi2 = hi2 + Math.imul(ah7, bh6) | 0;
          lo3 = lo3 + Math.imul(al6, bl7) | 0;
          mid = mid + Math.imul(al6, bh7) | 0;
          mid = mid + Math.imul(ah6, bl7) | 0;
          hi2 = hi2 + Math.imul(ah6, bh7) | 0;
          lo3 = lo3 + Math.imul(al5, bl8) | 0;
          mid = mid + Math.imul(al5, bh8) | 0;
          mid = mid + Math.imul(ah5, bl8) | 0;
          hi2 = hi2 + Math.imul(ah5, bh8) | 0;
          lo3 = lo3 + Math.imul(al4, bl9) | 0;
          mid = mid + Math.imul(al4, bh9) | 0;
          mid = mid + Math.imul(ah4, bl9) | 0;
          hi2 = hi2 + Math.imul(ah4, bh9) | 0;
          var w13 = (c9 + lo3 | 0) + ((mid & 8191) << 13) | 0;
          c9 = (hi2 + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
          w13 &= 67108863;
          lo3 = Math.imul(al9, bl5);
          mid = Math.imul(al9, bh5);
          mid = mid + Math.imul(ah9, bl5) | 0;
          hi2 = Math.imul(ah9, bh5);
          lo3 = lo3 + Math.imul(al8, bl6) | 0;
          mid = mid + Math.imul(al8, bh6) | 0;
          mid = mid + Math.imul(ah8, bl6) | 0;
          hi2 = hi2 + Math.imul(ah8, bh6) | 0;
          lo3 = lo3 + Math.imul(al7, bl7) | 0;
          mid = mid + Math.imul(al7, bh7) | 0;
          mid = mid + Math.imul(ah7, bl7) | 0;
          hi2 = hi2 + Math.imul(ah7, bh7) | 0;
          lo3 = lo3 + Math.imul(al6, bl8) | 0;
          mid = mid + Math.imul(al6, bh8) | 0;
          mid = mid + Math.imul(ah6, bl8) | 0;
          hi2 = hi2 + Math.imul(ah6, bh8) | 0;
          lo3 = lo3 + Math.imul(al5, bl9) | 0;
          mid = mid + Math.imul(al5, bh9) | 0;
          mid = mid + Math.imul(ah5, bl9) | 0;
          hi2 = hi2 + Math.imul(ah5, bh9) | 0;
          var w14 = (c9 + lo3 | 0) + ((mid & 8191) << 13) | 0;
          c9 = (hi2 + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
          w14 &= 67108863;
          lo3 = Math.imul(al9, bl6);
          mid = Math.imul(al9, bh6);
          mid = mid + Math.imul(ah9, bl6) | 0;
          hi2 = Math.imul(ah9, bh6);
          lo3 = lo3 + Math.imul(al8, bl7) | 0;
          mid = mid + Math.imul(al8, bh7) | 0;
          mid = mid + Math.imul(ah8, bl7) | 0;
          hi2 = hi2 + Math.imul(ah8, bh7) | 0;
          lo3 = lo3 + Math.imul(al7, bl8) | 0;
          mid = mid + Math.imul(al7, bh8) | 0;
          mid = mid + Math.imul(ah7, bl8) | 0;
          hi2 = hi2 + Math.imul(ah7, bh8) | 0;
          lo3 = lo3 + Math.imul(al6, bl9) | 0;
          mid = mid + Math.imul(al6, bh9) | 0;
          mid = mid + Math.imul(ah6, bl9) | 0;
          hi2 = hi2 + Math.imul(ah6, bh9) | 0;
          var w15 = (c9 + lo3 | 0) + ((mid & 8191) << 13) | 0;
          c9 = (hi2 + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
          w15 &= 67108863;
          lo3 = Math.imul(al9, bl7);
          mid = Math.imul(al9, bh7);
          mid = mid + Math.imul(ah9, bl7) | 0;
          hi2 = Math.imul(ah9, bh7);
          lo3 = lo3 + Math.imul(al8, bl8) | 0;
          mid = mid + Math.imul(al8, bh8) | 0;
          mid = mid + Math.imul(ah8, bl8) | 0;
          hi2 = hi2 + Math.imul(ah8, bh8) | 0;
          lo3 = lo3 + Math.imul(al7, bl9) | 0;
          mid = mid + Math.imul(al7, bh9) | 0;
          mid = mid + Math.imul(ah7, bl9) | 0;
          hi2 = hi2 + Math.imul(ah7, bh9) | 0;
          var w16 = (c9 + lo3 | 0) + ((mid & 8191) << 13) | 0;
          c9 = (hi2 + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
          w16 &= 67108863;
          lo3 = Math.imul(al9, bl8);
          mid = Math.imul(al9, bh8);
          mid = mid + Math.imul(ah9, bl8) | 0;
          hi2 = Math.imul(ah9, bh8);
          lo3 = lo3 + Math.imul(al8, bl9) | 0;
          mid = mid + Math.imul(al8, bh9) | 0;
          mid = mid + Math.imul(ah8, bl9) | 0;
          hi2 = hi2 + Math.imul(ah8, bh9) | 0;
          var w17 = (c9 + lo3 | 0) + ((mid & 8191) << 13) | 0;
          c9 = (hi2 + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
          w17 &= 67108863;
          lo3 = Math.imul(al9, bl9);
          mid = Math.imul(al9, bh9);
          mid = mid + Math.imul(ah9, bl9) | 0;
          hi2 = Math.imul(ah9, bh9);
          var w18 = (c9 + lo3 | 0) + ((mid & 8191) << 13) | 0;
          c9 = (hi2 + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
          w18 &= 67108863;
          o9[0] = w0;
          o9[1] = w1;
          o9[2] = w22;
          o9[3] = w32;
          o9[4] = w42;
          o9[5] = w52;
          o9[6] = w62;
          o9[7] = w72;
          o9[8] = w8;
          o9[9] = w9;
          o9[10] = w10;
          o9[11] = w11;
          o9[12] = w12;
          o9[13] = w13;
          o9[14] = w14;
          o9[15] = w15;
          o9[16] = w16;
          o9[17] = w17;
          o9[18] = w18;
          if (c9 !== 0) {
            o9[19] = c9;
            out.length++;
          }
          return out;
        };
        if (!Math.imul) {
          comb10MulTo = smallMulTo;
        }
        function bigMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          out.length = self2.length + num.length;
          var carry = 0;
          var hncarry = 0;
          for (var k6 = 0; k6 < out.length - 1; k6++) {
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 67108863;
            var maxJ = Math.min(k6, num.length - 1);
            for (var j7 = Math.max(0, k6 - self2.length + 1); j7 <= maxJ; j7++) {
              var i7 = k6 - j7;
              var a6 = self2.words[i7] | 0;
              var b7 = num.words[j7] | 0;
              var r8 = a6 * b7;
              var lo3 = r8 & 67108863;
              ncarry = ncarry + (r8 / 67108864 | 0) | 0;
              lo3 = lo3 + rword | 0;
              rword = lo3 & 67108863;
              ncarry = ncarry + (lo3 >>> 26) | 0;
              hncarry += ncarry >>> 26;
              ncarry &= 67108863;
            }
            out.words[k6] = rword;
            carry = ncarry;
            ncarry = hncarry;
          }
          if (carry !== 0) {
            out.words[k6] = carry;
          } else {
            out.length--;
          }
          return out._strip();
        }
        function jumboMulTo(self2, num, out) {
          return bigMulTo(self2, num, out);
        }
        BN3.prototype.mulTo = function mulTo(num, out) {
          var res;
          var len = this.length + num.length;
          if (this.length === 10 && num.length === 10) {
            res = comb10MulTo(this, num, out);
          } else if (len < 63) {
            res = smallMulTo(this, num, out);
          } else if (len < 1024) {
            res = bigMulTo(this, num, out);
          } else {
            res = jumboMulTo(this, num, out);
          }
          return res;
        };
        function FFTM(x4, y11) {
          this.x = x4;
          this.y = y11;
        }
        FFTM.prototype.makeRBT = function makeRBT(N17) {
          var t6 = new Array(N17);
          var l9 = BN3.prototype._countBits(N17) - 1;
          for (var i7 = 0; i7 < N17; i7++) {
            t6[i7] = this.revBin(i7, l9, N17);
          }
          return t6;
        };
        FFTM.prototype.revBin = function revBin(x4, l9, N17) {
          if (x4 === 0 || x4 === N17 - 1)
            return x4;
          var rb = 0;
          for (var i7 = 0; i7 < l9; i7++) {
            rb |= (x4 & 1) << l9 - i7 - 1;
            x4 >>= 1;
          }
          return rb;
        };
        FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N17) {
          for (var i7 = 0; i7 < N17; i7++) {
            rtws[i7] = rws[rbt[i7]];
            itws[i7] = iws[rbt[i7]];
          }
        };
        FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N17, rbt) {
          this.permute(rbt, rws, iws, rtws, itws, N17);
          for (var s7 = 1; s7 < N17; s7 <<= 1) {
            var l9 = s7 << 1;
            var rtwdf = Math.cos(2 * Math.PI / l9);
            var itwdf = Math.sin(2 * Math.PI / l9);
            for (var p8 = 0; p8 < N17; p8 += l9) {
              var rtwdf_ = rtwdf;
              var itwdf_ = itwdf;
              for (var j7 = 0; j7 < s7; j7++) {
                var re6 = rtws[p8 + j7];
                var ie6 = itws[p8 + j7];
                var ro3 = rtws[p8 + j7 + s7];
                var io3 = itws[p8 + j7 + s7];
                var rx = rtwdf_ * ro3 - itwdf_ * io3;
                io3 = rtwdf_ * io3 + itwdf_ * ro3;
                ro3 = rx;
                rtws[p8 + j7] = re6 + ro3;
                itws[p8 + j7] = ie6 + io3;
                rtws[p8 + j7 + s7] = re6 - ro3;
                itws[p8 + j7 + s7] = ie6 - io3;
                if (j7 !== l9) {
                  rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                  itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                  rtwdf_ = rx;
                }
              }
            }
          }
        };
        FFTM.prototype.guessLen13b = function guessLen13b(n9, m6) {
          var N17 = Math.max(m6, n9) | 1;
          var odd = N17 & 1;
          var i7 = 0;
          for (N17 = N17 / 2 | 0; N17; N17 = N17 >>> 1) {
            i7++;
          }
          return 1 << i7 + 1 + odd;
        };
        FFTM.prototype.conjugate = function conjugate(rws, iws, N17) {
          if (N17 <= 1)
            return;
          for (var i7 = 0; i7 < N17 / 2; i7++) {
            var t6 = rws[i7];
            rws[i7] = rws[N17 - i7 - 1];
            rws[N17 - i7 - 1] = t6;
            t6 = iws[i7];
            iws[i7] = -iws[N17 - i7 - 1];
            iws[N17 - i7 - 1] = -t6;
          }
        };
        FFTM.prototype.normalize13b = function normalize13b(ws3, N17) {
          var carry = 0;
          for (var i7 = 0; i7 < N17 / 2; i7++) {
            var w8 = Math.round(ws3[2 * i7 + 1] / N17) * 8192 + Math.round(ws3[2 * i7] / N17) + carry;
            ws3[i7] = w8 & 67108863;
            if (w8 < 67108864) {
              carry = 0;
            } else {
              carry = w8 / 67108864 | 0;
            }
          }
          return ws3;
        };
        FFTM.prototype.convert13b = function convert13b(ws3, len, rws, N17) {
          var carry = 0;
          for (var i7 = 0; i7 < len; i7++) {
            carry = carry + (ws3[i7] | 0);
            rws[2 * i7] = carry & 8191;
            carry = carry >>> 13;
            rws[2 * i7 + 1] = carry & 8191;
            carry = carry >>> 13;
          }
          for (i7 = 2 * len; i7 < N17; ++i7) {
            rws[i7] = 0;
          }
          assert3(carry === 0);
          assert3((carry & ~8191) === 0);
        };
        FFTM.prototype.stub = function stub(N17) {
          var ph = new Array(N17);
          for (var i7 = 0; i7 < N17; i7++) {
            ph[i7] = 0;
          }
          return ph;
        };
        FFTM.prototype.mulp = function mulp(x4, y11, out) {
          var N17 = 2 * this.guessLen13b(x4.length, y11.length);
          var rbt = this.makeRBT(N17);
          var _8 = this.stub(N17);
          var rws = new Array(N17);
          var rwst = new Array(N17);
          var iwst = new Array(N17);
          var nrws = new Array(N17);
          var nrwst = new Array(N17);
          var niwst = new Array(N17);
          var rmws = out.words;
          rmws.length = N17;
          this.convert13b(x4.words, x4.length, rws, N17);
          this.convert13b(y11.words, y11.length, nrws, N17);
          this.transform(rws, _8, rwst, iwst, N17, rbt);
          this.transform(nrws, _8, nrwst, niwst, N17, rbt);
          for (var i7 = 0; i7 < N17; i7++) {
            var rx = rwst[i7] * nrwst[i7] - iwst[i7] * niwst[i7];
            iwst[i7] = rwst[i7] * niwst[i7] + iwst[i7] * nrwst[i7];
            rwst[i7] = rx;
          }
          this.conjugate(rwst, iwst, N17);
          this.transform(rwst, iwst, rmws, _8, N17, rbt);
          this.conjugate(rmws, _8, N17);
          this.normalize13b(rmws, N17);
          out.negative = x4.negative ^ y11.negative;
          out.length = x4.length + y11.length;
          return out._strip();
        };
        BN3.prototype.mul = function mul3(num) {
          var out = new BN3(null);
          out.words = new Array(this.length + num.length);
          return this.mulTo(num, out);
        };
        BN3.prototype.mulf = function mulf(num) {
          var out = new BN3(null);
          out.words = new Array(this.length + num.length);
          return jumboMulTo(this, num, out);
        };
        BN3.prototype.imul = function imul(num) {
          return this.clone().mulTo(num, this);
        };
        BN3.prototype.imuln = function imuln(num) {
          var isNegNum = num < 0;
          if (isNegNum)
            num = -num;
          assert3(typeof num === "number");
          assert3(num < 67108864);
          var carry = 0;
          for (var i7 = 0; i7 < this.length; i7++) {
            var w8 = (this.words[i7] | 0) * num;
            var lo3 = (w8 & 67108863) + (carry & 67108863);
            carry >>= 26;
            carry += w8 / 67108864 | 0;
            carry += lo3 >>> 26;
            this.words[i7] = lo3 & 67108863;
          }
          if (carry !== 0) {
            this.words[i7] = carry;
            this.length++;
          }
          return isNegNum ? this.ineg() : this;
        };
        BN3.prototype.muln = function muln(num) {
          return this.clone().imuln(num);
        };
        BN3.prototype.sqr = function sqr() {
          return this.mul(this);
        };
        BN3.prototype.isqr = function isqr() {
          return this.imul(this.clone());
        };
        BN3.prototype.pow = function pow(num) {
          var w8 = toBitArray(num);
          if (w8.length === 0)
            return new BN3(1);
          var res = this;
          for (var i7 = 0; i7 < w8.length; i7++, res = res.sqr()) {
            if (w8[i7] !== 0)
              break;
          }
          if (++i7 < w8.length) {
            for (var q8 = res.sqr(); i7 < w8.length; i7++, q8 = q8.sqr()) {
              if (w8[i7] === 0)
                continue;
              res = res.mul(q8);
            }
          }
          return res;
        };
        BN3.prototype.iushln = function iushln(bits) {
          assert3(typeof bits === "number" && bits >= 0);
          var r8 = bits % 26;
          var s7 = (bits - r8) / 26;
          var carryMask = 67108863 >>> 26 - r8 << 26 - r8;
          var i7;
          if (r8 !== 0) {
            var carry = 0;
            for (i7 = 0; i7 < this.length; i7++) {
              var newCarry = this.words[i7] & carryMask;
              var c9 = (this.words[i7] | 0) - newCarry << r8;
              this.words[i7] = c9 | carry;
              carry = newCarry >>> 26 - r8;
            }
            if (carry) {
              this.words[i7] = carry;
              this.length++;
            }
          }
          if (s7 !== 0) {
            for (i7 = this.length - 1; i7 >= 0; i7--) {
              this.words[i7 + s7] = this.words[i7];
            }
            for (i7 = 0; i7 < s7; i7++) {
              this.words[i7] = 0;
            }
            this.length += s7;
          }
          return this._strip();
        };
        BN3.prototype.ishln = function ishln(bits) {
          assert3(this.negative === 0);
          return this.iushln(bits);
        };
        BN3.prototype.iushrn = function iushrn(bits, hint, extended) {
          assert3(typeof bits === "number" && bits >= 0);
          var h10;
          if (hint) {
            h10 = (hint - hint % 26) / 26;
          } else {
            h10 = 0;
          }
          var r8 = bits % 26;
          var s7 = Math.min((bits - r8) / 26, this.length);
          var mask = 67108863 ^ 67108863 >>> r8 << r8;
          var maskedWords = extended;
          h10 -= s7;
          h10 = Math.max(0, h10);
          if (maskedWords) {
            for (var i7 = 0; i7 < s7; i7++) {
              maskedWords.words[i7] = this.words[i7];
            }
            maskedWords.length = s7;
          }
          if (s7 === 0) {
          } else if (this.length > s7) {
            this.length -= s7;
            for (i7 = 0; i7 < this.length; i7++) {
              this.words[i7] = this.words[i7 + s7];
            }
          } else {
            this.words[0] = 0;
            this.length = 1;
          }
          var carry = 0;
          for (i7 = this.length - 1; i7 >= 0 && (carry !== 0 || i7 >= h10); i7--) {
            var word = this.words[i7] | 0;
            this.words[i7] = carry << 26 - r8 | word >>> r8;
            carry = word & mask;
          }
          if (maskedWords && carry !== 0) {
            maskedWords.words[maskedWords.length++] = carry;
          }
          if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
          }
          return this._strip();
        };
        BN3.prototype.ishrn = function ishrn(bits, hint, extended) {
          assert3(this.negative === 0);
          return this.iushrn(bits, hint, extended);
        };
        BN3.prototype.shln = function shln(bits) {
          return this.clone().ishln(bits);
        };
        BN3.prototype.ushln = function ushln(bits) {
          return this.clone().iushln(bits);
        };
        BN3.prototype.shrn = function shrn(bits) {
          return this.clone().ishrn(bits);
        };
        BN3.prototype.ushrn = function ushrn(bits) {
          return this.clone().iushrn(bits);
        };
        BN3.prototype.testn = function testn(bit) {
          assert3(typeof bit === "number" && bit >= 0);
          var r8 = bit % 26;
          var s7 = (bit - r8) / 26;
          var q8 = 1 << r8;
          if (this.length <= s7)
            return false;
          var w8 = this.words[s7];
          return !!(w8 & q8);
        };
        BN3.prototype.imaskn = function imaskn(bits) {
          assert3(typeof bits === "number" && bits >= 0);
          var r8 = bits % 26;
          var s7 = (bits - r8) / 26;
          assert3(this.negative === 0, "imaskn works only with positive numbers");
          if (this.length <= s7) {
            return this;
          }
          if (r8 !== 0) {
            s7++;
          }
          this.length = Math.min(s7, this.length);
          if (r8 !== 0) {
            var mask = 67108863 ^ 67108863 >>> r8 << r8;
            this.words[this.length - 1] &= mask;
          }
          return this._strip();
        };
        BN3.prototype.maskn = function maskn(bits) {
          return this.clone().imaskn(bits);
        };
        BN3.prototype.iaddn = function iaddn(num) {
          assert3(typeof num === "number");
          assert3(num < 67108864);
          if (num < 0)
            return this.isubn(-num);
          if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) <= num) {
              this.words[0] = num - (this.words[0] | 0);
              this.negative = 0;
              return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
          }
          return this._iaddn(num);
        };
        BN3.prototype._iaddn = function _iaddn(num) {
          this.words[0] += num;
          for (var i7 = 0; i7 < this.length && this.words[i7] >= 67108864; i7++) {
            this.words[i7] -= 67108864;
            if (i7 === this.length - 1) {
              this.words[i7 + 1] = 1;
            } else {
              this.words[i7 + 1]++;
            }
          }
          this.length = Math.max(this.length, i7 + 1);
          return this;
        };
        BN3.prototype.isubn = function isubn(num) {
          assert3(typeof num === "number");
          assert3(num < 67108864);
          if (num < 0)
            return this.iaddn(-num);
          if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
          }
          this.words[0] -= num;
          if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
          } else {
            for (var i7 = 0; i7 < this.length && this.words[i7] < 0; i7++) {
              this.words[i7] += 67108864;
              this.words[i7 + 1] -= 1;
            }
          }
          return this._strip();
        };
        BN3.prototype.addn = function addn(num) {
          return this.clone().iaddn(num);
        };
        BN3.prototype.subn = function subn(num) {
          return this.clone().isubn(num);
        };
        BN3.prototype.iabs = function iabs() {
          this.negative = 0;
          return this;
        };
        BN3.prototype.abs = function abs() {
          return this.clone().iabs();
        };
        BN3.prototype._ishlnsubmul = function _ishlnsubmul(num, mul3, shift) {
          var len = num.length + shift;
          var i7;
          this._expand(len);
          var w8;
          var carry = 0;
          for (i7 = 0; i7 < num.length; i7++) {
            w8 = (this.words[i7 + shift] | 0) + carry;
            var right = (num.words[i7] | 0) * mul3;
            w8 -= right & 67108863;
            carry = (w8 >> 26) - (right / 67108864 | 0);
            this.words[i7 + shift] = w8 & 67108863;
          }
          for (; i7 < this.length - shift; i7++) {
            w8 = (this.words[i7 + shift] | 0) + carry;
            carry = w8 >> 26;
            this.words[i7 + shift] = w8 & 67108863;
          }
          if (carry === 0)
            return this._strip();
          assert3(carry === -1);
          carry = 0;
          for (i7 = 0; i7 < this.length; i7++) {
            w8 = -(this.words[i7] | 0) + carry;
            carry = w8 >> 26;
            this.words[i7] = w8 & 67108863;
          }
          this.negative = 1;
          return this._strip();
        };
        BN3.prototype._wordDiv = function _wordDiv(num, mode) {
          var shift = this.length - num.length;
          var a6 = this.clone();
          var b7 = num;
          var bhi = b7.words[b7.length - 1] | 0;
          var bhiBits = this._countBits(bhi);
          shift = 26 - bhiBits;
          if (shift !== 0) {
            b7 = b7.ushln(shift);
            a6.iushln(shift);
            bhi = b7.words[b7.length - 1] | 0;
          }
          var m6 = a6.length - b7.length;
          var q8;
          if (mode !== "mod") {
            q8 = new BN3(null);
            q8.length = m6 + 1;
            q8.words = new Array(q8.length);
            for (var i7 = 0; i7 < q8.length; i7++) {
              q8.words[i7] = 0;
            }
          }
          var diff = a6.clone()._ishlnsubmul(b7, 1, m6);
          if (diff.negative === 0) {
            a6 = diff;
            if (q8) {
              q8.words[m6] = 1;
            }
          }
          for (var j7 = m6 - 1; j7 >= 0; j7--) {
            var qj = (a6.words[b7.length + j7] | 0) * 67108864 + (a6.words[b7.length + j7 - 1] | 0);
            qj = Math.min(qj / bhi | 0, 67108863);
            a6._ishlnsubmul(b7, qj, j7);
            while (a6.negative !== 0) {
              qj--;
              a6.negative = 0;
              a6._ishlnsubmul(b7, 1, j7);
              if (!a6.isZero()) {
                a6.negative ^= 1;
              }
            }
            if (q8) {
              q8.words[j7] = qj;
            }
          }
          if (q8) {
            q8._strip();
          }
          a6._strip();
          if (mode !== "div" && shift !== 0) {
            a6.iushrn(shift);
          }
          return {
            div: q8 || null,
            mod: a6
          };
        };
        BN3.prototype.divmod = function divmod(num, mode, positive) {
          assert3(!num.isZero());
          if (this.isZero()) {
            return {
              div: new BN3(0),
              mod: new BN3(0)
            };
          }
          var div, mod, res;
          if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.iadd(num);
              }
            }
            return {
              div,
              mod
            };
          }
          if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            return {
              div,
              mod: res.mod
            };
          }
          if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.isub(num);
              }
            }
            return {
              div: res.div,
              mod
            };
          }
          if (num.length > this.length || this.cmp(num) < 0) {
            return {
              div: new BN3(0),
              mod: this
            };
          }
          if (num.length === 1) {
            if (mode === "div") {
              return {
                div: this.divn(num.words[0]),
                mod: null
              };
            }
            if (mode === "mod") {
              return {
                div: null,
                mod: new BN3(this.modrn(num.words[0]))
              };
            }
            return {
              div: this.divn(num.words[0]),
              mod: new BN3(this.modrn(num.words[0]))
            };
          }
          return this._wordDiv(num, mode);
        };
        BN3.prototype.div = function div(num) {
          return this.divmod(num, "div", false).div;
        };
        BN3.prototype.mod = function mod(num) {
          return this.divmod(num, "mod", false).mod;
        };
        BN3.prototype.umod = function umod(num) {
          return this.divmod(num, "mod", true).mod;
        };
        BN3.prototype.divRound = function divRound(num) {
          var dm = this.divmod(num);
          if (dm.mod.isZero())
            return dm.div;
          var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
          var half = num.ushrn(1);
          var r22 = num.andln(1);
          var cmp = mod.cmp(half);
          if (cmp < 0 || r22 === 1 && cmp === 0)
            return dm.div;
          return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
        };
        BN3.prototype.modrn = function modrn(num) {
          var isNegNum = num < 0;
          if (isNegNum)
            num = -num;
          assert3(num <= 67108863);
          var p8 = (1 << 26) % num;
          var acc = 0;
          for (var i7 = this.length - 1; i7 >= 0; i7--) {
            acc = (p8 * acc + (this.words[i7] | 0)) % num;
          }
          return isNegNum ? -acc : acc;
        };
        BN3.prototype.modn = function modn(num) {
          return this.modrn(num);
        };
        BN3.prototype.idivn = function idivn(num) {
          var isNegNum = num < 0;
          if (isNegNum)
            num = -num;
          assert3(num <= 67108863);
          var carry = 0;
          for (var i7 = this.length - 1; i7 >= 0; i7--) {
            var w8 = (this.words[i7] | 0) + carry * 67108864;
            this.words[i7] = w8 / num | 0;
            carry = w8 % num;
          }
          this._strip();
          return isNegNum ? this.ineg() : this;
        };
        BN3.prototype.divn = function divn(num) {
          return this.clone().idivn(num);
        };
        BN3.prototype.egcd = function egcd(p8) {
          assert3(p8.negative === 0);
          assert3(!p8.isZero());
          var x4 = this;
          var y11 = p8.clone();
          if (x4.negative !== 0) {
            x4 = x4.umod(p8);
          } else {
            x4 = x4.clone();
          }
          var A7 = new BN3(1);
          var B10 = new BN3(0);
          var C6 = new BN3(0);
          var D10 = new BN3(1);
          var g7 = 0;
          while (x4.isEven() && y11.isEven()) {
            x4.iushrn(1);
            y11.iushrn(1);
            ++g7;
          }
          var yp = y11.clone();
          var xp = x4.clone();
          while (!x4.isZero()) {
            for (var i7 = 0, im = 1; (x4.words[0] & im) === 0 && i7 < 26; ++i7, im <<= 1)
              ;
            if (i7 > 0) {
              x4.iushrn(i7);
              while (i7-- > 0) {
                if (A7.isOdd() || B10.isOdd()) {
                  A7.iadd(yp);
                  B10.isub(xp);
                }
                A7.iushrn(1);
                B10.iushrn(1);
              }
            }
            for (var j7 = 0, jm = 1; (y11.words[0] & jm) === 0 && j7 < 26; ++j7, jm <<= 1)
              ;
            if (j7 > 0) {
              y11.iushrn(j7);
              while (j7-- > 0) {
                if (C6.isOdd() || D10.isOdd()) {
                  C6.iadd(yp);
                  D10.isub(xp);
                }
                C6.iushrn(1);
                D10.iushrn(1);
              }
            }
            if (x4.cmp(y11) >= 0) {
              x4.isub(y11);
              A7.isub(C6);
              B10.isub(D10);
            } else {
              y11.isub(x4);
              C6.isub(A7);
              D10.isub(B10);
            }
          }
          return {
            a: C6,
            b: D10,
            gcd: y11.iushln(g7)
          };
        };
        BN3.prototype._invmp = function _invmp(p8) {
          assert3(p8.negative === 0);
          assert3(!p8.isZero());
          var a6 = this;
          var b7 = p8.clone();
          if (a6.negative !== 0) {
            a6 = a6.umod(p8);
          } else {
            a6 = a6.clone();
          }
          var x1 = new BN3(1);
          var x22 = new BN3(0);
          var delta = b7.clone();
          while (a6.cmpn(1) > 0 && b7.cmpn(1) > 0) {
            for (var i7 = 0, im = 1; (a6.words[0] & im) === 0 && i7 < 26; ++i7, im <<= 1)
              ;
            if (i7 > 0) {
              a6.iushrn(i7);
              while (i7-- > 0) {
                if (x1.isOdd()) {
                  x1.iadd(delta);
                }
                x1.iushrn(1);
              }
            }
            for (var j7 = 0, jm = 1; (b7.words[0] & jm) === 0 && j7 < 26; ++j7, jm <<= 1)
              ;
            if (j7 > 0) {
              b7.iushrn(j7);
              while (j7-- > 0) {
                if (x22.isOdd()) {
                  x22.iadd(delta);
                }
                x22.iushrn(1);
              }
            }
            if (a6.cmp(b7) >= 0) {
              a6.isub(b7);
              x1.isub(x22);
            } else {
              b7.isub(a6);
              x22.isub(x1);
            }
          }
          var res;
          if (a6.cmpn(1) === 0) {
            res = x1;
          } else {
            res = x22;
          }
          if (res.cmpn(0) < 0) {
            res.iadd(p8);
          }
          return res;
        };
        BN3.prototype.gcd = function gcd(num) {
          if (this.isZero())
            return num.abs();
          if (num.isZero())
            return this.abs();
          var a6 = this.clone();
          var b7 = num.clone();
          a6.negative = 0;
          b7.negative = 0;
          for (var shift = 0; a6.isEven() && b7.isEven(); shift++) {
            a6.iushrn(1);
            b7.iushrn(1);
          }
          do {
            while (a6.isEven()) {
              a6.iushrn(1);
            }
            while (b7.isEven()) {
              b7.iushrn(1);
            }
            var r8 = a6.cmp(b7);
            if (r8 < 0) {
              var t6 = a6;
              a6 = b7;
              b7 = t6;
            } else if (r8 === 0 || b7.cmpn(1) === 0) {
              break;
            }
            a6.isub(b7);
          } while (true);
          return b7.iushln(shift);
        };
        BN3.prototype.invm = function invm(num) {
          return this.egcd(num).a.umod(num);
        };
        BN3.prototype.isEven = function isEven() {
          return (this.words[0] & 1) === 0;
        };
        BN3.prototype.isOdd = function isOdd() {
          return (this.words[0] & 1) === 1;
        };
        BN3.prototype.andln = function andln(num) {
          return this.words[0] & num;
        };
        BN3.prototype.bincn = function bincn(bit) {
          assert3(typeof bit === "number");
          var r8 = bit % 26;
          var s7 = (bit - r8) / 26;
          var q8 = 1 << r8;
          if (this.length <= s7) {
            this._expand(s7 + 1);
            this.words[s7] |= q8;
            return this;
          }
          var carry = q8;
          for (var i7 = s7; carry !== 0 && i7 < this.length; i7++) {
            var w8 = this.words[i7] | 0;
            w8 += carry;
            carry = w8 >>> 26;
            w8 &= 67108863;
            this.words[i7] = w8;
          }
          if (carry !== 0) {
            this.words[i7] = carry;
            this.length++;
          }
          return this;
        };
        BN3.prototype.isZero = function isZero() {
          return this.length === 1 && this.words[0] === 0;
        };
        BN3.prototype.cmpn = function cmpn(num) {
          var negative = num < 0;
          if (this.negative !== 0 && !negative)
            return -1;
          if (this.negative === 0 && negative)
            return 1;
          this._strip();
          var res;
          if (this.length > 1) {
            res = 1;
          } else {
            if (negative) {
              num = -num;
            }
            assert3(num <= 67108863, "Number is too big");
            var w8 = this.words[0] | 0;
            res = w8 === num ? 0 : w8 < num ? -1 : 1;
          }
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN3.prototype.cmp = function cmp(num) {
          if (this.negative !== 0 && num.negative === 0)
            return -1;
          if (this.negative === 0 && num.negative !== 0)
            return 1;
          var res = this.ucmp(num);
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN3.prototype.ucmp = function ucmp(num) {
          if (this.length > num.length)
            return 1;
          if (this.length < num.length)
            return -1;
          var res = 0;
          for (var i7 = this.length - 1; i7 >= 0; i7--) {
            var a6 = this.words[i7] | 0;
            var b7 = num.words[i7] | 0;
            if (a6 === b7)
              continue;
            if (a6 < b7) {
              res = -1;
            } else if (a6 > b7) {
              res = 1;
            }
            break;
          }
          return res;
        };
        BN3.prototype.gtn = function gtn(num) {
          return this.cmpn(num) === 1;
        };
        BN3.prototype.gt = function gt5(num) {
          return this.cmp(num) === 1;
        };
        BN3.prototype.gten = function gten(num) {
          return this.cmpn(num) >= 0;
        };
        BN3.prototype.gte = function gte(num) {
          return this.cmp(num) >= 0;
        };
        BN3.prototype.ltn = function ltn(num) {
          return this.cmpn(num) === -1;
        };
        BN3.prototype.lt = function lt4(num) {
          return this.cmp(num) === -1;
        };
        BN3.prototype.lten = function lten(num) {
          return this.cmpn(num) <= 0;
        };
        BN3.prototype.lte = function lte(num) {
          return this.cmp(num) <= 0;
        };
        BN3.prototype.eqn = function eqn(num) {
          return this.cmpn(num) === 0;
        };
        BN3.prototype.eq = function eq4(num) {
          return this.cmp(num) === 0;
        };
        BN3.red = function red(num) {
          return new Red(num);
        };
        BN3.prototype.toRed = function toRed(ctx) {
          assert3(!this.red, "Already a number in reduction context");
          assert3(this.negative === 0, "red works only with positives");
          return ctx.convertTo(this)._forceRed(ctx);
        };
        BN3.prototype.fromRed = function fromRed() {
          assert3(this.red, "fromRed works only with numbers in reduction context");
          return this.red.convertFrom(this);
        };
        BN3.prototype._forceRed = function _forceRed(ctx) {
          this.red = ctx;
          return this;
        };
        BN3.prototype.forceRed = function forceRed(ctx) {
          assert3(!this.red, "Already a number in reduction context");
          return this._forceRed(ctx);
        };
        BN3.prototype.redAdd = function redAdd(num) {
          assert3(this.red, "redAdd works only with red numbers");
          return this.red.add(this, num);
        };
        BN3.prototype.redIAdd = function redIAdd(num) {
          assert3(this.red, "redIAdd works only with red numbers");
          return this.red.iadd(this, num);
        };
        BN3.prototype.redSub = function redSub(num) {
          assert3(this.red, "redSub works only with red numbers");
          return this.red.sub(this, num);
        };
        BN3.prototype.redISub = function redISub(num) {
          assert3(this.red, "redISub works only with red numbers");
          return this.red.isub(this, num);
        };
        BN3.prototype.redShl = function redShl(num) {
          assert3(this.red, "redShl works only with red numbers");
          return this.red.shl(this, num);
        };
        BN3.prototype.redMul = function redMul(num) {
          assert3(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.mul(this, num);
        };
        BN3.prototype.redIMul = function redIMul(num) {
          assert3(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.imul(this, num);
        };
        BN3.prototype.redSqr = function redSqr() {
          assert3(this.red, "redSqr works only with red numbers");
          this.red._verify1(this);
          return this.red.sqr(this);
        };
        BN3.prototype.redISqr = function redISqr() {
          assert3(this.red, "redISqr works only with red numbers");
          this.red._verify1(this);
          return this.red.isqr(this);
        };
        BN3.prototype.redSqrt = function redSqrt() {
          assert3(this.red, "redSqrt works only with red numbers");
          this.red._verify1(this);
          return this.red.sqrt(this);
        };
        BN3.prototype.redInvm = function redInvm() {
          assert3(this.red, "redInvm works only with red numbers");
          this.red._verify1(this);
          return this.red.invm(this);
        };
        BN3.prototype.redNeg = function redNeg() {
          assert3(this.red, "redNeg works only with red numbers");
          this.red._verify1(this);
          return this.red.neg(this);
        };
        BN3.prototype.redPow = function redPow(num) {
          assert3(this.red && !num.red, "redPow(normalNum)");
          this.red._verify1(this);
          return this.red.pow(this, num);
        };
        var primes = {
          k256: null,
          p224: null,
          p192: null,
          p25519: null
        };
        function MPrime(name2, p8) {
          this.name = name2;
          this.p = new BN3(p8, 16);
          this.n = this.p.bitLength();
          this.k = new BN3(1).iushln(this.n).isub(this.p);
          this.tmp = this._tmp();
        }
        MPrime.prototype._tmp = function _tmp() {
          var tmp = new BN3(null);
          tmp.words = new Array(Math.ceil(this.n / 13));
          return tmp;
        };
        MPrime.prototype.ireduce = function ireduce(num) {
          var r8 = num;
          var rlen;
          do {
            this.split(r8, this.tmp);
            r8 = this.imulK(r8);
            r8 = r8.iadd(this.tmp);
            rlen = r8.bitLength();
          } while (rlen > this.n);
          var cmp = rlen < this.n ? -1 : r8.ucmp(this.p);
          if (cmp === 0) {
            r8.words[0] = 0;
            r8.length = 1;
          } else if (cmp > 0) {
            r8.isub(this.p);
          } else {
            if (r8.strip !== void 0) {
              r8.strip();
            } else {
              r8._strip();
            }
          }
          return r8;
        };
        MPrime.prototype.split = function split2(input, out) {
          input.iushrn(this.n, 0, out);
        };
        MPrime.prototype.imulK = function imulK(num) {
          return num.imul(this.k);
        };
        function K256() {
          MPrime.call(
            this,
            "k256",
            "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
          );
        }
        inherits2(K256, MPrime);
        K256.prototype.split = function split2(input, output2) {
          var mask = 4194303;
          var outLen = Math.min(input.length, 9);
          for (var i7 = 0; i7 < outLen; i7++) {
            output2.words[i7] = input.words[i7];
          }
          output2.length = outLen;
          if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
          }
          var prev = input.words[9];
          output2.words[output2.length++] = prev & mask;
          for (i7 = 10; i7 < input.length; i7++) {
            var next = input.words[i7] | 0;
            input.words[i7 - 10] = (next & mask) << 4 | prev >>> 22;
            prev = next;
          }
          prev >>>= 22;
          input.words[i7 - 10] = prev;
          if (prev === 0 && input.length > 10) {
            input.length -= 10;
          } else {
            input.length -= 9;
          }
        };
        K256.prototype.imulK = function imulK(num) {
          num.words[num.length] = 0;
          num.words[num.length + 1] = 0;
          num.length += 2;
          var lo3 = 0;
          for (var i7 = 0; i7 < num.length; i7++) {
            var w8 = num.words[i7] | 0;
            lo3 += w8 * 977;
            num.words[i7] = lo3 & 67108863;
            lo3 = w8 * 64 + (lo3 / 67108864 | 0);
          }
          if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) {
              num.length--;
            }
          }
          return num;
        };
        function P224() {
          MPrime.call(
            this,
            "p224",
            "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
          );
        }
        inherits2(P224, MPrime);
        function P192() {
          MPrime.call(
            this,
            "p192",
            "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
          );
        }
        inherits2(P192, MPrime);
        function P25519() {
          MPrime.call(
            this,
            "25519",
            "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
          );
        }
        inherits2(P25519, MPrime);
        P25519.prototype.imulK = function imulK(num) {
          var carry = 0;
          for (var i7 = 0; i7 < num.length; i7++) {
            var hi2 = (num.words[i7] | 0) * 19 + carry;
            var lo3 = hi2 & 67108863;
            hi2 >>>= 26;
            num.words[i7] = lo3;
            carry = hi2;
          }
          if (carry !== 0) {
            num.words[num.length++] = carry;
          }
          return num;
        };
        BN3._prime = function prime(name2) {
          if (primes[name2])
            return primes[name2];
          var prime2;
          if (name2 === "k256") {
            prime2 = new K256();
          } else if (name2 === "p224") {
            prime2 = new P224();
          } else if (name2 === "p192") {
            prime2 = new P192();
          } else if (name2 === "p25519") {
            prime2 = new P25519();
          } else {
            throw new Error("Unknown prime " + name2);
          }
          primes[name2] = prime2;
          return prime2;
        };
        function Red(m6) {
          if (typeof m6 === "string") {
            var prime = BN3._prime(m6);
            this.m = prime.p;
            this.prime = prime;
          } else {
            assert3(m6.gtn(1), "modulus must be greater than 1");
            this.m = m6;
            this.prime = null;
          }
        }
        Red.prototype._verify1 = function _verify1(a6) {
          assert3(a6.negative === 0, "red works only with positives");
          assert3(a6.red, "red works only with red numbers");
        };
        Red.prototype._verify2 = function _verify2(a6, b7) {
          assert3((a6.negative | b7.negative) === 0, "red works only with positives");
          assert3(
            a6.red && a6.red === b7.red,
            "red works only with red numbers"
          );
        };
        Red.prototype.imod = function imod(a6) {
          if (this.prime)
            return this.prime.ireduce(a6)._forceRed(this);
          move(a6, a6.umod(this.m)._forceRed(this));
          return a6;
        };
        Red.prototype.neg = function neg3(a6) {
          if (a6.isZero()) {
            return a6.clone();
          }
          return this.m.sub(a6)._forceRed(this);
        };
        Red.prototype.add = function add4(a6, b7) {
          this._verify2(a6, b7);
          var res = a6.add(b7);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.iadd = function iadd(a6, b7) {
          this._verify2(a6, b7);
          var res = a6.iadd(b7);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res;
        };
        Red.prototype.sub = function sub(a6, b7) {
          this._verify2(a6, b7);
          var res = a6.sub(b7);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.isub = function isub(a6, b7) {
          this._verify2(a6, b7);
          var res = a6.isub(b7);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res;
        };
        Red.prototype.shl = function shl(a6, num) {
          this._verify1(a6);
          return this.imod(a6.ushln(num));
        };
        Red.prototype.imul = function imul(a6, b7) {
          this._verify2(a6, b7);
          return this.imod(a6.imul(b7));
        };
        Red.prototype.mul = function mul3(a6, b7) {
          this._verify2(a6, b7);
          return this.imod(a6.mul(b7));
        };
        Red.prototype.isqr = function isqr(a6) {
          return this.imul(a6, a6.clone());
        };
        Red.prototype.sqr = function sqr(a6) {
          return this.mul(a6, a6);
        };
        Red.prototype.sqrt = function sqrt(a6) {
          if (a6.isZero())
            return a6.clone();
          var mod3 = this.m.andln(3);
          assert3(mod3 % 2 === 1);
          if (mod3 === 3) {
            var pow = this.m.add(new BN3(1)).iushrn(2);
            return this.pow(a6, pow);
          }
          var q8 = this.m.subn(1);
          var s7 = 0;
          while (!q8.isZero() && q8.andln(1) === 0) {
            s7++;
            q8.iushrn(1);
          }
          assert3(!q8.isZero());
          var one = new BN3(1).toRed(this);
          var nOne = one.redNeg();
          var lpow = this.m.subn(1).iushrn(1);
          var z7 = this.m.bitLength();
          z7 = new BN3(2 * z7 * z7).toRed(this);
          while (this.pow(z7, lpow).cmp(nOne) !== 0) {
            z7.redIAdd(nOne);
          }
          var c9 = this.pow(z7, q8);
          var r8 = this.pow(a6, q8.addn(1).iushrn(1));
          var t6 = this.pow(a6, q8);
          var m6 = s7;
          while (t6.cmp(one) !== 0) {
            var tmp = t6;
            for (var i7 = 0; tmp.cmp(one) !== 0; i7++) {
              tmp = tmp.redSqr();
            }
            assert3(i7 < m6);
            var b7 = this.pow(c9, new BN3(1).iushln(m6 - i7 - 1));
            r8 = r8.redMul(b7);
            c9 = b7.redSqr();
            t6 = t6.redMul(c9);
            m6 = i7;
          }
          return r8;
        };
        Red.prototype.invm = function invm(a6) {
          var inv = a6._invmp(this.m);
          if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
          } else {
            return this.imod(inv);
          }
        };
        Red.prototype.pow = function pow(a6, num) {
          if (num.isZero())
            return new BN3(1).toRed(this);
          if (num.cmpn(1) === 0)
            return a6.clone();
          var windowSize = 4;
          var wnd = new Array(1 << windowSize);
          wnd[0] = new BN3(1).toRed(this);
          wnd[1] = a6;
          for (var i7 = 2; i7 < wnd.length; i7++) {
            wnd[i7] = this.mul(wnd[i7 - 1], a6);
          }
          var res = wnd[0];
          var current = 0;
          var currentLen = 0;
          var start = num.bitLength() % 26;
          if (start === 0) {
            start = 26;
          }
          for (i7 = num.length - 1; i7 >= 0; i7--) {
            var word = num.words[i7];
            for (var j7 = start - 1; j7 >= 0; j7--) {
              var bit = word >> j7 & 1;
              if (res !== wnd[0]) {
                res = this.sqr(res);
              }
              if (bit === 0 && current === 0) {
                currentLen = 0;
                continue;
              }
              current <<= 1;
              current |= bit;
              currentLen++;
              if (currentLen !== windowSize && (i7 !== 0 || j7 !== 0))
                continue;
              res = this.mul(res, wnd[current]);
              currentLen = 0;
              current = 0;
            }
            start = 26;
          }
          return res;
        };
        Red.prototype.convertTo = function convertTo(num) {
          var r8 = num.umod(this.m);
          return r8 === num ? r8.clone() : r8;
        };
        Red.prototype.convertFrom = function convertFrom(num) {
          var res = num.clone();
          res.red = null;
          return res;
        };
        BN3.mont = function mont(num) {
          return new Mont(num);
        };
        function Mont(m6) {
          Red.call(this, m6);
          this.shift = this.m.bitLength();
          if (this.shift % 26 !== 0) {
            this.shift += 26 - this.shift % 26;
          }
          this.r = new BN3(1).iushln(this.shift);
          this.r2 = this.imod(this.r.sqr());
          this.rinv = this.r._invmp(this.m);
          this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
          this.minv = this.minv.umod(this.r);
          this.minv = this.r.sub(this.minv);
        }
        inherits2(Mont, Red);
        Mont.prototype.convertTo = function convertTo(num) {
          return this.imod(num.ushln(this.shift));
        };
        Mont.prototype.convertFrom = function convertFrom(num) {
          var r8 = this.imod(num.mul(this.rinv));
          r8.red = null;
          return r8;
        };
        Mont.prototype.imul = function imul(a6, b7) {
          if (a6.isZero() || b7.isZero()) {
            a6.words[0] = 0;
            a6.length = 1;
            return a6;
          }
          var t6 = a6.imul(b7);
          var c9 = t6.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u7 = t6.isub(c9).iushrn(this.shift);
          var res = u7;
          if (u7.cmp(this.m) >= 0) {
            res = u7.isub(this.m);
          } else if (u7.cmpn(0) < 0) {
            res = u7.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.mul = function mul3(a6, b7) {
          if (a6.isZero() || b7.isZero())
            return new BN3(0)._forceRed(this);
          var t6 = a6.mul(b7);
          var c9 = t6.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u7 = t6.isub(c9).iushrn(this.shift);
          var res = u7;
          if (u7.cmp(this.m) >= 0) {
            res = u7.isub(this.m);
          } else if (u7.cmpn(0) < 0) {
            res = u7.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.invm = function invm(a6) {
          var res = this.imod(a6._invmp(this.m).mul(this.r2));
          return res._forceRed(this);
        };
      })(typeof module === "undefined" || module, exports);
    }
  });

  // node_modules/js-sha3/src/sha3.js
  var require_sha3 = __commonJS({
    "node_modules/js-sha3/src/sha3.js"(exports, module) {
      (function() {
        "use strict";
        var INPUT_ERROR = "input is invalid type";
        var FINALIZE_ERROR = "finalize already called";
        var WINDOW = typeof window === "object";
        var root2 = WINDOW ? window : {};
        if (root2.JS_SHA3_NO_WINDOW) {
          WINDOW = false;
        }
        var WEB_WORKER = !WINDOW && typeof self === "object";
        var NODE_JS = !root2.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
        if (NODE_JS) {
          root2 = global;
        } else if (WEB_WORKER) {
          root2 = self;
        }
        var COMMON_JS = !root2.JS_SHA3_NO_COMMON_JS && typeof module === "object" && module.exports;
        var AMD = typeof define === "function" && define.amd;
        var ARRAY_BUFFER = !root2.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
        var HEX_CHARS = "0123456789abcdef".split("");
        var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
        var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
        var KECCAK_PADDING = [1, 256, 65536, 16777216];
        var PADDING = [6, 1536, 393216, 100663296];
        var SHIFT = [0, 8, 16, 24];
        var RC = [
          1,
          0,
          32898,
          0,
          32906,
          2147483648,
          2147516416,
          2147483648,
          32907,
          0,
          2147483649,
          0,
          2147516545,
          2147483648,
          32777,
          2147483648,
          138,
          0,
          136,
          0,
          2147516425,
          0,
          2147483658,
          0,
          2147516555,
          0,
          139,
          2147483648,
          32905,
          2147483648,
          32771,
          2147483648,
          32770,
          2147483648,
          128,
          2147483648,
          32778,
          0,
          2147483658,
          2147483648,
          2147516545,
          2147483648,
          32896,
          2147483648,
          2147483649,
          0,
          2147516424,
          2147483648
        ];
        var BITS = [224, 256, 384, 512];
        var SHAKE_BITS = [128, 256];
        var OUTPUT_TYPES = ["hex", "buffer", "arrayBuffer", "array", "digest"];
        var CSHAKE_BYTEPAD = {
          "128": 168,
          "256": 136
        };
        if (root2.JS_SHA3_NO_NODE_JS || !Array.isArray) {
          Array.isArray = function(obj) {
            return Object.prototype.toString.call(obj) === "[object Array]";
          };
        }
        if (ARRAY_BUFFER && (root2.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
          ArrayBuffer.isView = function(obj) {
            return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
          };
        }
        var createOutputMethod = function(bits2, padding2, outputType) {
          return function(message) {
            return new Keccak2(bits2, padding2, bits2).update(message)[outputType]();
          };
        };
        var createShakeOutputMethod = function(bits2, padding2, outputType) {
          return function(message, outputBits) {
            return new Keccak2(bits2, padding2, outputBits).update(message)[outputType]();
          };
        };
        var createCshakeOutputMethod = function(bits2, padding2, outputType) {
          return function(message, outputBits, n9, s7) {
            return methods["cshake" + bits2].update(message, outputBits, n9, s7)[outputType]();
          };
        };
        var createKmacOutputMethod = function(bits2, padding2, outputType) {
          return function(key2, message, outputBits, s7) {
            return methods["kmac" + bits2].update(key2, message, outputBits, s7)[outputType]();
          };
        };
        var createOutputMethods = function(method, createMethod2, bits2, padding2) {
          for (var i8 = 0; i8 < OUTPUT_TYPES.length; ++i8) {
            var type = OUTPUT_TYPES[i8];
            method[type] = createMethod2(bits2, padding2, type);
          }
          return method;
        };
        var createMethod = function(bits2, padding2) {
          var method = createOutputMethod(bits2, padding2, "hex");
          method.create = function() {
            return new Keccak2(bits2, padding2, bits2);
          };
          method.update = function(message) {
            return method.create().update(message);
          };
          return createOutputMethods(method, createOutputMethod, bits2, padding2);
        };
        var createShakeMethod = function(bits2, padding2) {
          var method = createShakeOutputMethod(bits2, padding2, "hex");
          method.create = function(outputBits) {
            return new Keccak2(bits2, padding2, outputBits);
          };
          method.update = function(message, outputBits) {
            return method.create(outputBits).update(message);
          };
          return createOutputMethods(method, createShakeOutputMethod, bits2, padding2);
        };
        var createCshakeMethod = function(bits2, padding2) {
          var w8 = CSHAKE_BYTEPAD[bits2];
          var method = createCshakeOutputMethod(bits2, padding2, "hex");
          method.create = function(outputBits, n9, s7) {
            if (!n9 && !s7) {
              return methods["shake" + bits2].create(outputBits);
            } else {
              return new Keccak2(bits2, padding2, outputBits).bytepad([n9, s7], w8);
            }
          };
          method.update = function(message, outputBits, n9, s7) {
            return method.create(outputBits, n9, s7).update(message);
          };
          return createOutputMethods(method, createCshakeOutputMethod, bits2, padding2);
        };
        var createKmacMethod = function(bits2, padding2) {
          var w8 = CSHAKE_BYTEPAD[bits2];
          var method = createKmacOutputMethod(bits2, padding2, "hex");
          method.create = function(key2, outputBits, s7) {
            return new Kmac(bits2, padding2, outputBits).bytepad(["KMAC", s7], w8).bytepad([key2], w8);
          };
          method.update = function(key2, message, outputBits, s7) {
            return method.create(key2, outputBits, s7).update(message);
          };
          return createOutputMethods(method, createKmacOutputMethod, bits2, padding2);
        };
        var algorithms = [
          { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod },
          { name: "sha3", padding: PADDING, bits: BITS, createMethod },
          { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
          { name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
          { name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
        ];
        var methods = {}, methodNames = [];
        for (var i7 = 0; i7 < algorithms.length; ++i7) {
          var algorithm = algorithms[i7];
          var bits = algorithm.bits;
          for (var j7 = 0; j7 < bits.length; ++j7) {
            var methodName = algorithm.name + "_" + bits[j7];
            methodNames.push(methodName);
            methods[methodName] = algorithm.createMethod(bits[j7], algorithm.padding);
            if (algorithm.name !== "sha3") {
              var newMethodName = algorithm.name + bits[j7];
              methodNames.push(newMethodName);
              methods[newMethodName] = methods[methodName];
            }
          }
        }
        function Keccak2(bits2, padding2, outputBits) {
          this.blocks = [];
          this.s = [];
          this.padding = padding2;
          this.outputBits = outputBits;
          this.reset = true;
          this.finalized = false;
          this.block = 0;
          this.start = 0;
          this.blockCount = 1600 - (bits2 << 1) >> 5;
          this.byteCount = this.blockCount << 2;
          this.outputBlocks = outputBits >> 5;
          this.extraBytes = (outputBits & 31) >> 3;
          for (var i8 = 0; i8 < 50; ++i8) {
            this.s[i8] = 0;
          }
        }
        Keccak2.prototype.update = function(message) {
          if (this.finalized) {
            throw new Error(FINALIZE_ERROR);
          }
          var notString, type = typeof message;
          if (type !== "string") {
            if (type === "object") {
              if (message === null) {
                throw new Error(INPUT_ERROR);
              } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
                message = new Uint8Array(message);
              } else if (!Array.isArray(message)) {
                if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                  throw new Error(INPUT_ERROR);
                }
              }
            } else {
              throw new Error(INPUT_ERROR);
            }
            notString = true;
          }
          var blocks = this.blocks, byteCount = this.byteCount, length2 = message.length, blockCount = this.blockCount, index2 = 0, s7 = this.s, i8, code2;
          while (index2 < length2) {
            if (this.reset) {
              this.reset = false;
              blocks[0] = this.block;
              for (i8 = 1; i8 < blockCount + 1; ++i8) {
                blocks[i8] = 0;
              }
            }
            if (notString) {
              for (i8 = this.start; index2 < length2 && i8 < byteCount; ++index2) {
                blocks[i8 >> 2] |= message[index2] << SHIFT[i8++ & 3];
              }
            } else {
              for (i8 = this.start; index2 < length2 && i8 < byteCount; ++index2) {
                code2 = message.charCodeAt(index2);
                if (code2 < 128) {
                  blocks[i8 >> 2] |= code2 << SHIFT[i8++ & 3];
                } else if (code2 < 2048) {
                  blocks[i8 >> 2] |= (192 | code2 >> 6) << SHIFT[i8++ & 3];
                  blocks[i8 >> 2] |= (128 | code2 & 63) << SHIFT[i8++ & 3];
                } else if (code2 < 55296 || code2 >= 57344) {
                  blocks[i8 >> 2] |= (224 | code2 >> 12) << SHIFT[i8++ & 3];
                  blocks[i8 >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i8++ & 3];
                  blocks[i8 >> 2] |= (128 | code2 & 63) << SHIFT[i8++ & 3];
                } else {
                  code2 = 65536 + ((code2 & 1023) << 10 | message.charCodeAt(++index2) & 1023);
                  blocks[i8 >> 2] |= (240 | code2 >> 18) << SHIFT[i8++ & 3];
                  blocks[i8 >> 2] |= (128 | code2 >> 12 & 63) << SHIFT[i8++ & 3];
                  blocks[i8 >> 2] |= (128 | code2 >> 6 & 63) << SHIFT[i8++ & 3];
                  blocks[i8 >> 2] |= (128 | code2 & 63) << SHIFT[i8++ & 3];
                }
              }
            }
            this.lastByteIndex = i8;
            if (i8 >= byteCount) {
              this.start = i8 - byteCount;
              this.block = blocks[blockCount];
              for (i8 = 0; i8 < blockCount; ++i8) {
                s7[i8] ^= blocks[i8];
              }
              f7(s7);
              this.reset = true;
            } else {
              this.start = i8;
            }
          }
          return this;
        };
        Keccak2.prototype.encode = function(x4, right) {
          var o9 = x4 & 255, n9 = 1;
          var bytes3 = [o9];
          x4 = x4 >> 8;
          o9 = x4 & 255;
          while (o9 > 0) {
            bytes3.unshift(o9);
            x4 = x4 >> 8;
            o9 = x4 & 255;
            ++n9;
          }
          if (right) {
            bytes3.push(n9);
          } else {
            bytes3.unshift(n9);
          }
          this.update(bytes3);
          return bytes3.length;
        };
        Keccak2.prototype.encodeString = function(str) {
          var notString, type = typeof str;
          if (type !== "string") {
            if (type === "object") {
              if (str === null) {
                throw new Error(INPUT_ERROR);
              } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
                str = new Uint8Array(str);
              } else if (!Array.isArray(str)) {
                if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
                  throw new Error(INPUT_ERROR);
                }
              }
            } else {
              throw new Error(INPUT_ERROR);
            }
            notString = true;
          }
          var bytes3 = 0, length2 = str.length;
          if (notString) {
            bytes3 = length2;
          } else {
            for (var i8 = 0; i8 < str.length; ++i8) {
              var code2 = str.charCodeAt(i8);
              if (code2 < 128) {
                bytes3 += 1;
              } else if (code2 < 2048) {
                bytes3 += 2;
              } else if (code2 < 55296 || code2 >= 57344) {
                bytes3 += 3;
              } else {
                code2 = 65536 + ((code2 & 1023) << 10 | str.charCodeAt(++i8) & 1023);
                bytes3 += 4;
              }
            }
          }
          bytes3 += this.encode(bytes3 * 8);
          this.update(str);
          return bytes3;
        };
        Keccak2.prototype.bytepad = function(strs, w8) {
          var bytes3 = this.encode(w8);
          for (var i8 = 0; i8 < strs.length; ++i8) {
            bytes3 += this.encodeString(strs[i8]);
          }
          var paddingBytes = w8 - bytes3 % w8;
          var zeros2 = [];
          zeros2.length = paddingBytes;
          this.update(zeros2);
          return this;
        };
        Keccak2.prototype.finalize = function() {
          if (this.finalized) {
            return;
          }
          this.finalized = true;
          var blocks = this.blocks, i8 = this.lastByteIndex, blockCount = this.blockCount, s7 = this.s;
          blocks[i8 >> 2] |= this.padding[i8 & 3];
          if (this.lastByteIndex === this.byteCount) {
            blocks[0] = blocks[blockCount];
            for (i8 = 1; i8 < blockCount + 1; ++i8) {
              blocks[i8] = 0;
            }
          }
          blocks[blockCount - 1] |= 2147483648;
          for (i8 = 0; i8 < blockCount; ++i8) {
            s7[i8] ^= blocks[i8];
          }
          f7(s7);
        };
        Keccak2.prototype.toString = Keccak2.prototype.hex = function() {
          this.finalize();
          var blockCount = this.blockCount, s7 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i8 = 0, j8 = 0;
          var hex = "", block2;
          while (j8 < outputBlocks) {
            for (i8 = 0; i8 < blockCount && j8 < outputBlocks; ++i8, ++j8) {
              block2 = s7[i8];
              hex += HEX_CHARS[block2 >> 4 & 15] + HEX_CHARS[block2 & 15] + HEX_CHARS[block2 >> 12 & 15] + HEX_CHARS[block2 >> 8 & 15] + HEX_CHARS[block2 >> 20 & 15] + HEX_CHARS[block2 >> 16 & 15] + HEX_CHARS[block2 >> 28 & 15] + HEX_CHARS[block2 >> 24 & 15];
            }
            if (j8 % blockCount === 0) {
              f7(s7);
              i8 = 0;
            }
          }
          if (extraBytes) {
            block2 = s7[i8];
            hex += HEX_CHARS[block2 >> 4 & 15] + HEX_CHARS[block2 & 15];
            if (extraBytes > 1) {
              hex += HEX_CHARS[block2 >> 12 & 15] + HEX_CHARS[block2 >> 8 & 15];
            }
            if (extraBytes > 2) {
              hex += HEX_CHARS[block2 >> 20 & 15] + HEX_CHARS[block2 >> 16 & 15];
            }
          }
          return hex;
        };
        Keccak2.prototype.arrayBuffer = function() {
          this.finalize();
          var blockCount = this.blockCount, s7 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i8 = 0, j8 = 0;
          var bytes3 = this.outputBits >> 3;
          var buffer2;
          if (extraBytes) {
            buffer2 = new ArrayBuffer(outputBlocks + 1 << 2);
          } else {
            buffer2 = new ArrayBuffer(bytes3);
          }
          var array = new Uint32Array(buffer2);
          while (j8 < outputBlocks) {
            for (i8 = 0; i8 < blockCount && j8 < outputBlocks; ++i8, ++j8) {
              array[j8] = s7[i8];
            }
            if (j8 % blockCount === 0) {
              f7(s7);
            }
          }
          if (extraBytes) {
            array[i8] = s7[i8];
            buffer2 = buffer2.slice(0, bytes3);
          }
          return buffer2;
        };
        Keccak2.prototype.buffer = Keccak2.prototype.arrayBuffer;
        Keccak2.prototype.digest = Keccak2.prototype.array = function() {
          this.finalize();
          var blockCount = this.blockCount, s7 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i8 = 0, j8 = 0;
          var array = [], offset, block2;
          while (j8 < outputBlocks) {
            for (i8 = 0; i8 < blockCount && j8 < outputBlocks; ++i8, ++j8) {
              offset = j8 << 2;
              block2 = s7[i8];
              array[offset] = block2 & 255;
              array[offset + 1] = block2 >> 8 & 255;
              array[offset + 2] = block2 >> 16 & 255;
              array[offset + 3] = block2 >> 24 & 255;
            }
            if (j8 % blockCount === 0) {
              f7(s7);
            }
          }
          if (extraBytes) {
            offset = j8 << 2;
            block2 = s7[i8];
            array[offset] = block2 & 255;
            if (extraBytes > 1) {
              array[offset + 1] = block2 >> 8 & 255;
            }
            if (extraBytes > 2) {
              array[offset + 2] = block2 >> 16 & 255;
            }
          }
          return array;
        };
        function Kmac(bits2, padding2, outputBits) {
          Keccak2.call(this, bits2, padding2, outputBits);
        }
        Kmac.prototype = new Keccak2();
        Kmac.prototype.finalize = function() {
          this.encode(this.outputBits, true);
          return Keccak2.prototype.finalize.call(this);
        };
        var f7 = function(s7) {
          var h10, l9, n9, c0, c1, c22, c32, c42, c52, c62, c72, c82, c9, b0, b1, b22, b32, b42, b52, b62, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b222, b23, b24, b25, b26, b27, b28, b29, b30, b31, b322, b33, b34, b35, b36, b37, b38, b39, b40, b41, b422, b43, b44, b45, b46, b47, b48, b49;
          for (n9 = 0; n9 < 48; n9 += 2) {
            c0 = s7[0] ^ s7[10] ^ s7[20] ^ s7[30] ^ s7[40];
            c1 = s7[1] ^ s7[11] ^ s7[21] ^ s7[31] ^ s7[41];
            c22 = s7[2] ^ s7[12] ^ s7[22] ^ s7[32] ^ s7[42];
            c32 = s7[3] ^ s7[13] ^ s7[23] ^ s7[33] ^ s7[43];
            c42 = s7[4] ^ s7[14] ^ s7[24] ^ s7[34] ^ s7[44];
            c52 = s7[5] ^ s7[15] ^ s7[25] ^ s7[35] ^ s7[45];
            c62 = s7[6] ^ s7[16] ^ s7[26] ^ s7[36] ^ s7[46];
            c72 = s7[7] ^ s7[17] ^ s7[27] ^ s7[37] ^ s7[47];
            c82 = s7[8] ^ s7[18] ^ s7[28] ^ s7[38] ^ s7[48];
            c9 = s7[9] ^ s7[19] ^ s7[29] ^ s7[39] ^ s7[49];
            h10 = c82 ^ (c22 << 1 | c32 >>> 31);
            l9 = c9 ^ (c32 << 1 | c22 >>> 31);
            s7[0] ^= h10;
            s7[1] ^= l9;
            s7[10] ^= h10;
            s7[11] ^= l9;
            s7[20] ^= h10;
            s7[21] ^= l9;
            s7[30] ^= h10;
            s7[31] ^= l9;
            s7[40] ^= h10;
            s7[41] ^= l9;
            h10 = c0 ^ (c42 << 1 | c52 >>> 31);
            l9 = c1 ^ (c52 << 1 | c42 >>> 31);
            s7[2] ^= h10;
            s7[3] ^= l9;
            s7[12] ^= h10;
            s7[13] ^= l9;
            s7[22] ^= h10;
            s7[23] ^= l9;
            s7[32] ^= h10;
            s7[33] ^= l9;
            s7[42] ^= h10;
            s7[43] ^= l9;
            h10 = c22 ^ (c62 << 1 | c72 >>> 31);
            l9 = c32 ^ (c72 << 1 | c62 >>> 31);
            s7[4] ^= h10;
            s7[5] ^= l9;
            s7[14] ^= h10;
            s7[15] ^= l9;
            s7[24] ^= h10;
            s7[25] ^= l9;
            s7[34] ^= h10;
            s7[35] ^= l9;
            s7[44] ^= h10;
            s7[45] ^= l9;
            h10 = c42 ^ (c82 << 1 | c9 >>> 31);
            l9 = c52 ^ (c9 << 1 | c82 >>> 31);
            s7[6] ^= h10;
            s7[7] ^= l9;
            s7[16] ^= h10;
            s7[17] ^= l9;
            s7[26] ^= h10;
            s7[27] ^= l9;
            s7[36] ^= h10;
            s7[37] ^= l9;
            s7[46] ^= h10;
            s7[47] ^= l9;
            h10 = c62 ^ (c0 << 1 | c1 >>> 31);
            l9 = c72 ^ (c1 << 1 | c0 >>> 31);
            s7[8] ^= h10;
            s7[9] ^= l9;
            s7[18] ^= h10;
            s7[19] ^= l9;
            s7[28] ^= h10;
            s7[29] ^= l9;
            s7[38] ^= h10;
            s7[39] ^= l9;
            s7[48] ^= h10;
            s7[49] ^= l9;
            b0 = s7[0];
            b1 = s7[1];
            b322 = s7[11] << 4 | s7[10] >>> 28;
            b33 = s7[10] << 4 | s7[11] >>> 28;
            b14 = s7[20] << 3 | s7[21] >>> 29;
            b15 = s7[21] << 3 | s7[20] >>> 29;
            b46 = s7[31] << 9 | s7[30] >>> 23;
            b47 = s7[30] << 9 | s7[31] >>> 23;
            b28 = s7[40] << 18 | s7[41] >>> 14;
            b29 = s7[41] << 18 | s7[40] >>> 14;
            b20 = s7[2] << 1 | s7[3] >>> 31;
            b21 = s7[3] << 1 | s7[2] >>> 31;
            b22 = s7[13] << 12 | s7[12] >>> 20;
            b32 = s7[12] << 12 | s7[13] >>> 20;
            b34 = s7[22] << 10 | s7[23] >>> 22;
            b35 = s7[23] << 10 | s7[22] >>> 22;
            b16 = s7[33] << 13 | s7[32] >>> 19;
            b17 = s7[32] << 13 | s7[33] >>> 19;
            b48 = s7[42] << 2 | s7[43] >>> 30;
            b49 = s7[43] << 2 | s7[42] >>> 30;
            b40 = s7[5] << 30 | s7[4] >>> 2;
            b41 = s7[4] << 30 | s7[5] >>> 2;
            b222 = s7[14] << 6 | s7[15] >>> 26;
            b23 = s7[15] << 6 | s7[14] >>> 26;
            b42 = s7[25] << 11 | s7[24] >>> 21;
            b52 = s7[24] << 11 | s7[25] >>> 21;
            b36 = s7[34] << 15 | s7[35] >>> 17;
            b37 = s7[35] << 15 | s7[34] >>> 17;
            b18 = s7[45] << 29 | s7[44] >>> 3;
            b19 = s7[44] << 29 | s7[45] >>> 3;
            b10 = s7[6] << 28 | s7[7] >>> 4;
            b11 = s7[7] << 28 | s7[6] >>> 4;
            b422 = s7[17] << 23 | s7[16] >>> 9;
            b43 = s7[16] << 23 | s7[17] >>> 9;
            b24 = s7[26] << 25 | s7[27] >>> 7;
            b25 = s7[27] << 25 | s7[26] >>> 7;
            b62 = s7[36] << 21 | s7[37] >>> 11;
            b7 = s7[37] << 21 | s7[36] >>> 11;
            b38 = s7[47] << 24 | s7[46] >>> 8;
            b39 = s7[46] << 24 | s7[47] >>> 8;
            b30 = s7[8] << 27 | s7[9] >>> 5;
            b31 = s7[9] << 27 | s7[8] >>> 5;
            b12 = s7[18] << 20 | s7[19] >>> 12;
            b13 = s7[19] << 20 | s7[18] >>> 12;
            b44 = s7[29] << 7 | s7[28] >>> 25;
            b45 = s7[28] << 7 | s7[29] >>> 25;
            b26 = s7[38] << 8 | s7[39] >>> 24;
            b27 = s7[39] << 8 | s7[38] >>> 24;
            b8 = s7[48] << 14 | s7[49] >>> 18;
            b9 = s7[49] << 14 | s7[48] >>> 18;
            s7[0] = b0 ^ ~b22 & b42;
            s7[1] = b1 ^ ~b32 & b52;
            s7[10] = b10 ^ ~b12 & b14;
            s7[11] = b11 ^ ~b13 & b15;
            s7[20] = b20 ^ ~b222 & b24;
            s7[21] = b21 ^ ~b23 & b25;
            s7[30] = b30 ^ ~b322 & b34;
            s7[31] = b31 ^ ~b33 & b35;
            s7[40] = b40 ^ ~b422 & b44;
            s7[41] = b41 ^ ~b43 & b45;
            s7[2] = b22 ^ ~b42 & b62;
            s7[3] = b32 ^ ~b52 & b7;
            s7[12] = b12 ^ ~b14 & b16;
            s7[13] = b13 ^ ~b15 & b17;
            s7[22] = b222 ^ ~b24 & b26;
            s7[23] = b23 ^ ~b25 & b27;
            s7[32] = b322 ^ ~b34 & b36;
            s7[33] = b33 ^ ~b35 & b37;
            s7[42] = b422 ^ ~b44 & b46;
            s7[43] = b43 ^ ~b45 & b47;
            s7[4] = b42 ^ ~b62 & b8;
            s7[5] = b52 ^ ~b7 & b9;
            s7[14] = b14 ^ ~b16 & b18;
            s7[15] = b15 ^ ~b17 & b19;
            s7[24] = b24 ^ ~b26 & b28;
            s7[25] = b25 ^ ~b27 & b29;
            s7[34] = b34 ^ ~b36 & b38;
            s7[35] = b35 ^ ~b37 & b39;
            s7[44] = b44 ^ ~b46 & b48;
            s7[45] = b45 ^ ~b47 & b49;
            s7[6] = b62 ^ ~b8 & b0;
            s7[7] = b7 ^ ~b9 & b1;
            s7[16] = b16 ^ ~b18 & b10;
            s7[17] = b17 ^ ~b19 & b11;
            s7[26] = b26 ^ ~b28 & b20;
            s7[27] = b27 ^ ~b29 & b21;
            s7[36] = b36 ^ ~b38 & b30;
            s7[37] = b37 ^ ~b39 & b31;
            s7[46] = b46 ^ ~b48 & b40;
            s7[47] = b47 ^ ~b49 & b41;
            s7[8] = b8 ^ ~b0 & b22;
            s7[9] = b9 ^ ~b1 & b32;
            s7[18] = b18 ^ ~b10 & b12;
            s7[19] = b19 ^ ~b11 & b13;
            s7[28] = b28 ^ ~b20 & b222;
            s7[29] = b29 ^ ~b21 & b23;
            s7[38] = b38 ^ ~b30 & b322;
            s7[39] = b39 ^ ~b31 & b33;
            s7[48] = b48 ^ ~b40 & b422;
            s7[49] = b49 ^ ~b41 & b43;
            s7[0] ^= RC[n9];
            s7[1] ^= RC[n9 + 1];
          }
        };
        if (COMMON_JS) {
          module.exports = methods;
        } else {
          for (i7 = 0; i7 < methodNames.length; ++i7) {
            root2[methodNames[i7]] = methods[methodNames[i7]];
          }
          if (AMD) {
            define(function() {
              return methods;
            });
          }
        }
      })();
    }
  });

  // node_modules/minimalistic-assert/index.js
  var require_minimalistic_assert = __commonJS({
    "node_modules/minimalistic-assert/index.js"(exports, module) {
      module.exports = assert3;
      function assert3(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      assert3.equal = function assertEqual2(l9, r8, msg) {
        if (l9 != r8)
          throw new Error(msg || "Assertion failed: " + l9 + " != " + r8);
      };
    }
  });

  // node_modules/inherits/inherits_browser.js
  var require_inherits_browser = __commonJS({
    "node_modules/inherits/inherits_browser.js"(exports, module) {
      if (typeof Object.create === "function") {
        module.exports = function inherits2(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          }
        };
      } else {
        module.exports = function inherits2(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {
            };
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          }
        };
      }
    }
  });

  // node_modules/hash.js/lib/hash/utils.js
  var require_utils5 = __commonJS({
    "node_modules/hash.js/lib/hash/utils.js"(exports) {
      "use strict";
      var assert3 = require_minimalistic_assert();
      var inherits2 = require_inherits_browser();
      exports.inherits = inherits2;
      function isSurrogatePair(msg, i7) {
        if ((msg.charCodeAt(i7) & 64512) !== 55296) {
          return false;
        }
        if (i7 < 0 || i7 + 1 >= msg.length) {
          return false;
        }
        return (msg.charCodeAt(i7 + 1) & 64512) === 56320;
      }
      function toArray2(msg, enc) {
        if (Array.isArray(msg))
          return msg.slice();
        if (!msg)
          return [];
        var res = [];
        if (typeof msg === "string") {
          if (!enc) {
            var p8 = 0;
            for (var i7 = 0; i7 < msg.length; i7++) {
              var c9 = msg.charCodeAt(i7);
              if (c9 < 128) {
                res[p8++] = c9;
              } else if (c9 < 2048) {
                res[p8++] = c9 >> 6 | 192;
                res[p8++] = c9 & 63 | 128;
              } else if (isSurrogatePair(msg, i7)) {
                c9 = 65536 + ((c9 & 1023) << 10) + (msg.charCodeAt(++i7) & 1023);
                res[p8++] = c9 >> 18 | 240;
                res[p8++] = c9 >> 12 & 63 | 128;
                res[p8++] = c9 >> 6 & 63 | 128;
                res[p8++] = c9 & 63 | 128;
              } else {
                res[p8++] = c9 >> 12 | 224;
                res[p8++] = c9 >> 6 & 63 | 128;
                res[p8++] = c9 & 63 | 128;
              }
            }
          } else if (enc === "hex") {
            msg = msg.replace(/[^a-z0-9]+/ig, "");
            if (msg.length % 2 !== 0)
              msg = "0" + msg;
            for (i7 = 0; i7 < msg.length; i7 += 2)
              res.push(parseInt(msg[i7] + msg[i7 + 1], 16));
          }
        } else {
          for (i7 = 0; i7 < msg.length; i7++)
            res[i7] = msg[i7] | 0;
        }
        return res;
      }
      exports.toArray = toArray2;
      function toHex3(msg) {
        var res = "";
        for (var i7 = 0; i7 < msg.length; i7++)
          res += zero2(msg[i7].toString(16));
        return res;
      }
      exports.toHex = toHex3;
      function htonl(w8) {
        var res = w8 >>> 24 | w8 >>> 8 & 65280 | w8 << 8 & 16711680 | (w8 & 255) << 24;
        return res >>> 0;
      }
      exports.htonl = htonl;
      function toHex32(msg, endian) {
        var res = "";
        for (var i7 = 0; i7 < msg.length; i7++) {
          var w8 = msg[i7];
          if (endian === "little")
            w8 = htonl(w8);
          res += zero8(w8.toString(16));
        }
        return res;
      }
      exports.toHex32 = toHex32;
      function zero2(word) {
        if (word.length === 1)
          return "0" + word;
        else
          return word;
      }
      exports.zero2 = zero2;
      function zero8(word) {
        if (word.length === 7)
          return "0" + word;
        else if (word.length === 6)
          return "00" + word;
        else if (word.length === 5)
          return "000" + word;
        else if (word.length === 4)
          return "0000" + word;
        else if (word.length === 3)
          return "00000" + word;
        else if (word.length === 2)
          return "000000" + word;
        else if (word.length === 1)
          return "0000000" + word;
        else
          return word;
      }
      exports.zero8 = zero8;
      function join32(msg, start, end, endian) {
        var len = end - start;
        assert3(len % 4 === 0);
        var res = new Array(len / 4);
        for (var i7 = 0, k6 = start; i7 < res.length; i7++, k6 += 4) {
          var w8;
          if (endian === "big")
            w8 = msg[k6] << 24 | msg[k6 + 1] << 16 | msg[k6 + 2] << 8 | msg[k6 + 3];
          else
            w8 = msg[k6 + 3] << 24 | msg[k6 + 2] << 16 | msg[k6 + 1] << 8 | msg[k6];
          res[i7] = w8 >>> 0;
        }
        return res;
      }
      exports.join32 = join32;
      function split32(msg, endian) {
        var res = new Array(msg.length * 4);
        for (var i7 = 0, k6 = 0; i7 < msg.length; i7++, k6 += 4) {
          var m6 = msg[i7];
          if (endian === "big") {
            res[k6] = m6 >>> 24;
            res[k6 + 1] = m6 >>> 16 & 255;
            res[k6 + 2] = m6 >>> 8 & 255;
            res[k6 + 3] = m6 & 255;
          } else {
            res[k6 + 3] = m6 >>> 24;
            res[k6 + 2] = m6 >>> 16 & 255;
            res[k6 + 1] = m6 >>> 8 & 255;
            res[k6] = m6 & 255;
          }
        }
        return res;
      }
      exports.split32 = split32;
      function rotr32(w8, b7) {
        return w8 >>> b7 | w8 << 32 - b7;
      }
      exports.rotr32 = rotr32;
      function rotl32(w8, b7) {
        return w8 << b7 | w8 >>> 32 - b7;
      }
      exports.rotl32 = rotl32;
      function sum32(a6, b7) {
        return a6 + b7 >>> 0;
      }
      exports.sum32 = sum32;
      function sum32_3(a6, b7, c9) {
        return a6 + b7 + c9 >>> 0;
      }
      exports.sum32_3 = sum32_3;
      function sum32_4(a6, b7, c9, d7) {
        return a6 + b7 + c9 + d7 >>> 0;
      }
      exports.sum32_4 = sum32_4;
      function sum32_5(a6, b7, c9, d7, e9) {
        return a6 + b7 + c9 + d7 + e9 >>> 0;
      }
      exports.sum32_5 = sum32_5;
      function sum64(buf, pos, ah, al) {
        var bh = buf[pos];
        var bl = buf[pos + 1];
        var lo3 = al + bl >>> 0;
        var hi2 = (lo3 < al ? 1 : 0) + ah + bh;
        buf[pos] = hi2 >>> 0;
        buf[pos + 1] = lo3;
      }
      exports.sum64 = sum64;
      function sum64_hi(ah, al, bh, bl) {
        var lo3 = al + bl >>> 0;
        var hi2 = (lo3 < al ? 1 : 0) + ah + bh;
        return hi2 >>> 0;
      }
      exports.sum64_hi = sum64_hi;
      function sum64_lo(ah, al, bh, bl) {
        var lo3 = al + bl;
        return lo3 >>> 0;
      }
      exports.sum64_lo = sum64_lo;
      function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
        var carry = 0;
        var lo3 = al;
        lo3 = lo3 + bl >>> 0;
        carry += lo3 < al ? 1 : 0;
        lo3 = lo3 + cl >>> 0;
        carry += lo3 < cl ? 1 : 0;
        lo3 = lo3 + dl >>> 0;
        carry += lo3 < dl ? 1 : 0;
        var hi2 = ah + bh + ch + dh + carry;
        return hi2 >>> 0;
      }
      exports.sum64_4_hi = sum64_4_hi;
      function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
        var lo3 = al + bl + cl + dl;
        return lo3 >>> 0;
      }
      exports.sum64_4_lo = sum64_4_lo;
      function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
        var carry = 0;
        var lo3 = al;
        lo3 = lo3 + bl >>> 0;
        carry += lo3 < al ? 1 : 0;
        lo3 = lo3 + cl >>> 0;
        carry += lo3 < cl ? 1 : 0;
        lo3 = lo3 + dl >>> 0;
        carry += lo3 < dl ? 1 : 0;
        lo3 = lo3 + el >>> 0;
        carry += lo3 < el ? 1 : 0;
        var hi2 = ah + bh + ch + dh + eh + carry;
        return hi2 >>> 0;
      }
      exports.sum64_5_hi = sum64_5_hi;
      function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
        var lo3 = al + bl + cl + dl + el;
        return lo3 >>> 0;
      }
      exports.sum64_5_lo = sum64_5_lo;
      function rotr64_hi(ah, al, num) {
        var r8 = al << 32 - num | ah >>> num;
        return r8 >>> 0;
      }
      exports.rotr64_hi = rotr64_hi;
      function rotr64_lo(ah, al, num) {
        var r8 = ah << 32 - num | al >>> num;
        return r8 >>> 0;
      }
      exports.rotr64_lo = rotr64_lo;
      function shr64_hi(ah, al, num) {
        return ah >>> num;
      }
      exports.shr64_hi = shr64_hi;
      function shr64_lo(ah, al, num) {
        var r8 = ah << 32 - num | al >>> num;
        return r8 >>> 0;
      }
      exports.shr64_lo = shr64_lo;
    }
  });

  // node_modules/hash.js/lib/hash/common.js
  var require_common = __commonJS({
    "node_modules/hash.js/lib/hash/common.js"(exports) {
      "use strict";
      var utils = require_utils5();
      var assert3 = require_minimalistic_assert();
      function BlockHash() {
        this.pending = null;
        this.pendingTotal = 0;
        this.blockSize = this.constructor.blockSize;
        this.outSize = this.constructor.outSize;
        this.hmacStrength = this.constructor.hmacStrength;
        this.padLength = this.constructor.padLength / 8;
        this.endian = "big";
        this._delta8 = this.blockSize / 8;
        this._delta32 = this.blockSize / 32;
      }
      exports.BlockHash = BlockHash;
      BlockHash.prototype.update = function update2(msg, enc) {
        msg = utils.toArray(msg, enc);
        if (!this.pending)
          this.pending = msg;
        else
          this.pending = this.pending.concat(msg);
        this.pendingTotal += msg.length;
        if (this.pending.length >= this._delta8) {
          msg = this.pending;
          var r8 = msg.length % this._delta8;
          this.pending = msg.slice(msg.length - r8, msg.length);
          if (this.pending.length === 0)
            this.pending = null;
          msg = utils.join32(msg, 0, msg.length - r8, this.endian);
          for (var i7 = 0; i7 < msg.length; i7 += this._delta32)
            this._update(msg, i7, i7 + this._delta32);
        }
        return this;
      };
      BlockHash.prototype.digest = function digest2(enc) {
        this.update(this._pad());
        assert3(this.pending === null);
        return this._digest(enc);
      };
      BlockHash.prototype._pad = function pad2() {
        var len = this.pendingTotal;
        var bytes3 = this._delta8;
        var k6 = bytes3 - (len + this.padLength) % bytes3;
        var res = new Array(k6 + this.padLength);
        res[0] = 128;
        for (var i7 = 1; i7 < k6; i7++)
          res[i7] = 0;
        len <<= 3;
        if (this.endian === "big") {
          for (var t6 = 8; t6 < this.padLength; t6++)
            res[i7++] = 0;
          res[i7++] = 0;
          res[i7++] = 0;
          res[i7++] = 0;
          res[i7++] = 0;
          res[i7++] = len >>> 24 & 255;
          res[i7++] = len >>> 16 & 255;
          res[i7++] = len >>> 8 & 255;
          res[i7++] = len & 255;
        } else {
          res[i7++] = len & 255;
          res[i7++] = len >>> 8 & 255;
          res[i7++] = len >>> 16 & 255;
          res[i7++] = len >>> 24 & 255;
          res[i7++] = 0;
          res[i7++] = 0;
          res[i7++] = 0;
          res[i7++] = 0;
          for (t6 = 8; t6 < this.padLength; t6++)
            res[i7++] = 0;
        }
        return res;
      };
    }
  });

  // node_modules/hash.js/lib/hash/sha/common.js
  var require_common2 = __commonJS({
    "node_modules/hash.js/lib/hash/sha/common.js"(exports) {
      "use strict";
      var utils = require_utils5();
      var rotr32 = utils.rotr32;
      function ft_1(s7, x4, y11, z7) {
        if (s7 === 0)
          return ch32(x4, y11, z7);
        if (s7 === 1 || s7 === 3)
          return p32(x4, y11, z7);
        if (s7 === 2)
          return maj32(x4, y11, z7);
      }
      exports.ft_1 = ft_1;
      function ch32(x4, y11, z7) {
        return x4 & y11 ^ ~x4 & z7;
      }
      exports.ch32 = ch32;
      function maj32(x4, y11, z7) {
        return x4 & y11 ^ x4 & z7 ^ y11 & z7;
      }
      exports.maj32 = maj32;
      function p32(x4, y11, z7) {
        return x4 ^ y11 ^ z7;
      }
      exports.p32 = p32;
      function s0_256(x4) {
        return rotr32(x4, 2) ^ rotr32(x4, 13) ^ rotr32(x4, 22);
      }
      exports.s0_256 = s0_256;
      function s1_256(x4) {
        return rotr32(x4, 6) ^ rotr32(x4, 11) ^ rotr32(x4, 25);
      }
      exports.s1_256 = s1_256;
      function g0_256(x4) {
        return rotr32(x4, 7) ^ rotr32(x4, 18) ^ x4 >>> 3;
      }
      exports.g0_256 = g0_256;
      function g1_256(x4) {
        return rotr32(x4, 17) ^ rotr32(x4, 19) ^ x4 >>> 10;
      }
      exports.g1_256 = g1_256;
    }
  });

  // node_modules/hash.js/lib/hash/sha/1.js
  var require__ = __commonJS({
    "node_modules/hash.js/lib/hash/sha/1.js"(exports, module) {
      "use strict";
      var utils = require_utils5();
      var common = require_common();
      var shaCommon = require_common2();
      var rotl32 = utils.rotl32;
      var sum32 = utils.sum32;
      var sum32_5 = utils.sum32_5;
      var ft_1 = shaCommon.ft_1;
      var BlockHash = common.BlockHash;
      var sha1_K = [
        1518500249,
        1859775393,
        2400959708,
        3395469782
      ];
      function SHA1() {
        if (!(this instanceof SHA1))
          return new SHA1();
        BlockHash.call(this);
        this.h = [
          1732584193,
          4023233417,
          2562383102,
          271733878,
          3285377520
        ];
        this.W = new Array(80);
      }
      utils.inherits(SHA1, BlockHash);
      module.exports = SHA1;
      SHA1.blockSize = 512;
      SHA1.outSize = 160;
      SHA1.hmacStrength = 80;
      SHA1.padLength = 64;
      SHA1.prototype._update = function _update(msg, start) {
        var W8 = this.W;
        for (var i7 = 0; i7 < 16; i7++)
          W8[i7] = msg[start + i7];
        for (; i7 < W8.length; i7++)
          W8[i7] = rotl32(W8[i7 - 3] ^ W8[i7 - 8] ^ W8[i7 - 14] ^ W8[i7 - 16], 1);
        var a6 = this.h[0];
        var b7 = this.h[1];
        var c9 = this.h[2];
        var d7 = this.h[3];
        var e9 = this.h[4];
        for (i7 = 0; i7 < W8.length; i7++) {
          var s7 = ~~(i7 / 20);
          var t6 = sum32_5(rotl32(a6, 5), ft_1(s7, b7, c9, d7), e9, W8[i7], sha1_K[s7]);
          e9 = d7;
          d7 = c9;
          c9 = rotl32(b7, 30);
          b7 = a6;
          a6 = t6;
        }
        this.h[0] = sum32(this.h[0], a6);
        this.h[1] = sum32(this.h[1], b7);
        this.h[2] = sum32(this.h[2], c9);
        this.h[3] = sum32(this.h[3], d7);
        this.h[4] = sum32(this.h[4], e9);
      };
      SHA1.prototype._digest = function digest2(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h, "big");
        else
          return utils.split32(this.h, "big");
      };
    }
  });

  // node_modules/hash.js/lib/hash/sha/256.js
  var require__2 = __commonJS({
    "node_modules/hash.js/lib/hash/sha/256.js"(exports, module) {
      "use strict";
      var utils = require_utils5();
      var common = require_common();
      var shaCommon = require_common2();
      var assert3 = require_minimalistic_assert();
      var sum32 = utils.sum32;
      var sum32_4 = utils.sum32_4;
      var sum32_5 = utils.sum32_5;
      var ch32 = shaCommon.ch32;
      var maj32 = shaCommon.maj32;
      var s0_256 = shaCommon.s0_256;
      var s1_256 = shaCommon.s1_256;
      var g0_256 = shaCommon.g0_256;
      var g1_256 = shaCommon.g1_256;
      var BlockHash = common.BlockHash;
      var sha256_K = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ];
      function SHA256() {
        if (!(this instanceof SHA256))
          return new SHA256();
        BlockHash.call(this);
        this.h = [
          1779033703,
          3144134277,
          1013904242,
          2773480762,
          1359893119,
          2600822924,
          528734635,
          1541459225
        ];
        this.k = sha256_K;
        this.W = new Array(64);
      }
      utils.inherits(SHA256, BlockHash);
      module.exports = SHA256;
      SHA256.blockSize = 512;
      SHA256.outSize = 256;
      SHA256.hmacStrength = 192;
      SHA256.padLength = 64;
      SHA256.prototype._update = function _update(msg, start) {
        var W8 = this.W;
        for (var i7 = 0; i7 < 16; i7++)
          W8[i7] = msg[start + i7];
        for (; i7 < W8.length; i7++)
          W8[i7] = sum32_4(g1_256(W8[i7 - 2]), W8[i7 - 7], g0_256(W8[i7 - 15]), W8[i7 - 16]);
        var a6 = this.h[0];
        var b7 = this.h[1];
        var c9 = this.h[2];
        var d7 = this.h[3];
        var e9 = this.h[4];
        var f7 = this.h[5];
        var g7 = this.h[6];
        var h10 = this.h[7];
        assert3(this.k.length === W8.length);
        for (i7 = 0; i7 < W8.length; i7++) {
          var T12 = sum32_5(h10, s1_256(e9), ch32(e9, f7, g7), this.k[i7], W8[i7]);
          var T22 = sum32(s0_256(a6), maj32(a6, b7, c9));
          h10 = g7;
          g7 = f7;
          f7 = e9;
          e9 = sum32(d7, T12);
          d7 = c9;
          c9 = b7;
          b7 = a6;
          a6 = sum32(T12, T22);
        }
        this.h[0] = sum32(this.h[0], a6);
        this.h[1] = sum32(this.h[1], b7);
        this.h[2] = sum32(this.h[2], c9);
        this.h[3] = sum32(this.h[3], d7);
        this.h[4] = sum32(this.h[4], e9);
        this.h[5] = sum32(this.h[5], f7);
        this.h[6] = sum32(this.h[6], g7);
        this.h[7] = sum32(this.h[7], h10);
      };
      SHA256.prototype._digest = function digest2(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h, "big");
        else
          return utils.split32(this.h, "big");
      };
    }
  });

  // node_modules/hash.js/lib/hash/sha/224.js
  var require__3 = __commonJS({
    "node_modules/hash.js/lib/hash/sha/224.js"(exports, module) {
      "use strict";
      var utils = require_utils5();
      var SHA256 = require__2();
      function SHA224() {
        if (!(this instanceof SHA224))
          return new SHA224();
        SHA256.call(this);
        this.h = [
          3238371032,
          914150663,
          812702999,
          4144912697,
          4290775857,
          1750603025,
          1694076839,
          3204075428
        ];
      }
      utils.inherits(SHA224, SHA256);
      module.exports = SHA224;
      SHA224.blockSize = 512;
      SHA224.outSize = 224;
      SHA224.hmacStrength = 192;
      SHA224.padLength = 64;
      SHA224.prototype._digest = function digest2(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h.slice(0, 7), "big");
        else
          return utils.split32(this.h.slice(0, 7), "big");
      };
    }
  });

  // node_modules/hash.js/lib/hash/sha/512.js
  var require__4 = __commonJS({
    "node_modules/hash.js/lib/hash/sha/512.js"(exports, module) {
      "use strict";
      var utils = require_utils5();
      var common = require_common();
      var assert3 = require_minimalistic_assert();
      var rotr64_hi = utils.rotr64_hi;
      var rotr64_lo = utils.rotr64_lo;
      var shr64_hi = utils.shr64_hi;
      var shr64_lo = utils.shr64_lo;
      var sum64 = utils.sum64;
      var sum64_hi = utils.sum64_hi;
      var sum64_lo = utils.sum64_lo;
      var sum64_4_hi = utils.sum64_4_hi;
      var sum64_4_lo = utils.sum64_4_lo;
      var sum64_5_hi = utils.sum64_5_hi;
      var sum64_5_lo = utils.sum64_5_lo;
      var BlockHash = common.BlockHash;
      var sha512_K = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      function SHA512() {
        if (!(this instanceof SHA512))
          return new SHA512();
        BlockHash.call(this);
        this.h = [
          1779033703,
          4089235720,
          3144134277,
          2227873595,
          1013904242,
          4271175723,
          2773480762,
          1595750129,
          1359893119,
          2917565137,
          2600822924,
          725511199,
          528734635,
          4215389547,
          1541459225,
          327033209
        ];
        this.k = sha512_K;
        this.W = new Array(160);
      }
      utils.inherits(SHA512, BlockHash);
      module.exports = SHA512;
      SHA512.blockSize = 1024;
      SHA512.outSize = 512;
      SHA512.hmacStrength = 192;
      SHA512.padLength = 128;
      SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
        var W8 = this.W;
        for (var i7 = 0; i7 < 32; i7++)
          W8[i7] = msg[start + i7];
        for (; i7 < W8.length; i7 += 2) {
          var c0_hi = g1_512_hi(W8[i7 - 4], W8[i7 - 3]);
          var c0_lo = g1_512_lo(W8[i7 - 4], W8[i7 - 3]);
          var c1_hi = W8[i7 - 14];
          var c1_lo = W8[i7 - 13];
          var c2_hi = g0_512_hi(W8[i7 - 30], W8[i7 - 29]);
          var c2_lo = g0_512_lo(W8[i7 - 30], W8[i7 - 29]);
          var c3_hi = W8[i7 - 32];
          var c3_lo = W8[i7 - 31];
          W8[i7] = sum64_4_hi(
            c0_hi,
            c0_lo,
            c1_hi,
            c1_lo,
            c2_hi,
            c2_lo,
            c3_hi,
            c3_lo
          );
          W8[i7 + 1] = sum64_4_lo(
            c0_hi,
            c0_lo,
            c1_hi,
            c1_lo,
            c2_hi,
            c2_lo,
            c3_hi,
            c3_lo
          );
        }
      };
      SHA512.prototype._update = function _update(msg, start) {
        this._prepareBlock(msg, start);
        var W8 = this.W;
        var ah = this.h[0];
        var al = this.h[1];
        var bh = this.h[2];
        var bl = this.h[3];
        var ch = this.h[4];
        var cl = this.h[5];
        var dh = this.h[6];
        var dl = this.h[7];
        var eh = this.h[8];
        var el = this.h[9];
        var fh = this.h[10];
        var fl = this.h[11];
        var gh = this.h[12];
        var gl = this.h[13];
        var hh = this.h[14];
        var hl = this.h[15];
        assert3(this.k.length === W8.length);
        for (var i7 = 0; i7 < W8.length; i7 += 2) {
          var c0_hi = hh;
          var c0_lo = hl;
          var c1_hi = s1_512_hi(eh, el);
          var c1_lo = s1_512_lo(eh, el);
          var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
          var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
          var c3_hi = this.k[i7];
          var c3_lo = this.k[i7 + 1];
          var c4_hi = W8[i7];
          var c4_lo = W8[i7 + 1];
          var T1_hi = sum64_5_hi(
            c0_hi,
            c0_lo,
            c1_hi,
            c1_lo,
            c2_hi,
            c2_lo,
            c3_hi,
            c3_lo,
            c4_hi,
            c4_lo
          );
          var T1_lo = sum64_5_lo(
            c0_hi,
            c0_lo,
            c1_hi,
            c1_lo,
            c2_hi,
            c2_lo,
            c3_hi,
            c3_lo,
            c4_hi,
            c4_lo
          );
          c0_hi = s0_512_hi(ah, al);
          c0_lo = s0_512_lo(ah, al);
          c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
          c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
          var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
          var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
          hh = gh;
          hl = gl;
          gh = fh;
          gl = fl;
          fh = eh;
          fl = el;
          eh = sum64_hi(dh, dl, T1_hi, T1_lo);
          el = sum64_lo(dl, dl, T1_hi, T1_lo);
          dh = ch;
          dl = cl;
          ch = bh;
          cl = bl;
          bh = ah;
          bl = al;
          ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
          al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
        }
        sum64(this.h, 0, ah, al);
        sum64(this.h, 2, bh, bl);
        sum64(this.h, 4, ch, cl);
        sum64(this.h, 6, dh, dl);
        sum64(this.h, 8, eh, el);
        sum64(this.h, 10, fh, fl);
        sum64(this.h, 12, gh, gl);
        sum64(this.h, 14, hh, hl);
      };
      SHA512.prototype._digest = function digest2(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h, "big");
        else
          return utils.split32(this.h, "big");
      };
      function ch64_hi(xh, xl, yh, yl, zh) {
        var r8 = xh & yh ^ ~xh & zh;
        if (r8 < 0)
          r8 += 4294967296;
        return r8;
      }
      function ch64_lo(xh, xl, yh, yl, zh, zl) {
        var r8 = xl & yl ^ ~xl & zl;
        if (r8 < 0)
          r8 += 4294967296;
        return r8;
      }
      function maj64_hi(xh, xl, yh, yl, zh) {
        var r8 = xh & yh ^ xh & zh ^ yh & zh;
        if (r8 < 0)
          r8 += 4294967296;
        return r8;
      }
      function maj64_lo(xh, xl, yh, yl, zh, zl) {
        var r8 = xl & yl ^ xl & zl ^ yl & zl;
        if (r8 < 0)
          r8 += 4294967296;
        return r8;
      }
      function s0_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 28);
        var c1_hi = rotr64_hi(xl, xh, 2);
        var c2_hi = rotr64_hi(xl, xh, 7);
        var r8 = c0_hi ^ c1_hi ^ c2_hi;
        if (r8 < 0)
          r8 += 4294967296;
        return r8;
      }
      function s0_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 28);
        var c1_lo = rotr64_lo(xl, xh, 2);
        var c2_lo = rotr64_lo(xl, xh, 7);
        var r8 = c0_lo ^ c1_lo ^ c2_lo;
        if (r8 < 0)
          r8 += 4294967296;
        return r8;
      }
      function s1_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 14);
        var c1_hi = rotr64_hi(xh, xl, 18);
        var c2_hi = rotr64_hi(xl, xh, 9);
        var r8 = c0_hi ^ c1_hi ^ c2_hi;
        if (r8 < 0)
          r8 += 4294967296;
        return r8;
      }
      function s1_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 14);
        var c1_lo = rotr64_lo(xh, xl, 18);
        var c2_lo = rotr64_lo(xl, xh, 9);
        var r8 = c0_lo ^ c1_lo ^ c2_lo;
        if (r8 < 0)
          r8 += 4294967296;
        return r8;
      }
      function g0_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 1);
        var c1_hi = rotr64_hi(xh, xl, 8);
        var c2_hi = shr64_hi(xh, xl, 7);
        var r8 = c0_hi ^ c1_hi ^ c2_hi;
        if (r8 < 0)
          r8 += 4294967296;
        return r8;
      }
      function g0_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 1);
        var c1_lo = rotr64_lo(xh, xl, 8);
        var c2_lo = shr64_lo(xh, xl, 7);
        var r8 = c0_lo ^ c1_lo ^ c2_lo;
        if (r8 < 0)
          r8 += 4294967296;
        return r8;
      }
      function g1_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 19);
        var c1_hi = rotr64_hi(xl, xh, 29);
        var c2_hi = shr64_hi(xh, xl, 6);
        var r8 = c0_hi ^ c1_hi ^ c2_hi;
        if (r8 < 0)
          r8 += 4294967296;
        return r8;
      }
      function g1_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 19);
        var c1_lo = rotr64_lo(xl, xh, 29);
        var c2_lo = shr64_lo(xh, xl, 6);
        var r8 = c0_lo ^ c1_lo ^ c2_lo;
        if (r8 < 0)
          r8 += 4294967296;
        return r8;
      }
    }
  });

  // node_modules/hash.js/lib/hash/sha/384.js
  var require__5 = __commonJS({
    "node_modules/hash.js/lib/hash/sha/384.js"(exports, module) {
      "use strict";
      var utils = require_utils5();
      var SHA512 = require__4();
      function SHA384() {
        if (!(this instanceof SHA384))
          return new SHA384();
        SHA512.call(this);
        this.h = [
          3418070365,
          3238371032,
          1654270250,
          914150663,
          2438529370,
          812702999,
          355462360,
          4144912697,
          1731405415,
          4290775857,
          2394180231,
          1750603025,
          3675008525,
          1694076839,
          1203062813,
          3204075428
        ];
      }
      utils.inherits(SHA384, SHA512);
      module.exports = SHA384;
      SHA384.blockSize = 1024;
      SHA384.outSize = 384;
      SHA384.hmacStrength = 192;
      SHA384.padLength = 128;
      SHA384.prototype._digest = function digest2(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h.slice(0, 12), "big");
        else
          return utils.split32(this.h.slice(0, 12), "big");
      };
    }
  });

  // node_modules/hash.js/lib/hash/sha.js
  var require_sha = __commonJS({
    "node_modules/hash.js/lib/hash/sha.js"(exports) {
      "use strict";
      exports.sha1 = require__();
      exports.sha224 = require__3();
      exports.sha256 = require__2();
      exports.sha384 = require__5();
      exports.sha512 = require__4();
    }
  });

  // node_modules/hash.js/lib/hash/ripemd.js
  var require_ripemd = __commonJS({
    "node_modules/hash.js/lib/hash/ripemd.js"(exports) {
      "use strict";
      var utils = require_utils5();
      var common = require_common();
      var rotl32 = utils.rotl32;
      var sum32 = utils.sum32;
      var sum32_3 = utils.sum32_3;
      var sum32_4 = utils.sum32_4;
      var BlockHash = common.BlockHash;
      function RIPEMD160() {
        if (!(this instanceof RIPEMD160))
          return new RIPEMD160();
        BlockHash.call(this);
        this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
        this.endian = "little";
      }
      utils.inherits(RIPEMD160, BlockHash);
      exports.ripemd160 = RIPEMD160;
      RIPEMD160.blockSize = 512;
      RIPEMD160.outSize = 160;
      RIPEMD160.hmacStrength = 192;
      RIPEMD160.padLength = 64;
      RIPEMD160.prototype._update = function update2(msg, start) {
        var A7 = this.h[0];
        var B10 = this.h[1];
        var C6 = this.h[2];
        var D10 = this.h[3];
        var E8 = this.h[4];
        var Ah = A7;
        var Bh = B10;
        var Ch = C6;
        var Dh = D10;
        var Eh = E8;
        for (var j7 = 0; j7 < 80; j7++) {
          var T6 = sum32(
            rotl32(
              sum32_4(A7, f7(j7, B10, C6, D10), msg[r8[j7] + start], K8(j7)),
              s7[j7]
            ),
            E8
          );
          A7 = E8;
          E8 = D10;
          D10 = rotl32(C6, 10);
          C6 = B10;
          B10 = T6;
          T6 = sum32(
            rotl32(
              sum32_4(Ah, f7(79 - j7, Bh, Ch, Dh), msg[rh[j7] + start], Kh(j7)),
              sh[j7]
            ),
            Eh
          );
          Ah = Eh;
          Eh = Dh;
          Dh = rotl32(Ch, 10);
          Ch = Bh;
          Bh = T6;
        }
        T6 = sum32_3(this.h[1], C6, Dh);
        this.h[1] = sum32_3(this.h[2], D10, Eh);
        this.h[2] = sum32_3(this.h[3], E8, Ah);
        this.h[3] = sum32_3(this.h[4], A7, Bh);
        this.h[4] = sum32_3(this.h[0], B10, Ch);
        this.h[0] = T6;
      };
      RIPEMD160.prototype._digest = function digest2(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h, "little");
        else
          return utils.split32(this.h, "little");
      };
      function f7(j7, x4, y11, z7) {
        if (j7 <= 15)
          return x4 ^ y11 ^ z7;
        else if (j7 <= 31)
          return x4 & y11 | ~x4 & z7;
        else if (j7 <= 47)
          return (x4 | ~y11) ^ z7;
        else if (j7 <= 63)
          return x4 & z7 | y11 & ~z7;
        else
          return x4 ^ (y11 | ~z7);
      }
      function K8(j7) {
        if (j7 <= 15)
          return 0;
        else if (j7 <= 31)
          return 1518500249;
        else if (j7 <= 47)
          return 1859775393;
        else if (j7 <= 63)
          return 2400959708;
        else
          return 2840853838;
      }
      function Kh(j7) {
        if (j7 <= 15)
          return 1352829926;
        else if (j7 <= 31)
          return 1548603684;
        else if (j7 <= 47)
          return 1836072691;
        else if (j7 <= 63)
          return 2053994217;
        else
          return 0;
      }
      var r8 = [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        7,
        4,
        13,
        1,
        10,
        6,
        15,
        3,
        12,
        0,
        9,
        5,
        2,
        14,
        11,
        8,
        3,
        10,
        14,
        4,
        9,
        15,
        8,
        1,
        2,
        7,
        0,
        6,
        13,
        11,
        5,
        12,
        1,
        9,
        11,
        10,
        0,
        8,
        12,
        4,
        13,
        3,
        7,
        15,
        14,
        5,
        6,
        2,
        4,
        0,
        5,
        9,
        7,
        12,
        2,
        10,
        14,
        1,
        3,
        8,
        11,
        6,
        15,
        13
      ];
      var rh = [
        5,
        14,
        7,
        0,
        9,
        2,
        11,
        4,
        13,
        6,
        15,
        8,
        1,
        10,
        3,
        12,
        6,
        11,
        3,
        7,
        0,
        13,
        5,
        10,
        14,
        15,
        8,
        12,
        4,
        9,
        1,
        2,
        15,
        5,
        1,
        3,
        7,
        14,
        6,
        9,
        11,
        8,
        12,
        2,
        10,
        0,
        4,
        13,
        8,
        6,
        4,
        1,
        3,
        11,
        15,
        0,
        5,
        12,
        2,
        13,
        9,
        7,
        10,
        14,
        12,
        15,
        10,
        4,
        1,
        5,
        8,
        7,
        6,
        2,
        13,
        14,
        0,
        3,
        9,
        11
      ];
      var s7 = [
        11,
        14,
        15,
        12,
        5,
        8,
        7,
        9,
        11,
        13,
        14,
        15,
        6,
        7,
        9,
        8,
        7,
        6,
        8,
        13,
        11,
        9,
        7,
        15,
        7,
        12,
        15,
        9,
        11,
        7,
        13,
        12,
        11,
        13,
        6,
        7,
        14,
        9,
        13,
        15,
        14,
        8,
        13,
        6,
        5,
        12,
        7,
        5,
        11,
        12,
        14,
        15,
        14,
        15,
        9,
        8,
        9,
        14,
        5,
        6,
        8,
        6,
        5,
        12,
        9,
        15,
        5,
        11,
        6,
        8,
        13,
        12,
        5,
        12,
        13,
        14,
        11,
        8,
        5,
        6
      ];
      var sh = [
        8,
        9,
        9,
        11,
        13,
        15,
        15,
        5,
        7,
        7,
        8,
        11,
        14,
        14,
        12,
        6,
        9,
        13,
        15,
        7,
        12,
        8,
        9,
        11,
        7,
        7,
        12,
        7,
        6,
        15,
        13,
        11,
        9,
        7,
        15,
        11,
        8,
        6,
        6,
        14,
        12,
        13,
        5,
        14,
        13,
        13,
        7,
        5,
        15,
        5,
        8,
        11,
        14,
        14,
        6,
        14,
        6,
        9,
        12,
        9,
        12,
        5,
        15,
        8,
        8,
        5,
        12,
        9,
        12,
        5,
        14,
        6,
        8,
        13,
        6,
        5,
        15,
        13,
        11,
        11
      ];
    }
  });

  // node_modules/hash.js/lib/hash/hmac.js
  var require_hmac2 = __commonJS({
    "node_modules/hash.js/lib/hash/hmac.js"(exports, module) {
      "use strict";
      var utils = require_utils5();
      var assert3 = require_minimalistic_assert();
      function Hmac(hash5, key2, enc) {
        if (!(this instanceof Hmac))
          return new Hmac(hash5, key2, enc);
        this.Hash = hash5;
        this.blockSize = hash5.blockSize / 8;
        this.outSize = hash5.outSize / 8;
        this.inner = null;
        this.outer = null;
        this._init(utils.toArray(key2, enc));
      }
      module.exports = Hmac;
      Hmac.prototype._init = function init2(key2) {
        if (key2.length > this.blockSize)
          key2 = new this.Hash().update(key2).digest();
        assert3(key2.length <= this.blockSize);
        for (var i7 = key2.length; i7 < this.blockSize; i7++)
          key2.push(0);
        for (i7 = 0; i7 < key2.length; i7++)
          key2[i7] ^= 54;
        this.inner = new this.Hash().update(key2);
        for (i7 = 0; i7 < key2.length; i7++)
          key2[i7] ^= 106;
        this.outer = new this.Hash().update(key2);
      };
      Hmac.prototype.update = function update2(msg, enc) {
        this.inner.update(msg, enc);
        return this;
      };
      Hmac.prototype.digest = function digest2(enc) {
        this.outer.update(this.inner.digest());
        return this.outer.digest(enc);
      };
    }
  });

  // node_modules/hash.js/lib/hash.js
  var require_hash2 = __commonJS({
    "node_modules/hash.js/lib/hash.js"(exports) {
      var hash5 = exports;
      hash5.utils = require_utils5();
      hash5.common = require_common();
      hash5.sha = require_sha();
      hash5.ripemd = require_ripemd();
      hash5.hmac = require_hmac2();
      hash5.sha1 = hash5.sha.sha1;
      hash5.sha256 = hash5.sha.sha256;
      hash5.sha224 = hash5.sha.sha224;
      hash5.sha384 = hash5.sha.sha384;
      hash5.sha512 = hash5.sha.sha512;
      hash5.ripemd160 = hash5.ripemd.ripemd160;
    }
  });

  // node_modules/aes-js/index.js
  var require_aes_js = __commonJS({
    "node_modules/aes-js/index.js"(exports, module) {
      "use strict";
      (function(root2) {
        function checkInt(value) {
          return parseInt(value) === value;
        }
        function checkInts(arrayish) {
          if (!checkInt(arrayish.length)) {
            return false;
          }
          for (var i7 = 0; i7 < arrayish.length; i7++) {
            if (!checkInt(arrayish[i7]) || arrayish[i7] < 0 || arrayish[i7] > 255) {
              return false;
            }
          }
          return true;
        }
        function coerceArray(arg, copy) {
          if (arg.buffer && ArrayBuffer.isView(arg) && arg.name === "Uint8Array") {
            if (copy) {
              if (arg.slice) {
                arg = arg.slice();
              } else {
                arg = Array.prototype.slice.call(arg);
              }
            }
            return arg;
          }
          if (Array.isArray(arg)) {
            if (!checkInts(arg)) {
              throw new Error("Array contains invalid value: " + arg);
            }
            return new Uint8Array(arg);
          }
          if (checkInt(arg.length) && checkInts(arg)) {
            return new Uint8Array(arg);
          }
          throw new Error("unsupported array-like object");
        }
        function createArray(length2) {
          return new Uint8Array(length2);
        }
        function copyArray(sourceArray, targetArray, targetStart, sourceStart, sourceEnd) {
          if (sourceStart != null || sourceEnd != null) {
            if (sourceArray.slice) {
              sourceArray = sourceArray.slice(sourceStart, sourceEnd);
            } else {
              sourceArray = Array.prototype.slice.call(sourceArray, sourceStart, sourceEnd);
            }
          }
          targetArray.set(sourceArray, targetStart);
        }
        var convertUtf8 = function() {
          function toBytes3(text) {
            var result = [], i7 = 0;
            text = encodeURI(text);
            while (i7 < text.length) {
              var c9 = text.charCodeAt(i7++);
              if (c9 === 37) {
                result.push(parseInt(text.substr(i7, 2), 16));
                i7 += 2;
              } else {
                result.push(c9);
              }
            }
            return coerceArray(result);
          }
          function fromBytes2(bytes3) {
            var result = [], i7 = 0;
            while (i7 < bytes3.length) {
              var c9 = bytes3[i7];
              if (c9 < 128) {
                result.push(String.fromCharCode(c9));
                i7++;
              } else if (c9 > 191 && c9 < 224) {
                result.push(String.fromCharCode((c9 & 31) << 6 | bytes3[i7 + 1] & 63));
                i7 += 2;
              } else {
                result.push(String.fromCharCode((c9 & 15) << 12 | (bytes3[i7 + 1] & 63) << 6 | bytes3[i7 + 2] & 63));
                i7 += 3;
              }
            }
            return result.join("");
          }
          return {
            toBytes: toBytes3,
            fromBytes: fromBytes2
          };
        }();
        var convertHex = function() {
          function toBytes3(text) {
            var result = [];
            for (var i7 = 0; i7 < text.length; i7 += 2) {
              result.push(parseInt(text.substr(i7, 2), 16));
            }
            return result;
          }
          var Hex = "0123456789abcdef";
          function fromBytes2(bytes3) {
            var result = [];
            for (var i7 = 0; i7 < bytes3.length; i7++) {
              var v6 = bytes3[i7];
              result.push(Hex[(v6 & 240) >> 4] + Hex[v6 & 15]);
            }
            return result.join("");
          }
          return {
            toBytes: toBytes3,
            fromBytes: fromBytes2
          };
        }();
        var numberOfRounds = { 16: 10, 24: 12, 32: 14 };
        var rcon = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145];
        var S12 = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22];
        var Si = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125];
        var T12 = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986];
        var T22 = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766];
        var T32 = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126];
        var T42 = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436];
        var T52 = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890];
        var T6 = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935];
        var T7 = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600];
        var T8 = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480];
        var U1 = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795];
        var U22 = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855];
        var U32 = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150];
        var U42 = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925];
        function convertToInt32(bytes3) {
          var result = [];
          for (var i7 = 0; i7 < bytes3.length; i7 += 4) {
            result.push(
              bytes3[i7] << 24 | bytes3[i7 + 1] << 16 | bytes3[i7 + 2] << 8 | bytes3[i7 + 3]
            );
          }
          return result;
        }
        var AES = function(key2) {
          if (!(this instanceof AES)) {
            throw Error("AES must be instanitated with `new`");
          }
          Object.defineProperty(this, "key", {
            value: coerceArray(key2, true)
          });
          this._prepare();
        };
        AES.prototype._prepare = function() {
          var rounds = numberOfRounds[this.key.length];
          if (rounds == null) {
            throw new Error("invalid key size (must be 16, 24 or 32 bytes)");
          }
          this._Ke = [];
          this._Kd = [];
          for (var i7 = 0; i7 <= rounds; i7++) {
            this._Ke.push([0, 0, 0, 0]);
            this._Kd.push([0, 0, 0, 0]);
          }
          var roundKeyCount = (rounds + 1) * 4;
          var KC = this.key.length / 4;
          var tk = convertToInt32(this.key);
          var index2;
          for (var i7 = 0; i7 < KC; i7++) {
            index2 = i7 >> 2;
            this._Ke[index2][i7 % 4] = tk[i7];
            this._Kd[rounds - index2][i7 % 4] = tk[i7];
          }
          var rconpointer = 0;
          var t6 = KC, tt4;
          while (t6 < roundKeyCount) {
            tt4 = tk[KC - 1];
            tk[0] ^= S12[tt4 >> 16 & 255] << 24 ^ S12[tt4 >> 8 & 255] << 16 ^ S12[tt4 & 255] << 8 ^ S12[tt4 >> 24 & 255] ^ rcon[rconpointer] << 24;
            rconpointer += 1;
            if (KC != 8) {
              for (var i7 = 1; i7 < KC; i7++) {
                tk[i7] ^= tk[i7 - 1];
              }
            } else {
              for (var i7 = 1; i7 < KC / 2; i7++) {
                tk[i7] ^= tk[i7 - 1];
              }
              tt4 = tk[KC / 2 - 1];
              tk[KC / 2] ^= S12[tt4 & 255] ^ S12[tt4 >> 8 & 255] << 8 ^ S12[tt4 >> 16 & 255] << 16 ^ S12[tt4 >> 24 & 255] << 24;
              for (var i7 = KC / 2 + 1; i7 < KC; i7++) {
                tk[i7] ^= tk[i7 - 1];
              }
            }
            var i7 = 0, r8, c9;
            while (i7 < KC && t6 < roundKeyCount) {
              r8 = t6 >> 2;
              c9 = t6 % 4;
              this._Ke[r8][c9] = tk[i7];
              this._Kd[rounds - r8][c9] = tk[i7++];
              t6++;
            }
          }
          for (var r8 = 1; r8 < rounds; r8++) {
            for (var c9 = 0; c9 < 4; c9++) {
              tt4 = this._Kd[r8][c9];
              this._Kd[r8][c9] = U1[tt4 >> 24 & 255] ^ U22[tt4 >> 16 & 255] ^ U32[tt4 >> 8 & 255] ^ U42[tt4 & 255];
            }
          }
        };
        AES.prototype.encrypt = function(plaintext) {
          if (plaintext.length != 16) {
            throw new Error("invalid plaintext size (must be 16 bytes)");
          }
          var rounds = this._Ke.length - 1;
          var a6 = [0, 0, 0, 0];
          var t6 = convertToInt32(plaintext);
          for (var i7 = 0; i7 < 4; i7++) {
            t6[i7] ^= this._Ke[0][i7];
          }
          for (var r8 = 1; r8 < rounds; r8++) {
            for (var i7 = 0; i7 < 4; i7++) {
              a6[i7] = T12[t6[i7] >> 24 & 255] ^ T22[t6[(i7 + 1) % 4] >> 16 & 255] ^ T32[t6[(i7 + 2) % 4] >> 8 & 255] ^ T42[t6[(i7 + 3) % 4] & 255] ^ this._Ke[r8][i7];
            }
            t6 = a6.slice();
          }
          var result = createArray(16), tt4;
          for (var i7 = 0; i7 < 4; i7++) {
            tt4 = this._Ke[rounds][i7];
            result[4 * i7] = (S12[t6[i7] >> 24 & 255] ^ tt4 >> 24) & 255;
            result[4 * i7 + 1] = (S12[t6[(i7 + 1) % 4] >> 16 & 255] ^ tt4 >> 16) & 255;
            result[4 * i7 + 2] = (S12[t6[(i7 + 2) % 4] >> 8 & 255] ^ tt4 >> 8) & 255;
            result[4 * i7 + 3] = (S12[t6[(i7 + 3) % 4] & 255] ^ tt4) & 255;
          }
          return result;
        };
        AES.prototype.decrypt = function(ciphertext) {
          if (ciphertext.length != 16) {
            throw new Error("invalid ciphertext size (must be 16 bytes)");
          }
          var rounds = this._Kd.length - 1;
          var a6 = [0, 0, 0, 0];
          var t6 = convertToInt32(ciphertext);
          for (var i7 = 0; i7 < 4; i7++) {
            t6[i7] ^= this._Kd[0][i7];
          }
          for (var r8 = 1; r8 < rounds; r8++) {
            for (var i7 = 0; i7 < 4; i7++) {
              a6[i7] = T52[t6[i7] >> 24 & 255] ^ T6[t6[(i7 + 3) % 4] >> 16 & 255] ^ T7[t6[(i7 + 2) % 4] >> 8 & 255] ^ T8[t6[(i7 + 1) % 4] & 255] ^ this._Kd[r8][i7];
            }
            t6 = a6.slice();
          }
          var result = createArray(16), tt4;
          for (var i7 = 0; i7 < 4; i7++) {
            tt4 = this._Kd[rounds][i7];
            result[4 * i7] = (Si[t6[i7] >> 24 & 255] ^ tt4 >> 24) & 255;
            result[4 * i7 + 1] = (Si[t6[(i7 + 3) % 4] >> 16 & 255] ^ tt4 >> 16) & 255;
            result[4 * i7 + 2] = (Si[t6[(i7 + 2) % 4] >> 8 & 255] ^ tt4 >> 8) & 255;
            result[4 * i7 + 3] = (Si[t6[(i7 + 1) % 4] & 255] ^ tt4) & 255;
          }
          return result;
        };
        var ModeOfOperationECB = function(key2) {
          if (!(this instanceof ModeOfOperationECB)) {
            throw Error("AES must be instanitated with `new`");
          }
          this.description = "Electronic Code Block";
          this.name = "ecb";
          this._aes = new AES(key2);
        };
        ModeOfOperationECB.prototype.encrypt = function(plaintext) {
          plaintext = coerceArray(plaintext);
          if (plaintext.length % 16 !== 0) {
            throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
          }
          var ciphertext = createArray(plaintext.length);
          var block2 = createArray(16);
          for (var i7 = 0; i7 < plaintext.length; i7 += 16) {
            copyArray(plaintext, block2, 0, i7, i7 + 16);
            block2 = this._aes.encrypt(block2);
            copyArray(block2, ciphertext, i7);
          }
          return ciphertext;
        };
        ModeOfOperationECB.prototype.decrypt = function(ciphertext) {
          ciphertext = coerceArray(ciphertext);
          if (ciphertext.length % 16 !== 0) {
            throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
          }
          var plaintext = createArray(ciphertext.length);
          var block2 = createArray(16);
          for (var i7 = 0; i7 < ciphertext.length; i7 += 16) {
            copyArray(ciphertext, block2, 0, i7, i7 + 16);
            block2 = this._aes.decrypt(block2);
            copyArray(block2, plaintext, i7);
          }
          return plaintext;
        };
        var ModeOfOperationCBC = function(key2, iv2) {
          if (!(this instanceof ModeOfOperationCBC)) {
            throw Error("AES must be instanitated with `new`");
          }
          this.description = "Cipher Block Chaining";
          this.name = "cbc";
          if (!iv2) {
            iv2 = createArray(16);
          } else if (iv2.length != 16) {
            throw new Error("invalid initialation vector size (must be 16 bytes)");
          }
          this._lastCipherblock = coerceArray(iv2, true);
          this._aes = new AES(key2);
        };
        ModeOfOperationCBC.prototype.encrypt = function(plaintext) {
          plaintext = coerceArray(plaintext);
          if (plaintext.length % 16 !== 0) {
            throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
          }
          var ciphertext = createArray(plaintext.length);
          var block2 = createArray(16);
          for (var i7 = 0; i7 < plaintext.length; i7 += 16) {
            copyArray(plaintext, block2, 0, i7, i7 + 16);
            for (var j7 = 0; j7 < 16; j7++) {
              block2[j7] ^= this._lastCipherblock[j7];
            }
            this._lastCipherblock = this._aes.encrypt(block2);
            copyArray(this._lastCipherblock, ciphertext, i7);
          }
          return ciphertext;
        };
        ModeOfOperationCBC.prototype.decrypt = function(ciphertext) {
          ciphertext = coerceArray(ciphertext);
          if (ciphertext.length % 16 !== 0) {
            throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
          }
          var plaintext = createArray(ciphertext.length);
          var block2 = createArray(16);
          for (var i7 = 0; i7 < ciphertext.length; i7 += 16) {
            copyArray(ciphertext, block2, 0, i7, i7 + 16);
            block2 = this._aes.decrypt(block2);
            for (var j7 = 0; j7 < 16; j7++) {
              plaintext[i7 + j7] = block2[j7] ^ this._lastCipherblock[j7];
            }
            copyArray(ciphertext, this._lastCipherblock, 0, i7, i7 + 16);
          }
          return plaintext;
        };
        var ModeOfOperationCFB = function(key2, iv2, segmentSize) {
          if (!(this instanceof ModeOfOperationCFB)) {
            throw Error("AES must be instanitated with `new`");
          }
          this.description = "Cipher Feedback";
          this.name = "cfb";
          if (!iv2) {
            iv2 = createArray(16);
          } else if (iv2.length != 16) {
            throw new Error("invalid initialation vector size (must be 16 size)");
          }
          if (!segmentSize) {
            segmentSize = 1;
          }
          this.segmentSize = segmentSize;
          this._shiftRegister = coerceArray(iv2, true);
          this._aes = new AES(key2);
        };
        ModeOfOperationCFB.prototype.encrypt = function(plaintext) {
          if (plaintext.length % this.segmentSize != 0) {
            throw new Error("invalid plaintext size (must be segmentSize bytes)");
          }
          var encrypted = coerceArray(plaintext, true);
          var xorSegment;
          for (var i7 = 0; i7 < encrypted.length; i7 += this.segmentSize) {
            xorSegment = this._aes.encrypt(this._shiftRegister);
            for (var j7 = 0; j7 < this.segmentSize; j7++) {
              encrypted[i7 + j7] ^= xorSegment[j7];
            }
            copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
            copyArray(encrypted, this._shiftRegister, 16 - this.segmentSize, i7, i7 + this.segmentSize);
          }
          return encrypted;
        };
        ModeOfOperationCFB.prototype.decrypt = function(ciphertext) {
          if (ciphertext.length % this.segmentSize != 0) {
            throw new Error("invalid ciphertext size (must be segmentSize bytes)");
          }
          var plaintext = coerceArray(ciphertext, true);
          var xorSegment;
          for (var i7 = 0; i7 < plaintext.length; i7 += this.segmentSize) {
            xorSegment = this._aes.encrypt(this._shiftRegister);
            for (var j7 = 0; j7 < this.segmentSize; j7++) {
              plaintext[i7 + j7] ^= xorSegment[j7];
            }
            copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
            copyArray(ciphertext, this._shiftRegister, 16 - this.segmentSize, i7, i7 + this.segmentSize);
          }
          return plaintext;
        };
        var ModeOfOperationOFB = function(key2, iv2) {
          if (!(this instanceof ModeOfOperationOFB)) {
            throw Error("AES must be instanitated with `new`");
          }
          this.description = "Output Feedback";
          this.name = "ofb";
          if (!iv2) {
            iv2 = createArray(16);
          } else if (iv2.length != 16) {
            throw new Error("invalid initialation vector size (must be 16 bytes)");
          }
          this._lastPrecipher = coerceArray(iv2, true);
          this._lastPrecipherIndex = 16;
          this._aes = new AES(key2);
        };
        ModeOfOperationOFB.prototype.encrypt = function(plaintext) {
          var encrypted = coerceArray(plaintext, true);
          for (var i7 = 0; i7 < encrypted.length; i7++) {
            if (this._lastPrecipherIndex === 16) {
              this._lastPrecipher = this._aes.encrypt(this._lastPrecipher);
              this._lastPrecipherIndex = 0;
            }
            encrypted[i7] ^= this._lastPrecipher[this._lastPrecipherIndex++];
          }
          return encrypted;
        };
        ModeOfOperationOFB.prototype.decrypt = ModeOfOperationOFB.prototype.encrypt;
        var Counter = function(initialValue) {
          if (!(this instanceof Counter)) {
            throw Error("Counter must be instanitated with `new`");
          }
          if (initialValue !== 0 && !initialValue) {
            initialValue = 1;
          }
          if (typeof initialValue === "number") {
            this._counter = createArray(16);
            this.setValue(initialValue);
          } else {
            this.setBytes(initialValue);
          }
        };
        Counter.prototype.setValue = function(value) {
          if (typeof value !== "number" || parseInt(value) != value) {
            throw new Error("invalid counter value (must be an integer)");
          }
          for (var index2 = 15; index2 >= 0; --index2) {
            this._counter[index2] = value % 256;
            value = value >> 8;
          }
        };
        Counter.prototype.setBytes = function(bytes3) {
          bytes3 = coerceArray(bytes3, true);
          if (bytes3.length != 16) {
            throw new Error("invalid counter bytes size (must be 16 bytes)");
          }
          this._counter = bytes3;
        };
        Counter.prototype.increment = function() {
          for (var i7 = 15; i7 >= 0; i7--) {
            if (this._counter[i7] === 255) {
              this._counter[i7] = 0;
            } else {
              this._counter[i7]++;
              break;
            }
          }
        };
        var ModeOfOperationCTR = function(key2, counter) {
          if (!(this instanceof ModeOfOperationCTR)) {
            throw Error("AES must be instanitated with `new`");
          }
          this.description = "Counter";
          this.name = "ctr";
          if (!(counter instanceof Counter)) {
            counter = new Counter(counter);
          }
          this._counter = counter;
          this._remainingCounter = null;
          this._remainingCounterIndex = 16;
          this._aes = new AES(key2);
        };
        ModeOfOperationCTR.prototype.encrypt = function(plaintext) {
          var encrypted = coerceArray(plaintext, true);
          for (var i7 = 0; i7 < encrypted.length; i7++) {
            if (this._remainingCounterIndex === 16) {
              this._remainingCounter = this._aes.encrypt(this._counter._counter);
              this._remainingCounterIndex = 0;
              this._counter.increment();
            }
            encrypted[i7] ^= this._remainingCounter[this._remainingCounterIndex++];
          }
          return encrypted;
        };
        ModeOfOperationCTR.prototype.decrypt = ModeOfOperationCTR.prototype.encrypt;
        function pkcs7pad(data2) {
          data2 = coerceArray(data2, true);
          var padder = 16 - data2.length % 16;
          var result = createArray(data2.length + padder);
          copyArray(data2, result);
          for (var i7 = data2.length; i7 < result.length; i7++) {
            result[i7] = padder;
          }
          return result;
        }
        function pkcs7strip(data2) {
          data2 = coerceArray(data2, true);
          if (data2.length < 16) {
            throw new Error("PKCS#7 invalid length");
          }
          var padder = data2[data2.length - 1];
          if (padder > 16) {
            throw new Error("PKCS#7 padding byte out of range");
          }
          var length2 = data2.length - padder;
          for (var i7 = 0; i7 < padder; i7++) {
            if (data2[length2 + i7] !== padder) {
              throw new Error("PKCS#7 invalid padding byte");
            }
          }
          var result = createArray(length2);
          copyArray(data2, result, 0, 0, length2);
          return result;
        }
        var aesjs = {
          AES,
          Counter,
          ModeOfOperation: {
            ecb: ModeOfOperationECB,
            cbc: ModeOfOperationCBC,
            cfb: ModeOfOperationCFB,
            ofb: ModeOfOperationOFB,
            ctr: ModeOfOperationCTR
          },
          utils: {
            hex: convertHex,
            utf8: convertUtf8
          },
          padding: {
            pkcs7: {
              pad: pkcs7pad,
              strip: pkcs7strip
            }
          },
          _arrayTest: {
            coerceArray,
            createArray,
            copyArray
          }
        };
        if (typeof exports !== "undefined") {
          module.exports = aesjs;
        } else if (typeof define === "function" && define.amd) {
          define(aesjs);
        } else {
          if (root2.aesjs) {
            aesjs._aesjs = root2.aesjs;
          }
          root2.aesjs = aesjs;
        }
      })(exports);
    }
  });

  // node_modules/scrypt-js/scrypt.js
  var require_scrypt = __commonJS({
    "node_modules/scrypt-js/scrypt.js"(exports, module) {
      "use strict";
      (function(root2) {
        const MAX_VALUE = 2147483647;
        function SHA256(m6) {
          const K8 = new Uint32Array([
            1116352408,
            1899447441,
            3049323471,
            3921009573,
            961987163,
            1508970993,
            2453635748,
            2870763221,
            3624381080,
            310598401,
            607225278,
            1426881987,
            1925078388,
            2162078206,
            2614888103,
            3248222580,
            3835390401,
            4022224774,
            264347078,
            604807628,
            770255983,
            1249150122,
            1555081692,
            1996064986,
            2554220882,
            2821834349,
            2952996808,
            3210313671,
            3336571891,
            3584528711,
            113926993,
            338241895,
            666307205,
            773529912,
            1294757372,
            1396182291,
            1695183700,
            1986661051,
            2177026350,
            2456956037,
            2730485921,
            2820302411,
            3259730800,
            3345764771,
            3516065817,
            3600352804,
            4094571909,
            275423344,
            430227734,
            506948616,
            659060556,
            883997877,
            958139571,
            1322822218,
            1537002063,
            1747873779,
            1955562222,
            2024104815,
            2227730452,
            2361852424,
            2428436474,
            2756734187,
            3204031479,
            3329325298
          ]);
          let h0 = 1779033703, h1 = 3144134277, h22 = 1013904242, h32 = 2773480762;
          let h42 = 1359893119, h52 = 2600822924, h62 = 528734635, h72 = 1541459225;
          const w8 = new Uint32Array(64);
          function blocks(p9) {
            let off = 0, len = p9.length;
            while (len >= 64) {
              let a6 = h0, b7 = h1, c9 = h22, d7 = h32, e9 = h42, f7 = h52, g7 = h62, h10 = h72, u7, i8, j7, t1, t22;
              for (i8 = 0; i8 < 16; i8++) {
                j7 = off + i8 * 4;
                w8[i8] = (p9[j7] & 255) << 24 | (p9[j7 + 1] & 255) << 16 | (p9[j7 + 2] & 255) << 8 | p9[j7 + 3] & 255;
              }
              for (i8 = 16; i8 < 64; i8++) {
                u7 = w8[i8 - 2];
                t1 = (u7 >>> 17 | u7 << 32 - 17) ^ (u7 >>> 19 | u7 << 32 - 19) ^ u7 >>> 10;
                u7 = w8[i8 - 15];
                t22 = (u7 >>> 7 | u7 << 32 - 7) ^ (u7 >>> 18 | u7 << 32 - 18) ^ u7 >>> 3;
                w8[i8] = (t1 + w8[i8 - 7] | 0) + (t22 + w8[i8 - 16] | 0) | 0;
              }
              for (i8 = 0; i8 < 64; i8++) {
                t1 = (((e9 >>> 6 | e9 << 32 - 6) ^ (e9 >>> 11 | e9 << 32 - 11) ^ (e9 >>> 25 | e9 << 32 - 25)) + (e9 & f7 ^ ~e9 & g7) | 0) + (h10 + (K8[i8] + w8[i8] | 0) | 0) | 0;
                t22 = ((a6 >>> 2 | a6 << 32 - 2) ^ (a6 >>> 13 | a6 << 32 - 13) ^ (a6 >>> 22 | a6 << 32 - 22)) + (a6 & b7 ^ a6 & c9 ^ b7 & c9) | 0;
                h10 = g7;
                g7 = f7;
                f7 = e9;
                e9 = d7 + t1 | 0;
                d7 = c9;
                c9 = b7;
                b7 = a6;
                a6 = t1 + t22 | 0;
              }
              h0 = h0 + a6 | 0;
              h1 = h1 + b7 | 0;
              h22 = h22 + c9 | 0;
              h32 = h32 + d7 | 0;
              h42 = h42 + e9 | 0;
              h52 = h52 + f7 | 0;
              h62 = h62 + g7 | 0;
              h72 = h72 + h10 | 0;
              off += 64;
              len -= 64;
            }
          }
          blocks(m6);
          let i7, bytesLeft = m6.length % 64, bitLenHi = m6.length / 536870912 | 0, bitLenLo = m6.length << 3, numZeros = bytesLeft < 56 ? 56 : 120, p8 = m6.slice(m6.length - bytesLeft, m6.length);
          p8.push(128);
          for (i7 = bytesLeft + 1; i7 < numZeros; i7++) {
            p8.push(0);
          }
          p8.push(bitLenHi >>> 24 & 255);
          p8.push(bitLenHi >>> 16 & 255);
          p8.push(bitLenHi >>> 8 & 255);
          p8.push(bitLenHi >>> 0 & 255);
          p8.push(bitLenLo >>> 24 & 255);
          p8.push(bitLenLo >>> 16 & 255);
          p8.push(bitLenLo >>> 8 & 255);
          p8.push(bitLenLo >>> 0 & 255);
          blocks(p8);
          return [
            h0 >>> 24 & 255,
            h0 >>> 16 & 255,
            h0 >>> 8 & 255,
            h0 >>> 0 & 255,
            h1 >>> 24 & 255,
            h1 >>> 16 & 255,
            h1 >>> 8 & 255,
            h1 >>> 0 & 255,
            h22 >>> 24 & 255,
            h22 >>> 16 & 255,
            h22 >>> 8 & 255,
            h22 >>> 0 & 255,
            h32 >>> 24 & 255,
            h32 >>> 16 & 255,
            h32 >>> 8 & 255,
            h32 >>> 0 & 255,
            h42 >>> 24 & 255,
            h42 >>> 16 & 255,
            h42 >>> 8 & 255,
            h42 >>> 0 & 255,
            h52 >>> 24 & 255,
            h52 >>> 16 & 255,
            h52 >>> 8 & 255,
            h52 >>> 0 & 255,
            h62 >>> 24 & 255,
            h62 >>> 16 & 255,
            h62 >>> 8 & 255,
            h62 >>> 0 & 255,
            h72 >>> 24 & 255,
            h72 >>> 16 & 255,
            h72 >>> 8 & 255,
            h72 >>> 0 & 255
          ];
        }
        function PBKDF2_HMAC_SHA256_OneIter(password, salt, dkLen) {
          password = password.length <= 64 ? password : SHA256(password);
          const innerLen = 64 + salt.length + 4;
          const inner = new Array(innerLen);
          const outerKey = new Array(64);
          let i7;
          let dk = [];
          for (i7 = 0; i7 < 64; i7++) {
            inner[i7] = 54;
          }
          for (i7 = 0; i7 < password.length; i7++) {
            inner[i7] ^= password[i7];
          }
          for (i7 = 0; i7 < salt.length; i7++) {
            inner[64 + i7] = salt[i7];
          }
          for (i7 = innerLen - 4; i7 < innerLen; i7++) {
            inner[i7] = 0;
          }
          for (i7 = 0; i7 < 64; i7++)
            outerKey[i7] = 92;
          for (i7 = 0; i7 < password.length; i7++)
            outerKey[i7] ^= password[i7];
          function incrementCounter() {
            for (let i8 = innerLen - 1; i8 >= innerLen - 4; i8--) {
              inner[i8]++;
              if (inner[i8] <= 255)
                return;
              inner[i8] = 0;
            }
          }
          while (dkLen >= 32) {
            incrementCounter();
            dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))));
            dkLen -= 32;
          }
          if (dkLen > 0) {
            incrementCounter();
            dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))).slice(0, dkLen));
          }
          return dk;
        }
        function blockmix_salsa8(BY, Yi2, r8, x4, _X) {
          let i7;
          arraycopy(BY, (2 * r8 - 1) * 16, _X, 0, 16);
          for (i7 = 0; i7 < 2 * r8; i7++) {
            blockxor(BY, i7 * 16, _X, 16);
            salsa20_8(_X, x4);
            arraycopy(_X, 0, BY, Yi2 + i7 * 16, 16);
          }
          for (i7 = 0; i7 < r8; i7++) {
            arraycopy(BY, Yi2 + i7 * 2 * 16, BY, i7 * 16, 16);
          }
          for (i7 = 0; i7 < r8; i7++) {
            arraycopy(BY, Yi2 + (i7 * 2 + 1) * 16, BY, (i7 + r8) * 16, 16);
          }
        }
        function R7(a6, b7) {
          return a6 << b7 | a6 >>> 32 - b7;
        }
        function salsa20_8(B10, x4) {
          arraycopy(B10, 0, x4, 0, 16);
          for (let i7 = 8; i7 > 0; i7 -= 2) {
            x4[4] ^= R7(x4[0] + x4[12], 7);
            x4[8] ^= R7(x4[4] + x4[0], 9);
            x4[12] ^= R7(x4[8] + x4[4], 13);
            x4[0] ^= R7(x4[12] + x4[8], 18);
            x4[9] ^= R7(x4[5] + x4[1], 7);
            x4[13] ^= R7(x4[9] + x4[5], 9);
            x4[1] ^= R7(x4[13] + x4[9], 13);
            x4[5] ^= R7(x4[1] + x4[13], 18);
            x4[14] ^= R7(x4[10] + x4[6], 7);
            x4[2] ^= R7(x4[14] + x4[10], 9);
            x4[6] ^= R7(x4[2] + x4[14], 13);
            x4[10] ^= R7(x4[6] + x4[2], 18);
            x4[3] ^= R7(x4[15] + x4[11], 7);
            x4[7] ^= R7(x4[3] + x4[15], 9);
            x4[11] ^= R7(x4[7] + x4[3], 13);
            x4[15] ^= R7(x4[11] + x4[7], 18);
            x4[1] ^= R7(x4[0] + x4[3], 7);
            x4[2] ^= R7(x4[1] + x4[0], 9);
            x4[3] ^= R7(x4[2] + x4[1], 13);
            x4[0] ^= R7(x4[3] + x4[2], 18);
            x4[6] ^= R7(x4[5] + x4[4], 7);
            x4[7] ^= R7(x4[6] + x4[5], 9);
            x4[4] ^= R7(x4[7] + x4[6], 13);
            x4[5] ^= R7(x4[4] + x4[7], 18);
            x4[11] ^= R7(x4[10] + x4[9], 7);
            x4[8] ^= R7(x4[11] + x4[10], 9);
            x4[9] ^= R7(x4[8] + x4[11], 13);
            x4[10] ^= R7(x4[9] + x4[8], 18);
            x4[12] ^= R7(x4[15] + x4[14], 7);
            x4[13] ^= R7(x4[12] + x4[15], 9);
            x4[14] ^= R7(x4[13] + x4[12], 13);
            x4[15] ^= R7(x4[14] + x4[13], 18);
          }
          for (let i7 = 0; i7 < 16; ++i7) {
            B10[i7] += x4[i7];
          }
        }
        function blockxor(S12, Si, D10, len) {
          for (let i7 = 0; i7 < len; i7++) {
            D10[i7] ^= S12[Si + i7];
          }
        }
        function arraycopy(src2, srcPos, dest, destPos, length2) {
          while (length2--) {
            dest[destPos++] = src2[srcPos++];
          }
        }
        function checkBufferish(o9) {
          if (!o9 || typeof o9.length !== "number") {
            return false;
          }
          for (let i7 = 0; i7 < o9.length; i7++) {
            const v6 = o9[i7];
            if (typeof v6 !== "number" || v6 % 1 || v6 < 0 || v6 >= 256) {
              return false;
            }
          }
          return true;
        }
        function ensureInteger(value, name2) {
          if (typeof value !== "number" || value % 1) {
            throw new Error("invalid " + name2);
          }
          return value;
        }
        function _scrypt(password, salt, N17, r8, p8, dkLen, callback) {
          N17 = ensureInteger(N17, "N");
          r8 = ensureInteger(r8, "r");
          p8 = ensureInteger(p8, "p");
          dkLen = ensureInteger(dkLen, "dkLen");
          if (N17 === 0 || (N17 & N17 - 1) !== 0) {
            throw new Error("N must be power of 2");
          }
          if (N17 > MAX_VALUE / 128 / r8) {
            throw new Error("N too large");
          }
          if (r8 > MAX_VALUE / 128 / p8) {
            throw new Error("r too large");
          }
          if (!checkBufferish(password)) {
            throw new Error("password must be an array or buffer");
          }
          password = Array.prototype.slice.call(password);
          if (!checkBufferish(salt)) {
            throw new Error("salt must be an array or buffer");
          }
          salt = Array.prototype.slice.call(salt);
          let b7 = PBKDF2_HMAC_SHA256_OneIter(password, salt, p8 * 128 * r8);
          const B10 = new Uint32Array(p8 * 32 * r8);
          for (let i7 = 0; i7 < B10.length; i7++) {
            const j7 = i7 * 4;
            B10[i7] = (b7[j7 + 3] & 255) << 24 | (b7[j7 + 2] & 255) << 16 | (b7[j7 + 1] & 255) << 8 | (b7[j7 + 0] & 255) << 0;
          }
          const XY = new Uint32Array(64 * r8);
          const V9 = new Uint32Array(32 * r8 * N17);
          const Yi2 = 32 * r8;
          const x4 = new Uint32Array(16);
          const _X = new Uint32Array(16);
          const totalOps = p8 * N17 * 2;
          let currentOp = 0;
          let lastPercent10 = null;
          let stop = false;
          let state = 0;
          let i0 = 0, i1;
          let Bi2;
          const limit = callback ? parseInt(1e3 / r8) : 4294967295;
          const nextTick = typeof setImmediate !== "undefined" ? setImmediate : setTimeout;
          const incrementalSMix = function() {
            if (stop) {
              return callback(new Error("cancelled"), currentOp / totalOps);
            }
            let steps2;
            switch (state) {
              case 0:
                Bi2 = i0 * 32 * r8;
                arraycopy(B10, Bi2, XY, 0, Yi2);
                state = 1;
                i1 = 0;
              case 1:
                steps2 = N17 - i1;
                if (steps2 > limit) {
                  steps2 = limit;
                }
                for (let i7 = 0; i7 < steps2; i7++) {
                  arraycopy(XY, 0, V9, (i1 + i7) * Yi2, Yi2);
                  blockmix_salsa8(XY, Yi2, r8, x4, _X);
                }
                i1 += steps2;
                currentOp += steps2;
                if (callback) {
                  const percent10 = parseInt(1e3 * currentOp / totalOps);
                  if (percent10 !== lastPercent10) {
                    stop = callback(null, currentOp / totalOps);
                    if (stop) {
                      break;
                    }
                    lastPercent10 = percent10;
                  }
                }
                if (i1 < N17) {
                  break;
                }
                i1 = 0;
                state = 2;
              case 2:
                steps2 = N17 - i1;
                if (steps2 > limit) {
                  steps2 = limit;
                }
                for (let i7 = 0; i7 < steps2; i7++) {
                  const offset = (2 * r8 - 1) * 16;
                  const j7 = XY[offset] & N17 - 1;
                  blockxor(V9, j7 * Yi2, XY, Yi2);
                  blockmix_salsa8(XY, Yi2, r8, x4, _X);
                }
                i1 += steps2;
                currentOp += steps2;
                if (callback) {
                  const percent10 = parseInt(1e3 * currentOp / totalOps);
                  if (percent10 !== lastPercent10) {
                    stop = callback(null, currentOp / totalOps);
                    if (stop) {
                      break;
                    }
                    lastPercent10 = percent10;
                  }
                }
                if (i1 < N17) {
                  break;
                }
                arraycopy(XY, 0, B10, Bi2, Yi2);
                i0++;
                if (i0 < p8) {
                  state = 0;
                  break;
                }
                b7 = [];
                for (let i7 = 0; i7 < B10.length; i7++) {
                  b7.push(B10[i7] >> 0 & 255);
                  b7.push(B10[i7] >> 8 & 255);
                  b7.push(B10[i7] >> 16 & 255);
                  b7.push(B10[i7] >> 24 & 255);
                }
                const derivedKey = PBKDF2_HMAC_SHA256_OneIter(password, b7, dkLen);
                if (callback) {
                  callback(null, 1, derivedKey);
                }
                return derivedKey;
            }
            if (callback) {
              nextTick(incrementalSMix);
            }
          };
          if (!callback) {
            while (true) {
              const derivedKey = incrementalSMix();
              if (derivedKey != void 0) {
                return derivedKey;
              }
            }
          }
          incrementalSMix();
        }
        const lib = {
          scrypt: function(password, salt, N17, r8, p8, dkLen, progressCallback) {
            return new Promise(function(resolve, reject) {
              let lastProgress = 0;
              if (progressCallback) {
                progressCallback(0);
              }
              _scrypt(password, salt, N17, r8, p8, dkLen, function(error, progress2, key2) {
                if (error) {
                  reject(error);
                } else if (key2) {
                  if (progressCallback && lastProgress !== 1) {
                    progressCallback(1);
                  }
                  resolve(new Uint8Array(key2));
                } else if (progressCallback && progress2 !== lastProgress) {
                  lastProgress = progress2;
                  return progressCallback(progress2);
                }
              });
            });
          },
          syncScrypt: function(password, salt, N17, r8, p8, dkLen) {
            return new Uint8Array(_scrypt(password, salt, N17, r8, p8, dkLen));
          }
        };
        if (typeof exports !== "undefined") {
          module.exports = lib;
        } else if (typeof define === "function" && define.amd) {
          define(lib);
        } else if (root2) {
          if (root2.scrypt) {
            root2._scrypt = root2.scrypt;
          }
          root2.scrypt = lib;
        }
      })(exports);
    }
  });

  // node_modules/bech32/index.js
  var require_bech32 = __commonJS({
    "node_modules/bech32/index.js"(exports, module) {
      "use strict";
      var ALPHABET2 = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
      var ALPHABET_MAP = {};
      for (z7 = 0; z7 < ALPHABET2.length; z7++) {
        x4 = ALPHABET2.charAt(z7);
        if (ALPHABET_MAP[x4] !== void 0)
          throw new TypeError(x4 + " is ambiguous");
        ALPHABET_MAP[x4] = z7;
      }
      var x4;
      var z7;
      function polymodStep(pre) {
        var b7 = pre >> 25;
        return (pre & 33554431) << 5 ^ -(b7 >> 0 & 1) & 996825010 ^ -(b7 >> 1 & 1) & 642813549 ^ -(b7 >> 2 & 1) & 513874426 ^ -(b7 >> 3 & 1) & 1027748829 ^ -(b7 >> 4 & 1) & 705979059;
      }
      function prefixChk(prefix) {
        var chk = 1;
        for (var i7 = 0; i7 < prefix.length; ++i7) {
          var c9 = prefix.charCodeAt(i7);
          if (c9 < 33 || c9 > 126)
            return "Invalid prefix (" + prefix + ")";
          chk = polymodStep(chk) ^ c9 >> 5;
        }
        chk = polymodStep(chk);
        for (i7 = 0; i7 < prefix.length; ++i7) {
          var v6 = prefix.charCodeAt(i7);
          chk = polymodStep(chk) ^ v6 & 31;
        }
        return chk;
      }
      function encode10(prefix, words2, LIMIT) {
        LIMIT = LIMIT || 90;
        if (prefix.length + 7 + words2.length > LIMIT)
          throw new TypeError("Exceeds length limit");
        prefix = prefix.toLowerCase();
        var chk = prefixChk(prefix);
        if (typeof chk === "string")
          throw new Error(chk);
        var result = prefix + "1";
        for (var i7 = 0; i7 < words2.length; ++i7) {
          var x5 = words2[i7];
          if (x5 >> 5 !== 0)
            throw new Error("Non 5-bit word");
          chk = polymodStep(chk) ^ x5;
          result += ALPHABET2.charAt(x5);
        }
        for (i7 = 0; i7 < 6; ++i7) {
          chk = polymodStep(chk);
        }
        chk ^= 1;
        for (i7 = 0; i7 < 6; ++i7) {
          var v6 = chk >> (5 - i7) * 5 & 31;
          result += ALPHABET2.charAt(v6);
        }
        return result;
      }
      function __decode(str, LIMIT) {
        LIMIT = LIMIT || 90;
        if (str.length < 8)
          return str + " too short";
        if (str.length > LIMIT)
          return "Exceeds length limit";
        var lowered = str.toLowerCase();
        var uppered = str.toUpperCase();
        if (str !== lowered && str !== uppered)
          return "Mixed-case string " + str;
        str = lowered;
        var split2 = str.lastIndexOf("1");
        if (split2 === -1)
          return "No separator character for " + str;
        if (split2 === 0)
          return "Missing prefix for " + str;
        var prefix = str.slice(0, split2);
        var wordChars = str.slice(split2 + 1);
        if (wordChars.length < 6)
          return "Data too short";
        var chk = prefixChk(prefix);
        if (typeof chk === "string")
          return chk;
        var words2 = [];
        for (var i7 = 0; i7 < wordChars.length; ++i7) {
          var c9 = wordChars.charAt(i7);
          var v6 = ALPHABET_MAP[c9];
          if (v6 === void 0)
            return "Unknown character " + c9;
          chk = polymodStep(chk) ^ v6;
          if (i7 + 6 >= wordChars.length)
            continue;
          words2.push(v6);
        }
        if (chk !== 1)
          return "Invalid checksum for " + str;
        return { prefix, words: words2 };
      }
      function decodeUnsafe() {
        var res = __decode.apply(null, arguments);
        if (typeof res === "object")
          return res;
      }
      function decode8(str) {
        var res = __decode.apply(null, arguments);
        if (typeof res === "object")
          return res;
        throw new Error(res);
      }
      function convert(data2, inBits, outBits, pad2) {
        var value = 0;
        var bits = 0;
        var maxV = (1 << outBits) - 1;
        var result = [];
        for (var i7 = 0; i7 < data2.length; ++i7) {
          value = value << inBits | data2[i7];
          bits += inBits;
          while (bits >= outBits) {
            bits -= outBits;
            result.push(value >> bits & maxV);
          }
        }
        if (pad2) {
          if (bits > 0) {
            result.push(value << outBits - bits & maxV);
          }
        } else {
          if (bits >= inBits)
            return "Excess padding";
          if (value << outBits - bits & maxV)
            return "Non-zero padding";
        }
        return result;
      }
      function toWordsUnsafe(bytes3) {
        var res = convert(bytes3, 8, 5, true);
        if (Array.isArray(res))
          return res;
      }
      function toWords(bytes3) {
        var res = convert(bytes3, 8, 5, true);
        if (Array.isArray(res))
          return res;
        throw new Error(res);
      }
      function fromWordsUnsafe(words2) {
        var res = convert(words2, 5, 8, false);
        if (Array.isArray(res))
          return res;
      }
      function fromWords(words2) {
        var res = convert(words2, 5, 8, false);
        if (Array.isArray(res))
          return res;
        throw new Error(res);
      }
      module.exports = {
        decodeUnsafe,
        decode: decode8,
        encode: encode10,
        toWordsUnsafe,
        toWords,
        fromWordsUnsafe,
        fromWords
      };
    }
  });

  // node_modules/classnames/index.js
  var require_classnames = __commonJS({
    "node_modules/classnames/index.js"(exports, module) {
      (function() {
        "use strict";
        var hasOwn = {}.hasOwnProperty;
        var nativeCodeString = "[native code]";
        function classNames7() {
          var classes = [];
          for (var i7 = 0; i7 < arguments.length; i7++) {
            var arg = arguments[i7];
            if (!arg)
              continue;
            var argType = typeof arg;
            if (argType === "string" || argType === "number") {
              classes.push(arg);
            } else if (Array.isArray(arg)) {
              if (arg.length) {
                var inner = classNames7.apply(null, arg);
                if (inner) {
                  classes.push(inner);
                }
              }
            } else if (argType === "object") {
              if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
                classes.push(arg.toString());
                continue;
              }
              for (var key2 in arg) {
                if (hasOwn.call(arg, key2) && arg[key2]) {
                  classes.push(key2);
                }
              }
            }
          }
          return classes.join(" ");
        }
        if (typeof module !== "undefined" && module.exports) {
          classNames7.default = classNames7;
          module.exports = classNames7;
        } else if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
          define("classnames", [], function() {
            return classNames7;
          });
        } else {
          window.classNames = classNames7;
        }
      })();
    }
  });

  // src/index.tsx
  var import_react23 = __toESM(require_react());
  var import_client = __toESM(require_client());

  // node_modules/@wagmi/chains/dist/index.mjs
  var arbitrum = {
    id: 42161,
    name: "Arbitrum One",
    network: "arbitrum",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      alchemy: {
        http: ["https://arb-mainnet.g.alchemy.com/v2"],
        webSocket: ["wss://arb-mainnet.g.alchemy.com/v2"]
      },
      infura: {
        http: ["https://arbitrum-mainnet.infura.io/v3"],
        webSocket: ["wss://arbitrum-mainnet.infura.io/ws/v3"]
      },
      default: {
        http: ["https://arb1.arbitrum.io/rpc"]
      },
      public: {
        http: ["https://arb1.arbitrum.io/rpc"]
      }
    },
    blockExplorers: {
      etherscan: { name: "Arbiscan", url: "https://arbiscan.io" },
      default: { name: "Arbiscan", url: "https://arbiscan.io" }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 7654707
      }
    }
  };
  var arbitrumGoerli = {
    id: 421613,
    name: "Arbitrum Goerli",
    network: "arbitrum-goerli",
    nativeCurrency: {
      name: "Arbitrum Goerli Ether",
      symbol: "ETH",
      decimals: 18
    },
    rpcUrls: {
      alchemy: {
        http: ["https://arb-goerli.g.alchemy.com/v2"],
        webSocket: ["wss://arb-goerli.g.alchemy.com/v2"]
      },
      infura: {
        http: ["https://arbitrum-goerli.infura.io/v3"],
        webSocket: ["wss://arbitrum-goerli.infura.io/ws/v3"]
      },
      default: {
        http: ["https://goerli-rollup.arbitrum.io/rpc"]
      },
      public: {
        http: ["https://goerli-rollup.arbitrum.io/rpc"]
      }
    },
    blockExplorers: {
      etherscan: { name: "Arbiscan", url: "https://goerli.arbiscan.io/" },
      default: { name: "Arbiscan", url: "https://goerli.arbiscan.io/" }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 88114
      }
    },
    testnet: true
  };
  var aurora = {
    id: 1313161554,
    name: "Aurora",
    network: "aurora",
    nativeCurrency: {
      decimals: 18,
      name: "Ether",
      symbol: "ETH"
    },
    rpcUrls: {
      infura: { http: ["https://aurora-mainnet.infura.io/v3"] },
      default: { http: ["https://mainnet.aurora.dev"] },
      public: { http: ["https://mainnet.aurora.dev"] }
    },
    blockExplorers: {
      etherscan: { name: "Aurorascan", url: "https://aurorascan.dev" },
      default: { name: "Aurorascan", url: "https://aurorascan.dev" }
    }
  };
  var auroraTestnet = {
    id: 1313161555,
    name: "Aurora Testnet",
    network: "aurora-testnet",
    nativeCurrency: {
      decimals: 18,
      name: "Ether",
      symbol: "ETH"
    },
    rpcUrls: {
      infura: { http: ["https://aurora-testnet.infura.io/v3"] },
      default: { http: ["https://testnet.aurora.dev"] },
      public: { http: ["https://testnet.aurora.dev"] }
    },
    blockExplorers: {
      etherscan: { name: "Aurorascan", url: "https://testnet.aurorascan.dev" },
      default: { name: "Aurorascan", url: "https://testnet.aurorascan.dev" }
    },
    testnet: true
  };
  var avalanche = {
    id: 43114,
    name: "Avalanche",
    network: "avalanche",
    nativeCurrency: {
      decimals: 18,
      name: "Avalanche",
      symbol: "AVAX"
    },
    rpcUrls: {
      default: { http: ["https://api.avax.network/ext/bc/C/rpc"] },
      public: { http: ["https://api.avax.network/ext/bc/C/rpc"] }
    },
    blockExplorers: {
      etherscan: { name: "SnowTrace", url: "https://snowtrace.io" },
      default: { name: "SnowTrace", url: "https://snowtrace.io" }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 11907934
      }
    }
  };
  var avalancheFuji = {
    id: 43113,
    name: "Avalanche Fuji",
    network: "avalanche-fuji",
    nativeCurrency: {
      decimals: 18,
      name: "Avalanche Fuji",
      symbol: "AVAX"
    },
    rpcUrls: {
      default: { http: ["https://api.avax-test.network/ext/bc/C/rpc"] },
      public: { http: ["https://api.avax-test.network/ext/bc/C/rpc"] }
    },
    blockExplorers: {
      etherscan: { name: "SnowTrace", url: "https://testnet.snowtrace.io" },
      default: { name: "SnowTrace", url: "https://testnet.snowtrace.io" }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 7096959
      }
    },
    testnet: true
  };
  var baseGoerli = {
    id: 84531,
    network: "base-goerli",
    name: "Base Goerli",
    nativeCurrency: { name: "Base Goerli", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://goerli.base.org"]
      },
      public: {
        http: ["https://goerli.base.org"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "Basescan",
        url: "https://goerli.basescan.org"
      },
      default: {
        name: "Basescan",
        url: "https://goerli.basescan.org"
      }
    },
    testnet: true
  };
  var boba = {
    id: 288,
    name: "Boba Network",
    network: "boba",
    nativeCurrency: {
      decimals: 18,
      name: "Boba",
      symbol: "BOBA"
    },
    rpcUrls: {
      default: { http: ["https://mainnet.boba.network"] },
      public: { http: ["https://mainnet.boba.network"] }
    },
    blockExplorers: {
      etherscan: { name: "BOBAScan", url: "https://bobascan.com" },
      default: { name: "BOBAScan", url: "https://bobascan.com" }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 446859
      }
    }
  };
  var bronos = {
    id: 1039,
    name: "Bronos",
    network: "bronos",
    nativeCurrency: {
      decimals: 18,
      name: "BRO",
      symbol: "BRO"
    },
    rpcUrls: {
      default: { http: ["https://evm.bronos.org"] },
      public: { http: ["https://evm.bronos.org"] }
    },
    blockExplorers: {
      default: { name: "BronoScan", url: "https://broscan.bronos.org" }
    }
  };
  var bronosTestnet = {
    id: 1038,
    name: "Bronos Testnet",
    network: "bronos-testnet",
    nativeCurrency: {
      decimals: 18,
      name: "Bronos Coin",
      symbol: "tBRO"
    },
    rpcUrls: {
      default: { http: ["https://evm-testnet.bronos.org"] },
      public: { http: ["https://evm-testnet.bronos.org"] }
    },
    blockExplorers: {
      default: { name: "BronoScan", url: "https://tbroscan.bronos.org" }
    },
    testnet: true
  };
  var bsc = {
    id: 56,
    name: "BNB Smart Chain",
    network: "bsc",
    nativeCurrency: {
      decimals: 18,
      name: "BNB",
      symbol: "BNB"
    },
    rpcUrls: {
      default: { http: ["https://rpc.ankr.com/bsc"] },
      public: { http: ["https://rpc.ankr.com/bsc"] }
    },
    blockExplorers: {
      etherscan: { name: "BscScan", url: "https://bscscan.com" },
      default: { name: "BscScan", url: "https://bscscan.com" }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 15921452
      }
    }
  };
  var bscTestnet = {
    id: 97,
    name: "Binance Smart Chain Testnet",
    network: "bsc-testnet",
    nativeCurrency: {
      decimals: 18,
      name: "BNB",
      symbol: "tBNB"
    },
    rpcUrls: {
      default: { http: ["https://data-seed-prebsc-1-s1.binance.org:8545"] },
      public: { http: ["https://data-seed-prebsc-1-s1.binance.org:8545"] }
    },
    blockExplorers: {
      etherscan: { name: "BscScan", url: "https://testnet.bscscan.com" },
      default: { name: "BscScan", url: "https://testnet.bscscan.com" }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 17422483
      }
    },
    testnet: true
  };
  var canto = {
    id: 7700,
    name: "Canto",
    network: "canto",
    nativeCurrency: {
      decimals: 18,
      name: "Canto",
      symbol: "CANTO"
    },
    rpcUrls: {
      default: { http: ["https://canto.slingshot.finance"] },
      public: { http: ["https://canto.slingshot.finance"] }
    },
    blockExplorers: {
      default: {
        name: "Canto EVM Explorer (Blockscout)",
        url: "https://evm.explorer.canto.io"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 2905789
      }
    }
  };
  var celo = {
    id: 42220,
    name: "Celo",
    network: "celo",
    nativeCurrency: {
      decimals: 18,
      name: "CELO",
      symbol: "CELO"
    },
    rpcUrls: {
      default: { http: ["https://forno.celo.org"] },
      infura: {
        http: ["https://celo-mainnet.infura.io/v3"]
      },
      public: {
        http: ["https://forno.celo.org"]
      }
    },
    blockExplorers: {
      default: {
        name: "Celo Explorer",
        url: "https://explorer.celo.org/mainnet"
      },
      etherscan: { name: "CeloScan", url: "https://celoscan.io" }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 13112599
      }
    },
    testnet: false
  };
  var celoAlfajores = {
    id: 44787,
    name: "Alfajores",
    network: "celo-alfajores",
    nativeCurrency: {
      decimals: 18,
      name: "CELO",
      symbol: "A-CELO"
    },
    rpcUrls: {
      default: {
        http: ["https://alfajores-forno.celo-testnet.org"]
      },
      infura: {
        http: ["https://celo-alfajores.infura.io/v3"]
      },
      public: {
        http: ["https://alfajores-forno.celo-testnet.org"]
      }
    },
    blockExplorers: {
      default: {
        name: "Celo Explorer",
        url: "https://explorer.celo.org/alfajores"
      },
      etherscan: { name: "CeloScan", url: "https://alfajores.celoscan.io/" }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 14569001
      }
    },
    testnet: true
  };
  var celoCannoli = {
    id: 17323,
    name: "Cannoli",
    network: "celo-cannoli",
    nativeCurrency: {
      decimals: 18,
      name: "CELO",
      symbol: "C-CELO"
    },
    rpcUrls: {
      default: {
        http: ["https://forno.cannoli.celo-testnet.org"]
      },
      public: {
        http: ["https://forno.cannoli.celo-testnet.org"]
      }
    },
    blockExplorers: {
      default: {
        name: "Celo Explorer",
        url: "https://explorer.celo.org/cannoli"
      }
    },
    contracts: {
      multicall3: {
        address: "0x5Acb0aa8BF4E8Ff0d882Ee187140713C12BF9718",
        blockCreated: 87429
      }
    },
    testnet: true
  };
  var cronos = {
    id: 25,
    name: "Cronos",
    network: "cronos",
    nativeCurrency: {
      decimals: 18,
      name: "Cronos",
      symbol: "CRO"
    },
    rpcUrls: {
      default: { http: ["https://node.croswap.com/rpc"] },
      public: { http: ["https://node.croswap.com/rpc"] }
    },
    blockExplorers: {
      etherscan: { name: "CronosScan", url: "https://cronoscan.com" },
      default: { name: "CronosScan", url: "https://cronoscan.com" }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 1963112
      }
    }
  };
  var crossbell = {
    id: 3737,
    network: "crossbell",
    name: "Crossbell",
    nativeCurrency: {
      decimals: 18,
      name: "CSB",
      symbol: "CSB"
    },
    rpcUrls: {
      default: {
        http: ["https://rpc.crossbell.io"]
      },
      public: {
        http: ["https://rpc.crossbell.io"]
      }
    },
    blockExplorers: {
      default: { name: "CrossScan", url: "https://scan.crossbell.io" }
    },
    contracts: {
      multicall3: {
        address: "0xBB9759009cDaC82774EfC84D94cD9F7440f75Fcf",
        blockCreated: 23499787
      }
    }
  };
  var dfk = {
    id: 53935,
    name: "DFK Chain",
    network: "dfk",
    nativeCurrency: {
      decimals: 18,
      name: "Jewel",
      symbol: "JEWEL"
    },
    rpcUrls: {
      default: {
        http: ["https://subnets.avax.network/defi-kingdoms/dfk-chain/rpc"]
      },
      public: {
        http: ["https://subnets.avax.network/defi-kingdoms/dfk-chain/rpc"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "DFKSubnetScan",
        url: "https://subnets.avax.network/defi-kingdoms"
      },
      default: {
        name: "DFKSubnetScan",
        url: "https://subnets.avax.network/defi-kingdoms"
      }
    }
  };
  var dogechain = {
    id: 2e3,
    name: "Dogechain",
    network: "dogechain",
    nativeCurrency: {
      decimals: 18,
      name: "Dogechain",
      symbol: "DC"
    },
    rpcUrls: {
      default: { http: ["https://rpc.dogechain.dog"] },
      public: { http: ["https://rpc.dogechain.dog"] }
    },
    blockExplorers: {
      etherscan: {
        name: "DogeChainExplorer",
        url: "https://explorer.dogechain.dog"
      },
      default: {
        name: "DogeChainExplorer",
        url: "https://explorer.dogechain.dog"
      }
    }
  };
  var evmos = {
    id: 9001,
    name: "Evmos",
    network: "evmos",
    nativeCurrency: {
      decimals: 18,
      name: "Evmos",
      symbol: "EVMOS"
    },
    rpcUrls: {
      default: { http: ["https://eth.bd.evmos.org:8545"] },
      public: { http: ["https://eth.bd.evmos.org:8545"] }
    },
    blockExplorers: {
      default: { name: "Evmos Block Explorer", url: "https://escan.live/" }
    }
  };
  var evmosTestnet = {
    id: 9e3,
    name: "Evmos Testnet",
    network: "evmos-testnet",
    nativeCurrency: {
      decimals: 18,
      name: "Evmos",
      symbol: "EVMOS"
    },
    rpcUrls: {
      default: { http: ["https://eth.bd.evmos.dev:8545"] },
      public: { http: ["https://eth.bd.evmos.dev:8545"] }
    },
    blockExplorers: {
      default: {
        name: "Evmos Testnet Block Explorer",
        url: "https://evm.evmos.dev/"
      }
    }
  };
  var fantom = {
    id: 250,
    name: "Fantom",
    network: "fantom",
    nativeCurrency: {
      decimals: 18,
      name: "Fantom",
      symbol: "FTM"
    },
    rpcUrls: {
      default: { http: ["https://rpc.ankr.com/fantom"] },
      public: { http: ["https://rpc.ankr.com/fantom"] }
    },
    blockExplorers: {
      etherscan: { name: "FTMScan", url: "https://ftmscan.com" },
      default: { name: "FTMScan", url: "https://ftmscan.com" }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 33001987
      }
    }
  };
  var fantomTestnet = {
    id: 4002,
    name: "Fantom Testnet",
    network: "fantom-testnet",
    nativeCurrency: {
      decimals: 18,
      name: "Fantom",
      symbol: "FTM"
    },
    rpcUrls: {
      default: { http: ["https://rpc.testnet.fantom.network"] },
      public: { http: ["https://rpc.testnet.fantom.network"] }
    },
    blockExplorers: {
      etherscan: { name: "FTMScan", url: "https://testnet.ftmscan.com" },
      default: { name: "FTMScan", url: "https://testnet.ftmscan.com" }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 8328688
      }
    }
  };
  var filecoin = {
    id: 314,
    name: "Filecoin Mainnet",
    network: "filecoin-mainnet",
    nativeCurrency: {
      decimals: 18,
      name: "filecoin",
      symbol: "FIL"
    },
    rpcUrls: {
      default: { http: ["https://api.node.glif.io/rpc/v1"] },
      public: { http: ["https://api.node.glif.io/rpc/v1"] }
    },
    blockExplorers: {
      default: { name: "Filfox", url: "https://filfox.info/en" },
      filscan: { name: "Filscan", url: "https://filscan.io" },
      filscout: { name: "Filscout", url: "https://filscout.io/en" },
      glif: { name: "Glif", url: "https://explorer.glif.io" }
    }
  };
  var filecoinCalibration = {
    id: 314159,
    name: "Filecoin Calibration",
    network: "filecoin-calibration",
    nativeCurrency: {
      decimals: 18,
      name: "testnet filecoin",
      symbol: "tFIL"
    },
    rpcUrls: {
      default: { http: ["https://api.calibration.node.glif.io/rpc/v1"] },
      public: { http: ["https://api.calibration.node.glif.io/rpc/v1"] }
    },
    blockExplorers: {
      default: { name: "Filscan", url: "https://calibration.filscan.io" }
    }
  };
  var filecoinHyperspace = {
    id: 3141,
    name: "Filecoin Hyperspace",
    network: "filecoin-hyperspace",
    nativeCurrency: {
      decimals: 18,
      name: "testnet filecoin",
      symbol: "tFIL"
    },
    rpcUrls: {
      default: { http: ["https://api.hyperspace.node.glif.io/rpc/v1"] },
      public: { http: ["https://api.hyperspace.node.glif.io/rpc/v1"] }
    },
    blockExplorers: {
      default: { name: "Filfox", url: "https://hyperspace.filfox.info/en" },
      filscan: { name: "Filscan", url: "https://hyperspace.filscan.io" }
    }
  };
  var flare = {
    id: 14,
    name: "Flare Mainnet",
    network: "flare-mainnet",
    nativeCurrency: {
      decimals: 18,
      name: "flare",
      symbol: "FLR"
    },
    rpcUrls: {
      default: { http: ["https://flare-api.flare.network/ext/C/rpc"] },
      public: { http: ["https://flare-api.flare.network/ext/C/rpc"] }
    },
    blockExplorers: {
      default: {
        name: "Flare Explorer",
        url: "https://flare-explorer.flare.network"
      }
    }
  };
  var flareTestnet = {
    id: 114,
    name: "Coston2",
    network: "coston2",
    nativeCurrency: {
      decimals: 18,
      name: "coston2flare",
      symbol: "C2FLR"
    },
    rpcUrls: {
      default: { http: ["https://coston2-api.flare.network/ext/C/rpc"] },
      public: { http: ["https://coston2-api.flare.network/ext/C/rpc"] }
    },
    blockExplorers: {
      default: {
        name: "Coston2 Explorer",
        url: "https://coston2-explorer.flare.network"
      }
    },
    testnet: true
  };
  var foundry = {
    id: 31337,
    name: "Foundry",
    network: "foundry",
    nativeCurrency: {
      decimals: 18,
      name: "Ether",
      symbol: "ETH"
    },
    rpcUrls: {
      default: {
        http: ["http://127.0.0.1:8545"],
        webSocket: ["ws://127.0.0.1:8545"]
      },
      public: {
        http: ["http://127.0.0.1:8545"],
        webSocket: ["ws://127.0.0.1:8545"]
      }
    }
  };
  var iotex = {
    id: 4689,
    name: "IoTeX",
    network: "iotex",
    nativeCurrency: {
      decimals: 18,
      name: "IoTeX",
      symbol: "IOTX"
    },
    rpcUrls: {
      default: {
        http: ["https://babel-api.mainnet.iotex.io"],
        webSocket: ["wss://babel-api.mainnet.iotex.io"]
      },
      public: {
        http: ["https://babel-api.mainnet.iotex.io"],
        webSocket: ["wss://babel-api.mainnet.iotex.io"]
      }
    },
    blockExplorers: {
      default: { name: "IoTeXScan", url: "https://iotexscan.io" }
    }
  };
  var iotexTestnet = {
    id: 4690,
    name: "IoTeX Testnet",
    network: "iotex-testnet",
    nativeCurrency: {
      decimals: 18,
      name: "IoTeX",
      symbol: "IOTX"
    },
    rpcUrls: {
      default: {
        http: ["https://babel-api.testnet.iotex.io"],
        webSocket: ["wss://babel-api.testnet.iotex.io"]
      },
      public: {
        http: ["https://babel-api.testnet.iotex.io"],
        webSocket: ["wss://babel-api.testnet.iotex.io"]
      }
    },
    blockExplorers: {
      default: { name: "IoTeXScan", url: "https://testnet.iotexscan.io" }
    }
  };
  var goerli = {
    id: 5,
    network: "goerli",
    name: "Goerli",
    nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      alchemy: {
        http: ["https://eth-goerli.g.alchemy.com/v2"],
        webSocket: ["wss://eth-goerli.g.alchemy.com/v2"]
      },
      infura: {
        http: ["https://goerli.infura.io/v3"],
        webSocket: ["wss://goerli.infura.io/ws/v3"]
      },
      default: {
        http: ["https://rpc.ankr.com/eth_goerli"]
      },
      public: {
        http: ["https://rpc.ankr.com/eth_goerli"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "Etherscan",
        url: "https://goerli.etherscan.io"
      },
      default: {
        name: "Etherscan",
        url: "https://goerli.etherscan.io"
      }
    },
    contracts: {
      ensRegistry: {
        address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
      },
      ensUniversalResolver: {
        address: "0xA292E2E58d4ddEb29C33c63173d0E8B7a2A4c62e",
        blockCreated: 8610406
      },
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 6507670
      }
    },
    testnet: true
  };
  var gnosis = {
    id: 100,
    name: "Gnosis",
    network: "gnosis",
    nativeCurrency: {
      decimals: 18,
      name: "Gnosis",
      symbol: "xDAI"
    },
    rpcUrls: {
      default: { http: ["https://rpc.gnosischain.com"] },
      public: { http: ["https://rpc.gnosischain.com"] }
    },
    blockExplorers: {
      etherscan: {
        name: "Gnosisscan",
        url: "https://gnosisscan.io/"
      },
      default: {
        name: "Gnosis Chain Explorer",
        url: "https://blockscout.com/xdai/mainnet/"
      }
    }
  };
  var gnosisChiado = {
    id: 10200,
    name: "Gnosis Chiado",
    network: "chiado",
    nativeCurrency: {
      decimals: 18,
      name: "Gnosis",
      symbol: "xDAI"
    },
    rpcUrls: {
      default: { http: ["https://rpc.chiadochain.net"] },
      public: { http: ["https://rpc.chiadochain.net"] }
    },
    blockExplorers: {
      default: {
        name: "Blockscout",
        url: "https://blockscout.chiadochain.net"
      }
    }
  };
  var hardhat = {
    id: 31337,
    name: "Hardhat",
    network: "hardhat",
    nativeCurrency: {
      decimals: 18,
      name: "Ether",
      symbol: "ETH"
    },
    rpcUrls: {
      default: { http: ["http://127.0.0.1:8545"] },
      public: { http: ["http://127.0.0.1:8545"] }
    }
  };
  var harmonyOne = {
    id: 16666e5,
    name: "Harmony One",
    network: "harmony",
    nativeCurrency: {
      name: "Harmony",
      symbol: "ONE",
      decimals: 18
    },
    rpcUrls: {
      public: { http: ["https://rpc.ankr.com/harmony"] },
      default: { http: ["https://rpc.ankr.com/harmony"] }
    },
    blockExplorers: {
      default: { name: "Harmony Explorer", url: "https://explorer.harmony.one" }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 24185753
      }
    }
  };
  var haqqMainnet = {
    id: 11235,
    name: "HAQQ Mainnet",
    network: "haqq-mainnet",
    nativeCurrency: {
      decimals: 18,
      name: "Islamic Coin",
      symbol: "ISLM"
    },
    rpcUrls: {
      default: {
        http: ["https://rpc.eth.haqq.network"]
      },
      public: {
        http: ["https://rpc.eth.haqq.network"]
      }
    },
    blockExplorers: {
      default: {
        name: "HAQQ Explorer",
        url: "https://explorer.haqq.network"
      }
    }
  };
  var haqqTestedge2 = {
    id: 54211,
    name: "HAQQ Testedge 2",
    network: "haqq-testedge-2",
    nativeCurrency: {
      decimals: 18,
      name: "Islamic Coin",
      symbol: "ISLMT"
    },
    rpcUrls: {
      default: {
        http: ["https://rpc.eth.testedge2.haqq.network"]
      },
      public: {
        http: ["https://rpc.eth.testedge2.haqq.network"]
      }
    },
    blockExplorers: {
      default: {
        name: "HAQQ Explorer",
        url: "https://explorer.testedge2.haqq.network"
      }
    }
  };
  var klaytn = {
    id: 8217,
    name: "Klaytn",
    network: "klaytn",
    nativeCurrency: {
      decimals: 18,
      name: "Klaytn",
      symbol: "KLAY"
    },
    rpcUrls: {
      default: { http: ["https://cypress.fautor.app/archive"] },
      public: { http: ["https://cypress.fautor.app/archive"] }
    },
    blockExplorers: {
      etherscan: { name: "KlaytnScope", url: "https://scope.klaytn.com" },
      default: { name: "KlaytnScope", url: "https://scope.klaytn.com" }
    }
  };
  var lineaTestnet = {
    id: 59140,
    name: "Linea Goerli Testnet",
    network: "linea-testnet",
    nativeCurrency: { name: "Linea Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      infura: {
        http: ["https://consensys-zkevm-goerli-prealpha.infura.io/v3"],
        webSocket: ["wss://consensys-zkevm-goerli-prealpha.infura.io/ws/v3"]
      },
      default: {
        http: ["https://rpc.goerli.linea.build"],
        webSocket: ["wss://rpc.goerli.linea.build"]
      },
      public: {
        http: ["https://rpc.goerli.linea.build"],
        webSocket: ["wss://rpc.goerli.linea.build"]
      }
    },
    blockExplorers: {
      default: {
        name: "BlockScout",
        url: "https://explorer.goerli.linea.build"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 498623
      }
    },
    testnet: true
  };
  var localhost = {
    id: 1337,
    name: "Localhost",
    network: "localhost",
    nativeCurrency: {
      decimals: 18,
      name: "Ether",
      symbol: "ETH"
    },
    rpcUrls: {
      default: { http: ["http://127.0.0.1:8545"] },
      public: { http: ["http://127.0.0.1:8545"] }
    }
  };
  var mainnet = {
    id: 1,
    network: "homestead",
    name: "Ethereum",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      alchemy: {
        http: ["https://eth-mainnet.g.alchemy.com/v2"],
        webSocket: ["wss://eth-mainnet.g.alchemy.com/v2"]
      },
      infura: {
        http: ["https://mainnet.infura.io/v3"],
        webSocket: ["wss://mainnet.infura.io/ws/v3"]
      },
      default: {
        http: ["https://cloudflare-eth.com"]
      },
      public: {
        http: ["https://cloudflare-eth.com"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "Etherscan",
        url: "https://etherscan.io"
      },
      default: {
        name: "Etherscan",
        url: "https://etherscan.io"
      }
    },
    contracts: {
      ensRegistry: {
        address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
      },
      ensUniversalResolver: {
        address: "0xE4Acdd618deED4e6d2f03b9bf62dc6118FC9A4da",
        blockCreated: 16773775
      },
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 14353601
      }
    }
  };
  var metis = {
    id: 1088,
    name: "Metis",
    network: "andromeda",
    nativeCurrency: {
      decimals: 18,
      name: "Metis",
      symbol: "METIS"
    },
    rpcUrls: {
      default: { http: ["https://andromeda.metis.io/?owner=1088"] },
      public: { http: ["https://andromeda.metis.io/?owner=1088"] }
    },
    blockExplorers: {
      default: {
        name: "Andromeda Explorer",
        url: "https://andromeda-explorer.metis.io"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 2338552
      }
    }
  };
  var metisGoerli = {
    id: 599,
    name: "Metis Goerli",
    network: "metis-goerli",
    nativeCurrency: {
      decimals: 18,
      name: "Metis Goerli",
      symbol: "METIS"
    },
    rpcUrls: {
      default: { http: ["https://goerli.gateway.metisdevops.link"] },
      public: { http: ["https://goerli.gateway.metisdevops.link"] }
    },
    blockExplorers: {
      default: {
        name: "Metis Goerli Explorer",
        url: "https://goerli.explorer.metisdevops.link"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 1006207
      }
    }
  };
  var moonbaseAlpha = {
    id: 1287,
    name: "Moonbase Alpha",
    network: "moonbase-alpha",
    nativeCurrency: {
      decimals: 18,
      name: "DEV",
      symbol: "DEV"
    },
    rpcUrls: {
      default: {
        http: ["https://rpc.api.moonbase.moonbeam.network"],
        webSocket: ["wss://wss.api.moonbase.moonbeam.network"]
      },
      public: {
        http: ["https://rpc.api.moonbase.moonbeam.network"],
        webSocket: ["wss://wss.api.moonbase.moonbeam.network"]
      }
    },
    blockExplorers: {
      default: {
        name: "Moonscan",
        url: "https://moonbase.moonscan.io"
      },
      etherscan: {
        name: "Moonscan",
        url: "https://moonbase.moonscan.io"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 1850686
      }
    },
    testnet: true
  };
  var moonbeam = {
    id: 1284,
    name: "Moonbeam",
    network: "moonbeam",
    nativeCurrency: {
      decimals: 18,
      name: "GLMR",
      symbol: "GLMR"
    },
    rpcUrls: {
      public: {
        http: ["https://moonbeam.public.blastapi.io"],
        webSocket: ["wss://moonbeam.public.blastapi.io"]
      },
      default: {
        http: ["https://moonbeam.public.blastapi.io"],
        webSocket: ["wss://moonbeam.public.blastapi.io"]
      }
    },
    blockExplorers: {
      default: {
        name: "Moonscan",
        url: "https://moonscan.io"
      },
      etherscan: {
        name: "Moonscan",
        url: "https://moonscan.io"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 609002
      }
    },
    testnet: false
  };
  var moonriver = {
    id: 1285,
    name: "Moonriver",
    network: "moonriver",
    nativeCurrency: {
      decimals: 18,
      name: "MOVR",
      symbol: "MOVR"
    },
    rpcUrls: {
      public: {
        http: ["https://moonriver.public.blastapi.io"],
        webSocket: ["wss://moonriver.public.blastapi.io"]
      },
      default: {
        http: ["https://moonriver.public.blastapi.io"],
        webSocket: ["wss://moonriver.public.blastapi.io"]
      }
    },
    blockExplorers: {
      default: {
        name: "Moonscan",
        url: "https://moonriver.moonscan.io"
      },
      etherscan: {
        name: "Moonscan",
        url: "https://moonriver.moonscan.io"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 1597904
      }
    },
    testnet: false
  };
  var nexi = {
    id: 4242,
    name: "Nexi",
    network: "nexi",
    nativeCurrency: { name: "Nexi", symbol: "NEXI", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc.chain.nexi.technology"]
      },
      public: {
        http: ["https://rpc.chain.nexi.technology"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "NexiScan",
        url: "https://www.nexiscan.com"
      },
      default: {
        name: "NexiScan",
        url: "https://www.nexiscan.com"
      }
    },
    contracts: {
      multicall3: {
        address: "0x0277A46Cc69A57eE3A6C8c158bA874832F718B8E",
        blockCreated: 25770160
      }
    }
  };
  var okc = {
    id: 66,
    name: "OKC",
    network: "okc",
    nativeCurrency: {
      decimals: 18,
      name: "OKT",
      symbol: "OKT"
    },
    rpcUrls: {
      default: { http: ["https://exchainrpc.okex.org"] },
      public: { http: ["https://exchainrpc.okex.org"] }
    },
    blockExplorers: {
      default: { name: "oklink", url: "https://www.oklink.com/okc" }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 10364792
      }
    }
  };
  var optimism = {
    id: 10,
    name: "Optimism",
    network: "optimism",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      alchemy: {
        http: ["https://opt-mainnet.g.alchemy.com/v2"],
        webSocket: ["wss://opt-mainnet.g.alchemy.com/v2"]
      },
      infura: {
        http: ["https://optimism-mainnet.infura.io/v3"],
        webSocket: ["wss://optimism-mainnet.infura.io/ws/v3"]
      },
      default: {
        http: ["https://mainnet.optimism.io"]
      },
      public: {
        http: ["https://mainnet.optimism.io"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "Etherscan",
        url: "https://optimistic.etherscan.io"
      },
      default: {
        name: "Optimism Explorer",
        url: "https://explorer.optimism.io"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 4286263
      }
    }
  };
  var optimismGoerli = {
    id: 420,
    name: "Optimism Goerli",
    network: "optimism-goerli",
    nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      alchemy: {
        http: ["https://opt-goerli.g.alchemy.com/v2"],
        webSocket: ["wss://opt-goerli.g.alchemy.com/v2"]
      },
      infura: {
        http: ["https://optimism-goerli.infura.io/v3"],
        webSocket: ["wss://optimism-goerli.infura.io/ws/v3"]
      },
      default: {
        http: ["https://goerli.optimism.io"]
      },
      public: {
        http: ["https://goerli.optimism.io"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "Etherscan",
        url: "https://goerli-optimism.etherscan.io"
      },
      default: {
        name: "Etherscan",
        url: "https://goerli-optimism.etherscan.io"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 49461
      }
    },
    testnet: true
  };
  var polygon = {
    id: 137,
    name: "Polygon",
    network: "matic",
    nativeCurrency: { name: "MATIC", symbol: "MATIC", decimals: 18 },
    rpcUrls: {
      alchemy: {
        http: ["https://polygon-mainnet.g.alchemy.com/v2"],
        webSocket: ["wss://polygon-mainnet.g.alchemy.com/v2"]
      },
      infura: {
        http: ["https://polygon-mainnet.infura.io/v3"],
        webSocket: ["wss://polygon-mainnet.infura.io/ws/v3"]
      },
      default: {
        http: ["https://polygon-rpc.com"]
      },
      public: {
        http: ["https://polygon-rpc.com"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "PolygonScan",
        url: "https://polygonscan.com"
      },
      default: {
        name: "PolygonScan",
        url: "https://polygonscan.com"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 25770160
      }
    }
  };
  var polygonMumbai = {
    id: 80001,
    name: "Polygon Mumbai",
    network: "maticmum",
    nativeCurrency: { name: "MATIC", symbol: "MATIC", decimals: 18 },
    rpcUrls: {
      alchemy: {
        http: ["https://polygon-mumbai.g.alchemy.com/v2"],
        webSocket: ["wss://polygon-mumbai.g.alchemy.com/v2"]
      },
      infura: {
        http: ["https://polygon-mumbai.infura.io/v3"],
        webSocket: ["wss://polygon-mumbai.infura.io/ws/v3"]
      },
      default: {
        http: ["https://matic-mumbai.chainstacklabs.com"]
      },
      public: {
        http: ["https://matic-mumbai.chainstacklabs.com"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "PolygonScan",
        url: "https://mumbai.polygonscan.com"
      },
      default: {
        name: "PolygonScan",
        url: "https://mumbai.polygonscan.com"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 25770160
      }
    },
    testnet: true
  };
  var polygonZkEvmTestnet = {
    id: 1442,
    name: "Polygon zkEVM Testnet",
    network: "polygon-zkevm-testnet",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc.public.zkevm-test.net"]
      },
      public: {
        http: ["https://rpc.public.zkevm-test.net"]
      }
    },
    blockExplorers: {
      default: {
        name: "Blockscout",
        url: "https://explorer.public.zkevm-test.net"
      }
    },
    testnet: true
  };
  var polygonZkEvm = {
    id: 1101,
    name: "Polygon zkEVM",
    network: "polygon-zkevm",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://zkevm-rpc.com"]
      },
      public: {
        http: ["https://zkevm-rpc.com"]
      }
    },
    blockExplorers: {
      default: {
        name: "PolygonScan",
        url: "https://zkevm.polygonscan.com"
      }
    }
  };
  var pulsechain = {
    id: 369,
    network: "pulsechain",
    name: "Pulsechain",
    nativeCurrency: { name: "Pulse", symbol: "PLS", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc.pulsechain.com"],
        webSocket: ["wss://ws.pulsechain.com"]
      },
      public: {
        http: ["https://rpc.pulsechain.com"],
        webSocket: ["wss://ws.pulsechain.com"]
      }
    },
    blockExplorers: {
      default: {
        name: "Etherscan",
        url: "https://scan.pulsechain.com"
      }
    },
    contracts: {
      ensRegistry: {
        address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
      },
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 14353601
      }
    }
  };
  var pulsechainV4 = {
    id: 943,
    network: "pulsechainV4",
    name: "Pulsechain V4",
    testnet: true,
    nativeCurrency: { name: "Pulse", symbol: "PLS", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc.v4.testnet.pulsechain.com"],
        webSocket: ["wss://ws.v4.testnet.pulsechain.com"]
      },
      public: {
        http: ["https://rpc.v4.testnet.pulsechain.com"],
        webSocket: ["wss://ws.v4.testnet.pulsechain.com"]
      }
    },
    blockExplorers: {
      default: {
        name: "Blockscout",
        url: "https://scan.v4.testnet.pulsechain.com"
      }
    },
    contracts: {
      ensRegistry: {
        address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
      },
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 14353601
      }
    }
  };
  var scrollTestnet = {
    id: 534353,
    name: "Scroll Testnet",
    network: "scroll-testnet",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://alpha-rpc.scroll.io/l2"],
        webSocket: ["wss://alpha-rpc.scroll.io/l2/ws"]
      },
      public: {
        http: ["https://alpha-rpc.scroll.io/l2"],
        webSocket: ["wss://alpha-rpc.scroll.io/l2/ws"]
      }
    },
    blockExplorers: {
      default: {
        name: "Blockscout",
        url: "https://blockscout.scroll.io"
      }
    },
    testnet: true
  };
  var sepolia = {
    id: 11155111,
    network: "sepolia",
    name: "Sepolia",
    nativeCurrency: { name: "Sepolia Ether", symbol: "SEP", decimals: 18 },
    rpcUrls: {
      alchemy: {
        http: ["https://eth-sepolia.g.alchemy.com/v2"],
        webSocket: ["wss://eth-sepolia.g.alchemy.com/v2"]
      },
      infura: {
        http: ["https://sepolia.infura.io/v3"],
        webSocket: ["wss://sepolia.infura.io/ws/v3"]
      },
      default: {
        http: ["https://rpc.sepolia.org"]
      },
      public: {
        http: ["https://rpc.sepolia.org"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "Etherscan",
        url: "https://sepolia.etherscan.io"
      },
      default: {
        name: "Etherscan",
        url: "https://sepolia.etherscan.io"
      }
    },
    contracts: {
      multicall3: {
        address: "0xca11bde05977b3631167028862be2a173976ca11",
        blockCreated: 6507670
      }
    },
    testnet: true
  };
  var skaleBlockBrawlers = {
    id: 391845894,
    name: "SKALE | Block Brawlers",
    network: "skale-brawl",
    nativeCurrency: { name: "BRAWL", symbol: "BRAWL", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://mainnet.skalenodes.com/v1/frayed-decent-antares"]
      },
      public: {
        http: ["https://mainnet.skalenodes.com/v1/frayed-decent-antares"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "SKALE Explorer",
        url: "https://frayed-decent-antares.explorer.mainnet.skalenodes.com"
      },
      default: {
        name: "SKALE Explorer",
        url: "https://frayed-decent-antares.explorer.mainnet.skalenodes.com"
      }
    },
    contracts: {}
  };
  var skaleCalypso = {
    id: 1564830818,
    name: "SKALE | Calypso NFT Hub",
    network: "skale-calypso",
    nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://mainnet.skalenodes.com/v1/honorable-steel-rasalhague"]
      },
      public: {
        http: ["https://mainnet.skalenodes.com/v1/honorable-steel-rasalhague"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "SKALE Explorer",
        url: "https://honorable-steel-rasalhague.explorer.mainnet.skalenodes.com"
      },
      default: {
        name: "SKALE Explorer",
        url: "https://honorable-steel-rasalhague.explorer.mainnet.skalenodes.com"
      }
    },
    contracts: {}
  };
  var skaleCalypsoTestnet = {
    id: 344106930,
    name: "SKALE | Calypso NFT Hub Testnet",
    network: "skale-calypso-testnet",
    nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
    rpcUrls: {
      default: {
        http: [
          "https://staging-v3.skalenodes.com/v1/staging-utter-unripe-menkar"
        ]
      },
      public: {
        http: [
          "https://staging-v3.skalenodes.com/v1/staging-utter-unripe-menkar"
        ]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "SKALE Explorer",
        url: "https://staging-utter-unripe-menkar.explorer.staging-v3.skalenodes.com"
      },
      default: {
        name: "SKALE Explorer",
        url: "https://staging-utter-unripe-menkar.explorer.staging-v3.skalenodes.com"
      }
    },
    contracts: {},
    testnet: true
  };
  var skaleChaosTestnet = {
    id: 1351057110,
    name: "SKALE | Chaos Testnet",
    network: "skale-chaos-testnet",
    nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
    rpcUrls: {
      default: {
        http: [
          "https://staging-v3.skalenodes.com/v1/staging-fast-active-bellatrix"
        ]
      },
      public: {
        http: [
          "https://staging-v3.skalenodes.com/v1/staging-fast-active-bellatrix"
        ]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "SKALE Explorer",
        url: "https://staging-fast-active-bellatrix.explorer.staging-v3.skalenodes.com"
      },
      default: {
        name: "SKALE Explorer",
        url: "https://staging-fast-active-bellatrix.explorer.staging-v3.skalenodes.com"
      }
    },
    contracts: {},
    testnet: true
  };
  var skaleCryptoBlades = {
    id: 1026062157,
    name: "SKALE | CryptoBlades",
    network: "skale-cryptoblades",
    nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://mainnet.skalenodes.com/v1/affectionate-immediate-pollux"]
      },
      public: {
        http: ["https://mainnet.skalenodes.com/v1/affectionate-immediate-pollux"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "SKALE Explorer",
        url: "https://affectionate-immediate-pollux.explorer.mainnet.skalenodes.com"
      },
      default: {
        name: "SKALE Explorer",
        url: "https://affectionate-immediate-pollux.explorer.mainnet.skalenodes.com"
      }
    },
    contracts: {}
  };
  var skaleCryptoColosseum = {
    id: 2046399126,
    name: "SKALE | Crypto Colosseum",
    network: "skale-crypto-coloseeum",
    nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://mainnet.skalenodes.com/v1/haunting-devoted-deneb"]
      },
      public: {
        http: ["https://mainnet.skalenodes.com/v1/haunting-devoted-deneb"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "SKALE Explorer",
        url: "https://haunting-devoted-deneb.explorer.mainnet.skalenodes.com"
      },
      default: {
        name: "SKALE Explorer",
        url: "https://haunting-devoted-deneb.explorer.mainnet.skalenodes.com"
      }
    },
    contracts: {}
  };
  var skaleEuropa = {
    id: 2046399126,
    name: "SKALE | Europa Liquidity Hub",
    network: "skale-europa",
    nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://mainnet.skalenodes.com/v1/elated-tan-skat"]
      },
      public: {
        http: ["https://mainnet.skalenodes.com/v1/elated-tan-skat"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "SKALE Explorer",
        url: "https://elated-tan-skat.explorer.mainnet.skalenodes.com"
      },
      default: {
        name: "SKALE Explorer",
        url: "https://elated-tan-skat.explorer.mainnet.skalenodes.com"
      }
    },
    contracts: {}
  };
  var skaleEuropaTestnet = {
    id: 476158412,
    name: "SKALE | Europa Liquidity Hub Testnet",
    network: "skale-europa-testnet",
    nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://staging-v3.skalenodes.com/v1/staging-legal-crazy-castor"]
      },
      public: {
        http: ["https://staging-v3.skalenodes.com/v1/staging-legal-crazy-castor"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "SKALE Explorer",
        url: "https://staging-legal-crazy-castor.explorer.staging-v3.skalenodes.com"
      },
      default: {
        name: "SKALE Explorer",
        url: "https://staging-legal-crazy-castor.explorer.staging-v3.skalenodes.com"
      }
    },
    contracts: {},
    testnet: true
  };
  var skaleExorde = {
    id: 2139927552,
    name: "SKALE | Exorde",
    network: "skale-exorde",
    nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://mainnet.skalenodes.com/v1/light-vast-diphda"]
      },
      public: {
        http: ["https://mainnet.skalenodes.com/v1/light-vast-diphda"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "SKALE Explorer",
        url: "https://light-vast-diphda.explorer.mainnet.skalenodes.com"
      },
      default: {
        name: "SKALE Explorer",
        url: "https://light-vast-diphda.explorer.mainnet.skalenodes.com"
      }
    },
    contracts: {}
  };
  var skaleHumanProtocol = {
    id: 1273227453,
    name: "SKALE | Human Protocol",
    network: "skale-human-protocol",
    nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://mainnet.skalenodes.com/v1/wan-red-ain"]
      },
      public: {
        http: ["https://mainnet.skalenodes.com/v1/wan-red-ain"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "SKALE Explorer",
        url: "https://wan-red-ain.explorer.mainnet.skalenodes.com"
      },
      default: {
        name: "SKALE Explorer",
        url: "https://wan-red-ain.explorer.mainnet.skalenodes.com"
      }
    },
    contracts: {}
  };
  var skaleNebula = {
    id: 1482601649,
    name: "SKALE | Nebula Gaming Hub",
    network: "skale-nebula",
    nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://mainnet.skalenodes.com/v1/green-giddy-denebola"]
      },
      public: {
        http: ["https://mainnet.skalenodes.com/v1/green-giddy-denebola"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "SKALE Explorer",
        url: "https://green-giddy-denebola.explorer.mainnet.skalenodes.com"
      },
      default: {
        name: "SKALE Explorer",
        url: "https://green-giddy-denebola.explorer.mainnet.skalenodes.com"
      }
    },
    contracts: {}
  };
  var skaleNebulaTestnet = {
    id: 503129905,
    name: "SKALE | Nebula Gaming Hub Testnet",
    network: "skale-nebula-testnet",
    nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://staging-v3.skalenodes.com/v1/staging-faint-slimy-achird"]
      },
      public: {
        http: ["https://staging-v3.skalenodes.com/v1/staging-faint-slimy-achird"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "SKALE Explorer",
        url: "https://staging-faint-slimy-achird.explorer.staging-v3.skalenodes.com"
      },
      default: {
        name: "SKALE Explorer",
        url: "https://staging-faint-slimy-achird.explorer.staging-v3.skalenodes.com"
      }
    },
    contracts: {},
    testnet: true
  };
  var skaleRazor = {
    id: 278611351,
    name: "SKALE | Razor Network",
    network: "skale-razor",
    nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://mainnet.skalenodes.com/v1/turbulent-unique-scheat"]
      },
      public: {
        http: ["https://mainnet.skalenodes.com/v1/turbulent-unique-scheat"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "SKALE Explorer",
        url: "https://turbulent-unique-scheat.explorer.mainnet.skalenodes.com"
      },
      default: {
        name: "SKALE Explorer",
        url: "https://turbulent-unique-scheat.explorer.mainnet.skalenodes.com"
      }
    },
    contracts: {}
  };
  var skaleTitan = {
    id: 1350216234,
    name: "SKALE | Titan Community Hub",
    network: "skale-titan",
    nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://mainnet.skalenodes.com/v1/parallel-stormy-spica"]
      },
      public: {
        http: ["https://mainnet.skalenodes.com/v1/parallel-stormy-spica"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "SKALE Explorer",
        url: "https://parallel-stormy-spica.explorer.mainnet.skalenodes.com"
      },
      default: {
        name: "SKALE Explorer",
        url: "https://parallel-stormy-spica.explorer.mainnet.skalenodes.com"
      }
    },
    contracts: {}
  };
  var skaleTitanTestnet = {
    id: 1517929550,
    name: "SKALE | Titan Community Hub Testnet",
    network: "skale-titan-testnet",
    nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
    rpcUrls: {
      default: {
        http: [
          "https://staging-v3.skalenodes.com/v1/staging-aware-chief-gianfar"
        ]
      },
      public: {
        http: [
          "https://staging-v3.skalenodes.com/v1/staging-aware-chief-gianfar"
        ]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "SKALE Explorer",
        url: "https://staging-aware-chief-gianfar.explorer.staging-v3.skalenodes.com"
      },
      default: {
        name: "SKALE Explorer",
        url: "https://staging-aware-chief-gianfar.explorer.staging-v3.skalenodes.com"
      }
    },
    contracts: {},
    testnet: true
  };
  var songbird = {
    id: 19,
    name: "Songbird Mainnet",
    network: "songbird-mainnet",
    nativeCurrency: {
      decimals: 18,
      name: "songbird",
      symbol: "SGB"
    },
    rpcUrls: {
      default: { http: ["https://songbird-api.flare.network/ext/C/rpc"] },
      public: { http: ["https://songbird-api.flare.network/ext/C/rpc"] }
    },
    blockExplorers: {
      default: {
        name: "Songbird Explorer",
        url: "https://songbird-explorer.flare.network"
      }
    }
  };
  var songbirdTestnet = {
    id: 16,
    name: "Coston",
    network: "coston",
    nativeCurrency: {
      decimals: 18,
      name: "costonflare",
      symbol: "CFLR"
    },
    rpcUrls: {
      default: { http: ["https://coston-api.flare.network/ext/C/rpc"] },
      public: { http: ["https://coston-api.flare.network/ext/C/rpc"] }
    },
    blockExplorers: {
      default: {
        name: "Coston Explorer",
        url: "https://coston-explorer.flare.network"
      }
    },
    testnet: true
  };
  var shardeumSphinx = {
    id: 8082,
    name: "Shardeum Sphinx",
    network: "shmSphinx",
    nativeCurrency: { name: "SHARDEUM", symbol: "SHM", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://sphinx.shardeum.org"]
      },
      public: {
        http: ["https://sphinx.shardeum.org"]
      }
    },
    blockExplorers: {
      default: {
        name: "Shardeum Explorer",
        url: "https://explorer-sphinx.shardeum.org"
      }
    },
    testnet: true
  };
  var syscoin = {
    id: 57,
    name: "Syscoin Mainnet",
    network: "syscoin",
    nativeCurrency: {
      decimals: 8,
      name: "Syscoin",
      symbol: "SYS"
    },
    rpcUrls: {
      default: { http: ["https://rpc.syscoin.org"] },
      public: { http: ["https://rpc.syscoin.org"] }
    },
    blockExplorers: {
      default: { name: "SyscoinExplorer", url: "https://explorer.syscoin.org" }
    },
    contracts: {
      multicall3: {
        address: "0x000562033783B1136159E10d976B519C929cdE8e",
        blockCreated: 80637
      }
    }
  };
  var taraxa = {
    id: 841,
    name: "Taraxa Mainnet",
    network: "taraxa",
    nativeCurrency: { name: "Tara", symbol: "TARA", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc.mainnet.taraxa.io"]
      },
      public: {
        http: ["https://rpc.mainnet.taraxa.io"]
      }
    },
    blockExplorers: {
      default: {
        name: "Taraxa Explorer",
        url: "https://explorer.mainnet.taraxa.io"
      }
    }
  };
  var taraxaTestnet = {
    id: 842,
    name: "Taraxa Testnet",
    network: "taraxa-testnet",
    nativeCurrency: { name: "Tara", symbol: "TARA", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc.testnet.taraxa.io"]
      },
      public: {
        http: ["https://rpc.testnet.taraxa.io"]
      }
    },
    blockExplorers: {
      default: {
        name: "Taraxa Explorer",
        url: "https://explorer.testnet.taraxa.io"
      }
    },
    testnet: true
  };
  var telos = {
    id: 40,
    name: "Telos",
    network: "telos",
    nativeCurrency: {
      decimals: 18,
      name: "Telos",
      symbol: "TLOS"
    },
    rpcUrls: {
      default: { http: ["https://mainnet.telos.net/evm"] },
      public: { http: ["https://mainnet.telos.net/evm"] }
    },
    blockExplorers: {
      default: {
        name: "Teloscan",
        url: "https://www.teloscan.io/"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 246530709
      }
    }
  };
  var telosTestnet = {
    id: 41,
    name: "Telos",
    network: "telosTestnet",
    nativeCurrency: {
      decimals: 18,
      name: "Telos",
      symbol: "TLOS"
    },
    rpcUrls: {
      default: { http: ["https://testnet.telos.net/evm"] },
      public: { http: ["https://testnet.telos.net/evm"] }
    },
    blockExplorers: {
      default: {
        name: "Teloscan (testnet)",
        url: "https://testnet.teloscan.io/"
      }
    },
    testnet: true
  };
  var thunderTestnet = {
    id: 997,
    name: "5ireChain Thunder Testnet",
    network: "5ireChain",
    nativeCurrency: { name: "5ire Token", symbol: "5IRE", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc-testnet.5ire.network"]
      },
      public: {
        http: ["https://rpc-testnet.5ire.network"]
      }
    },
    blockExplorers: {
      default: {
        name: "5ireChain Explorer",
        url: "https://explorer.5ire.network"
      }
    },
    testnet: true
  };
  var wanchain = {
    id: 888,
    name: "Wanchain",
    network: "wanchain",
    nativeCurrency: { name: "WANCHAIN", symbol: "WAN", decimals: 18 },
    rpcUrls: {
      default: {
        http: [
          "https://gwan-ssl.wandevs.org:56891",
          "https://gwan2-ssl.wandevs.org"
        ]
      },
      public: {
        http: [
          "https://gwan-ssl.wandevs.org:56891",
          "https://gwan2-ssl.wandevs.org"
        ]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "WanScan",
        url: "https://wanscan.org"
      },
      default: {
        name: "WanScan",
        url: "https://wanscan.org"
      }
    },
    contracts: {
      multicall3: {
        address: "0xcDF6A1566e78EB4594c86Fe73Fcdc82429e97fbB",
        blockCreated: 25312390
      }
    }
  };
  var wanchainTestnet = {
    id: 999,
    name: "Wanchain Testnet",
    network: "wanchainTestnet",
    nativeCurrency: { name: "WANCHAIN", symbol: "WANt", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://gwan-ssl.wandevs.org:46891"]
      },
      public: {
        http: ["https://gwan-ssl.wandevs.org:46891"]
      }
    },
    blockExplorers: {
      etherscan: {
        name: "WanScanTest",
        url: "https://wanscan.org"
      },
      default: {
        name: "WanScanTest",
        url: "https://wanscan.org"
      }
    },
    contracts: {
      multicall3: {
        address: "0x11c89bF4496c39FB80535Ffb4c92715839CC5324",
        blockCreated: 24743448
      }
    },
    testnet: true
  };
  var xdc = {
    id: 50,
    name: "XinFin Network",
    network: "xdc",
    nativeCurrency: {
      decimals: 18,
      name: "XDC",
      symbol: "XDC"
    },
    rpcUrls: {
      default: { http: ["https://rpc.xinfin.network"] },
      public: { http: ["https://rpc.xinfin.network"] }
    },
    blockExplorers: {
      xinfin: { name: "XinFin", url: "https://explorer.xinfin.network" },
      default: { name: "Blocksscan", url: "https://xdc.blocksscan.io" }
    }
  };
  var xdcTestnet = {
    id: 51,
    name: "Apothem Network",
    network: "xdc-testnet",
    nativeCurrency: {
      decimals: 18,
      name: "TXDC",
      symbol: "TXDC"
    },
    rpcUrls: {
      default: { http: ["https://erpc.apothem.network"] },
      public: { http: ["https://erpc.apothem.network"] }
    },
    blockExplorers: {
      xinfin: { name: "XinFin", url: "https://explorer.apothem.network" },
      default: { name: "Blocksscan", url: "https://apothem.blocksscan.io" }
    }
  };
  var zhejiang = {
    id: 1337803,
    network: "zhejiang",
    name: "Zhejiang",
    nativeCurrency: { name: "Zhejiang Ether", symbol: "ZhejETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://rpc.zhejiang.ethpandaops.io"]
      },
      public: {
        http: ["https://rpc.zhejiang.ethpandaops.io"]
      }
    },
    blockExplorers: {
      beaconchain: {
        name: "Etherscan",
        url: "https://zhejiang.beaconcha.in"
      },
      blockscout: {
        name: "Blockscout",
        url: "https://blockscout.com/eth/zhejiang-testnet"
      },
      default: {
        name: "Beaconchain",
        url: "https://zhejiang.beaconcha.in"
      }
    },
    testnet: true
  };
  var zkSync = {
    id: 324,
    name: "zkSync Era",
    network: "zksync-era",
    nativeCurrency: {
      decimals: 18,
      name: "Ether",
      symbol: "ETH"
    },
    rpcUrls: {
      default: {
        http: ["https://mainnet.era.zksync.io"],
        webSocket: ["wss://mainnet.era.zksync.io/ws"]
      },
      public: {
        http: ["https://mainnet.era.zksync.io"],
        webSocket: ["wss://mainnet.era.zksync.io/ws"]
      }
    },
    blockExplorers: {
      default: {
        name: "zkExplorer",
        url: "https://explorer.zksync.io"
      }
    },
    contracts: {
      multicall3: {
        address: "0xF9cda624FBC7e059355ce98a31693d299FACd963"
      }
    }
  };
  var zkSyncTestnet = {
    id: 280,
    name: "zkSync Era Testnet",
    network: "zksync-era-testnet",
    nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
    rpcUrls: {
      default: {
        http: ["https://testnet.era.zksync.dev"],
        webSocket: ["wss://testnet.era.zksync.dev/ws"]
      },
      public: {
        http: ["https://testnet.era.zksync.dev"],
        webSocket: ["wss://testnet.era.zksync.dev/ws"]
      }
    },
    blockExplorers: {
      default: {
        name: "zkExplorer",
        url: "https://goerli.explorer.zksync.io"
      }
    },
    contracts: {
      multicall3: {
        address: "0xF9cda624FBC7e059355ce98a31693d299FACd963"
      }
    },
    testnet: true
  };
  var zoraTestnet = {
    id: 999,
    name: "ZORA Goerli Testnet",
    network: "zora-testnet",
    nativeCurrency: {
      decimals: 18,
      name: "ZORA Goerli",
      symbol: "ETH"
    },
    rpcUrls: {
      default: {
        http: ["https://testnet.rpc.zora.co"],
        webSocket: ["wss://testnet.rpc.zora.co"]
      },
      public: {
        http: ["https://testnet.rpc.zora.co"],
        webSocket: ["wss://testnet.rpc.zora.co"]
      }
    },
    blockExplorers: {
      etherscan: { name: "ZORA", url: "https://testnet.explorer.zora.co" },
      default: { name: "ZORA", url: "https://testnet.explorer.zora.co" }
    },
    contracts: {
      multicall3: {
        address: "0xcA11bde05977b3631167028862bE2a173976CA11",
        blockCreated: 189123
      }
    },
    testnet: true
  };

  // node_modules/viem/dist/esm/chains.js
  init_chain2();

  // node_modules/viem/dist/esm/utils/formatters/block.js
  init_format();

  // node_modules/viem/dist/esm/utils/formatters/transaction.js
  init_fromHex();
  init_format();
  var transactionType = {
    "0x0": "legacy",
    "0x1": "eip2930",
    "0x2": "eip1559"
  };
  function formatTransaction(transaction) {
    const transaction_ = {
      ...transaction,
      blockHash: transaction.blockHash ? transaction.blockHash : null,
      blockNumber: transaction.blockNumber ? BigInt(transaction.blockNumber) : null,
      chainId: transaction.chainId ? hexToNumber(transaction.chainId) : void 0,
      gas: transaction.gas ? BigInt(transaction.gas) : void 0,
      gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : void 0,
      maxFeePerGas: transaction.maxFeePerGas ? BigInt(transaction.maxFeePerGas) : void 0,
      maxPriorityFeePerGas: transaction.maxPriorityFeePerGas ? BigInt(transaction.maxPriorityFeePerGas) : void 0,
      nonce: transaction.nonce ? hexToNumber(transaction.nonce) : void 0,
      to: transaction.to ? transaction.to : null,
      transactionIndex: transaction.transactionIndex ? Number(transaction.transactionIndex) : null,
      type: transaction.type ? transactionType[transaction.type] : void 0,
      value: transaction.value ? BigInt(transaction.value) : void 0,
      v: transaction.v ? BigInt(transaction.v) : void 0
    };
    if (transaction_.type === "legacy") {
      delete transaction_["accessList"];
      delete transaction_["maxFeePerGas"];
      delete transaction_["maxPriorityFeePerGas"];
    }
    if (transaction_.type === "eip2930") {
      delete transaction_["maxFeePerGas"];
      delete transaction_["maxPriorityFeePerGas"];
    }
    return transaction_;
  }
  var defineTransaction = defineFormatter({ format: formatTransaction });

  // node_modules/viem/dist/esm/utils/formatters/block.js
  function formatBlock(block2) {
    const transactions = block2.transactions?.map((transaction) => {
      if (typeof transaction === "string")
        return transaction;
      return formatTransaction(transaction);
    });
    return {
      ...block2,
      baseFeePerGas: block2.baseFeePerGas ? BigInt(block2.baseFeePerGas) : null,
      difficulty: block2.difficulty ? BigInt(block2.difficulty) : void 0,
      gasLimit: block2.gasLimit ? BigInt(block2.gasLimit) : void 0,
      gasUsed: block2.gasUsed ? BigInt(block2.gasUsed) : void 0,
      hash: block2.hash ? block2.hash : null,
      logsBloom: block2.logsBloom ? block2.logsBloom : null,
      nonce: block2.nonce ? block2.nonce : null,
      number: block2.number ? BigInt(block2.number) : null,
      size: block2.size ? BigInt(block2.size) : void 0,
      timestamp: block2.timestamp ? BigInt(block2.timestamp) : void 0,
      transactions,
      totalDifficulty: block2.totalDifficulty ? BigInt(block2.totalDifficulty) : null
    };
  }
  var defineBlock = defineFormatter({ format: formatBlock });

  // node_modules/viem/dist/esm/utils/formatters/transactionReceipt.js
  init_fromHex();
  init_format();

  // node_modules/viem/dist/esm/utils/formatters/log.js
  function formatLog(log, { args, eventName } = {}) {
    return {
      ...log,
      blockHash: log.blockHash ? log.blockHash : null,
      blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
      logIndex: log.logIndex ? BigInt(log.logIndex) : null,
      transactionHash: log.transactionHash ? log.transactionHash : null,
      transactionIndex: log.transactionIndex ? BigInt(log.transactionIndex) : null,
      ...eventName ? { args, eventName } : {}
    };
  }

  // node_modules/viem/dist/esm/utils/formatters/transactionReceipt.js
  var statuses = {
    "0x0": "reverted",
    "0x1": "success"
  };
  function formatTransactionReceipt(transactionReceipt) {
    return {
      ...transactionReceipt,
      blockNumber: transactionReceipt.blockNumber ? BigInt(transactionReceipt.blockNumber) : null,
      contractAddress: transactionReceipt.contractAddress ? transactionReceipt.contractAddress : null,
      cumulativeGasUsed: transactionReceipt.cumulativeGasUsed ? BigInt(transactionReceipt.cumulativeGasUsed) : null,
      effectiveGasPrice: transactionReceipt.effectiveGasPrice ? BigInt(transactionReceipt.effectiveGasPrice) : null,
      gasUsed: transactionReceipt.gasUsed ? BigInt(transactionReceipt.gasUsed) : null,
      logs: transactionReceipt.logs ? transactionReceipt.logs.map((log) => formatLog(log)) : null,
      to: transactionReceipt.to ? transactionReceipt.to : null,
      transactionIndex: transactionReceipt.transactionIndex ? hexToNumber(transactionReceipt.transactionIndex) : null,
      status: transactionReceipt.status ? statuses[transactionReceipt.status] : null,
      type: transactionReceipt.type ? transactionType[transactionReceipt.type] : null
    };
  }
  var defineTransactionReceipt = defineFormatter({
    format: formatTransactionReceipt
  });

  // node_modules/viem/dist/esm/chains.js
  init_transactionRequest();
  var celoFormatters = {
    block: defineBlock({
      exclude: ["difficulty", "gasLimit", "mixHash", "nonce", "uncles"],
      format: (block2) => ({
        randomness: block2.randomness
      })
    }),
    transaction: defineTransaction({
      format: (transaction) => ({
        feeCurrency: transaction.feeCurrency,
        gatewayFee: transaction.gatewayFee ? BigInt(transaction.gatewayFee) : null,
        gatewayFeeRecipient: transaction.gatewayFeeRecipient
      })
    }),
    transactionReceipt: defineTransactionReceipt({
      format: (transaction) => ({
        feeCurrency: transaction.feeCurrency,
        gatewayFee: transaction.gatewayFee ? BigInt(transaction.gatewayFee) : null,
        gatewayFeeRecipient: transaction.gatewayFeeRecipient
      })
    }),
    transactionRequest: defineTransactionRequest({
      format: (transactionRequest) => ({
        feeCurrency: transactionRequest.feeCurrency,
        gatewayFee: transactionRequest.gatewayFee,
        gatewayFeeRecipient: transactionRequest.gatewayFeeRecipient
      })
    })
  };
  var arbitrum2 = defineChain(arbitrum);
  var arbitrumGoerli2 = defineChain(arbitrumGoerli);
  var aurora2 = defineChain(aurora);
  var auroraTestnet2 = defineChain(auroraTestnet);
  var avalanche2 = defineChain(avalanche);
  var avalancheFuji2 = defineChain(avalancheFuji);
  var baseGoerli2 = defineChain(baseGoerli);
  var boba2 = defineChain(boba);
  var bronos2 = defineChain(bronos);
  var bronosTestnet2 = defineChain(bronosTestnet);
  var bsc2 = defineChain(bsc);
  var bscTestnet2 = defineChain(bscTestnet);
  var canto2 = defineChain(canto);
  var celo2 = defineChain({
    ...celo,
    formatters: celoFormatters
  });
  var celoAlfajores2 = defineChain({
    ...celoAlfajores,
    formatters: celoFormatters
  });
  var celoCannoli2 = defineChain({
    ...celoCannoli,
    formatters: celoFormatters
  });
  var cronos2 = defineChain(cronos);
  var crossbell2 = defineChain(crossbell);
  var dfk2 = defineChain(dfk);
  var dogechain2 = defineChain(dogechain);
  var evmos2 = defineChain(evmos);
  var evmosTestnet2 = defineChain(evmosTestnet);
  var fantom2 = defineChain(fantom);
  var fantomTestnet2 = defineChain(fantomTestnet);
  var filecoin2 = defineChain(filecoin);
  var filecoinCalibration2 = defineChain(filecoinCalibration);
  var filecoinHyperspace2 = defineChain(filecoinHyperspace);
  var flare2 = defineChain(flare);
  var flareTestnet2 = defineChain(flareTestnet);
  var foundry2 = defineChain(foundry);
  var iotex2 = defineChain(iotex);
  var iotexTestnet2 = defineChain(iotexTestnet);
  var goerli2 = defineChain(goerli);
  var gnosis2 = defineChain(gnosis);
  var gnosisChiado2 = defineChain(gnosisChiado);
  var haqqMainnet2 = defineChain(haqqMainnet);
  var haqqTestedge22 = defineChain(haqqTestedge2);
  var hardhat2 = defineChain(hardhat);
  var harmonyOne2 = defineChain(harmonyOne);
  var klaytn2 = defineChain(klaytn);
  var lineaTestnet2 = defineChain(lineaTestnet);
  var localhost2 = defineChain(localhost);
  var mainnet2 = defineChain(mainnet);
  var metis2 = defineChain(metis);
  var metisGoerli2 = defineChain(metisGoerli);
  var moonbaseAlpha2 = defineChain(moonbaseAlpha);
  var moonbeam2 = defineChain(moonbeam);
  var moonriver2 = defineChain(moonriver);
  var nexi2 = defineChain(nexi);
  var okc2 = defineChain(okc);
  var optimism2 = defineChain(optimism);
  var optimismGoerli2 = defineChain(optimismGoerli);
  var polygon2 = defineChain(polygon);
  var polygonMumbai2 = defineChain(polygonMumbai);
  var polygonZkEvm2 = defineChain(polygonZkEvm);
  var polygonZkEvmTestnet2 = defineChain(polygonZkEvmTestnet);
  var pulsechain2 = defineChain(pulsechain);
  var pulsechainV42 = defineChain(pulsechainV4);
  var scrollTestnet2 = defineChain(scrollTestnet);
  var sepolia2 = defineChain(sepolia);
  var skaleBlockBrawlers2 = defineChain(skaleBlockBrawlers);
  var skaleCalypso2 = defineChain(skaleCalypso);
  var skaleCalypsoTestnet2 = defineChain(skaleCalypsoTestnet);
  var skaleChaosTestnet2 = defineChain(skaleChaosTestnet);
  var skaleCryptoBlades2 = defineChain(skaleCryptoBlades);
  var skaleCryptoColosseum2 = defineChain(skaleCryptoColosseum);
  var skaleEuropa2 = defineChain(skaleEuropa);
  var skaleEuropaTestnet2 = defineChain(skaleEuropaTestnet);
  var skaleExorde2 = defineChain(skaleExorde);
  var skaleHumanProtocol2 = defineChain(skaleHumanProtocol);
  var skaleNebula2 = defineChain(skaleNebula);
  var skaleNebulaTestnet2 = defineChain(skaleNebulaTestnet);
  var skaleRazor2 = defineChain(skaleRazor);
  var skaleTitan2 = defineChain(skaleTitan);
  var skaleTitanTestnet2 = defineChain(skaleTitanTestnet);
  var songbird2 = defineChain(songbird);
  var songbirdTestnet2 = defineChain(songbirdTestnet);
  var shardeumSphinx2 = defineChain(shardeumSphinx);
  var syscoin2 = defineChain(syscoin);
  var taraxa2 = defineChain(taraxa);
  var taraxaTestnet2 = defineChain(taraxaTestnet);
  var telos2 = defineChain(telos);
  var telosTestnet2 = defineChain(telosTestnet);
  var thunderTestnet2 = defineChain(thunderTestnet);
  var wanchain2 = defineChain(wanchain);
  var wanchainTestnet2 = defineChain(wanchainTestnet);
  var xdc2 = defineChain(xdc);
  var xdcTestnet2 = defineChain(xdcTestnet);
  var zhejiang2 = defineChain(zhejiang);
  var zkSync2 = defineChain(zkSync);
  var zkSyncTestnet2 = defineChain(zkSyncTestnet);
  var zoraTestnet2 = defineChain(zoraTestnet);

  // node_modules/@wagmi/connectors/dist/chunk-UGBGYVBH.js
  var ChainNotConfiguredForConnectorError = class extends Error {
    constructor({
      chainId,
      connectorId
    }) {
      super(`Chain "${chainId}" not configured for connector "${connectorId}".`);
      this.name = "ChainNotConfiguredForConnectorError";
    }
  };
  var ConnectorNotFoundError = class extends Error {
    constructor() {
      super(...arguments);
      this.name = "ConnectorNotFoundError";
      this.message = "Connector not found";
    }
  };

  // node_modules/@wagmi/connectors/dist/chunk-OQILYQDO.js
  function normalizeChainId(chainId) {
    if (typeof chainId === "string")
      return Number.parseInt(
        chainId,
        chainId.trim().substring(0, 2) === "0x" ? 16 : 10
      );
    if (typeof chainId === "bigint")
      return Number(chainId);
    return chainId;
  }

  // node_modules/@wagmi/connectors/dist/chunk-W65LBPLT.js
  var import_eventemitter3 = __toESM(require_eventemitter3(), 1);
  var __accessCheck = (obj, member, msg) => {
    if (!member.has(obj))
      throw TypeError("Cannot " + msg);
  };
  var __privateGet = (obj, member, getter) => {
    __accessCheck(obj, member, "read from private field");
    return getter ? getter.call(obj) : member.get(obj);
  };
  var __privateAdd = (obj, member, value) => {
    if (member.has(obj))
      throw TypeError("Cannot add the same private member more than once");
    member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
  };
  var __privateSet = (obj, member, value, setter) => {
    __accessCheck(obj, member, "write to private field");
    setter ? setter.call(obj, value) : member.set(obj, value);
    return value;
  };
  var __privateMethod = (obj, member, method) => {
    __accessCheck(obj, member, "access private method");
    return method;
  };
  var Connector = class extends import_eventemitter3.default {
    constructor({
      chains: chains2 = [mainnet2, goerli2],
      options: options2
    }) {
      super();
      this.chains = chains2;
      this.options = options2;
    }
    getBlockExplorerUrls(chain) {
      const { default: blockExplorer, ...blockExplorers } = chain.blockExplorers ?? {};
      if (blockExplorer)
        return [
          blockExplorer.url,
          ...Object.values(blockExplorers).map((x4) => x4.url)
        ];
    }
    isChainUnsupported(chainId) {
      return !this.chains.some((x4) => x4.id === chainId);
    }
    setStorage(storage) {
      this.storage = storage;
    }
  };

  // node_modules/viem/dist/esm/utils/abi/encodeEventTopics.js
  init_abi();

  // node_modules/viem/dist/esm/errors/log.js
  init_base();
  var FilterTypeNotSupportedError = class extends BaseError {
    constructor(type) {
      super(`Filter type "${type}" is not supported.`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "FilterTypeNotSupportedError"
      });
    }
  };

  // node_modules/viem/dist/esm/utils/abi/encodeEventTopics.js
  init_toBytes();

  // node_modules/viem/dist/esm/utils/hash/getEventSelector.js
  init_hashFunction();
  var getEventSelector = (event) => hashFunction(event);

  // node_modules/viem/dist/esm/utils/abi/encodeEventTopics.js
  init_keccak256();
  init_encodeAbiParameters();
  init_formatAbiItem();
  init_getAbiItem();
  function encodeEventTopics({ abi, eventName, args }) {
    let abiItem = abi[0];
    if (eventName) {
      abiItem = getAbiItem({
        abi,
        args,
        name: eventName
      });
      if (!abiItem)
        throw new AbiEventNotFoundError(eventName, {
          docsPath: "/docs/contract/encodeEventTopics"
        });
    }
    if (abiItem.type !== "event")
      throw new AbiEventNotFoundError(void 0, {
        docsPath: "/docs/contract/encodeEventTopics"
      });
    const definition = formatAbiItem(abiItem);
    const signature2 = getEventSelector(definition);
    let topics = [];
    if (args && "inputs" in abiItem) {
      const indexedInputs = abiItem.inputs?.filter((param) => "indexed" in param && param.indexed);
      const args_ = Array.isArray(args) ? args : indexedInputs?.map((x4) => args[x4.name]) ?? [];
      topics = indexedInputs?.map((param, i7) => Array.isArray(args_[i7]) ? args_[i7].map((_8, j7) => encodeArg({ param, value: args_[i7][j7] })) : args_[i7] ? encodeArg({ param, value: args_[i7] }) : null) ?? [];
    }
    return [signature2, ...topics];
  }
  function encodeArg({ param, value }) {
    if (param.type === "string" || param.type === "bytes")
      return keccak256(toBytes(value));
    if (param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
      throw new FilterTypeNotSupportedError(param.type);
    return encodeAbiParameters([param], [value]);
  }

  // node_modules/viem/dist/esm/actions/public/createContractEventFilter.js
  init_toHex();

  // node_modules/viem/dist/esm/utils/filters/createFilterRequestScope.js
  function createFilterRequestScope(client, { method }) {
    const requestMap = {};
    if (client.transport.type === "fallback")
      client.transport.onResponse?.(({ method: method_, response: id3, status, transport }) => {
        if (status === "success" && method === method_)
          requestMap[id3] = transport.request;
      });
    return (id3) => requestMap[id3] || client.request;
  }

  // node_modules/viem/dist/esm/actions/public/createContractEventFilter.js
  async function createContractEventFilter(client, { address, abi, args, eventName, fromBlock, toBlock }) {
    const getRequest = createFilterRequestScope(client, {
      method: "eth_newFilter"
    });
    const topics = eventName ? encodeEventTopics({
      abi,
      args,
      eventName
    }) : void 0;
    const id3 = await client.request({
      method: "eth_newFilter",
      params: [
        {
          address,
          fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
          toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock,
          topics
        }
      ]
    });
    return {
      abi,
      args,
      eventName,
      id: id3,
      request: getRequest(id3),
      type: "event"
    };
  }

  // node_modules/viem/dist/esm/actions/public/estimateContractGas.js
  init_parseAccount();
  init_encodeFunctionData();
  init_getContractError();

  // node_modules/viem/dist/esm/actions/public/estimateGas.js
  init_parseAccount();

  // node_modules/viem/dist/esm/errors/account.js
  init_base();
  var AccountNotFoundError = class extends BaseError {
    constructor({ docsPath: docsPath4 } = {}) {
      super([
        "Could not find an Account to execute with this Action.",
        "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the WalletClient."
      ].join("\n"), {
        docsPath: docsPath4,
        docsSlug: "account"
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "AccountNotFoundError"
      });
    }
  };

  // node_modules/viem/dist/esm/actions/public/estimateGas.js
  init_toHex();

  // node_modules/viem/dist/esm/errors/estimateGas.js
  init_formatEther();
  init_formatGwei();
  init_base();
  init_transaction();
  var EstimateGasExecutionError = class extends BaseError {
    constructor(cause, { account, docsPath: docsPath4, chain, data: data2, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to: to3, value }) {
      const prettyArgs = prettyPrint({
        from: account?.address,
        to: to3,
        value: typeof value !== "undefined" && `${formatEther(value)} ${chain?.nativeCurrency.symbol || "ETH"}`,
        data: data2,
        gas,
        gasPrice: typeof gasPrice !== "undefined" && `${formatGwei(gasPrice)} gwei`,
        maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${formatGwei(maxFeePerGas)} gwei`,
        maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${formatGwei(maxPriorityFeePerGas)} gwei`,
        nonce
      });
      super(cause.shortMessage, {
        cause,
        docsPath: docsPath4,
        metaMessages: [
          ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
          "Estimate Gas Arguments:",
          prettyArgs
        ].filter(Boolean)
      });
      Object.defineProperty(this, "cause", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "EstimateGasExecutionError"
      });
      this.cause = cause;
    }
  };

  // node_modules/viem/dist/esm/utils/errors/getEstimateGasError.js
  init_getNodeError();
  function getEstimateGasError(err, { docsPath: docsPath4, ...args }) {
    let cause = err;
    if (containsNodeError(err))
      cause = getNodeError(err, args);
    return new EstimateGasExecutionError(cause, {
      docsPath: docsPath4,
      ...args
    });
  }

  // node_modules/viem/dist/esm/actions/public/estimateGas.js
  init_extract();
  init_format();
  init_transactionRequest();
  init_assertRequest();

  // node_modules/viem/dist/esm/utils/transaction/prepareRequest.js
  init_parseAccount();

  // node_modules/viem/dist/esm/errors/block.js
  init_base();
  var BlockNotFoundError = class extends BaseError {
    constructor({ blockHash, blockNumber }) {
      let identifier = "Block";
      if (blockHash)
        identifier = `Block at hash "${blockHash}"`;
      if (blockNumber)
        identifier = `Block at number "${blockNumber}"`;
      super(`${identifier} could not be found.`);
      Object.defineProperty(this, "name", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "BlockNotFoundError"
      });
    }
  };

  // node_modules/viem/dist/esm/actions/public/getBlock.js
  init_toHex();
  init_format();
  async function getBlock(client, { blockHash, blockNumber, blockTag = "latest", includeTransactions = false } = {}) {
    const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
    let block2 = null;
    if (blockHash) {
      block2 = await client.request({
        method: "eth_getBlockByHash",
        params: [blockHash, includeTransactions]
      });
    } else {
      block2 = await client.request({
        method: "eth_getBlockByNumber",
        params: [blockNumberHex || blockTag, includeTransactions]
      });
    }
    if (!block2)
      throw new BlockNotFoundError({ blockHash, blockNumber });
    return format(block2, {
      formatter: client.chain?.formatters?.block || formatBlock
    });
  }

  // node_modules/viem/dist/esm/actions/public/getGasPrice.js
  async function getGasPrice(client) {
    const gasPrice = await client.request({
      method: "eth_gasPrice"
    });
    return BigInt(gasPrice);
  }

  // node_modules/viem/dist/esm/actions/public/getTransactionCount.js
  init_fromHex();
  init_toHex();
  async function getTransactionCount(client, { address, blockTag = "latest", blockNumber }) {
    const count = await client.request({
      method: "eth_getTransactionCount",
      params: [address, blockNumber ? numberToHex(blockNumber) : blockTag]
    });
    return hexToNumber(count);
  }

  // node_modules/viem/dist/esm/utils/transaction/prepareRequest.js
  init_base();
  init_assertRequest();
  var defaultTip = 1500000000n;
  async function prepareRequest(client, args) {
    const { account: account_, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce } = args;
    if (!account_)
      throw new AccountNotFoundError();
    const account = parseAccount(account_);
    const block2 = await getBlock(client, { blockTag: "latest" });
    const request = { ...args, from: account.address };
    if (typeof nonce === "undefined")
      request.nonce = await getTransactionCount(client, {
        address: account.address,
        blockTag: "pending"
      });
    if (block2.baseFeePerGas) {
      if (typeof gasPrice !== "undefined")
        throw new BaseError("Chain does not support legacy `gasPrice`.");
      if (typeof maxFeePerGas === "undefined") {
        request.maxPriorityFeePerGas = maxPriorityFeePerGas ?? defaultTip;
        request.maxFeePerGas = block2.baseFeePerGas * 120n / 100n + request.maxPriorityFeePerGas;
      } else {
        if (typeof maxPriorityFeePerGas === "undefined" && maxFeePerGas < defaultTip)
          throw new BaseError("`maxFeePerGas` cannot be less than the default `maxPriorityFeePerGas` (1.5 gwei).");
        request.maxFeePerGas = maxFeePerGas;
        request.maxPriorityFeePerGas = maxPriorityFeePerGas ?? defaultTip;
      }
    } else {
      if (typeof maxFeePerGas !== "undefined" || typeof maxPriorityFeePerGas !== "undefined")
        throw new BaseError("Chain does not support EIP-1559 fees.");
      if (typeof gasPrice === "undefined")
        request.gasPrice = await getGasPrice(client) * 120n / 100n;
    }
    if (typeof gas === "undefined")
      request.gas = await estimateGas(client, {
        ...request,
        account: { address: account.address, type: "json-rpc" }
      });
    assertRequest(request);
    return request;
  }

  // node_modules/viem/dist/esm/actions/public/estimateGas.js
  async function estimateGas(client, args) {
    const account_ = args.account ?? client.account;
    if (!account_)
      throw new AccountNotFoundError({
        docsPath: "/docs/actions/public/estimateGas"
      });
    const account = parseAccount(account_);
    try {
      const { accessList, blockNumber, blockTag, data: data2, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to: to3, value, ...rest } = account.type === "local" ? await prepareRequest(client, args) : args;
      const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;
      const block2 = blockNumberHex || blockTag;
      assertRequest(args);
      const formatter = client.chain?.formatters?.transactionRequest;
      const request = format({
        from: account.address,
        accessList,
        data: data2,
        gas,
        gasPrice,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        to: to3,
        value,
        ...extract(rest, { formatter })
      }, {
        formatter: formatter || formatTransactionRequest
      });
      const balance = await client.request({
        method: "eth_estimateGas",
        params: block2 ? [request, block2] : [request]
      });
      return BigInt(balance);
    } catch (err) {
      throw getEstimateGasError(err, {
        ...args,
        account,
        chain: client.chain
      });
    }
  }

  // node_modules/viem/dist/esm/actions/public/estimateContractGas.js
  async function estimateContractGas(client, { abi, address, args, functionName, ...request }) {
    const data2 = encodeFunctionData({
      abi,
      args,
      functionName
    });
    try {
      const gas = await estimateGas(client, {
        data: data2,
        to: address,
        ...request
      });
      return gas;
    } catch (err) {
      const account = request.account ? parseAccount(request.account) : void 0;
      throw getContractError(err, {
        abi,
        address,
        args,
        docsPath: "/docs/contract/simulateContract",
        functionName,
        sender: account?.address
      });
    }
  }

  // node_modules/viem/dist/esm/actions/getContract.js
  init_readContract();

  // node_modules/viem/dist/esm/actions/public/simulateContract.js
  init_parseAccount();
  init_decodeFunctionResult();
  init_encodeFunctionData();
  init_getContractError();
  init_call();
  async function simulateContract(client, { abi, address, args, dataSuffix, functionName, ...callRequest }) {
    const account = callRequest.account ? parseAccount(callRequest.account) : void 0;
    const calldata = encodeFunctionData({
      abi,
      args,
      functionName
    });
    try {
      const { data: data2 } = await call(client, {
        batch: false,
        data: `${calldata}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
        to: address,
        ...callRequest
      });
      const result = decodeFunctionResult({
        abi,
        args,
        functionName,
        data: data2 || "0x"
      });
      return {
        result,
        request: {
          abi,
          address,
          args,
          functionName,
          ...callRequest
        }
      };
    } catch (err) {
      throw getContractError(err, {
        abi,
        address,
        args,
        docsPath: "/docs/contract/simulateContract",
        functionName,
        sender: account?.address
      });
    }
  }

  // node_modules/viem/dist/esm/actions/public/watchContractEvent.js
  init_getAbiItem();

  // node_modules/viem/dist/esm/utils/observe.js
  var listenersCache = /* @__PURE__ */ new Map();
  var cleanupCache = /* @__PURE__ */ new Map();
  var callbackCount = 0;
  function observe(observerId, callbacks, fn2) {
    const callbackId = ++callbackCount;
    const getListeners = () => listenersCache.get(observerId) || [];
    const unsubscribe = () => {
      const listeners2 = getListeners();
      listenersCache.set(observerId, listeners2.filter((cb) => cb.id !== callbackId));
    };
    const unwatch = () => {
      const cleanup2 = cleanupCache.get(observerId);
      if (getListeners().length === 1 && cleanup2)
        cleanup2();
      unsubscribe();
    };
    const listeners = getListeners();
    listenersCache.set(observerId, [
      ...listeners,
      { id: callbackId, fns: callbacks }
    ]);
    if (listeners && listeners.length > 0)
      return unwatch;
    const emit = {};
    for (const key2 in callbacks) {
      emit[key2] = (...args) => {
        const listeners2 = getListeners();
        if (listeners2.length === 0)
          return;
        listeners2.forEach((listener) => listener.fns[key2]?.(...args));
      };
    }
    const cleanup = fn2(emit);
    if (typeof cleanup === "function")
      cleanupCache.set(observerId, cleanup);
    return unwatch;
  }

  // node_modules/viem/dist/esm/utils/wait.js
  async function wait(time2) {
    return new Promise((res) => setTimeout(res, time2));
  }

  // node_modules/viem/dist/esm/utils/poll.js
  function poll(fn2, { emitOnBegin, initialWaitTime, interval }) {
    let active = true;
    const unwatch = () => active = false;
    const watch2 = async () => {
      let data2;
      if (emitOnBegin)
        data2 = await fn2({ unpoll: unwatch });
      const initialWait = await initialWaitTime?.(data2) ?? interval;
      await wait(initialWait);
      const poll3 = async () => {
        if (!active)
          return;
        await fn2({ unpoll: unwatch });
        await wait(interval);
        poll3();
      };
      poll3();
    };
    watch2();
    return unwatch;
  }

  // node_modules/viem/dist/esm/actions/public/watchContractEvent.js
  init_stringify();

  // node_modules/viem/dist/esm/utils/promise/withCache.js
  var promiseCache = /* @__PURE__ */ new Map();
  var responseCache = /* @__PURE__ */ new Map();
  function getCache(cacheKey2) {
    const buildCache = (cacheKey3, cache) => ({
      clear: () => cache.delete(cacheKey3),
      get: () => cache.get(cacheKey3),
      set: (data2) => cache.set(cacheKey3, data2)
    });
    const promise = buildCache(cacheKey2, promiseCache);
    const response = buildCache(cacheKey2, responseCache);
    return {
      clear: () => {
        promise.clear();
        response.clear();
      },
      promise,
      response
    };
  }
  async function withCache(fn2, { cacheKey: cacheKey2, maxAge = Infinity }) {
    const cache = getCache(cacheKey2);
    const response = cache.response.get();
    if (response && maxAge > 0) {
      const age = (/* @__PURE__ */ new Date()).getTime() - response.created.getTime();
      if (age < maxAge)
        return response.data;
    }
    let promise = cache.promise.get();
    if (!promise) {
      promise = fn2();
      cache.promise.set(promise);
    }
    try {
      const data2 = await promise;
      cache.response.set({ created: /* @__PURE__ */ new Date(), data: data2 });
      return data2;
    } finally {
      cache.promise.clear();
    }
  }

  // node_modules/viem/dist/esm/actions/public/getBlockNumber.js
  var cacheKey = (id3) => `blockNumber.${id3}`;
  async function getBlockNumber(client, { maxAge = client.pollingInterval } = {}) {
    const blockNumberHex = await withCache(() => client.request({
      method: "eth_blockNumber"
    }), { cacheKey: cacheKey(client.uid), maxAge });
    return BigInt(blockNumberHex);
  }

  // node_modules/viem/dist/esm/utils/abi/decodeEventLog.js
  init_abi();
  init_decodeAbiParameters();
  init_formatAbiItem();
  var docsPath2 = "/docs/contract/decodeEventLog";
  function decodeEventLog({ abi, data: data2, topics }) {
    const [signature2, ...argTopics] = topics;
    if (!signature2)
      throw new AbiEventSignatureEmptyTopicsError({
        docsPath: docsPath2
      });
    const abiItem = abi.find((x4) => x4.type === "event" && signature2 === getEventSelector(formatAbiItem(x4)));
    if (!(abiItem && "name" in abiItem))
      throw new AbiEventSignatureNotFoundError(signature2, {
        docsPath: docsPath2
      });
    const { name: name2, inputs } = abiItem;
    const isUnnamed = inputs?.some((x4) => !("name" in x4 && x4.name));
    let args = isUnnamed ? [] : {};
    const indexedInputs = inputs.filter((x4) => "indexed" in x4 && x4.indexed);
    if (argTopics.length > 0) {
      for (let i7 = 0; i7 < indexedInputs.length; i7++) {
        const param = indexedInputs[i7];
        const topic = argTopics[i7];
        if (!topic)
          throw new DecodeLogTopicsMismatch({
            abiItem,
            param
          });
        args[param.name || i7] = decodeTopic({ param, value: topic });
      }
    }
    const nonIndexedInputs = inputs.filter((x4) => !("indexed" in x4 && x4.indexed));
    if (data2 && data2 !== "0x") {
      try {
        const decodedData = decodeAbiParameters(nonIndexedInputs, data2);
        if (decodedData) {
          if (isUnnamed)
            args = [...args, ...decodedData];
          else {
            for (let i7 = 0; i7 < nonIndexedInputs.length; i7++) {
              args[nonIndexedInputs[i7].name] = decodedData[i7];
            }
          }
        }
      } catch (err) {
        if (err instanceof AbiDecodingDataSizeTooSmallError)
          throw new DecodeLogDataMismatch({
            data: err.data,
            params: err.params,
            size: err.size
          });
        throw err;
      }
    }
    return {
      eventName: name2,
      args: Object.values(args).length > 0 ? args : void 0
    };
  }
  function decodeTopic({ param, value }) {
    if (param.type === "string" || param.type === "bytes" || param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
      return value;
    const decodedArg = decodeAbiParameters([param], value) || [];
    return decodedArg[0];
  }

  // node_modules/viem/dist/esm/actions/public/getFilterChanges.js
  async function getFilterChanges(_client, { filter: filter2 }) {
    const logs = await filter2.request({
      method: "eth_getFilterChanges",
      params: [filter2.id]
    });
    return logs.map((log) => {
      if (typeof log === "string")
        return log;
      try {
        const { eventName, args } = "abi" in filter2 && filter2.abi ? decodeEventLog({
          abi: filter2.abi,
          data: log.data,
          topics: log.topics
        }) : { eventName: void 0, args: void 0 };
        return formatLog(log, { args, eventName });
      } catch {
        return;
      }
    }).filter(Boolean);
  }

  // node_modules/viem/dist/esm/actions/public/getLogs.js
  init_toHex();
  async function getLogs(client, { address, blockHash, fromBlock, toBlock, event, args } = {}) {
    let topics = [];
    if (event)
      topics = encodeEventTopics({
        abi: [event],
        eventName: event.name,
        args
      });
    let logs;
    if (blockHash) {
      logs = await client.request({
        method: "eth_getLogs",
        params: [{ address, topics, blockHash }]
      });
    } else {
      logs = await client.request({
        method: "eth_getLogs",
        params: [
          {
            address,
            topics,
            fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
            toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock
          }
        ]
      });
    }
    return logs.map((log) => {
      try {
        const { eventName, args: args2 } = event ? decodeEventLog({
          abi: [event],
          data: log.data,
          topics: log.topics
        }) : { eventName: void 0, args: void 0 };
        return formatLog(log, { args: args2, eventName });
      } catch {
        return;
      }
    }).filter(Boolean);
  }

  // node_modules/viem/dist/esm/actions/public/uninstallFilter.js
  async function uninstallFilter(_client, { filter: filter2 }) {
    return filter2.request({
      method: "eth_uninstallFilter",
      params: [filter2.id]
    });
  }

  // node_modules/viem/dist/esm/actions/public/watchContractEvent.js
  function watchContractEvent(client, { abi, address, args, batch = true, eventName, onError: onError2, onLogs, pollingInterval = client.pollingInterval }) {
    const observerId = stringify([
      "watchContractEvent",
      address,
      args,
      batch,
      client.uid,
      eventName,
      pollingInterval
    ]);
    return observe(observerId, { onLogs, onError: onError2 }, (emit) => {
      let previousBlockNumber;
      let filter2;
      let initialized = false;
      const unwatch = poll(async () => {
        if (!initialized) {
          try {
            filter2 = await createContractEventFilter(client, {
              abi,
              address,
              args,
              eventName
            });
          } catch {
          }
          initialized = true;
          return;
        }
        try {
          let logs;
          if (filter2) {
            logs = await getFilterChanges(client, { filter: filter2 });
          } else {
            const blockNumber = await getBlockNumber(client);
            if (previousBlockNumber && previousBlockNumber !== blockNumber) {
              logs = await getLogs(client, {
                address,
                args,
                fromBlock: previousBlockNumber + 1n,
                toBlock: blockNumber,
                event: getAbiItem({
                  abi,
                  name: eventName
                })
              });
            } else {
              logs = [];
            }
            previousBlockNumber = blockNumber;
          }
          if (logs.length === 0)
            return;
          if (batch)
            emit.onLogs(logs);
          else
            logs.forEach((log) => emit.onLogs([log]));
        } catch (err) {
          emit.onError?.(err);
        }
      }, {
        emitOnBegin: true,
        interval: pollingInterval
      });
      return async () => {
        if (filter2)
          await uninstallFilter(client, { filter: filter2 });
        unwatch();
      };
    });
  }

  // node_modules/viem/dist/esm/actions/wallet/writeContract.js
  init_encodeFunctionData();

  // node_modules/viem/dist/esm/actions/wallet/sendTransaction.js
  init_parseAccount();
  init_chain2();

  // node_modules/viem/dist/esm/utils/errors/getTransactionError.js
  init_transaction();
  init_getNodeError();
  function getTransactionError(err, { docsPath: docsPath4, ...args }) {
    let cause = err;
    if (containsNodeError(err))
      cause = getNodeError(err, args);
    return new TransactionExecutionError(cause, {
      docsPath: docsPath4,
      ...args
    });
  }

  // node_modules/viem/dist/esm/actions/wallet/sendTransaction.js
  init_extract();
  init_format();
  init_transactionRequest();
  init_assertRequest();

  // node_modules/viem/dist/esm/actions/public/getChainId.js
  init_fromHex();
  async function getChainId(client) {
    const chainIdHex = await client.request({ method: "eth_chainId" });
    return hexToNumber(chainIdHex);
  }

  // node_modules/viem/dist/esm/actions/wallet/sendTransaction.js
  async function sendTransaction(client, args) {
    const { account: account_ = client.account, chain = client.chain, accessList, data: data2, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to: to3, value, ...rest } = args;
    if (!account_)
      throw new AccountNotFoundError({
        docsPath: "/docs/actions/wallet/sendTransaction"
      });
    const account = parseAccount(account_);
    try {
      assertRequest(args);
      let chainId;
      if (chain !== null) {
        chainId = await getChainId(client);
        assertCurrentChain({
          currentChainId: chainId,
          chain
        });
      }
      if (account.type === "local") {
        const request2 = await prepareRequest(client, {
          account,
          accessList,
          chain,
          data: data2,
          gas,
          gasPrice,
          maxFeePerGas,
          maxPriorityFeePerGas,
          nonce,
          to: to3,
          value,
          ...rest
        });
        if (!chainId)
          chainId = await getChainId(client);
        const signedRequest = await account.signTransaction({
          chainId,
          ...request2
        });
        return await client.request({
          method: "eth_sendRawTransaction",
          params: [signedRequest]
        });
      }
      const formatter = chain?.formatters?.transactionRequest;
      const request = format({
        accessList,
        data: data2,
        from: account.address,
        gas,
        gasPrice,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        to: to3,
        value,
        ...extract(rest, { formatter })
      }, {
        formatter: formatter || formatTransactionRequest
      });
      return await client.request({
        method: "eth_sendTransaction",
        params: [request]
      });
    } catch (err) {
      throw getTransactionError(err, {
        ...args,
        account,
        chain: args.chain || void 0
      });
    }
  }

  // node_modules/viem/dist/esm/actions/wallet/writeContract.js
  async function writeContract(client, { abi, address, args, dataSuffix, functionName, ...request }) {
    const data2 = encodeFunctionData({
      abi,
      args,
      functionName
    });
    const hash5 = await sendTransaction(client, {
      data: `${data2}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
      to: address,
      ...request
    });
    return hash5;
  }

  // node_modules/viem/dist/esm/index.js
  init_call();

  // node_modules/viem/dist/esm/actions/public/createEventFilter.js
  init_toHex();
  async function createEventFilter(client, { address, args, event, fromBlock, toBlock } = {}) {
    const getRequest = createFilterRequestScope(client, {
      method: "eth_newFilter"
    });
    let topics = [];
    if (event)
      topics = encodeEventTopics({
        abi: [event],
        eventName: event.name,
        args
      });
    const id3 = await client.request({
      method: "eth_newFilter",
      params: [
        {
          address,
          fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
          toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock,
          ...topics.length ? { topics } : {}
        }
      ]
    });
    return {
      abi: event ? [event] : void 0,
      args,
      eventName: event ? event.name : void 0,
      id: id3,
      request: getRequest(id3),
      type: "event"
    };
  }

  // node_modules/viem/dist/esm/utils/abi/encodeDeployData.js
  init_abi();
  init_concat();
  init_encodeAbiParameters();
  var docsPath3 = "/docs/contract/encodeDeployData";
  function encodeDeployData({ abi, args, bytecode }) {
    if (!args || args.length === 0)
      return bytecode;
    const description = abi.find((x4) => "type" in x4 && x4.type === "constructor");
    if (!description)
      throw new AbiConstructorNotFoundError({ docsPath: docsPath3 });
    if (!("inputs" in description))
      throw new AbiConstructorParamsNotFoundError({ docsPath: docsPath3 });
    if (!description.inputs || description.inputs.length === 0)
      throw new AbiConstructorParamsNotFoundError({ docsPath: docsPath3 });
    const data2 = encodeAbiParameters(description.inputs, args);
    return concatHex([bytecode, data2]);
  }

  // node_modules/viem/dist/esm/actions/wallet/deployContract.js
  function deployContract(walletClient, { abi, args, bytecode, ...request }) {
    const calldata = encodeDeployData({
      abi,
      args,
      bytecode
    });
    return sendTransaction(walletClient, {
      ...request,
      data: calldata
    });
  }

  // node_modules/viem/dist/esm/actions/public/getBalance.js
  init_toHex();
  async function getBalance(client, { address, blockNumber, blockTag = "latest" }) {
    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;
    const balance = await client.request({
      method: "eth_getBalance",
      params: [address, blockNumberHex || blockTag]
    });
    return BigInt(balance);
  }

  // node_modules/viem/dist/esm/actions/public/getBlockTransactionCount.js
  init_fromHex();
  init_toHex();
  async function getBlockTransactionCount(client, { blockHash, blockNumber, blockTag = "latest" } = {}) {
    const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
    let count = null;
    if (blockHash) {
      count = await client.request({
        method: "eth_getBlockTransactionCountByHash",
        params: [blockHash]
      });
    } else {
      count = await client.request({
        method: "eth_getBlockTransactionCountByNumber",
        params: [blockNumberHex || blockTag]
      });
    }
    return hexToNumber(count);
  }

  // node_modules/viem/dist/esm/actions/public/getBytecode.js
  init_toHex();
  async function getBytecode(client, { address, blockNumber, blockTag = "latest" }) {
    const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
    const hex = await client.request({
      method: "eth_getCode",
      params: [address, blockNumberHex || blockTag]
    });
    if (hex === "0x")
      return void 0;
    return hex;
  }

  // node_modules/viem/dist/esm/index.js
  init_getEnsAddress();
  init_getEnsName();
  init_getEnsResolver();

  // node_modules/viem/dist/esm/actions/public/getFeeHistory.js
  init_toHex();

  // node_modules/viem/dist/esm/utils/formatters/feeHistory.js
  function formatFeeHistory(feeHistory) {
    return {
      baseFeePerGas: feeHistory.baseFeePerGas.map((value) => BigInt(value)),
      gasUsedRatio: feeHistory.gasUsedRatio,
      oldestBlock: BigInt(feeHistory.oldestBlock),
      reward: feeHistory.reward?.map((reward) => reward.map((value) => BigInt(value)))
    };
  }

  // node_modules/viem/dist/esm/actions/public/getFeeHistory.js
  async function getFeeHistory(client, { blockCount, blockNumber, blockTag = "latest", rewardPercentiles }) {
    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;
    const feeHistory = await client.request({
      method: "eth_feeHistory",
      params: [
        numberToHex(blockCount),
        blockNumberHex || blockTag,
        rewardPercentiles
      ]
    });
    return formatFeeHistory(feeHistory);
  }

  // node_modules/viem/dist/esm/actions/public/getFilterLogs.js
  async function getFilterLogs(_client, { filter: filter2 }) {
    const logs = await filter2.request({
      method: "eth_getFilterLogs",
      params: [filter2.id]
    });
    return logs.map((log) => {
      try {
        const { eventName, args } = "abi" in filter2 && filter2.abi ? decodeEventLog({
          abi: filter2.abi,
          data: log.data,
          topics: log.topics
        }) : { eventName: void 0, args: void 0 };
        return formatLog(log, { args, eventName });
      } catch {
        return;
      }
    }).filter(Boolean);
  }

  // node_modules/viem/dist/esm/actions/public/getStorageAt.js
  init_toHex();
  async function getStorageAt(client, { address, blockNumber, blockTag = "latest", slot }) {
    const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
    const data2 = await client.request({
      method: "eth_getStorageAt",
      params: [address, slot, blockNumberHex || blockTag]
    });
    return data2;
  }

  // node_modules/viem/dist/esm/actions/public/getTransaction.js
  init_transaction();
  init_toHex();
  init_format();
  async function getTransaction(client, { blockHash, blockNumber, blockTag = "latest", hash: hash5, index: index2 }) {
    const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
    let transaction = null;
    if (hash5) {
      transaction = await client.request({
        method: "eth_getTransactionByHash",
        params: [hash5]
      });
    } else if (blockHash) {
      transaction = await client.request({
        method: "eth_getTransactionByBlockHashAndIndex",
        params: [blockHash, numberToHex(index2)]
      });
    } else if (blockNumberHex || blockTag) {
      transaction = await client.request({
        method: "eth_getTransactionByBlockNumberAndIndex",
        params: [blockNumberHex || blockTag, numberToHex(index2)]
      });
    }
    if (!transaction)
      throw new TransactionNotFoundError({
        blockHash,
        blockNumber,
        blockTag,
        hash: hash5,
        index: index2
      });
    return format(transaction, {
      formatter: client.chain?.formatters?.transaction || formatTransaction
    });
  }

  // node_modules/viem/dist/esm/actions/public/getTransactionConfirmations.js
  async function getTransactionConfirmations(client, { hash: hash5, transactionReceipt }) {
    const [blockNumber, transaction] = await Promise.all([
      getBlockNumber(client),
      hash5 ? getTransaction(client, { hash: hash5 }) : void 0
    ]);
    const transactionBlockNumber = transactionReceipt?.blockNumber || transaction?.blockNumber;
    if (!transactionBlockNumber)
      return 0n;
    return blockNumber - transactionBlockNumber + 1n;
  }

  // node_modules/viem/dist/esm/actions/public/getTransactionReceipt.js
  init_transaction();
  init_format();
  async function getTransactionReceipt(client, { hash: hash5 }) {
    const receipt = await client.request({
      method: "eth_getTransactionReceipt",
      params: [hash5]
    });
    if (!receipt)
      throw new TransactionReceiptNotFoundError({ hash: hash5 });
    return format(receipt, {
      formatter: client.chain?.formatters?.transactionReceipt || formatTransactionReceipt
    });
  }

  // node_modules/viem/dist/esm/actions/public/multicall.js
  init_abis();
  init_abi();
  init_contract();
  init_decodeFunctionResult();
  init_encodeFunctionData();
  init_chain2();
  init_getContractError();
  init_readContract();
  async function multicall(client, args) {
    const { allowFailure = true, batchSize: batchSize_, blockNumber, blockTag, contracts: contracts_, multicallAddress: multicallAddress_ } = args;
    const batchSize = batchSize_ ?? (typeof client.batch?.multicall === "object" && client.batch.multicall.batchSize || 1024);
    const contracts = contracts_;
    let multicallAddress = multicallAddress_;
    if (!multicallAddress) {
      if (!client.chain)
        throw new Error("client chain not configured. multicallAddress is required.");
      multicallAddress = getChainContractAddress({
        blockNumber,
        chain: client.chain,
        contract: "multicall3"
      });
    }
    const chunkedCalls = [[]];
    let currentChunk = 0;
    let currentChunkSize = 0;
    for (let i7 = 0; i7 < contracts.length; i7++) {
      const { abi, address, args: args2, functionName } = contracts[i7];
      try {
        const callData = encodeFunctionData({
          abi,
          args: args2,
          functionName
        });
        currentChunkSize += callData.length;
        if (batchSize > 0 && currentChunkSize > batchSize) {
          currentChunk++;
          currentChunkSize = (callData.length - 2) / 2;
          chunkedCalls[currentChunk] = [];
        }
        chunkedCalls[currentChunk] = [
          ...chunkedCalls[currentChunk],
          {
            allowFailure: true,
            callData,
            target: address
          }
        ];
      } catch (err) {
        const error = getContractError(err, {
          abi,
          address,
          args: args2,
          docsPath: "/docs/contract/multicall",
          functionName
        });
        if (!allowFailure)
          throw error;
        chunkedCalls[currentChunk] = [
          ...chunkedCalls[currentChunk],
          {
            allowFailure: true,
            callData: "0x",
            target: address
          }
        ];
      }
    }
    const results2 = await Promise.all(chunkedCalls.map((calls) => readContract(client, {
      abi: multicall3Abi,
      address: multicallAddress,
      args: [calls],
      blockNumber,
      blockTag,
      functionName: "aggregate3"
    })));
    return results2.flat().map(({ returnData, success }, i7) => {
      const calls = chunkedCalls.flat();
      const { callData } = calls[i7];
      const { abi, address, functionName, args: args2 } = contracts[i7];
      try {
        if (callData === "0x")
          throw new AbiDecodingZeroDataError();
        if (!success)
          throw new RawContractError({ data: returnData });
        const result = decodeFunctionResult({
          abi,
          data: returnData,
          functionName
        });
        return allowFailure ? { result, status: "success" } : result;
      } catch (err) {
        const error = getContractError(err, {
          abi,
          address,
          args: args2,
          docsPath: "/docs/contract/multicall",
          functionName
        });
        if (!allowFailure)
          throw error;
        return { error, result: void 0, status: "failure" };
      }
    });
  }

  // node_modules/viem/dist/esm/actions/public/watchBlocks.js
  init_stringify();
  function watchBlocks(client, { blockTag = "latest", emitMissed = false, emitOnBegin = false, onBlock, onError: onError2, includeTransactions = false, poll: poll_, pollingInterval = client.pollingInterval }) {
    const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
    let prevBlock;
    const pollBlocks = () => {
      const observerId = stringify([
        "watchBlocks",
        client.uid,
        emitMissed,
        emitOnBegin,
        includeTransactions,
        pollingInterval
      ]);
      return observe(observerId, { onBlock, onError: onError2 }, (emit) => poll(async () => {
        try {
          const block2 = await getBlock(client, {
            blockTag,
            includeTransactions
          });
          if (block2.number && prevBlock?.number) {
            if (block2.number === prevBlock.number)
              return;
            if (block2.number - prevBlock.number > 1 && emitMissed) {
              for (let i7 = prevBlock?.number + 1n; i7 < block2.number; i7++) {
                const block3 = await getBlock(client, {
                  blockNumber: i7,
                  includeTransactions
                });
                emit.onBlock(block3, prevBlock);
                prevBlock = block3;
              }
            }
          }
          if (!prevBlock?.number || blockTag === "pending" && !block2?.number || block2.number && block2.number > prevBlock.number) {
            emit.onBlock(block2, prevBlock);
            prevBlock = block2;
          }
        } catch (err) {
          emit.onError?.(err);
        }
      }, {
        emitOnBegin,
        interval: pollingInterval
      }));
    };
    const subscribeBlocks = () => {
      let active = true;
      let unsubscribe = () => active = false;
      (async () => {
        try {
          const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
            params: ["newHeads"],
            onData(data2) {
              if (!active)
                return;
              const block2 = data2.result;
              onBlock(block2, prevBlock);
              prevBlock = block2;
            },
            onError(error) {
              onError2?.(error);
            }
          });
          unsubscribe = unsubscribe_;
          if (!active)
            unsubscribe();
        } catch (err) {
          onError2?.(err);
        }
      })();
      return unsubscribe;
    };
    return enablePolling ? pollBlocks() : subscribeBlocks();
  }

  // node_modules/viem/dist/esm/actions/public/watchBlockNumber.js
  init_fromHex();
  init_stringify();
  function watchBlockNumber(client, { emitOnBegin = false, emitMissed = false, onBlockNumber, onError: onError2, poll: poll_, pollingInterval = client.pollingInterval }) {
    const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
    let prevBlockNumber;
    const pollBlockNumber = () => {
      const observerId = stringify([
        "watchBlockNumber",
        client.uid,
        emitOnBegin,
        emitMissed,
        pollingInterval
      ]);
      return observe(observerId, { onBlockNumber, onError: onError2 }, (emit) => poll(async () => {
        try {
          const blockNumber = await getBlockNumber(client, { maxAge: 0 });
          if (prevBlockNumber) {
            if (blockNumber === prevBlockNumber)
              return;
            if (blockNumber - prevBlockNumber > 1 && emitMissed) {
              for (let i7 = prevBlockNumber + 1n; i7 < blockNumber; i7++) {
                emit.onBlockNumber(i7, prevBlockNumber);
                prevBlockNumber = i7;
              }
            }
          }
          if (!prevBlockNumber || blockNumber > prevBlockNumber) {
            emit.onBlockNumber(blockNumber, prevBlockNumber);
            prevBlockNumber = blockNumber;
          }
        } catch (err) {
          emit.onError?.(err);
        }
      }, {
        emitOnBegin,
        interval: pollingInterval
      }));
    };
    const subscribeBlockNumber = () => {
      let active = true;
      let unsubscribe = () => active = false;
      (async () => {
        try {
          const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
            params: ["newHeads"],
            onData(data2) {
              if (!active)
                return;
              const blockNumber = hexToBigInt(data2.result?.number);
              onBlockNumber(blockNumber, prevBlockNumber);
              prevBlockNumber = blockNumber;
            },
            onError(error) {
              onError2?.(error);
            }
          });
          unsubscribe = unsubscribe_;
          if (!active)
            unsubscribe();
        } catch (err) {
          onError2?.(err);
        }
      })();
      return unsubscribe;
    };
    return enablePolling ? pollBlockNumber() : subscribeBlockNumber();
  }

  // node_modules/viem/dist/esm/actions/public/watchEvent.js
  init_stringify();
  function watchEvent(client, { address, args, batch = true, event, onError: onError2, onLogs, pollingInterval = client.pollingInterval }) {
    const observerId = stringify([
      "watchEvent",
      address,
      args,
      batch,
      client.uid,
      event,
      pollingInterval
    ]);
    return observe(observerId, { onLogs, onError: onError2 }, (emit) => {
      let previousBlockNumber;
      let filter2;
      let initialized = false;
      const unwatch = poll(async () => {
        if (!initialized) {
          try {
            filter2 = await createEventFilter(client, {
              address,
              args,
              event
            });
          } catch {
          }
          initialized = true;
          return;
        }
        try {
          let logs;
          if (filter2) {
            logs = await getFilterChanges(client, { filter: filter2 });
          } else {
            const blockNumber = await getBlockNumber(client);
            if (previousBlockNumber && previousBlockNumber !== blockNumber) {
              logs = await getLogs(client, {
                address,
                args,
                fromBlock: previousBlockNumber + 1n,
                toBlock: blockNumber,
                event
              });
            } else {
              logs = [];
            }
            previousBlockNumber = blockNumber;
          }
          if (logs.length === 0)
            return;
          if (batch)
            emit.onLogs(logs);
          else
            logs.forEach((log) => emit.onLogs([log]));
        } catch (err) {
          emit.onError?.(err);
        }
      }, {
        emitOnBegin: true,
        interval: pollingInterval
      });
      return async () => {
        if (filter2)
          await uninstallFilter(client, { filter: filter2 });
        unwatch();
      };
    });
  }

  // node_modules/viem/dist/esm/actions/public/watchPendingTransactions.js
  init_stringify();

  // node_modules/viem/dist/esm/actions/public/createPendingTransactionFilter.js
  async function createPendingTransactionFilter(client) {
    const getRequest = createFilterRequestScope(client, {
      method: "eth_newPendingTransactionFilter"
    });
    const id3 = await client.request({
      method: "eth_newPendingTransactionFilter"
    });
    return { id: id3, request: getRequest(id3), type: "transaction" };
  }

  // node_modules/viem/dist/esm/actions/public/watchPendingTransactions.js
  function watchPendingTransactions(client, { batch = true, onError: onError2, onTransactions, poll: poll_, pollingInterval = client.pollingInterval }) {
    const enablePolling = typeof poll_ !== "undefined" ? poll_ : client.transport.type !== "webSocket";
    const pollPendingTransactions = () => {
      const observerId = stringify([
        "watchPendingTransactions",
        client.uid,
        batch,
        pollingInterval
      ]);
      return observe(observerId, { onTransactions, onError: onError2 }, (emit) => {
        let filter2;
        const unwatch = poll(async () => {
          try {
            if (!filter2) {
              try {
                filter2 = await createPendingTransactionFilter(client);
                return;
              } catch (err) {
                unwatch();
                throw err;
              }
            }
            const hashes2 = await getFilterChanges(client, { filter: filter2 });
            if (hashes2.length === 0)
              return;
            if (batch)
              emit.onTransactions(hashes2);
            else
              hashes2.forEach((hash5) => emit.onTransactions([hash5]));
          } catch (err) {
            emit.onError?.(err);
          }
        }, {
          emitOnBegin: true,
          interval: pollingInterval
        });
        return async () => {
          if (filter2)
            await uninstallFilter(client, { filter: filter2 });
          unwatch();
        };
      });
    };
    const subscribePendingTransactions = () => {
      let active = true;
      let unsubscribe = () => active = false;
      (async () => {
        try {
          const { unsubscribe: unsubscribe_ } = await client.transport.subscribe({
            params: ["newPendingTransactions"],
            onData(data2) {
              if (!active)
                return;
              const transaction = data2.result;
              onTransactions([transaction]);
            },
            onError(error) {
              onError2?.(error);
            }
          });
          unsubscribe = unsubscribe_;
          if (!active)
            unsubscribe();
        } catch (err) {
          onError2?.(err);
        }
      })();
      return unsubscribe;
    };
    return enablePolling ? pollPendingTransactions() : subscribePendingTransactions();
  }

  // node_modules/viem/dist/esm/index.js
  init_readContract();

  // node_modules/viem/dist/esm/actions/public/waitForTransactionReceipt.js
  init_transaction();

  // node_modules/viem/dist/esm/utils/promise/withRetry.js
  function withRetry(fn2, { delay: delay_ = 100, retryCount = 2, shouldRetry = () => true } = {}) {
    return new Promise((resolve, reject) => {
      const attemptRetry = async ({ count = 0 } = {}) => {
        const retry = async ({ error }) => {
          const delay = typeof delay_ === "function" ? delay_({ count, error }) : delay_;
          if (delay)
            await wait(delay);
          attemptRetry({ count: count + 1 });
        };
        try {
          const data2 = await fn2();
          resolve(data2);
        } catch (err) {
          if (count < retryCount && await shouldRetry({ count, error: err }))
            return retry({ error: err });
          reject(err);
        }
      };
      attemptRetry();
    });
  }

  // node_modules/viem/dist/esm/actions/public/waitForTransactionReceipt.js
  init_stringify();
  async function waitForTransactionReceipt(client, { confirmations = 1, hash: hash5, onReplaced, pollingInterval = client.pollingInterval, timeout }) {
    const observerId = stringify(["waitForTransactionReceipt", client.uid, hash5]);
    let transaction;
    let replacedTransaction;
    let receipt;
    let retrying = false;
    return new Promise((resolve, reject) => {
      if (timeout)
        setTimeout(() => reject(new WaitForTransactionReceiptTimeoutError({ hash: hash5 })), timeout);
      const _unobserve = observe(observerId, { onReplaced, resolve, reject }, (emit) => {
        const unwatch = watchBlockNumber(client, {
          emitMissed: true,
          emitOnBegin: true,
          poll: true,
          pollingInterval,
          async onBlockNumber(blockNumber_) {
            if (retrying)
              return;
            let blockNumber = blockNumber_;
            const done = async (fn2) => {
              unwatch();
              fn2();
              _unobserve();
            };
            try {
              if (receipt) {
                if (blockNumber - receipt.blockNumber + 1n < confirmations)
                  return;
                done(() => emit.resolve(receipt));
                return;
              }
              if (!transaction) {
                retrying = true;
                await withRetry(async () => {
                  transaction = await getTransaction(client, { hash: hash5 });
                  if (transaction.blockNumber)
                    blockNumber = transaction.blockNumber;
                }, {
                  delay: ({ count }) => ~~(1 << count) * 200,
                  retryCount: 6
                });
                retrying = false;
              }
              receipt = await getTransactionReceipt(client, { hash: hash5 });
              if (confirmations > 0 && blockNumber - receipt.blockNumber + 1n < confirmations)
                return;
              done(() => emit.resolve(receipt));
            } catch (err) {
              if (transaction && (err instanceof TransactionNotFoundError || err instanceof TransactionReceiptNotFoundError)) {
                replacedTransaction = transaction;
                const block2 = await getBlock(client, {
                  blockNumber,
                  includeTransactions: true
                });
                const replacementTransaction = block2.transactions.find(({ from: from3, nonce }) => from3 === replacedTransaction.from && nonce === replacedTransaction.nonce);
                if (!replacementTransaction)
                  return;
                receipt = await getTransactionReceipt(client, {
                  hash: replacementTransaction.hash
                });
                if (blockNumber - receipt.blockNumber + 1n < confirmations)
                  return;
                let reason = "replaced";
                if (replacementTransaction.to === replacedTransaction.to && replacementTransaction.value === replacedTransaction.value) {
                  reason = "repriced";
                } else if (replacementTransaction.from === replacementTransaction.to && replacementTransaction.value === 0n) {
                  reason = "cancelled";
                }
                done(() => {
                  emit.onReplaced?.({
                    reason,
                    replacedTransaction,
                    transaction: replacementTransaction,
                    transactionReceipt: receipt
                  });
                  emit.resolve(receipt);
                });
              } else {
                done(() => emit.reject(err));
              }
            }
          }
        });
        return unwatch;
      });
    });
  }

  // node_modules/viem/dist/esm/actions/wallet/requestPermissions.js
  async function requestPermissions(client, permissions) {
    return client.request({
      method: "wallet_requestPermissions",
      params: [permissions]
    });
  }

  // node_modules/viem/dist/esm/actions/test/sendUnsignedTransaction.js
  init_transactionRequest();

  // node_modules/viem/dist/esm/actions/wallet/signMessage.js
  init_parseAccount();
  init_toHex();
  async function signMessage(client, { account: account_ = client.account, message }) {
    if (!account_)
      throw new AccountNotFoundError({
        docsPath: "/docs/actions/wallet/signMessage"
      });
    const account = parseAccount(account_);
    if (account.type === "local")
      return account.signMessage({ message });
    const message_ = (() => {
      if (typeof message === "string")
        return stringToHex(message);
      if (message.raw instanceof Uint8Array)
        return toHex(message.raw);
      return message.raw;
    })();
    return client.request({
      method: "personal_sign",
      params: [message_, account.address]
    });
  }

  // node_modules/viem/dist/esm/actions/wallet/signTypedData.js
  init_parseAccount();
  init_isHex();
  init_stringify();

  // node_modules/viem/dist/esm/utils/typedData.js
  init_abi();
  init_address();
  init_isAddress();
  init_size();
  init_toHex();

  // node_modules/viem/dist/esm/utils/regex.js
  var bytesRegex2 = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
  var integerRegex2 = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;

  // node_modules/viem/dist/esm/utils/typedData.js
  function validateTypedData({ domain: domain2, message, primaryType, types: types_ }) {
    const types = types_;
    const validateData = (struct, value_) => {
      for (const param of struct) {
        const { name: name2, type: type_ } = param;
        const type = type_;
        const value = value_[name2];
        const integerMatch = type.match(integerRegex2);
        if (integerMatch && (typeof value === "number" || typeof value === "bigint")) {
          const [_type, base4, size_] = integerMatch;
          numberToHex(value, {
            signed: base4 === "int",
            size: parseInt(size_) / 8
          });
        }
        if (type === "address" && typeof value === "string" && !isAddress(value))
          throw new InvalidAddressError({ address: value });
        const bytesMatch = type.match(bytesRegex2);
        if (bytesMatch) {
          const [_type, size_] = bytesMatch;
          if (size_ && size(value) !== parseInt(size_))
            throw new BytesSizeMismatchError({
              expectedSize: parseInt(size_),
              givenSize: size(value)
            });
        }
        const struct2 = types[type];
        if (struct2)
          validateData(struct2, value);
      }
    };
    if (types["EIP712Domain"] && domain2)
      validateData(types["EIP712Domain"], domain2);
    if (primaryType !== "EIP712Domain") {
      const type = types[primaryType];
      validateData(type, message);
    }
  }

  // node_modules/viem/dist/esm/actions/wallet/signTypedData.js
  async function signTypedData(client, { account: account_ = client.account, domain: domain2, message, primaryType, types: types_ }) {
    if (!account_)
      throw new AccountNotFoundError({
        docsPath: "/docs/actions/wallet/signTypedData"
      });
    const account = parseAccount(account_);
    const types = {
      EIP712Domain: [
        domain2?.name && { name: "name", type: "string" },
        domain2?.version && { name: "version", type: "string" },
        domain2?.chainId && { name: "chainId", type: "uint256" },
        domain2?.verifyingContract && {
          name: "verifyingContract",
          type: "address"
        },
        domain2?.salt && { name: "salt", type: "bytes32" }
      ].filter(Boolean),
      ...types_
    };
    validateTypedData({
      domain: domain2,
      message,
      primaryType,
      types
    });
    if (account.type === "local")
      return account.signTypedData({
        domain: domain2,
        primaryType,
        types,
        message
      });
    const typedData = stringify({ domain: domain2 ?? {}, primaryType, types, message }, (_8, value) => isHex(value) ? value.toLowerCase() : value);
    return client.request({
      method: "eth_signTypedData_v4",
      params: [account.address, typedData]
    });
  }

  // node_modules/viem/dist/esm/actions/wallet/watchAsset.js
  async function watchAsset(client, params) {
    const added = await client.request({
      method: "wallet_watchAsset",
      params
    });
    return added;
  }

  // node_modules/viem/dist/esm/utils/uid.js
  var size2 = 256;
  var index = size2;
  var buffer;
  function uid(length2 = 11) {
    if (!buffer || index + length2 > size2 * 2) {
      buffer = "";
      index = 0;
      for (let i7 = 0; i7 < size2; i7++) {
        buffer += (256 + Math.random() * 256 | 0).toString(16).substring(1);
      }
    }
    return buffer.substring(index, index++ + length2);
  }

  // node_modules/viem/dist/esm/clients/createClient.js
  function createClient({ chain, key: key2 = "base", name: name2 = "Base Client", pollingInterval = 4e3, transport, type = "base" }) {
    const { config: config2, request, value } = transport({ chain, pollingInterval });
    return {
      chain,
      key: key2,
      name: name2,
      pollingInterval,
      request,
      transport: { ...config2, ...value },
      type,
      uid: uid()
    };
  }

  // node_modules/viem/dist/esm/utils/buildRequest.js
  init_base();
  init_request();
  init_rpc();
  var isDeterministicError = (error) => {
    if ("code" in error)
      return error.code !== -1 && error.code !== -32004 && error.code !== -32005 && error.code !== -32042 && error.code !== -32603;
    if (error instanceof HttpRequestError && error.status)
      return error.status !== 403 && error.status !== 408 && error.status !== 413 && error.status !== 429 && error.status !== 500 && error.status !== 502 && error.status !== 503 && error.status !== 504;
    return false;
  };
  function buildRequest(request, { retryDelay = 150, retryCount = 3 } = {}) {
    return async (args) => withRetry(async () => {
      try {
        return await request(args);
      } catch (err_) {
        const err = err_;
        if (err.code === -32700)
          throw new ParseRpcError(err);
        if (err.code === -32600)
          throw new InvalidRequestRpcError(err);
        if (err.code === -32601)
          throw new MethodNotFoundRpcError(err);
        if (err.code === -32602)
          throw new InvalidParamsRpcError(err);
        if (err.code === -32603)
          throw new InternalRpcError(err);
        if (err.code === -32e3)
          throw new InvalidInputRpcError(err);
        if (err.code === -32001)
          throw new ResourceNotFoundRpcError(err);
        if (err.code === -32002)
          throw new ResourceUnavailableRpcError(err);
        if (err.code === -32003)
          throw new TransactionRejectedRpcError(err);
        if (err.code === -32004)
          throw new MethodNotSupportedRpcError(err);
        if (err.code === -32005)
          throw new LimitExceededRpcError(err);
        if (err.code === -32006)
          throw new JsonRpcVersionUnsupportedError(err);
        if (err.code === -32042)
          throw new MethodNotSupportedRpcError(err);
        if (err.code === 4001)
          throw new UserRejectedRequestError(err);
        if (err.code === 4100)
          throw new UnauthorizedProviderError(err);
        if (err.code === 4200)
          throw new UnsupportedProviderMethodError(err);
        if (err.code === 4900)
          throw new ProviderDisconnectedError(err);
        if (err.code === 4901)
          throw new ChainDisconnectedError(err);
        if (err.code === 4902)
          throw new SwitchChainError(err);
        if (err_ instanceof BaseError)
          throw err_;
        throw new UnknownRpcError(err);
      }
    }, {
      delay: ({ count, error }) => {
        if (error && error instanceof HttpRequestError) {
          const retryAfter = error?.headers?.get("Retry-After");
          if (retryAfter?.match(/\d/))
            return parseInt(retryAfter) * 1e3;
        }
        return ~~(1 << count) * retryDelay;
      },
      retryCount,
      shouldRetry: ({ error }) => !isDeterministicError(error)
    });
  }

  // node_modules/viem/dist/esm/clients/transports/createTransport.js
  function createTransport({ key: key2, name: name2, request, retryCount = 3, retryDelay = 150, timeout, type }, value) {
    return {
      config: { key: key2, name: name2, request, retryCount, retryDelay, timeout, type },
      request: buildRequest(request, { retryCount, retryDelay }),
      value
    };
  }

  // node_modules/viem/dist/esm/clients/transports/custom.js
  function custom(provider, config2 = {}) {
    const { key: key2 = "custom", name: name2 = "Custom Provider", retryDelay } = config2;
    return ({ retryCount: defaultRetryCount }) => createTransport({
      key: key2,
      name: name2,
      request: provider.request.bind(provider),
      retryCount: config2.retryCount ?? defaultRetryCount,
      retryDelay,
      type: "custom"
    });
  }

  // node_modules/viem/dist/esm/clients/transports/fallback.js
  function fallback(transports_, config2 = {}) {
    const { key: key2 = "fallback", name: name2 = "Fallback", rank = false, retryCount, retryDelay } = config2;
    return ({ chain, pollingInterval = 4e3, timeout }) => {
      let transports = transports_;
      let onResponse = () => {
      };
      const transport = createTransport({
        key: key2,
        name: name2,
        async request({ method, params }) {
          const fetch3 = async (i7 = 0) => {
            const transport2 = transports[i7]({ chain, retryCount: 0, timeout });
            try {
              const response = await transport2.request({
                method,
                params
              });
              onResponse({
                method,
                params,
                response,
                transport: transport2,
                status: "success"
              });
              return response;
            } catch (err) {
              onResponse({
                error: err,
                method,
                params,
                transport: transport2,
                status: "error"
              });
              if (isDeterministicError(err))
                throw err;
              if (i7 === transports.length - 1)
                throw err;
              return fetch3(i7 + 1);
            }
          };
          return fetch3();
        },
        retryCount,
        retryDelay,
        type: "fallback"
      }, {
        onResponse: (fn2) => onResponse = fn2,
        transports: transports.map((fn2) => fn2({ chain, retryCount: 0 }))
      });
      if (rank) {
        const rankOptions = typeof rank === "object" ? rank : {};
        rankTransports({
          chain,
          interval: rankOptions.interval ?? pollingInterval,
          onTransports: (transports_2) => transports = transports_2,
          sampleCount: rankOptions.sampleCount,
          timeout: rankOptions.timeout,
          transports,
          weights: rankOptions.weights
        });
      }
      return transport;
    };
  }
  function rankTransports({ chain, interval = 4e3, onTransports, sampleCount = 10, timeout = 1e3, transports, weights = {} }) {
    const { stability: stabilityWeight = 0.7, latency: latencyWeight = 0.3 } = weights;
    const samples = [];
    const rankTransports_ = async () => {
      const sample = await Promise.all(transports.map(async (transport) => {
        const transport_ = transport({ chain, retryCount: 0, timeout });
        const start = Date.now();
        let end;
        let success;
        try {
          await transport_.request({ method: "net_listening" });
          success = 1;
        } catch {
          success = 0;
        } finally {
          end = Date.now();
        }
        const latency = end - start;
        return { latency, success };
      }));
      samples.push(sample);
      if (samples.length > sampleCount)
        samples.shift();
      const maxLatency = Math.max(...samples.map((sample2) => Math.max(...sample2.map(({ latency }) => latency))));
      const scores = transports.map((_8, i7) => {
        const latencies = samples.map((sample2) => sample2[i7].latency);
        const meanLatency = latencies.reduce((acc, latency) => acc + latency, 0) / latencies.length;
        const latencyScore = 1 - meanLatency / maxLatency;
        const successes = samples.map((sample2) => sample2[i7].success);
        const stabilityScore = successes.reduce((acc, success) => acc + success, 0) / successes.length;
        if (stabilityScore === 0)
          return [0, i7];
        return [
          latencyWeight * latencyScore + stabilityWeight * stabilityScore,
          i7
        ];
      }).sort((a6, b7) => b7[0] - a6[0]);
      onTransports(scores.map(([, i7]) => transports[i7]));
      await wait(interval);
      rankTransports_();
    };
    rankTransports_();
  }

  // node_modules/viem/dist/esm/errors/transport.js
  init_base();
  var UrlRequiredError = class extends BaseError {
    constructor() {
      super("No URL was provided to the Transport. Please provide a valid RPC URL to the Transport.", {
        docsPath: "/docs/clients/intro"
      });
    }
  };

  // node_modules/viem/dist/esm/utils/rpc.js
  init_request();
  init_createBatchScheduler();

  // node_modules/viem/dist/esm/utils/promise/withTimeout.js
  function withTimeout(fn2, { errorInstance, timeout, signal }) {
    return new Promise((resolve, reject) => {
      ;
      (async () => {
        let timeoutId;
        try {
          const controller = new AbortController();
          if (timeout > 0) {
            timeoutId = setTimeout(() => {
              if (signal) {
                controller.abort();
              } else {
                reject(errorInstance);
              }
            }, timeout);
          }
          resolve(await fn2({ signal: controller?.signal }));
        } catch (err) {
          if (err.name === "AbortError")
            reject(errorInstance);
          reject(err);
        } finally {
          clearTimeout(timeoutId);
        }
      })();
    });
  }

  // node_modules/viem/dist/esm/utils/rpc.js
  init_stringify();
  var id = 0;
  async function http(url, { body, fetchOptions = {}, timeout = 1e4 }) {
    const { headers, method, signal: signal_ } = fetchOptions;
    try {
      const response = await withTimeout(async ({ signal }) => {
        const response2 = await fetch(url, {
          ...fetchOptions,
          body: stringify({ jsonrpc: "2.0", id: id++, ...body }),
          headers: {
            ...headers,
            "Content-Type": "application/json"
          },
          method: method || "POST",
          signal: signal_ || (timeout > 0 ? signal : void 0)
        });
        return response2;
      }, {
        errorInstance: new TimeoutError({ body, url }),
        timeout,
        signal: true
      });
      let data2;
      if (response.headers.get("Content-Type")?.startsWith("application/json")) {
        data2 = await response.json();
      } else {
        data2 = await response.text();
      }
      if (!response.ok) {
        throw new HttpRequestError({
          body,
          details: stringify(data2.error) || response.statusText,
          headers: response.headers,
          status: response.status,
          url
        });
      }
      if (data2.error) {
        throw new RpcRequestError({ body, error: data2.error, url });
      }
      return data2;
    } catch (err) {
      if (err instanceof HttpRequestError)
        throw err;
      if (err instanceof RpcRequestError)
        throw err;
      if (err instanceof TimeoutError)
        throw err;
      throw new HttpRequestError({
        body,
        details: err.message,
        url
      });
    }
  }
  var sockets = /* @__PURE__ */ new Map();
  async function getSocket(url_) {
    const url = new URL(url_);
    const urlKey = url.toString();
    let socket = sockets.get(urlKey);
    if (socket)
      return socket;
    const { schedule } = createBatchScheduler({
      id: urlKey,
      fn: async () => {
        let WebSocket2 = await Promise.resolve().then(() => (init_browser(), browser_exports));
        if (WebSocket2.default?.constructor)
          WebSocket2 = WebSocket2.default;
        else
          WebSocket2 = WebSocket2.WebSocket;
        const webSocket3 = new WebSocket2(url);
        const requests = /* @__PURE__ */ new Map();
        const subscriptions = /* @__PURE__ */ new Map();
        const onMessage = ({ data: data2 }) => {
          const message = JSON.parse(data2);
          const isSubscription = message.method === "eth_subscription";
          const id3 = isSubscription ? message.params.subscription : message.id;
          const cache = isSubscription ? subscriptions : requests;
          const callback = cache.get(id3);
          if (callback)
            callback({ data: data2 });
          if (!isSubscription)
            cache.delete(id3);
        };
        const onClose = () => {
          sockets.delete(urlKey);
          webSocket3.removeEventListener("close", onClose);
          webSocket3.removeEventListener("message", onMessage);
        };
        webSocket3.addEventListener("close", onClose);
        webSocket3.addEventListener("message", onMessage);
        if (webSocket3.readyState === WebSocket2.CONNECTING) {
          await new Promise((resolve, reject) => {
            if (!webSocket3)
              return;
            webSocket3.onopen = resolve;
            webSocket3.onerror = reject;
          });
        }
        socket = Object.assign(webSocket3, {
          requests,
          subscriptions
        });
        sockets.set(urlKey, socket);
        return [socket];
      }
    });
    const [_8, [socket_]] = await schedule();
    return socket_;
  }
  function webSocket(socket, { body, onData, onError: onError2 }) {
    if (socket.readyState === socket.CLOSED || socket.readyState === socket.CLOSING)
      throw new WebSocketRequestError({
        body,
        url: socket.url,
        details: "Socket is closed."
      });
    const id_ = id++;
    const callback = ({ data: data2 }) => {
      const message = JSON.parse(data2);
      if (typeof message.id === "number" && id_ !== message.id)
        return;
      if (message.error) {
        onError2?.(new RpcRequestError({ body, error: message.error, url: socket.url }));
      } else {
        onData?.(message);
      }
      if (body.method === "eth_subscribe" && typeof message.result === "string") {
        socket.subscriptions.set(message.result, callback);
      }
      if (body.method === "eth_unsubscribe") {
        socket.subscriptions.delete(body.params?.[0]);
      }
    };
    socket.requests.set(id_, callback);
    socket.send(JSON.stringify({ jsonrpc: "2.0", ...body, id: id_ }));
    return socket;
  }
  async function webSocketAsync(socket, { body, timeout = 1e4 }) {
    return withTimeout(() => new Promise((onData, onError2) => rpc.webSocket(socket, {
      body,
      onData,
      onError: onError2
    })), {
      errorInstance: new TimeoutError({ body, url: socket.url }),
      timeout
    });
  }
  var rpc = {
    http,
    webSocket,
    webSocketAsync
  };

  // node_modules/viem/dist/esm/clients/transports/http.js
  function http2(url, config2 = {}) {
    const { fetchOptions, key: key2 = "http", name: name2 = "HTTP JSON-RPC", retryDelay } = config2;
    return ({ chain, retryCount: retryCount_, timeout: timeout_ }) => {
      const retryCount = config2.retryCount ?? retryCount_;
      const timeout = timeout_ ?? config2.timeout ?? 1e4;
      const url_ = url || chain?.rpcUrls.default.http[0];
      if (!url_)
        throw new UrlRequiredError();
      return createTransport({
        key: key2,
        name: name2,
        async request({ method, params }) {
          const { result } = await rpc.http(url_, {
            body: {
              method,
              params
            },
            fetchOptions,
            timeout
          });
          return result;
        },
        retryCount,
        retryDelay,
        timeout,
        type: "http"
      }, {
        url
      });
    };
  }

  // node_modules/viem/dist/esm/clients/decorators/public.js
  init_getEnsAddress();
  init_getEnsAvatar();
  init_getEnsName();
  init_getEnsResolver();
  init_getEnsText();
  init_call();

  // node_modules/viem/dist/esm/actions/public/createBlockFilter.js
  async function createBlockFilter(client) {
    const getRequest = createFilterRequestScope(client, {
      method: "eth_newBlockFilter"
    });
    const id3 = await client.request({
      method: "eth_newBlockFilter"
    });
    return { id: id3, request: getRequest(id3), type: "block" };
  }

  // node_modules/viem/dist/esm/clients/decorators/public.js
  init_readContract();

  // node_modules/viem/dist/esm/utils/index.js
  init_ccip2();
  init_chain2();
  init_stringify();
  init_decodeAbiParameters();
  init_decodeErrorResult();

  // node_modules/viem/dist/esm/utils/abi/decodeFunctionData.js
  init_abi();
  init_slice();
  init_getFunctionSelector();
  init_decodeAbiParameters();
  init_formatAbiItem();

  // node_modules/viem/dist/esm/utils/index.js
  init_decodeFunctionResult();
  init_encodeAbiParameters();

  // node_modules/viem/dist/esm/utils/abi/encodeErrorResult.js
  init_abi();
  init_concat();
  init_getFunctionSelector();
  init_encodeAbiParameters();
  init_formatAbiItem();
  init_getAbiItem();

  // node_modules/viem/dist/esm/utils/index.js
  init_encodeFunctionData();

  // node_modules/viem/dist/esm/utils/abi/encodeFunctionResult.js
  init_abi();
  init_encodeAbiParameters();
  init_getAbiItem();

  // node_modules/viem/dist/esm/utils/index.js
  init_getAbiItem();

  // node_modules/viem/dist/esm/utils/abi/encodePacked.js
  init_abi();
  init_address();
  init_isAddress();
  init_concat();
  init_pad();
  init_toHex();

  // node_modules/viem/dist/esm/utils/index.js
  init_formatAbiItemWithArgs();
  init_formatAbiItem();
  init_parseAccount();

  // node_modules/viem/dist/esm/accounts/utils/publicKeyToAddress.js
  init_getAddress();
  init_keccak256();

  // node_modules/viem/dist/esm/utils/address/getContractAddress.js
  init_concat();
  init_pad();
  init_slice();
  init_toBytes();

  // node_modules/viem/dist/esm/utils/encoding/toRlp.js
  init_concat();
  init_toBytes();
  init_toHex();

  // node_modules/viem/dist/esm/utils/address/getContractAddress.js
  init_keccak256();
  init_getAddress();

  // node_modules/viem/dist/esm/utils/index.js
  init_getAddress();
  init_isAddress();
  init_isAddressEqual();
  init_extractFunctionParts();
  init_concat();
  init_isHex();
  init_pad();
  init_size();
  init_slice();
  init_trim();
  init_format();
  init_transactionRequest();
  init_extract();
  init_toBytes();
  init_toHex();

  // node_modules/viem/dist/esm/utils/encoding/fromBytes.js
  init_encoding();
  init_trim();
  init_fromHex();
  init_toHex();

  // node_modules/viem/dist/esm/utils/index.js
  init_fromHex();

  // node_modules/viem/dist/esm/utils/encoding/fromRlp.js
  init_encoding();
  init_toBytes();
  init_toHex();

  // node_modules/viem/dist/esm/utils/index.js
  init_getNodeError();
  init_getCallError();
  init_getContractError();
  init_getFunctionSelector();

  // node_modules/viem/dist/esm/utils/hash/isHash.js
  init_isHex();
  init_size();

  // node_modules/viem/dist/esm/utils/index.js
  init_keccak256();

  // node_modules/viem/dist/esm/utils/signature/hashTypedData.js
  init_encodeAbiParameters();
  init_concat();
  init_toHex();
  init_keccak256();
  function hashTypedData({ domain: domain_, message, primaryType, types: types_ }) {
    const domain2 = typeof domain_ === "undefined" ? {} : domain_;
    const types = {
      EIP712Domain: [
        domain2?.name && { name: "name", type: "string" },
        domain2?.version && { name: "version", type: "string" },
        domain2?.chainId && { name: "chainId", type: "uint256" },
        domain2?.verifyingContract && {
          name: "verifyingContract",
          type: "address"
        },
        domain2?.salt && { name: "salt", type: "bytes32" }
      ].filter(Boolean),
      ...types_
    };
    validateTypedData({
      domain: domain2,
      message,
      primaryType,
      types
    });
    const parts = ["0x1901"];
    if (domain2)
      parts.push(hashDomain({
        domain: domain2,
        types
      }));
    if (primaryType !== "EIP712Domain") {
      parts.push(hashStruct({
        data: message,
        primaryType,
        types
      }));
    }
    return keccak256(concat(parts));
  }
  function hashDomain({ domain: domain2, types }) {
    return hashStruct({
      data: domain2,
      primaryType: "EIP712Domain",
      types
    });
  }
  function hashStruct({ data: data2, primaryType, types }) {
    const encoded = encodeData({
      data: data2,
      primaryType,
      types
    });
    return keccak256(encoded);
  }
  function encodeData({ data: data2, primaryType, types }) {
    const encodedTypes = [{ type: "bytes32" }];
    const encodedValues = [hashType({ primaryType, types })];
    for (const field of types[primaryType]) {
      const [type, value] = encodeField({
        types,
        name: field.name,
        type: field.type,
        value: data2[field.name]
      });
      encodedTypes.push(type);
      encodedValues.push(value);
    }
    return encodeAbiParameters(encodedTypes, encodedValues);
  }
  function hashType({ primaryType, types }) {
    const encodedHashType = toHex(encodeType({ primaryType, types }));
    return keccak256(encodedHashType);
  }
  function encodeType({ primaryType, types }) {
    let result = "";
    const unsortedDeps = findTypeDependencies({ primaryType, types });
    unsortedDeps.delete(primaryType);
    const deps = [primaryType, ...Array.from(unsortedDeps).sort()];
    for (const type of deps) {
      result += `${type}(${types[type].map(({ name: name2, type: t6 }) => `${t6} ${name2}`).join(",")})`;
    }
    return result;
  }
  function findTypeDependencies({ primaryType: primaryType_, types }, results2 = /* @__PURE__ */ new Set()) {
    const match = primaryType_.match(/^\w*/u);
    const primaryType = match?.[0];
    if (results2.has(primaryType) || types[primaryType] === void 0) {
      return results2;
    }
    results2.add(primaryType);
    for (const field of types[primaryType]) {
      findTypeDependencies({ primaryType: field.type, types }, results2);
    }
    return results2;
  }
  function encodeField({ types, name: name2, type, value }) {
    if (types[type] !== void 0) {
      return [
        { type: "bytes32" },
        keccak256(encodeData({ data: value, primaryType: type, types }))
      ];
    }
    if (type === "bytes") {
      const prepend = value.length % 2 ? "0" : "";
      value = `0x${prepend + value.slice(2)}`;
      return [{ type: "bytes32" }, keccak256(value)];
    }
    if (type === "string")
      return [{ type: "bytes32" }, keccak256(toHex(value))];
    if (type.lastIndexOf("]") === type.length - 1) {
      const parsedType = type.slice(0, type.lastIndexOf("["));
      const typeValuePairs = value.map((item) => encodeField({
        name: name2,
        type: parsedType,
        types,
        value: item
      }));
      return [
        { type: "bytes32" },
        keccak256(encodeAbiParameters(typeValuePairs.map(([t6]) => t6), typeValuePairs.map(([, v6]) => v6)))
      ];
    }
    return [{ type }, value];
  }

  // node_modules/viem/dist/esm/utils/signature/recoverPublicKey.js
  init_isHex();
  init_fromHex();
  init_toHex();

  // node_modules/viem/dist/esm/utils/signature/hashMessage.js
  init_concat();
  init_toBytes();
  init_keccak256();
  function hashMessage(message, to_) {
    const messageBytes = (() => {
      if (typeof message === "string")
        return stringToBytes(message);
      if (message.raw instanceof Uint8Array)
        return message.raw;
      return toBytes(message.raw);
    })();
    const prefixBytes = stringToBytes(`Ethereum Signed Message:
${messageBytes.length}`);
    return keccak256(concat([prefixBytes, messageBytes]), to_);
  }

  // node_modules/viem/dist/esm/utils/signature/verifyMessage.js
  init_getAddress();
  init_isAddressEqual();

  // node_modules/viem/dist/esm/utils/signature/verifyTypedData.js
  init_getAddress();
  init_isAddressEqual();

  // node_modules/viem/dist/esm/utils/transaction/getSerializedTransactionType.js
  init_transaction();
  init_slice();
  init_fromHex();

  // node_modules/viem/dist/esm/utils/transaction/getTransactionType.js
  init_transaction();

  // node_modules/viem/dist/esm/utils/index.js
  init_assertRequest();

  // node_modules/viem/dist/esm/utils/transaction/assertTransaction.js
  init_address();
  init_base();
  init_chain();
  init_node();
  init_isAddress();

  // node_modules/viem/dist/esm/utils/transaction/parseTransaction.js
  init_address();
  init_transaction();
  init_isAddress();
  init_isHex();
  init_pad();
  init_trim();
  init_fromHex();

  // node_modules/viem/dist/esm/utils/transaction/serializeTransaction.js
  init_address();
  init_transaction();
  init_isAddress();
  init_concat();
  init_trim();
  init_toHex();

  // node_modules/viem/dist/esm/utils/index.js
  init_formatEther();
  init_formatGwei();
  init_formatUnits();

  // node_modules/viem/dist/esm/utils/unit/parseEther.js
  init_unit();

  // node_modules/viem/dist/esm/utils/unit/parseGwei.js
  init_unit();

  // node_modules/viem/dist/esm/actions/public/verifyHash.js
  init_abis();

  // node_modules/viem/dist/esm/constants/contracts.js
  var universalSignatureValidatorByteCode = "0x60806040523480156200001157600080fd5b50604051620007003803806200070083398101604081905262000034916200056f565b6000620000438484846200004f565b9050806000526001601ff35b600080846001600160a01b0316803b806020016040519081016040528181526000908060200190933c90507f6492649264926492649264926492649264926492649264926492649264926492620000a68462000451565b036200021f57600060608085806020019051810190620000c79190620005ce565b8651929550909350915060000362000192576000836001600160a01b031683604051620000f5919062000643565b6000604051808303816000865af19150503d806000811462000134576040519150601f19603f3d011682016040523d82523d6000602084013e62000139565b606091505b5050905080620001905760405162461bcd60e51b815260206004820152601e60248201527f5369676e617475726556616c696461746f723a206465706c6f796d656e74000060448201526064015b60405180910390fd5b505b604051630b135d3f60e11b808252906001600160a01b038a1690631626ba7e90620001c4908b90869060040162000661565b602060405180830381865afa158015620001e2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200020891906200069d565b6001600160e01b031916149450505050506200044a565b805115620002b157604051630b135d3f60e11b808252906001600160a01b03871690631626ba7e9062000259908890889060040162000661565b602060405180830381865afa15801562000277573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906200029d91906200069d565b6001600160e01b031916149150506200044a565b8251604114620003195760405162461bcd60e51b815260206004820152603a6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e6174757265206c656e677468000000000000606482015260840162000187565b620003236200046b565b506020830151604080850151855186939260009185919081106200034b576200034b620006c9565b016020015160f81c9050601b81148015906200036b57508060ff16601c14155b15620003cf5760405162461bcd60e51b815260206004820152603b6024820152600080516020620006e083398151915260448201527f3a20696e76616c6964207369676e617475726520762076616c75650000000000606482015260840162000187565b6040805160008152602081018083528a905260ff83169181019190915260608101849052608081018390526001600160a01b038a169060019060a0016020604051602081039080840390855afa1580156200042e573d6000803e3d6000fd5b505050602060405103516001600160a01b031614955050505050505b9392505050565b60006020825110156200046357600080fd5b508051015190565b60405180606001604052806003906020820280368337509192915050565b6001600160a01b03811681146200049f57600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60005b83811015620004d5578181015183820152602001620004bb565b50506000910152565b600082601f830112620004f057600080fd5b81516001600160401b03808211156200050d576200050d620004a2565b604051601f8301601f19908116603f01168101908282118183101715620005385762000538620004a2565b816040528381528660208588010111156200055257600080fd5b62000565846020830160208901620004b8565b9695505050505050565b6000806000606084860312156200058557600080fd5b8351620005928162000489565b6020850151604086015191945092506001600160401b03811115620005b657600080fd5b620005c486828701620004de565b9150509250925092565b600080600060608486031215620005e457600080fd5b8351620005f18162000489565b60208501519093506001600160401b03808211156200060f57600080fd5b6200061d87838801620004de565b935060408601519150808211156200063457600080fd5b50620005c486828701620004de565b6000825162000657818460208701620004b8565b9190910192915050565b828152604060208201526000825180604084015262000688816060850160208701620004b8565b601f01601f1916919091016060019392505050565b600060208284031215620006b057600080fd5b81516001600160e01b0319811681146200044a57600080fd5b634e487b7160e01b600052603260045260246000fdfe5369676e617475726556616c696461746f72237265636f7665725369676e6572";

  // node_modules/viem/dist/esm/actions/public/verifyHash.js
  init_contract();

  // node_modules/viem/dist/esm/utils/data/isBytesEqual.js
  init_utils4();
  function isBytesEqual(a_, b_) {
    const a6 = isHex(a_) ? toBytes(a_) : a_;
    const b7 = isHex(b_) ? toBytes(b_) : b_;
    return equalBytes(a6, b7);
  }

  // node_modules/viem/dist/esm/actions/public/verifyHash.js
  init_call();
  async function verifyHash(client, { address, hash: hash5, signature: signature2, ...callRequest }) {
    const signatureHex = isHex(signature2) ? signature2 : toHex(signature2);
    try {
      const { data: data2 } = await call(client, {
        data: encodeDeployData({
          abi: universalSignatureValidatorAbi,
          args: [address, hash5, signatureHex],
          bytecode: universalSignatureValidatorByteCode
        }),
        ...callRequest
      });
      return isBytesEqual(data2 ?? "0x0", "0x1");
    } catch (error) {
      if (error instanceof CallExecutionError) {
        return false;
      }
      throw error;
    }
  }

  // node_modules/viem/dist/esm/actions/public/verifyMessage.js
  async function verifyMessage2(client, { address, message, signature: signature2, ...callRequest }) {
    const hash5 = hashMessage(message);
    return verifyHash(client, {
      address,
      hash: hash5,
      signature: signature2,
      ...callRequest
    });
  }

  // node_modules/viem/dist/esm/actions/public/verifyTypedData.js
  async function verifyTypedData2(client, { address, signature: signature2, message, primaryType, types, domain: domain2, ...callRequest }) {
    const hash5 = hashTypedData({ message, primaryType, types, domain: domain2 });
    return verifyHash(client, {
      address,
      hash: hash5,
      signature: signature2,
      ...callRequest
    });
  }

  // node_modules/viem/dist/esm/clients/decorators/public.js
  var publicActions = (client) => ({
    call: (args) => call(client, args),
    createBlockFilter: () => createBlockFilter(client),
    createContractEventFilter: (args) => createContractEventFilter(client, args),
    createEventFilter: (args) => createEventFilter(client, args),
    createPendingTransactionFilter: () => createPendingTransactionFilter(client),
    estimateContractGas: (args) => estimateContractGas(client, args),
    estimateGas: (args) => estimateGas(client, args),
    getBalance: (args) => getBalance(client, args),
    getBlock: (args) => getBlock(client, args),
    getBlockNumber: (args) => getBlockNumber(client, args),
    getBlockTransactionCount: (args) => getBlockTransactionCount(client, args),
    getBytecode: (args) => getBytecode(client, args),
    getChainId: () => getChainId(client),
    getEnsAddress: (args) => getEnsAddress(client, args),
    getEnsAvatar: (args) => getEnsAvatar(client, args),
    getEnsName: (args) => getEnsName(client, args),
    getEnsResolver: (args) => getEnsResolver(client, args),
    getEnsText: (args) => getEnsText(client, args),
    getFeeHistory: (args) => getFeeHistory(client, args),
    getFilterChanges: (args) => getFilterChanges(client, args),
    getFilterLogs: (args) => getFilterLogs(client, args),
    getGasPrice: () => getGasPrice(client),
    getLogs: (args) => getLogs(client, args),
    getStorageAt: (args) => getStorageAt(client, args),
    getTransaction: (args) => getTransaction(client, args),
    getTransactionConfirmations: (args) => getTransactionConfirmations(client, args),
    getTransactionCount: (args) => getTransactionCount(client, args),
    getTransactionReceipt: (args) => getTransactionReceipt(client, args),
    multicall: (args) => multicall(client, args),
    readContract: (args) => readContract(client, args),
    simulateContract: (args) => simulateContract(client, args),
    verifyMessage: (args) => verifyMessage2(client, args),
    verifyTypedData: (args) => verifyTypedData2(client, args),
    uninstallFilter: (args) => uninstallFilter(client, args),
    waitForTransactionReceipt: (args) => waitForTransactionReceipt(client, args),
    watchBlocks: (args) => watchBlocks(client, args),
    watchBlockNumber: (args) => watchBlockNumber(client, args),
    watchContractEvent: (args) => watchContractEvent(client, args),
    watchEvent: (args) => watchEvent(client, args),
    watchPendingTransactions: (args) => watchPendingTransactions(client, args)
  });

  // node_modules/viem/dist/esm/clients/createPublicClient.js
  function createPublicClient({ batch, chain, key: key2 = "public", name: name2 = "Public Client", transport, pollingInterval }) {
    const client = {
      batch,
      ...createClient({
        chain,
        key: key2,
        name: name2,
        pollingInterval,
        transport,
        type: "publicClient"
      })
    };
    return {
      ...client,
      ...publicActions(client)
    };
  }

  // node_modules/viem/dist/esm/actions/test/getTxpoolStatus.js
  init_fromHex();

  // node_modules/viem/dist/esm/actions/test/increaseTime.js
  init_toHex();

  // node_modules/viem/dist/esm/actions/test/mine.js
  init_toHex();

  // node_modules/viem/dist/esm/actions/test/setBalance.js
  init_toHex();

  // node_modules/viem/dist/esm/actions/test/setBlockGasLimit.js
  init_toHex();

  // node_modules/viem/dist/esm/actions/test/setMinGasPrice.js
  init_toHex();

  // node_modules/viem/dist/esm/actions/test/setNextBlockBaseFeePerGas.js
  init_toHex();

  // node_modules/viem/dist/esm/actions/test/setNextBlockTimestamp.js
  init_toHex();

  // node_modules/viem/dist/esm/actions/test/setNonce.js
  init_toHex();

  // node_modules/viem/dist/esm/actions/test/setStorageAt.js
  init_toHex();

  // node_modules/viem/dist/esm/clients/createWalletClient.js
  init_parseAccount();

  // node_modules/viem/dist/esm/actions/wallet/addChain.js
  init_toHex();
  async function addChain(client, { chain }) {
    const { id: id3, name: name2, nativeCurrency, rpcUrls, blockExplorers } = chain;
    await client.request({
      method: "wallet_addEthereumChain",
      params: [
        {
          chainId: numberToHex(id3),
          chainName: name2,
          nativeCurrency,
          rpcUrls: rpcUrls.default.http,
          blockExplorerUrls: blockExplorers ? Object.values(blockExplorers).map(({ url }) => url) : void 0
        }
      ]
    });
  }

  // node_modules/viem/dist/esm/actions/wallet/getAddresses.js
  init_getAddress();
  async function getAddresses(client) {
    const addresses = await client.request({ method: "eth_accounts" });
    return addresses.map((address) => checksumAddress(address));
  }

  // node_modules/viem/dist/esm/actions/wallet/getPermissions.js
  async function getPermissions(client) {
    const permissions = await client.request({ method: "wallet_getPermissions" });
    return permissions;
  }

  // node_modules/viem/dist/esm/actions/wallet/requestAddresses.js
  init_getAddress();
  async function requestAddresses(client) {
    const addresses = await client.request({ method: "eth_requestAccounts" });
    return addresses.map((address) => getAddress(address));
  }

  // node_modules/viem/dist/esm/actions/wallet/switchChain.js
  init_toHex();
  async function switchChain(client, { id: id3 }) {
    await client.request({
      method: "wallet_switchEthereumChain",
      params: [
        {
          chainId: numberToHex(id3)
        }
      ]
    });
  }

  // node_modules/viem/dist/esm/clients/decorators/wallet.js
  var walletActions = (client) => ({
    addChain: (args) => addChain(client, args),
    deployContract: (args) => deployContract(client, args),
    getAddresses: () => getAddresses(client),
    getChainId: () => getChainId(client),
    getPermissions: () => getPermissions(client),
    requestAddresses: () => requestAddresses(client),
    requestPermissions: (args) => requestPermissions(client, args),
    sendTransaction: (args) => sendTransaction(client, args),
    signMessage: (args) => signMessage(client, args),
    signTypedData: (args) => signTypedData(client, args),
    switchChain: (args) => switchChain(client, args),
    watchAsset: (args) => watchAsset(client, args),
    writeContract: (args) => writeContract(client, args)
  });

  // node_modules/viem/dist/esm/clients/createWalletClient.js
  function createWalletClient({ account, chain, transport, key: key2 = "wallet", name: name2 = "Wallet Client", pollingInterval }) {
    const client = {
      ...createClient({
        chain,
        key: key2,
        name: name2,
        pollingInterval,
        transport: (opts) => transport({ ...opts, retryCount: 0 }),
        type: "walletClient"
      }),
      account: account ? parseAccount(account) : void 0
    };
    return {
      ...client,
      ...walletActions(client)
    };
  }

  // node_modules/viem/dist/esm/clients/transports/webSocket.js
  function webSocket2(url, config2 = {}) {
    const { key: key2 = "webSocket", name: name2 = "WebSocket JSON-RPC", retryDelay } = config2;
    return ({ chain, retryCount: retryCount_, timeout: timeout_ }) => {
      const retryCount = config2.retryCount ?? retryCount_;
      const timeout = timeout_ ?? config2.timeout ?? 1e4;
      const url_ = url || chain?.rpcUrls.default.webSocket?.[0];
      if (!url_)
        throw new UrlRequiredError();
      return createTransport({
        key: key2,
        name: name2,
        async request({ method, params }) {
          const socket = await getSocket(url_);
          const { result } = await rpc.webSocketAsync(socket, {
            body: { method, params },
            timeout
          });
          return result;
        },
        retryCount,
        retryDelay,
        timeout,
        type: "webSocket"
      }, {
        getSocket() {
          return getSocket(url_);
        },
        async subscribe({ params, onData, onError: onError2 }) {
          const socket = await getSocket(url_);
          const { result: subscriptionId } = await new Promise((resolve, reject) => rpc.webSocket(socket, {
            body: {
              method: "eth_subscribe",
              params
            },
            onData: (data2) => {
              if (typeof data2.id === "number") {
                resolve(data2);
                return;
              }
              if (data2.method !== "eth_subscription")
                return;
              onData(data2.params);
            },
            onError: (error) => {
              reject(error);
              onError2?.(error);
            }
          }));
          return {
            subscriptionId,
            async unsubscribe() {
              return new Promise((resolve, reject) => rpc.webSocket(socket, {
                body: {
                  method: "eth_unsubscribe",
                  params: [subscriptionId]
                },
                onData: resolve,
                onError: reject
              }));
            }
          };
        }
      });
    };
  }

  // node_modules/viem/dist/esm/index.js
  init_abis();
  init_unit();
  init_abi();
  init_base();
  init_contract();
  init_rpc();
  init_chain();
  init_encoding();
  init_ens();
  init_node();
  init_request();
  init_address();
  init_transaction();
  init_data();
  init_labelhash();
  init_namehash();
  init_decodeAbiParameters();
  init_decodeErrorResult();
  init_decodeFunctionResult();
  init_encodeAbiParameters();
  init_encodeFunctionData();
  init_format();
  init_transactionRequest();
  init_getAbiItem();
  init_assertRequest();
  init_toBytes();
  init_toHex();
  init_ccip2();
  init_concat();
  init_chain2();
  init_formatEther();
  init_formatGwei();
  init_formatUnits();
  init_fromHex();
  init_getAddress();
  init_getContractError();
  init_getFunctionSelector();
  init_isAddress();
  init_isAddressEqual();
  init_isHex();
  init_keccak256();
  init_pad();
  init_size();
  init_slice();
  init_stringify();
  init_trim();

  // node_modules/@wagmi/connectors/dist/chunk-P4NRLOY7.js
  function getInjectedName(ethereum) {
    if (!ethereum)
      return "Injected";
    const getName = (provider) => {
      if (provider.isApexWallet)
        return "Apex Wallet";
      if (provider.isAvalanche)
        return "Core Wallet";
      if (provider.isBackpack)
        return "Backpack";
      if (provider.isBifrost)
        return "Bifrost Wallet";
      if (provider.isBitKeep)
        return "BitKeep";
      if (provider.isBitski)
        return "Bitski";
      if (provider.isBlockWallet)
        return "BlockWallet";
      if (provider.isBraveWallet)
        return "Brave Wallet";
      if (provider.isCoin98)
        return "Coin98 Wallet";
      if (provider.isCoinbaseWallet)
        return "Coinbase Wallet";
      if (provider.isDawn)
        return "Dawn Wallet";
      if (provider.isDefiant)
        return "Defiant";
      if (provider.isDesig)
        return "Desig Wallet";
      if (provider.isEnkrypt)
        return "Enkrypt";
      if (provider.isExodus)
        return "Exodus";
      if (provider.isFordefi)
        return "Fordefi";
      if (provider.isFrame)
        return "Frame";
      if (provider.isFrontier)
        return "Frontier Wallet";
      if (provider.isGamestop)
        return "GameStop Wallet";
      if (provider.isHaqqWallet)
        return "HAQQ Wallet";
      if (provider.isHyperPay)
        return "HyperPay Wallet";
      if (provider.isImToken)
        return "ImToken";
      if (provider.isHaloWallet)
        return "Halo Wallet";
      if (provider.isKuCoinWallet)
        return "KuCoin Wallet";
      if (provider.isMathWallet)
        return "MathWallet";
      if (provider.isNovaWallet)
        return "Nova Wallet";
      if (provider.isOkxWallet || provider.isOKExWallet)
        return "OKX Wallet";
      if (provider.isOktoWallet)
        return "Okto Wallet";
      if (provider.isOneInchIOSWallet || provider.isOneInchAndroidWallet)
        return "1inch Wallet";
      if (provider.isOneKey)
        return "OneKey Wallet";
      if (provider.isOpera)
        return "Opera";
      if (provider.isPhantom)
        return "Phantom";
      if (provider.isPortal)
        return "Ripio Portal";
      if (provider.isRabby)
        return "Rabby Wallet";
      if (provider.isRainbow)
        return "Rainbow";
      if (provider.isSafePal)
        return "SafePal Wallet";
      if (provider.isStatus)
        return "Status";
      if (provider.isSubWallet)
        return "SubWallet";
      if (provider.isTalisman)
        return "Talisman";
      if (provider.isTally)
        return "Taho";
      if (provider.isTokenPocket)
        return "TokenPocket";
      if (provider.isTokenary)
        return "Tokenary";
      if (provider.isTrust || provider.isTrustWallet)
        return "Trust Wallet";
      if (provider.isTTWallet)
        return "TTWallet";
      if (provider.isXDEFI)
        return "XDEFI Wallet";
      if (provider.isZeal)
        return "Zeal";
      if (provider.isZerion)
        return "Zerion";
      if (provider.isMetaMask)
        return "MetaMask";
    };
    if (ethereum.providers?.length) {
      const nameSet = /* @__PURE__ */ new Set();
      let unknownCount = 1;
      for (const provider of ethereum.providers) {
        let name2 = getName(provider);
        if (!name2) {
          name2 = `Unknown Wallet #${unknownCount}`;
          unknownCount += 1;
        }
        nameSet.add(name2);
      }
      const names2 = [...nameSet];
      if (names2.length)
        return names2;
      return names2[0] ?? "Injected";
    }
    return getName(ethereum) ?? "Injected";
  }
  var _provider;
  var InjectedConnector = class extends Connector {
    constructor({
      chains: chains2,
      options: options_
    } = {}) {
      const options2 = {
        shimDisconnect: true,
        getProvider() {
          if (typeof window === "undefined")
            return;
          const ethereum = window.ethereum;
          if (ethereum?.providers && ethereum.providers.length > 0)
            return ethereum.providers[0];
          return ethereum;
        },
        ...options_
      };
      super({ chains: chains2, options: options2 });
      this.id = "injected";
      __privateAdd(this, _provider, void 0);
      this.shimDisconnectKey = `${this.id}.shimDisconnect`;
      this.onAccountsChanged = (accounts) => {
        if (accounts.length === 0)
          this.emit("disconnect");
        else
          this.emit("change", {
            account: getAddress(accounts[0])
          });
      };
      this.onChainChanged = (chainId) => {
        const id3 = normalizeChainId(chainId);
        const unsupported = this.isChainUnsupported(id3);
        this.emit("change", { chain: { id: id3, unsupported } });
      };
      this.onDisconnect = async (error) => {
        if (error.code === 1013) {
          const provider2 = await this.getProvider();
          if (provider2) {
            const isAuthorized = await this.getAccount();
            if (isAuthorized)
              return;
          }
        }
        this.emit("disconnect");
        if (this.options.shimDisconnect)
          this.storage?.removeItem(this.shimDisconnectKey);
      };
      const provider = options2.getProvider();
      if (typeof options2.name === "string")
        this.name = options2.name;
      else if (provider) {
        const detectedName = getInjectedName(provider);
        if (options2.name)
          this.name = options2.name(detectedName);
        else {
          if (typeof detectedName === "string")
            this.name = detectedName;
          else
            this.name = detectedName[0];
        }
      } else
        this.name = "Injected";
      this.ready = !!provider;
    }
    async connect({ chainId } = {}) {
      try {
        const provider = await this.getProvider();
        if (!provider)
          throw new ConnectorNotFoundError();
        if (provider.on) {
          provider.on("accountsChanged", this.onAccountsChanged);
          provider.on("chainChanged", this.onChainChanged);
          provider.on("disconnect", this.onDisconnect);
        }
        this.emit("message", { type: "connecting" });
        const accounts = await provider.request({
          method: "eth_requestAccounts"
        });
        const account = getAddress(accounts[0]);
        let id3 = await this.getChainId();
        let unsupported = this.isChainUnsupported(id3);
        if (chainId && id3 !== chainId) {
          const chain = await this.switchChain(chainId);
          id3 = chain.id;
          unsupported = this.isChainUnsupported(id3);
        }
        if (this.options.shimDisconnect)
          this.storage?.setItem(this.shimDisconnectKey, true);
        return { account, chain: { id: id3, unsupported } };
      } catch (error) {
        if (this.isUserRejectedRequestError(error))
          throw new UserRejectedRequestError(error);
        if (error.code === -32002)
          throw new ResourceUnavailableRpcError(error);
        throw error;
      }
    }
    async disconnect() {
      const provider = await this.getProvider();
      if (!provider?.removeListener)
        return;
      provider.removeListener("accountsChanged", this.onAccountsChanged);
      provider.removeListener("chainChanged", this.onChainChanged);
      provider.removeListener("disconnect", this.onDisconnect);
      if (this.options.shimDisconnect)
        this.storage?.removeItem(this.shimDisconnectKey);
    }
    async getAccount() {
      const provider = await this.getProvider();
      if (!provider)
        throw new ConnectorNotFoundError();
      const accounts = await provider.request({
        method: "eth_accounts"
      });
      return getAddress(accounts[0]);
    }
    async getChainId() {
      const provider = await this.getProvider();
      if (!provider)
        throw new ConnectorNotFoundError();
      return provider.request({ method: "eth_chainId" }).then(normalizeChainId);
    }
    async getProvider() {
      const provider = this.options.getProvider();
      if (provider)
        __privateSet(this, _provider, provider);
      return __privateGet(this, _provider);
    }
    async getWalletClient({
      chainId
    } = {}) {
      const [provider, account] = await Promise.all([
        this.getProvider(),
        this.getAccount()
      ]);
      const chain = this.chains.find((x4) => x4.id === chainId);
      if (!provider)
        throw new Error("provider is required.");
      return createWalletClient({
        account,
        chain,
        transport: custom(provider)
      });
    }
    async isAuthorized() {
      try {
        if (this.options.shimDisconnect && !this.storage?.getItem(this.shimDisconnectKey))
          return false;
        const provider = await this.getProvider();
        if (!provider)
          throw new ConnectorNotFoundError();
        const account = await this.getAccount();
        return !!account;
      } catch {
        return false;
      }
    }
    async switchChain(chainId) {
      const provider = await this.getProvider();
      if (!provider)
        throw new ConnectorNotFoundError();
      const id3 = numberToHex(chainId);
      try {
        await Promise.all([
          provider.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: id3 }]
          }),
          new Promise(
            (res) => this.on("change", ({ chain }) => {
              if (chain?.id === chainId)
                res();
            })
          )
        ]);
        return this.chains.find((x4) => x4.id === chainId) ?? {
          id: chainId,
          name: `Chain ${id3}`,
          network: `${id3}`,
          nativeCurrency: { name: "Ether", decimals: 18, symbol: "ETH" },
          rpcUrls: { default: { http: [""] }, public: { http: [""] } }
        };
      } catch (error) {
        const chain = this.chains.find((x4) => x4.id === chainId);
        if (!chain)
          throw new ChainNotConfiguredForConnectorError({
            chainId,
            connectorId: this.id
          });
        if (error.code === 4902 || error?.data?.originalError?.code === 4902) {
          try {
            await provider.request({
              method: "wallet_addEthereumChain",
              params: [
                {
                  chainId: id3,
                  chainName: chain.name,
                  nativeCurrency: chain.nativeCurrency,
                  rpcUrls: [chain.rpcUrls.public?.http[0] ?? ""],
                  blockExplorerUrls: this.getBlockExplorerUrls(chain)
                }
              ]
            });
            const currentChainId = await this.getChainId();
            if (currentChainId !== chainId)
              throw new UserRejectedRequestError(
                new Error("User rejected switch after adding network.")
              );
            return chain;
          } catch (error2) {
            throw new UserRejectedRequestError(error2);
          }
        }
        if (this.isUserRejectedRequestError(error))
          throw new UserRejectedRequestError(error);
        throw new SwitchChainError(error);
      }
    }
    async watchAsset({
      address,
      decimals = 18,
      image,
      symbol
    }) {
      const provider = await this.getProvider();
      if (!provider)
        throw new ConnectorNotFoundError();
      return provider.request({
        method: "wallet_watchAsset",
        params: {
          type: "ERC20",
          options: {
            address,
            decimals,
            image,
            symbol
          }
        }
      });
    }
    isUserRejectedRequestError(error) {
      return error.code === 4001;
    }
  };
  _provider = /* @__PURE__ */ new WeakMap();

  // node_modules/@wagmi/core/dist/chunk-MQXBDTVK.js
  var __accessCheck2 = (obj, member, msg) => {
    if (!member.has(obj))
      throw TypeError("Cannot " + msg);
  };
  var __privateGet2 = (obj, member, getter) => {
    __accessCheck2(obj, member, "read from private field");
    return getter ? getter.call(obj) : member.get(obj);
  };
  var __privateAdd2 = (obj, member, value) => {
    if (member.has(obj))
      throw TypeError("Cannot add the same private member more than once");
    member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
  };
  var __privateSet2 = (obj, member, value, setter) => {
    __accessCheck2(obj, member, "write to private field");
    setter ? setter.call(obj, value) : member.set(obj, value);
    return value;
  };
  var __privateMethod2 = (obj, member, method) => {
    __accessCheck2(obj, member, "access private method");
    return method;
  };

  // node_modules/zustand/esm/middleware.mjs
  var import_meta = {};
  var subscribeWithSelectorImpl = (fn2) => (set2, get2, api) => {
    const origSubscribe = api.subscribe;
    api.subscribe = (selector, optListener, options2) => {
      let listener = selector;
      if (optListener) {
        const equalityFn = (options2 == null ? void 0 : options2.equalityFn) || Object.is;
        let currentSlice = selector(api.getState());
        listener = (state) => {
          const nextSlice = selector(state);
          if (!equalityFn(currentSlice, nextSlice)) {
            const previousSlice = currentSlice;
            optListener(currentSlice = nextSlice, previousSlice);
          }
        };
        if (options2 == null ? void 0 : options2.fireImmediately) {
          optListener(currentSlice, currentSlice);
        }
      }
      return origSubscribe(listener);
    };
    const initialState = fn2(set2, get2, api);
    return initialState;
  };
  var subscribeWithSelector = subscribeWithSelectorImpl;
  function createJSONStorage(getStorage, options2) {
    let storage;
    try {
      storage = getStorage();
    } catch (e9) {
      return;
    }
    const persistStorage = {
      getItem: (name2) => {
        var _a2;
        const parse4 = (str2) => {
          if (str2 === null) {
            return null;
          }
          return JSON.parse(str2, options2 == null ? void 0 : options2.reviver);
        };
        const str = (_a2 = storage.getItem(name2)) != null ? _a2 : null;
        if (str instanceof Promise) {
          return str.then(parse4);
        }
        return parse4(str);
      },
      setItem: (name2, newValue) => storage.setItem(
        name2,
        JSON.stringify(newValue, options2 == null ? void 0 : options2.replacer)
      ),
      removeItem: (name2) => storage.removeItem(name2)
    };
    return persistStorage;
  }
  var toThenable = (fn2) => (input) => {
    try {
      const result = fn2(input);
      if (result instanceof Promise) {
        return result;
      }
      return {
        then(onFulfilled) {
          return toThenable(onFulfilled)(result);
        },
        catch(_onRejected) {
          return this;
        }
      };
    } catch (e9) {
      return {
        then(_onFulfilled) {
          return this;
        },
        catch(onRejected) {
          return toThenable(onRejected)(e9);
        }
      };
    }
  };
  var oldImpl = (config2, baseOptions) => (set2, get2, api) => {
    let options2 = {
      getStorage: () => localStorage,
      serialize: JSON.stringify,
      deserialize: JSON.parse,
      partialize: (state) => state,
      version: 0,
      merge: (persistedState, currentState) => ({
        ...currentState,
        ...persistedState
      }),
      ...baseOptions
    };
    let hasHydrated = false;
    const hydrationListeners = /* @__PURE__ */ new Set();
    const finishHydrationListeners = /* @__PURE__ */ new Set();
    let storage;
    try {
      storage = options2.getStorage();
    } catch (e9) {
    }
    if (!storage) {
      return config2(
        (...args) => {
          console.warn(
            `[zustand persist middleware] Unable to update item '${options2.name}', the given storage is currently unavailable.`
          );
          set2(...args);
        },
        get2,
        api
      );
    }
    const thenableSerialize = toThenable(options2.serialize);
    const setItem = () => {
      const state = options2.partialize({ ...get2() });
      let errorInSync;
      const thenable = thenableSerialize({ state, version: options2.version }).then(
        (serializedValue) => storage.setItem(options2.name, serializedValue)
      ).catch((e9) => {
        errorInSync = e9;
      });
      if (errorInSync) {
        throw errorInSync;
      }
      return thenable;
    };
    const savedSetState = api.setState;
    api.setState = (state, replace) => {
      savedSetState(state, replace);
      void setItem();
    };
    const configResult = config2(
      (...args) => {
        set2(...args);
        void setItem();
      },
      get2,
      api
    );
    let stateFromStorage;
    const hydrate2 = () => {
      var _a2;
      if (!storage)
        return;
      hasHydrated = false;
      hydrationListeners.forEach((cb) => cb(get2()));
      const postRehydrationCallback = ((_a2 = options2.onRehydrateStorage) == null ? void 0 : _a2.call(options2, get2())) || void 0;
      return toThenable(storage.getItem.bind(storage))(options2.name).then((storageValue) => {
        if (storageValue) {
          return options2.deserialize(storageValue);
        }
      }).then((deserializedStorageValue) => {
        if (deserializedStorageValue) {
          if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options2.version) {
            if (options2.migrate) {
              return options2.migrate(
                deserializedStorageValue.state,
                deserializedStorageValue.version
              );
            }
            console.error(
              `State loaded from storage couldn't be migrated since no migrate function was provided`
            );
          } else {
            return deserializedStorageValue.state;
          }
        }
      }).then((migratedState) => {
        var _a22;
        stateFromStorage = options2.merge(
          migratedState,
          (_a22 = get2()) != null ? _a22 : configResult
        );
        set2(stateFromStorage, true);
        return setItem();
      }).then(() => {
        postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);
        hasHydrated = true;
        finishHydrationListeners.forEach((cb) => cb(stateFromStorage));
      }).catch((e9) => {
        postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e9);
      });
    };
    api.persist = {
      setOptions: (newOptions) => {
        options2 = {
          ...options2,
          ...newOptions
        };
        if (newOptions.getStorage) {
          storage = newOptions.getStorage();
        }
      },
      clearStorage: () => {
        storage == null ? void 0 : storage.removeItem(options2.name);
      },
      getOptions: () => options2,
      rehydrate: () => hydrate2(),
      hasHydrated: () => hasHydrated,
      onHydrate: (cb) => {
        hydrationListeners.add(cb);
        return () => {
          hydrationListeners.delete(cb);
        };
      },
      onFinishHydration: (cb) => {
        finishHydrationListeners.add(cb);
        return () => {
          finishHydrationListeners.delete(cb);
        };
      }
    };
    hydrate2();
    return stateFromStorage || configResult;
  };
  var newImpl = (config2, baseOptions) => (set2, get2, api) => {
    let options2 = {
      storage: createJSONStorage(() => localStorage),
      partialize: (state) => state,
      version: 0,
      merge: (persistedState, currentState) => ({
        ...currentState,
        ...persistedState
      }),
      ...baseOptions
    };
    let hasHydrated = false;
    const hydrationListeners = /* @__PURE__ */ new Set();
    const finishHydrationListeners = /* @__PURE__ */ new Set();
    let storage = options2.storage;
    if (!storage) {
      return config2(
        (...args) => {
          console.warn(
            `[zustand persist middleware] Unable to update item '${options2.name}', the given storage is currently unavailable.`
          );
          set2(...args);
        },
        get2,
        api
      );
    }
    const setItem = () => {
      const state = options2.partialize({ ...get2() });
      return storage.setItem(options2.name, {
        state,
        version: options2.version
      });
    };
    const savedSetState = api.setState;
    api.setState = (state, replace) => {
      savedSetState(state, replace);
      void setItem();
    };
    const configResult = config2(
      (...args) => {
        set2(...args);
        void setItem();
      },
      get2,
      api
    );
    let stateFromStorage;
    const hydrate2 = () => {
      var _a2, _b;
      if (!storage)
        return;
      hasHydrated = false;
      hydrationListeners.forEach((cb) => {
        var _a22;
        return cb((_a22 = get2()) != null ? _a22 : configResult);
      });
      const postRehydrationCallback = ((_b = options2.onRehydrateStorage) == null ? void 0 : _b.call(options2, (_a2 = get2()) != null ? _a2 : configResult)) || void 0;
      return toThenable(storage.getItem.bind(storage))(options2.name).then((deserializedStorageValue) => {
        if (deserializedStorageValue) {
          if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options2.version) {
            if (options2.migrate) {
              return options2.migrate(
                deserializedStorageValue.state,
                deserializedStorageValue.version
              );
            }
            console.error(
              `State loaded from storage couldn't be migrated since no migrate function was provided`
            );
          } else {
            return deserializedStorageValue.state;
          }
        }
      }).then((migratedState) => {
        var _a22;
        stateFromStorage = options2.merge(
          migratedState,
          (_a22 = get2()) != null ? _a22 : configResult
        );
        set2(stateFromStorage, true);
        return setItem();
      }).then(() => {
        postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);
        stateFromStorage = get2();
        hasHydrated = true;
        finishHydrationListeners.forEach((cb) => cb(stateFromStorage));
      }).catch((e9) => {
        postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e9);
      });
    };
    api.persist = {
      setOptions: (newOptions) => {
        options2 = {
          ...options2,
          ...newOptions
        };
        if (newOptions.storage) {
          storage = newOptions.storage;
        }
      },
      clearStorage: () => {
        storage == null ? void 0 : storage.removeItem(options2.name);
      },
      getOptions: () => options2,
      rehydrate: () => hydrate2(),
      hasHydrated: () => hasHydrated,
      onHydrate: (cb) => {
        hydrationListeners.add(cb);
        return () => {
          hydrationListeners.delete(cb);
        };
      },
      onFinishHydration: (cb) => {
        finishHydrationListeners.add(cb);
        return () => {
          finishHydrationListeners.delete(cb);
        };
      }
    };
    if (!options2.skipHydration) {
      hydrate2();
    }
    return stateFromStorage || configResult;
  };
  var persistImpl = (config2, baseOptions) => {
    if ("getStorage" in baseOptions || "serialize" in baseOptions || "deserialize" in baseOptions) {
      if ((import_meta.env ? import_meta.env.MODE : void 0) !== "production") {
        console.warn(
          "[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."
        );
      }
      return oldImpl(config2, baseOptions);
    }
    return newImpl(config2, baseOptions);
  };
  var persist = persistImpl;

  // node_modules/zustand/esm/vanilla.mjs
  var import_meta2 = {};
  var createStoreImpl = (createState) => {
    let state;
    const listeners = /* @__PURE__ */ new Set();
    const setState = (partial, replace) => {
      const nextState = typeof partial === "function" ? partial(state) : partial;
      if (!Object.is(nextState, state)) {
        const previousState = state;
        state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
        listeners.forEach((listener) => listener(state, previousState));
      }
    };
    const getState = () => state;
    const subscribe3 = (listener) => {
      listeners.add(listener);
      return () => listeners.delete(listener);
    };
    const destroy = () => {
      if ((import_meta2.env ? import_meta2.env.MODE : void 0) !== "production") {
        console.warn(
          "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
        );
      }
      listeners.clear();
    };
    const api = { setState, getState, subscribe: subscribe3, destroy };
    state = createState(setState, getState, api);
    return api;
  };
  var createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;

  // node_modules/zustand/esm/shallow.mjs
  function shallow$1(objA, objB) {
    if (Object.is(objA, objB)) {
      return true;
    }
    if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
      return false;
    }
    if (objA instanceof Map && objB instanceof Map) {
      if (objA.size !== objB.size)
        return false;
      for (const [key2, value] of objA) {
        if (!Object.is(value, objB.get(key2))) {
          return false;
        }
      }
      return true;
    }
    if (objA instanceof Set && objB instanceof Set) {
      if (objA.size !== objB.size)
        return false;
      for (const value of objA) {
        if (!objB.has(value)) {
          return false;
        }
      }
      return true;
    }
    const keysA = Object.keys(objA);
    if (keysA.length !== Object.keys(objB).length) {
      return false;
    }
    for (let i7 = 0; i7 < keysA.length; i7++) {
      if (!Object.prototype.hasOwnProperty.call(objB, keysA[i7]) || !Object.is(objA[keysA[i7]], objB[keysA[i7]])) {
        return false;
      }
    }
    return true;
  }

  // node_modules/@wagmi/core/dist/chunk-TSH6VVF4.js
  function configureChains(defaultChains, providers, {
    batch = { multicall: { wait: 32 } },
    pollingInterval = 4e3,
    rank,
    retryCount,
    retryDelay,
    stallTimeout
  } = {}) {
    if (!defaultChains.length)
      throw new Error("must have at least one chain");
    let chains2 = [];
    const httpUrls = {};
    const wsUrls = {};
    for (const chain of defaultChains) {
      let configExists = false;
      for (const provider of providers) {
        const apiConfig = provider(chain);
        if (!apiConfig)
          continue;
        configExists = true;
        if (!chains2.some(({ id: id3 }) => id3 === chain.id)) {
          chains2 = [...chains2, apiConfig.chain];
        }
        httpUrls[chain.id] = [
          ...httpUrls[chain.id] || [],
          ...apiConfig.rpcUrls.http
        ];
        if (apiConfig.rpcUrls.webSocket) {
          wsUrls[chain.id] = [
            ...wsUrls[chain.id] || [],
            ...apiConfig.rpcUrls.webSocket
          ];
        }
      }
      if (!configExists) {
        throw new Error(
          [
            `Could not find valid provider configuration for chain "${chain.name}".
`,
            "You may need to add `jsonRpcProvider` to `configureChains` with the chain's RPC URLs.",
            "Read more: https://wagmi.sh/core/providers/jsonRpc"
          ].join("\n")
        );
      }
    }
    return {
      chains: chains2,
      publicClient: ({ chainId }) => {
        const activeChain = chains2.find((x4) => x4.id === chainId) ?? defaultChains[0];
        const chainHttpUrls = httpUrls[activeChain.id];
        if (!chainHttpUrls || !chainHttpUrls[0])
          throw new Error(`No providers configured for chain "${activeChain.id}"`);
        const publicClient2 = createPublicClient({
          batch,
          chain: activeChain,
          transport: fallback(
            chainHttpUrls.map((url) => http2(url, { timeout: stallTimeout })),
            { rank, retryCount, retryDelay }
          ),
          pollingInterval
        });
        return Object.assign(publicClient2, {
          chains: chains2
        });
      },
      webSocketPublicClient: ({ chainId }) => {
        const activeChain = chains2.find((x4) => x4.id === chainId) ?? defaultChains[0];
        const chainWsUrls = wsUrls[activeChain.id];
        if (!chainWsUrls || !chainWsUrls[0])
          return void 0;
        const publicClient2 = createPublicClient({
          batch,
          chain: activeChain,
          transport: fallback(
            chainWsUrls.map((url) => webSocket2(url, { timeout: stallTimeout })),
            { rank, retryCount, retryDelay }
          ),
          pollingInterval
        });
        return Object.assign(publicClient2, {
          chains: chains2
        });
      }
    };
  }
  var ChainNotConfiguredError = class extends Error {
    constructor({
      chainId,
      connectorId
    }) {
      super(
        `Chain "${chainId}" not configured${connectorId ? ` for connector "${connectorId}"` : ""}.`
      );
      this.name = "ChainNotConfigured";
    }
  };
  var ConnectorAlreadyConnectedError = class extends Error {
    constructor() {
      super(...arguments);
      this.name = "ConnectorAlreadyConnectedError";
      this.message = "Connector already connected";
    }
  };
  var ConfigChainsNotFound = class extends Error {
    constructor() {
      super(...arguments);
      this.name = "ConfigChainsNotFound";
      this.message = "No chains were found on the wagmi config. Some functions that require a chain may not work.";
    }
  };
  var SwitchChainNotSupportedError = class extends Error {
    constructor({ connector }) {
      super(`"${connector.name}" does not support programmatic chain switching.`);
      this.name = "SwitchChainNotSupportedError";
    }
  };
  function deepEqual(a6, b7) {
    if (a6 === b7)
      return true;
    if (a6 && b7 && typeof a6 === "object" && typeof b7 === "object") {
      if (a6.constructor !== b7.constructor)
        return false;
      let length2;
      let i7;
      if (Array.isArray(a6) && Array.isArray(b7)) {
        length2 = a6.length;
        if (length2 != b7.length)
          return false;
        for (i7 = length2; i7-- !== 0; )
          if (!deepEqual(a6[i7], b7[i7]))
            return false;
        return true;
      }
      if (a6.valueOf !== Object.prototype.valueOf)
        return a6.valueOf() === b7.valueOf();
      if (a6.toString !== Object.prototype.toString)
        return a6.toString() === b7.toString();
      const keys2 = Object.keys(a6);
      length2 = keys2.length;
      if (length2 !== Object.keys(b7).length)
        return false;
      for (i7 = length2; i7-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(b7, keys2[i7]))
          return false;
      for (i7 = length2; i7-- !== 0; ) {
        const key2 = keys2[i7];
        if (key2 && !deepEqual(a6[key2], b7[key2]))
          return false;
      }
      return true;
    }
    return a6 !== a6 && b7 !== b7;
  }
  var findAndReplace = (cacheRef, {
    find,
    replace
  }) => {
    if (cacheRef && find(cacheRef)) {
      return replace(cacheRef);
    }
    if (typeof cacheRef !== "object") {
      return cacheRef;
    }
    if (Array.isArray(cacheRef)) {
      return cacheRef.map((item) => findAndReplace(item, { find, replace }));
    }
    if (cacheRef instanceof Object) {
      return Object.entries(cacheRef).reduce(
        (curr, [key2, value]) => ({
          ...curr,
          [key2]: findAndReplace(value, { find, replace })
        }),
        {}
      );
    }
    return cacheRef;
  };
  function deserialize(cachedString) {
    const cache = JSON.parse(cachedString);
    const deserializedCacheWithBigInts = findAndReplace(cache, {
      find: (data2) => typeof data2 === "string" && data2.startsWith("#bigint."),
      replace: (data2) => BigInt(data2.replace("#bigint.", ""))
    });
    return deserializedCacheWithBigInts;
  }
  function getUnit(unit) {
    if (typeof unit === "number")
      return unit;
    if (unit === "wei")
      return 0;
    return Math.abs(weiUnits[unit]);
  }
  function getReferenceKey(keys2, cutoff) {
    return keys2.slice(0, cutoff).join(".") || ".";
  }
  function getCutoff(array, value) {
    const { length: length2 } = array;
    for (let index2 = 0; index2 < length2; ++index2) {
      if (array[index2] === value) {
        return index2 + 1;
      }
    }
    return 0;
  }
  function createReplacer(replacer, circularReplacer) {
    const hasReplacer = typeof replacer === "function";
    const hasCircularReplacer = typeof circularReplacer === "function";
    const cache = [];
    const keys2 = [];
    return function replace(key2, value) {
      if (typeof value === "object") {
        if (cache.length) {
          const thisCutoff = getCutoff(cache, this);
          if (thisCutoff === 0) {
            cache[cache.length] = this;
          } else {
            cache.splice(thisCutoff);
            keys2.splice(thisCutoff);
          }
          keys2[keys2.length] = key2;
          const valueCutoff = getCutoff(cache, value);
          if (valueCutoff !== 0) {
            return hasCircularReplacer ? circularReplacer.call(
              this,
              key2,
              value,
              getReferenceKey(keys2, valueCutoff)
            ) : `[ref=${getReferenceKey(keys2, valueCutoff)}]`;
          }
        } else {
          cache[0] = value;
          keys2[0] = key2;
        }
      }
      return hasReplacer ? replacer.call(this, key2, value) : value;
    };
  }
  function serialize(value, replacer, indent, circularReplacer) {
    return JSON.stringify(
      value,
      createReplacer((key2, value_) => {
        const value2 = typeof value_ === "bigint" ? `#bigint.${value_.toString()}` : value_;
        return replacer?.(key2, value2) || value2;
      }, circularReplacer),
      indent ?? void 0
    );
  }
  var noopStorage = {
    getItem: (_key) => "",
    setItem: (_key, _value) => null,
    removeItem: (_key) => null
  };
  function createStorage({
    deserialize: deserialize2 = deserialize,
    key: prefix = "wagmi",
    serialize: serialize22 = serialize,
    storage
  }) {
    return {
      ...storage,
      getItem: (key2, defaultState = null) => {
        const value = storage.getItem(`${prefix}.${key2}`);
        try {
          return value ? deserialize2(value) : defaultState;
        } catch (error) {
          console.warn(error);
          return defaultState;
        }
      },
      setItem: (key2, value) => {
        if (value === null) {
          storage.removeItem(`${prefix}.${key2}`);
        } else {
          try {
            storage.setItem(`${prefix}.${key2}`, serialize22(value));
          } catch (err) {
            console.error(err);
          }
        }
      },
      removeItem: (key2) => storage.removeItem(`${prefix}.${key2}`)
    };
  }
  var storeKey = "store";
  var _isAutoConnecting;
  var _lastUsedConnector;
  var _addEffects;
  var addEffects_fn;
  var Config = class {
    constructor({
      autoConnect = false,
      connectors = [new InjectedConnector()],
      publicClient: publicClient2,
      storage = createStorage({
        storage: typeof window !== "undefined" ? window.localStorage : noopStorage
      }),
      logger: logger47 = {
        warn: console.warn
      },
      webSocketPublicClient
    }) {
      __privateAdd2(this, _addEffects);
      this.publicClients = /* @__PURE__ */ new Map();
      this.webSocketPublicClients = /* @__PURE__ */ new Map();
      __privateAdd2(this, _isAutoConnecting, void 0);
      __privateAdd2(this, _lastUsedConnector, void 0);
      this.args = {
        autoConnect,
        connectors,
        logger: logger47,
        publicClient: publicClient2,
        storage,
        webSocketPublicClient
      };
      let status = "disconnected";
      let chainId;
      if (autoConnect) {
        try {
          const rawState = storage.getItem(storeKey);
          const data2 = rawState?.state?.data;
          status = data2?.account ? "reconnecting" : "connecting";
          chainId = data2?.chain?.id;
        } catch (_error) {
        }
      }
      const connectors_ = typeof connectors === "function" ? connectors() : connectors;
      connectors_.forEach((connector) => connector.setStorage(storage));
      this.store = createStore(
        subscribeWithSelector(
          persist(
            () => ({
              connectors: connectors_,
              publicClient: this.getPublicClient({ chainId }),
              status,
              webSocketPublicClient: this.getWebSocketPublicClient({ chainId })
            }),
            {
              name: storeKey,
              storage,
              partialize: (state) => ({
                ...autoConnect && {
                  data: {
                    account: state?.data?.account,
                    chain: state?.data?.chain
                  }
                },
                chains: state?.chains
              }),
              version: 2
            }
          )
        )
      );
      this.storage = storage;
      __privateSet2(this, _lastUsedConnector, storage?.getItem("wallet"));
      __privateMethod2(this, _addEffects, addEffects_fn).call(this);
      if (autoConnect && typeof window !== "undefined")
        setTimeout(async () => await this.autoConnect(), 0);
    }
    get chains() {
      return this.store.getState().chains;
    }
    get connectors() {
      return this.store.getState().connectors;
    }
    get connector() {
      return this.store.getState().connector;
    }
    get data() {
      return this.store.getState().data;
    }
    get error() {
      return this.store.getState().error;
    }
    get lastUsedChainId() {
      return this.data?.chain?.id;
    }
    get publicClient() {
      return this.store.getState().publicClient;
    }
    get status() {
      return this.store.getState().status;
    }
    get subscribe() {
      return this.store.subscribe;
    }
    get webSocketPublicClient() {
      return this.store.getState().webSocketPublicClient;
    }
    setState(updater) {
      const newState = typeof updater === "function" ? updater(this.store.getState()) : updater;
      this.store.setState(newState, true);
    }
    clearState() {
      this.setState((x4) => ({
        ...x4,
        chains: void 0,
        connector: void 0,
        data: void 0,
        error: void 0,
        status: "disconnected"
      }));
    }
    async destroy() {
      if (this.connector)
        await this.connector.disconnect?.();
      __privateSet2(this, _isAutoConnecting, false);
      this.clearState();
      this.store.destroy();
    }
    async autoConnect() {
      if (__privateGet2(this, _isAutoConnecting))
        return;
      __privateSet2(this, _isAutoConnecting, true);
      this.setState((x4) => ({
        ...x4,
        status: x4.data?.account ? "reconnecting" : "connecting"
      }));
      const sorted = __privateGet2(this, _lastUsedConnector) ? [...this.connectors].sort(
        (x4) => x4.id === __privateGet2(this, _lastUsedConnector) ? -1 : 1
      ) : this.connectors;
      let connected = false;
      for (const connector of sorted) {
        if (!connector.ready || !connector.isAuthorized)
          continue;
        const isAuthorized = await connector.isAuthorized();
        if (!isAuthorized)
          continue;
        const data2 = await connector.connect();
        this.setState((x4) => ({
          ...x4,
          connector,
          chains: connector?.chains,
          data: data2,
          status: "connected"
        }));
        connected = true;
        break;
      }
      if (!connected)
        this.setState((x4) => ({
          ...x4,
          data: void 0,
          status: "disconnected"
        }));
      __privateSet2(this, _isAutoConnecting, false);
      return this.data;
    }
    setConnectors(connectors) {
      this.args = {
        ...this.args,
        connectors
      };
      const connectors_ = typeof connectors === "function" ? connectors() : connectors;
      connectors_.forEach((connector) => connector.setStorage(this.args.storage));
      this.setState((x4) => ({
        ...x4,
        connectors: connectors_
      }));
    }
    getPublicClient({ chainId } = {}) {
      let publicClient_ = this.publicClients.get(-1);
      if (publicClient_ && publicClient_?.chain.id === chainId)
        return publicClient_;
      publicClient_ = this.publicClients.get(chainId ?? -1);
      if (publicClient_)
        return publicClient_;
      const { publicClient: publicClient2 } = this.args;
      publicClient_ = typeof publicClient2 === "function" ? publicClient2({ chainId }) : publicClient2;
      this.publicClients.set(chainId ?? -1, publicClient_);
      return publicClient_;
    }
    setPublicClient(publicClient2) {
      const chainId = this.data?.chain?.id;
      this.args = {
        ...this.args,
        publicClient: publicClient2
      };
      this.publicClients.clear();
      this.setState((x4) => ({
        ...x4,
        publicClient: this.getPublicClient({ chainId })
      }));
    }
    getWebSocketPublicClient({ chainId } = {}) {
      let webSocketPublicClient_ = this.webSocketPublicClients.get(-1);
      if (webSocketPublicClient_ && webSocketPublicClient_?.chain.id === chainId)
        return webSocketPublicClient_;
      webSocketPublicClient_ = this.webSocketPublicClients.get(chainId ?? -1);
      if (webSocketPublicClient_)
        return webSocketPublicClient_;
      const { webSocketPublicClient } = this.args;
      webSocketPublicClient_ = typeof webSocketPublicClient === "function" ? webSocketPublicClient({ chainId }) : webSocketPublicClient;
      if (webSocketPublicClient_)
        this.webSocketPublicClients.set(chainId ?? -1, webSocketPublicClient_);
      return webSocketPublicClient_;
    }
    setWebSocketPublicClient(webSocketPublicClient) {
      const chainId = this.data?.chain?.id;
      this.args = {
        ...this.args,
        webSocketPublicClient
      };
      this.webSocketPublicClients.clear();
      this.setState((x4) => ({
        ...x4,
        webSocketPublicClient: this.getWebSocketPublicClient({
          chainId
        })
      }));
    }
    setLastUsedConnector(lastUsedConnector = null) {
      this.storage?.setItem("wallet", lastUsedConnector);
    }
  };
  _isAutoConnecting = /* @__PURE__ */ new WeakMap();
  _lastUsedConnector = /* @__PURE__ */ new WeakMap();
  _addEffects = /* @__PURE__ */ new WeakSet();
  addEffects_fn = function() {
    const onChange = (data2) => {
      this.setState((x4) => ({
        ...x4,
        data: { ...x4.data, ...data2 }
      }));
    };
    const onDisconnect = () => {
      this.clearState();
    };
    const onError2 = (error) => {
      this.setState((x4) => ({ ...x4, error }));
    };
    this.store.subscribe(
      ({ connector }) => connector,
      (connector, prevConnector) => {
        prevConnector?.off?.("change", onChange);
        prevConnector?.off?.("disconnect", onDisconnect);
        prevConnector?.off?.("error", onError2);
        if (!connector)
          return;
        connector.on?.("change", onChange);
        connector.on?.("disconnect", onDisconnect);
        connector.on?.("error", onError2);
      }
    );
    const { publicClient: publicClient2, webSocketPublicClient } = this.args;
    const subscribePublicClient = typeof publicClient2 === "function";
    const subscribeWebSocketPublicClient = typeof webSocketPublicClient === "function";
    if (subscribePublicClient || subscribeWebSocketPublicClient)
      this.store.subscribe(
        ({ data: data2 }) => data2?.chain?.id,
        (chainId) => {
          this.setState((x4) => ({
            ...x4,
            publicClient: this.getPublicClient({ chainId }),
            webSocketPublicClient: this.getWebSocketPublicClient({
              chainId
            })
          }));
        }
      );
  };
  var config;
  function createConfig(args) {
    const config_ = new Config(args);
    config = config_;
    return config_;
  }
  function getConfig() {
    if (!config) {
      throw new Error(
        "No wagmi config found. Ensure you have set up a config: https://wagmi.sh/react/config"
      );
    }
    return config;
  }
  async function connect({ chainId, connector }) {
    const config2 = getConfig();
    const activeConnector = config2.connector;
    if (activeConnector && connector.id === activeConnector.id)
      throw new ConnectorAlreadyConnectedError();
    try {
      config2.setState((x4) => ({ ...x4, status: "connecting" }));
      const data2 = await connector.connect({ chainId });
      config2.setLastUsedConnector(connector.id);
      config2.setState((x4) => ({
        ...x4,
        connector,
        chains: connector?.chains,
        data: data2,
        status: "connected"
      }));
      config2.storage.setItem("connected", true);
      return { ...data2, connector };
    } catch (err) {
      config2.setState((x4) => {
        return {
          ...x4,
          status: x4.connector ? "connected" : "disconnected"
        };
      });
      throw err;
    }
  }
  async function disconnect() {
    const config2 = getConfig();
    if (config2.connector)
      await config2.connector.disconnect();
    config2.clearState();
    config2.storage.removeItem("connected");
  }
  var erc20ABI = [
    {
      type: "event",
      name: "Approval",
      inputs: [
        {
          indexed: true,
          name: "owner",
          type: "address"
        },
        {
          indexed: true,
          name: "spender",
          type: "address"
        },
        {
          indexed: false,
          name: "value",
          type: "uint256"
        }
      ]
    },
    {
      type: "event",
      name: "Transfer",
      inputs: [
        {
          indexed: true,
          name: "from",
          type: "address"
        },
        {
          indexed: true,
          name: "to",
          type: "address"
        },
        {
          indexed: false,
          name: "value",
          type: "uint256"
        }
      ]
    },
    {
      type: "function",
      name: "allowance",
      stateMutability: "view",
      inputs: [
        {
          name: "owner",
          type: "address"
        },
        {
          name: "spender",
          type: "address"
        }
      ],
      outputs: [
        {
          name: "",
          type: "uint256"
        }
      ]
    },
    {
      type: "function",
      name: "approve",
      stateMutability: "nonpayable",
      inputs: [
        {
          name: "spender",
          type: "address"
        },
        {
          name: "amount",
          type: "uint256"
        }
      ],
      outputs: [
        {
          name: "",
          type: "bool"
        }
      ]
    },
    {
      type: "function",
      name: "balanceOf",
      stateMutability: "view",
      inputs: [
        {
          name: "account",
          type: "address"
        }
      ],
      outputs: [
        {
          name: "",
          type: "uint256"
        }
      ]
    },
    {
      type: "function",
      name: "decimals",
      stateMutability: "view",
      inputs: [],
      outputs: [
        {
          name: "",
          type: "uint8"
        }
      ]
    },
    {
      type: "function",
      name: "name",
      stateMutability: "view",
      inputs: [],
      outputs: [
        {
          name: "",
          type: "string"
        }
      ]
    },
    {
      type: "function",
      name: "symbol",
      stateMutability: "view",
      inputs: [],
      outputs: [
        {
          name: "",
          type: "string"
        }
      ]
    },
    {
      type: "function",
      name: "totalSupply",
      stateMutability: "view",
      inputs: [],
      outputs: [
        {
          name: "",
          type: "uint256"
        }
      ]
    },
    {
      type: "function",
      name: "transfer",
      stateMutability: "nonpayable",
      inputs: [
        {
          name: "recipient",
          type: "address"
        },
        {
          name: "amount",
          type: "uint256"
        }
      ],
      outputs: [
        {
          name: "",
          type: "bool"
        }
      ]
    },
    {
      type: "function",
      name: "transferFrom",
      stateMutability: "nonpayable",
      inputs: [
        {
          name: "sender",
          type: "address"
        },
        {
          name: "recipient",
          type: "address"
        },
        {
          name: "amount",
          type: "uint256"
        }
      ],
      outputs: [
        {
          name: "",
          type: "bool"
        }
      ]
    }
  ];
  var erc20ABI_bytes32 = [
    {
      type: "event",
      name: "Approval",
      inputs: [
        {
          indexed: true,
          name: "owner",
          type: "address"
        },
        {
          indexed: true,
          name: "spender",
          type: "address"
        },
        {
          indexed: false,
          name: "value",
          type: "uint256"
        }
      ]
    },
    {
      type: "event",
      name: "Transfer",
      inputs: [
        {
          indexed: true,
          name: "from",
          type: "address"
        },
        {
          indexed: true,
          name: "to",
          type: "address"
        },
        {
          indexed: false,
          name: "value",
          type: "uint256"
        }
      ]
    },
    {
      type: "function",
      name: "allowance",
      stateMutability: "view",
      inputs: [
        {
          name: "owner",
          type: "address"
        },
        {
          name: "spender",
          type: "address"
        }
      ],
      outputs: [
        {
          name: "",
          type: "uint256"
        }
      ]
    },
    {
      type: "function",
      name: "approve",
      stateMutability: "nonpayable",
      inputs: [
        {
          name: "spender",
          type: "address"
        },
        {
          name: "amount",
          type: "uint256"
        }
      ],
      outputs: [
        {
          name: "",
          type: "bool"
        }
      ]
    },
    {
      type: "function",
      name: "balanceOf",
      stateMutability: "view",
      inputs: [
        {
          name: "account",
          type: "address"
        }
      ],
      outputs: [
        {
          name: "",
          type: "uint256"
        }
      ]
    },
    {
      type: "function",
      name: "decimals",
      stateMutability: "view",
      inputs: [],
      outputs: [
        {
          name: "",
          type: "uint8"
        }
      ]
    },
    {
      type: "function",
      name: "name",
      stateMutability: "view",
      inputs: [],
      outputs: [
        {
          name: "",
          type: "bytes32"
        }
      ]
    },
    {
      type: "function",
      name: "symbol",
      stateMutability: "view",
      inputs: [],
      outputs: [
        {
          name: "",
          type: "bytes32"
        }
      ]
    },
    {
      type: "function",
      name: "totalSupply",
      stateMutability: "view",
      inputs: [],
      outputs: [
        {
          name: "",
          type: "uint256"
        }
      ]
    },
    {
      type: "function",
      name: "transfer",
      stateMutability: "nonpayable",
      inputs: [
        {
          name: "recipient",
          type: "address"
        },
        {
          name: "amount",
          type: "uint256"
        }
      ],
      outputs: [
        {
          name: "",
          type: "bool"
        }
      ]
    },
    {
      type: "function",
      name: "transferFrom",
      stateMutability: "nonpayable",
      inputs: [
        {
          name: "sender",
          type: "address"
        },
        {
          name: "recipient",
          type: "address"
        },
        {
          name: "amount",
          type: "uint256"
        }
      ],
      outputs: [
        {
          name: "",
          type: "bool"
        }
      ]
    }
  ];
  function getPublicClient({ chainId } = {}) {
    const config2 = getConfig();
    if (chainId)
      return config2.getPublicClient({ chainId }) || config2.publicClient;
    return config2.publicClient;
  }
  async function multicall2({
    chainId,
    contracts,
    blockNumber,
    blockTag,
    ...args
  }) {
    const publicClient2 = getPublicClient({ chainId });
    if (!publicClient2.chains)
      throw new ConfigChainsNotFound();
    if (chainId && publicClient2.chain.id !== chainId)
      throw new ChainNotConfiguredError({ chainId });
    return publicClient2.multicall({
      allowFailure: args.allowFailure ?? true,
      blockNumber,
      blockTag,
      contracts
    });
  }
  async function readContract2({
    address,
    account,
    chainId,
    abi,
    args,
    functionName,
    blockNumber,
    blockTag
  }) {
    const publicClient2 = getPublicClient({ chainId });
    return publicClient2.readContract({
      abi,
      address,
      account,
      functionName,
      args,
      blockNumber,
      blockTag
    });
  }
  async function readContracts({
    contracts,
    blockNumber,
    blockTag,
    ...args
  }) {
    const { allowFailure = true } = args;
    try {
      const publicClient2 = getPublicClient();
      const contractsByChainId = contracts.reduce((contracts2, contract, index2) => {
        const chainId = contract.chainId ?? publicClient2.chain.id;
        return {
          ...contracts2,
          [chainId]: [...contracts2[chainId] || [], { contract, index: index2 }]
        };
      }, {});
      const promises = () => Object.entries(contractsByChainId).map(
        ([chainId, contracts2]) => multicall2({
          allowFailure,
          chainId: parseInt(chainId),
          contracts: contracts2.map(
            ({ contract }) => contract
          ),
          blockNumber,
          blockTag
        })
      );
      const multicallResults = (await Promise.all(promises())).flat();
      const resultIndexes = Object.values(contractsByChainId).flatMap(
        (contracts2) => contracts2.map(({ index: index2 }) => index2)
      );
      return multicallResults.reduce((results2, result, index2) => {
        if (results2)
          results2[resultIndexes[index2]] = result;
        return results2;
      }, []);
    } catch (err) {
      if (err instanceof ContractFunctionExecutionError)
        throw err;
      const promises = () => contracts.map(
        (contract) => readContract2({ ...contract, blockNumber, blockTag })
      );
      if (allowFailure)
        return (await Promise.allSettled(promises())).map((result) => {
          if (result.status === "fulfilled")
            return { result: result.value, status: "success" };
          return { error: result.reason, result: void 0, status: "failure" };
        });
      return await Promise.all(promises());
    }
  }
  async function fetchBalance({
    address,
    chainId,
    formatUnits: unit,
    token
  }) {
    const config2 = getConfig();
    const publicClient2 = getPublicClient({ chainId });
    if (token) {
      const fetchContractBalance = async ({ abi }) => {
        const erc20Config = { abi, address: token, chainId };
        const [value2, decimals, symbol] = await readContracts({
          allowFailure: false,
          contracts: [
            {
              ...erc20Config,
              functionName: "balanceOf",
              args: [address]
            },
            { ...erc20Config, functionName: "decimals" },
            { ...erc20Config, functionName: "symbol" }
          ]
        });
        return {
          decimals,
          formatted: formatUnits(value2 ?? "0", getUnit(unit ?? decimals)),
          symbol,
          value: value2
        };
      };
      try {
        return await fetchContractBalance({ abi: erc20ABI });
      } catch (err) {
        if (err instanceof ContractFunctionExecutionError) {
          const { symbol, ...rest } = await fetchContractBalance({
            abi: erc20ABI_bytes32
          });
          return {
            symbol: hexToString(trim(symbol, { dir: "right" })),
            ...rest
          };
        }
        throw err;
      }
    }
    const chains2 = [
      ...config2.publicClient.chains || [],
      ...config2.chains ?? []
    ];
    const value = await publicClient2.getBalance({ address });
    const chain = chains2.find((x4) => x4.id === publicClient2.chain.id);
    return {
      decimals: chain?.nativeCurrency.decimals ?? 18,
      formatted: formatUnits(value ?? "0", getUnit(unit ?? 18)),
      symbol: chain?.nativeCurrency.symbol ?? "ETH",
      value
    };
  }
  function getAccount() {
    const { data: data2, connector, status } = getConfig();
    switch (status) {
      case "connected":
        return {
          address: data2?.account,
          connector,
          isConnected: true,
          isConnecting: false,
          isDisconnected: false,
          isReconnecting: false,
          status
        };
      case "reconnecting":
        return {
          address: data2?.account,
          connector,
          isConnected: !!data2?.account,
          isConnecting: false,
          isDisconnected: false,
          isReconnecting: true,
          status
        };
      case "connecting":
        return {
          address: data2?.account,
          connector,
          isConnected: false,
          isConnecting: true,
          isDisconnected: false,
          isReconnecting: false,
          status
        };
      case "disconnected":
        return {
          address: void 0,
          connector: void 0,
          isConnected: false,
          isConnecting: false,
          isDisconnected: true,
          isReconnecting: false,
          status
        };
    }
  }
  function getNetwork() {
    const config2 = getConfig();
    const chainId = config2.data?.chain?.id;
    const activeChains = config2.chains ?? [];
    const activeChain = [
      ...config2.publicClient?.chains || [],
      ...activeChains
    ].find((x4) => x4.id === chainId) ?? {
      id: chainId,
      name: `Chain ${chainId}`,
      network: `${chainId}`,
      nativeCurrency: { name: "Ether", decimals: 18, symbol: "ETH" },
      rpcUrls: {
        default: { http: [""] },
        public: { http: [""] }
      }
    };
    return {
      chain: chainId ? {
        ...activeChain,
        ...config2.data?.chain,
        id: chainId
      } : void 0,
      chains: activeChains
    };
  }
  async function switchNetwork({
    chainId
  }) {
    const { connector } = getConfig();
    if (!connector)
      throw new ConnectorNotFoundError();
    if (!connector.switchChain)
      throw new SwitchChainNotSupportedError({
        connector
      });
    return connector.switchChain(chainId);
  }
  function watchAccount(callback, { selector = (x4) => x4 } = {}) {
    const config2 = getConfig();
    const handleChange = () => callback(getAccount());
    const unsubscribe = config2.subscribe(
      ({ data: data2, connector, status }) => selector({
        address: data2?.account,
        connector,
        status
      }),
      handleChange,
      {
        equalityFn: shallow$1
      }
    );
    return unsubscribe;
  }
  function watchNetwork(callback, { selector = (x4) => x4 } = {}) {
    const config2 = getConfig();
    const handleChange = () => callback(getNetwork());
    const unsubscribe = config2.subscribe(
      ({ data: data2, chains: chains2 }) => selector({ chainId: data2?.chain?.id, chains: chains2 }),
      handleChange,
      {
        equalityFn: shallow$1
      }
    );
    return unsubscribe;
  }
  async function fetchEnsAvatar({
    name: name2,
    chainId
  }) {
    const { normalize: normalize3 } = await Promise.resolve().then(() => (init_ens2(), ens_exports));
    const publicClient2 = getPublicClient({ chainId });
    const avatar = await publicClient2.getEnsAvatar({ name: normalize3(name2) });
    return avatar;
  }
  async function fetchEnsName({
    address,
    chainId
  }) {
    const publicClient2 = getPublicClient({ chainId });
    return publicClient2.getEnsName({
      address: getAddress(address)
    });
  }

  // node_modules/@wagmi/connectors/node_modules/@walletconnect/utils/dist/index.es.js
  var import_chacha20poly1305 = __toESM(require_chacha20poly1305());
  var import_hkdf = __toESM(require_hkdf());
  var import_random = __toESM(require_random());
  var import_sha256 = __toESM(require_sha256());
  var fe = __toESM(require_x25519());
  init_src2();
  var import_time = __toESM(require_cjs());
  var import_window_getters = __toESM(require_cjs2());
  var import_window_metadata = __toESM(require_cjs3());
  var V = __toESM(require_query_string());
  init_esm();
  function S(e9 = [], n9 = []) {
    return [.../* @__PURE__ */ new Set([...e9, ...n9])];
  }
  var Ot = Object.defineProperty;
  var St = Object.defineProperties;
  var wt = Object.getOwnPropertyDescriptors;
  var ze = Object.getOwnPropertySymbols;
  var It = Object.prototype.hasOwnProperty;
  var Pt = Object.prototype.propertyIsEnumerable;
  var Ye = (e9, n9, t6) => n9 in e9 ? Ot(e9, n9, { enumerable: true, configurable: true, writable: true, value: t6 }) : e9[n9] = t6;
  var Tt = (e9, n9) => {
    for (var t6 in n9 || (n9 = {}))
      It.call(n9, t6) && Ye(e9, t6, n9[t6]);
    if (ze)
      for (var t6 of ze(n9))
        Pt.call(n9, t6) && Ye(e9, t6, n9[t6]);
    return e9;
  };
  var Rt = (e9, n9) => St(e9, wt(n9));
  function oe(e9) {
    return e9.includes(":");
  }
  function Xe(e9) {
    return oe(e9) ? e9.split(":")[0] : e9;
  }
  function se(e9) {
    var n9, t6, r8;
    const o9 = {};
    if (!B(e9))
      return o9;
    for (const [s7, i7] of Object.entries(e9)) {
      const l9 = oe(s7) ? [s7] : i7.chains, d7 = i7.methods || [], c9 = i7.events || [], u7 = Xe(s7);
      o9[u7] = Rt(Tt({}, o9[u7]), { chains: S(l9, (n9 = o9[u7]) == null ? void 0 : n9.chains), methods: S(d7, (t6 = o9[u7]) == null ? void 0 : t6.methods), events: S(c9, (r8 = o9[u7]) == null ? void 0 : r8.events) });
    }
    return o9;
  }
  function B(e9) {
    return Object.getPrototypeOf(e9) === Object.prototype && Object.keys(e9).length;
  }

  // node_modules/@wagmi/connectors/dist/walletConnect.js
  var NAMESPACE = "eip155";
  var STORE_KEY = "store";
  var REQUESTED_CHAINS_KEY = "requestedChains";
  var ADD_ETH_CHAIN_METHOD = "wallet_addEthereumChain";
  var _provider2;
  var _initProviderPromise;
  var _createProvider;
  var createProvider_fn;
  var _initProvider;
  var initProvider_fn;
  var _isChainsStale;
  var isChainsStale_fn;
  var _setupListeners;
  var setupListeners_fn;
  var _removeListeners;
  var removeListeners_fn;
  var _setRequestedChainsIds;
  var setRequestedChainsIds_fn;
  var _getRequestedChainsIds;
  var getRequestedChainsIds_fn;
  var _getNamespaceChainsIds;
  var getNamespaceChainsIds_fn;
  var _getNamespaceMethods;
  var getNamespaceMethods_fn;
  var WalletConnectConnector = class extends Connector {
    constructor(config2) {
      super({
        ...config2,
        options: { isNewChainsStale: true, ...config2.options }
      });
      __privateAdd(this, _createProvider);
      __privateAdd(this, _initProvider);
      __privateAdd(this, _isChainsStale);
      __privateAdd(this, _setupListeners);
      __privateAdd(this, _removeListeners);
      __privateAdd(this, _setRequestedChainsIds);
      __privateAdd(this, _getRequestedChainsIds);
      __privateAdd(this, _getNamespaceChainsIds);
      __privateAdd(this, _getNamespaceMethods);
      this.id = "walletConnect";
      this.name = "WalletConnect";
      this.ready = true;
      __privateAdd(this, _provider2, void 0);
      __privateAdd(this, _initProviderPromise, void 0);
      this.onAccountsChanged = (accounts) => {
        if (accounts.length === 0)
          this.emit("disconnect");
        else
          this.emit("change", { account: getAddress(accounts[0]) });
      };
      this.onChainChanged = (chainId) => {
        const id3 = Number(chainId);
        const unsupported = this.isChainUnsupported(id3);
        this.emit("change", { chain: { id: id3, unsupported } });
      };
      this.onDisconnect = () => {
        __privateMethod(this, _setRequestedChainsIds, setRequestedChainsIds_fn).call(this, []);
        this.emit("disconnect");
      };
      this.onDisplayUri = (uri) => {
        this.emit("message", { type: "display_uri", data: uri });
      };
      this.onConnect = () => {
        this.emit("connect", {});
      };
      __privateMethod(this, _createProvider, createProvider_fn).call(this);
    }
    async connect({ chainId, pairingTopic } = {}) {
      try {
        let targetChainId = chainId;
        if (!targetChainId) {
          const store = this.storage?.getItem(STORE_KEY);
          const lastUsedChainId = store?.state?.data?.chain?.id;
          if (lastUsedChainId && !this.isChainUnsupported(lastUsedChainId))
            targetChainId = lastUsedChainId;
          else
            targetChainId = this.chains[0]?.id;
        }
        if (!targetChainId)
          throw new Error("No chains found on connector.");
        const provider = await this.getProvider();
        __privateMethod(this, _setupListeners, setupListeners_fn).call(this);
        const isChainsStale = __privateMethod(this, _isChainsStale, isChainsStale_fn).call(this);
        if (provider.session && isChainsStale)
          await provider.disconnect();
        if (!provider.session || isChainsStale) {
          const optionalChains = this.chains.filter((chain) => chain.id !== targetChainId).map((optionalChain) => optionalChain.id);
          this.emit("message", { type: "connecting" });
          await provider.connect({
            pairingTopic,
            optionalChains: [targetChainId, ...optionalChains]
          });
          __privateMethod(this, _setRequestedChainsIds, setRequestedChainsIds_fn).call(this, this.chains.map(({ id: id22 }) => id22));
        }
        const accounts = await provider.enable();
        const account = getAddress(accounts[0]);
        const id3 = await this.getChainId();
        const unsupported = this.isChainUnsupported(id3);
        return {
          account,
          chain: { id: id3, unsupported }
        };
      } catch (error) {
        if (/user rejected/i.test(error?.message)) {
          throw new UserRejectedRequestError(error);
        }
        throw error;
      }
    }
    async disconnect() {
      const provider = await this.getProvider();
      try {
        await provider.disconnect();
      } catch (error) {
        if (!/No matching key/i.test(error.message))
          throw error;
      } finally {
        __privateMethod(this, _removeListeners, removeListeners_fn).call(this);
        __privateMethod(this, _setRequestedChainsIds, setRequestedChainsIds_fn).call(this, []);
      }
    }
    async getAccount() {
      const { accounts } = await this.getProvider();
      return getAddress(accounts[0]);
    }
    async getChainId() {
      const { chainId } = await this.getProvider();
      return chainId;
    }
    async getProvider({ chainId } = {}) {
      if (!__privateGet(this, _provider2))
        await __privateMethod(this, _createProvider, createProvider_fn).call(this);
      if (chainId)
        await this.switchChain(chainId);
      return __privateGet(this, _provider2);
    }
    async getWalletClient({
      chainId
    } = {}) {
      const [provider, account] = await Promise.all([
        this.getProvider({ chainId }),
        this.getAccount()
      ]);
      const chain = this.chains.find((x4) => x4.id === chainId);
      if (!provider)
        throw new Error("provider is required.");
      return createWalletClient({
        account,
        chain,
        transport: custom(provider)
      });
    }
    async isAuthorized() {
      try {
        const [account, provider] = await Promise.all([
          this.getAccount(),
          this.getProvider()
        ]);
        const isChainsStale = __privateMethod(this, _isChainsStale, isChainsStale_fn).call(this);
        if (!account)
          return false;
        if (isChainsStale && provider.session) {
          try {
            await provider.disconnect();
          } catch {
          }
          return false;
        }
        return true;
      } catch {
        return false;
      }
    }
    async switchChain(chainId) {
      const chain = this.chains.find((chain2) => chain2.id === chainId);
      if (!chain)
        throw new SwitchChainError(new Error("chain not found on connector."));
      try {
        const provider = await this.getProvider();
        const namespaceChains = __privateMethod(this, _getNamespaceChainsIds, getNamespaceChainsIds_fn).call(this);
        const namespaceMethods = __privateMethod(this, _getNamespaceMethods, getNamespaceMethods_fn).call(this);
        const isChainApproved = namespaceChains.includes(chainId);
        if (!isChainApproved && namespaceMethods.includes(ADD_ETH_CHAIN_METHOD)) {
          await provider.request({
            method: ADD_ETH_CHAIN_METHOD,
            params: [
              {
                chainId: numberToHex(chain.id),
                blockExplorerUrls: [chain.blockExplorers?.default?.url],
                chainName: chain.name,
                nativeCurrency: chain.nativeCurrency,
                rpcUrls: [...chain.rpcUrls.default.http]
              }
            ]
          });
          const requestedChains = __privateMethod(this, _getRequestedChainsIds, getRequestedChainsIds_fn).call(this);
          requestedChains.push(chainId);
          __privateMethod(this, _setRequestedChainsIds, setRequestedChainsIds_fn).call(this, requestedChains);
        }
        await provider.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: numberToHex(chainId) }]
        });
        return chain;
      } catch (error) {
        const message = typeof error === "string" ? error : error?.message;
        if (/user rejected request/i.test(message)) {
          throw new UserRejectedRequestError(error);
        }
        throw new SwitchChainError(error);
      }
    }
  };
  _provider2 = /* @__PURE__ */ new WeakMap();
  _initProviderPromise = /* @__PURE__ */ new WeakMap();
  _createProvider = /* @__PURE__ */ new WeakSet();
  createProvider_fn = async function() {
    if (!__privateGet(this, _initProviderPromise) && typeof window !== "undefined") {
      __privateSet(this, _initProviderPromise, __privateMethod(this, _initProvider, initProvider_fn).call(this));
    }
    return __privateGet(this, _initProviderPromise);
  };
  _initProvider = /* @__PURE__ */ new WeakSet();
  initProvider_fn = async function() {
    const { EthereumProvider } = await Promise.resolve().then(() => (init_index_es14(), index_es_exports));
    const optionalChains = this.chains.map(({ id: id3 }) => id3);
    if (optionalChains.length) {
      const {
        projectId: projectId2,
        showQrModal = true,
        qrModalOptions,
        metadata,
        relayUrl
      } = this.options;
      __privateSet(this, _provider2, await EthereumProvider.init({
        showQrModal,
        qrModalOptions,
        projectId: projectId2,
        optionalChains,
        rpcMap: Object.fromEntries(
          this.chains.map((chain) => [
            chain.id,
            chain.rpcUrls.default.http[0]
          ])
        ),
        metadata,
        relayUrl
      }));
    }
  };
  _isChainsStale = /* @__PURE__ */ new WeakSet();
  isChainsStale_fn = function() {
    const namespaceMethods = __privateMethod(this, _getNamespaceMethods, getNamespaceMethods_fn).call(this);
    if (namespaceMethods.includes(ADD_ETH_CHAIN_METHOD))
      return false;
    if (!this.options.isNewChainsStale)
      return false;
    const requestedChains = __privateMethod(this, _getRequestedChainsIds, getRequestedChainsIds_fn).call(this);
    const connectorChains = this.chains.map(({ id: id3 }) => id3);
    const namespaceChains = __privateMethod(this, _getNamespaceChainsIds, getNamespaceChainsIds_fn).call(this);
    if (namespaceChains.length && !namespaceChains.some((id3) => connectorChains.includes(id3)))
      return false;
    return !connectorChains.every((id3) => requestedChains.includes(id3));
  };
  _setupListeners = /* @__PURE__ */ new WeakSet();
  setupListeners_fn = function() {
    if (!__privateGet(this, _provider2))
      return;
    __privateMethod(this, _removeListeners, removeListeners_fn).call(this);
    __privateGet(this, _provider2).on("accountsChanged", this.onAccountsChanged);
    __privateGet(this, _provider2).on("chainChanged", this.onChainChanged);
    __privateGet(this, _provider2).on("disconnect", this.onDisconnect);
    __privateGet(this, _provider2).on("session_delete", this.onDisconnect);
    __privateGet(this, _provider2).on("display_uri", this.onDisplayUri);
    __privateGet(this, _provider2).on("connect", this.onConnect);
  };
  _removeListeners = /* @__PURE__ */ new WeakSet();
  removeListeners_fn = function() {
    if (!__privateGet(this, _provider2))
      return;
    __privateGet(this, _provider2).removeListener("accountsChanged", this.onAccountsChanged);
    __privateGet(this, _provider2).removeListener("chainChanged", this.onChainChanged);
    __privateGet(this, _provider2).removeListener("disconnect", this.onDisconnect);
    __privateGet(this, _provider2).removeListener("session_delete", this.onDisconnect);
    __privateGet(this, _provider2).removeListener("display_uri", this.onDisplayUri);
    __privateGet(this, _provider2).removeListener("connect", this.onConnect);
  };
  _setRequestedChainsIds = /* @__PURE__ */ new WeakSet();
  setRequestedChainsIds_fn = function(chains2) {
    this.storage?.setItem(REQUESTED_CHAINS_KEY, chains2);
  };
  _getRequestedChainsIds = /* @__PURE__ */ new WeakSet();
  getRequestedChainsIds_fn = function() {
    return this.storage?.getItem(REQUESTED_CHAINS_KEY) ?? [];
  };
  _getNamespaceChainsIds = /* @__PURE__ */ new WeakSet();
  getNamespaceChainsIds_fn = function() {
    if (!__privateGet(this, _provider2))
      return [];
    const namespaces = __privateGet(this, _provider2).session?.namespaces;
    if (!namespaces)
      return [];
    const normalizedNamespaces = se(namespaces);
    const chainIds = normalizedNamespaces[NAMESPACE]?.chains?.map(
      (chain) => parseInt(chain.split(":")[1] || "")
    );
    return chainIds ?? [];
  };
  _getNamespaceMethods = /* @__PURE__ */ new WeakSet();
  getNamespaceMethods_fn = function() {
    if (!__privateGet(this, _provider2))
      return [];
    const namespaces = __privateGet(this, _provider2).session?.namespaces;
    if (!namespaces)
      return [];
    const normalizedNamespaces = se(namespaces);
    const methods = normalizedNamespaces[NAMESPACE]?.methods;
    return methods ?? [];
  };

  // node_modules/@wagmi/core/dist/providers/jsonRpc.js
  function jsonRpcProvider({
    rpc: rpc2
  }) {
    return function(chain) {
      const rpcConfig = rpc2(chain);
      if (!rpcConfig || rpcConfig.http === "")
        return null;
      return {
        chain: {
          ...chain,
          rpcUrls: {
            ...chain.rpcUrls,
            default: { http: [rpcConfig.http] }
          }
        },
        rpcUrls: {
          http: [rpcConfig.http],
          webSocket: rpcConfig.webSocket ? [rpcConfig.webSocket] : void 0
        }
      };
    };
  }

  // node_modules/@web3modal/ethereum/dist/index.js
  var A5 = "wallet_addEthereumChain";
  var j5 = class {
    constructor(t6, e9) {
      this.wagmi = {}, this.chains = [], this.namespace = "eip155", this.disconnect = disconnect, this.getAccount = getAccount, this.watchAccount = watchAccount, this.fetchBalance = fetchBalance, this.getNetwork = getNetwork, this.watchNetwork = watchNetwork, this.switchNetwork = switchNetwork, this.fetchEnsName = fetchEnsName, this.fetchEnsAvatar = fetchEnsAvatar, this.wagmi = t6, this.chains = e9;
    }
    getWalletConnectConnector() {
      const t6 = this.wagmi.connectors.find((e9) => e9.id === "walletConnect");
      if (!t6)
        throw new Error("WalletConnectConnector is required");
      return t6;
    }
    async connectWalletConnectProvider(t6, e9) {
      return await t6.getProvider(), new Promise((n9) => {
        t6.once("message", (o9) => {
          o9.type === "display_uri" && (e9(o9.data), n9());
        });
      });
    }
    getConnectorById(t6) {
      const e9 = this.wagmi.connectors.find((n9) => n9.id === t6);
      if (!e9)
        throw new Error(`Connector for id ${t6} was not found`);
      return e9;
    }
    getConnectors() {
      return this.wagmi.connectors.filter((t6) => !t6.id.includes("walletConnect"));
    }
    async connectWalletConnect(t6, e9) {
      const n9 = this.getWalletConnectConnector(), o9 = { connector: n9 };
      return e9 && (o9.chainId = e9), Promise.all([connect(o9), this.connectWalletConnectProvider(n9, t6)]);
    }
    async connectConnector(t6, e9) {
      const n9 = { connector: this.getConnectorById(t6) };
      return e9 && (n9.chainId = e9), await connect(n9);
    }
    isInjectedProviderInstalled() {
      return typeof window.ethereum < "u";
    }
    safeCheckInjectedProvider(t6) {
      var e9;
      try {
        const n9 = String(t6);
        return Boolean((e9 = window.ethereum) == null ? void 0 : e9[n9]);
      } catch (n9) {
        return console.error(n9), false;
      }
    }
    async getConnectedChainIds() {
      var t6, e9, n9;
      const o9 = (e9 = (t6 = (await this.getWalletConnectConnector().getProvider()).signer) == null ? void 0 : t6.session) == null ? void 0 : e9.namespaces, s7 = (n9 = o9?.[this.namespace]) == null ? void 0 : n9.methods;
      if (s7 != null && s7.includes(A5))
        return "ALL";
      if (o9) {
        const i7 = [];
        return Object.keys(o9).forEach((r8) => {
          r8.includes(this.namespace) && i7.push(...o9[r8].accounts);
        }), i7?.map((r8) => r8.split(":")[1]);
      }
      return "ALL";
    }
  };
  var P4 = "eip155";
  var y9 = "https://rpc.walletconnect.com";
  function W6({ projectId: c9 }) {
    return jsonRpcProvider({ rpc: (t6) => {
      var e9;
      return [1, 3, 4, 5, 10, 42, 56, 69, 97, 100, 137, 280, 324, 420, 42161, 42220, 43114, 80001, 421611, 421613, 1313161554, 1313161555].includes(t6.id) ? { http: `${y9}/v1/?chainId=${P4}:${t6.id}&projectId=${c9}` } : { http: t6.rpcUrls.default.http[0], webSocket: (e9 = t6.rpcUrls.default.webSocket) == null ? void 0 : e9[0] };
    } });
  }
  function B7({ chains: c9, projectId: t6 }) {
    return [new WalletConnectConnector({ chains: c9, options: { projectId: t6, showQrModal: false } }), new InjectedConnector({ chains: c9, options: { shimDisconnect: true } })];
  }

  // node_modules/@web3modal/react/dist/index.js
  var import_react = __toESM(require_react(), 1);
  init_dist8();
  var q7 = Object.defineProperty;
  var f6 = Object.getOwnPropertySymbols;
  var z6 = Object.prototype.hasOwnProperty;
  var B9 = Object.prototype.propertyIsEnumerable;
  var m5 = (t6, e9, r8) => e9 in t6 ? q7(t6, e9, { enumerable: true, configurable: true, writable: true, value: r8 }) : t6[e9] = r8;
  var D9 = (t6, e9) => {
    for (var r8 in e9 || (e9 = {}))
      z6.call(e9, r8) && m5(t6, r8, e9[r8]);
    if (f6)
      for (var r8 of f6(e9))
        B9.call(e9, r8) && m5(t6, r8, e9[r8]);
    return t6;
  };
  function L8(t6) {
    return import_react.default.createElement("w3m-modal", D9({}, t6));
  }
  var v5 = Object.getOwnPropertySymbols;
  var N15 = Object.prototype.hasOwnProperty;
  var Q9 = Object.prototype.propertyIsEnumerable;
  var U8 = (t6, e9) => {
    var r8 = {};
    for (var o9 in t6)
      N15.call(t6, o9) && e9.indexOf(o9) < 0 && (r8[o9] = t6[o9]);
    if (t6 != null && v5)
      for (var o9 of v5(t6))
        e9.indexOf(o9) < 0 && Q9.call(t6, o9) && (r8[o9] = t6[o9]);
    return r8;
  };
  function A6(t6) {
    var e9 = t6, { ethereumClient: r8 } = e9, o9 = U8(e9, ["ethereumClient"]);
    const i7 = (0, import_react.useCallback)(async () => {
      ue5.setThemeConfig(o9), r8 && f5.setEthereumClient(r8), C4.setConfig(o9), await Promise.resolve().then(() => (init_dist9(), dist_exports4)), b6.setIsUiLoaded(true);
    }, [r8, o9]);
    return (0, import_react.useEffect)(() => {
      i7();
    }, [i7]), import_react.default.createElement(L8, null);
  }
  var te8 = (0, import_react.memo)(A6);
  var K7 = Object.defineProperty;
  var h9 = Object.getOwnPropertySymbols;
  var R6 = Object.prototype.hasOwnProperty;
  var X7 = Object.prototype.propertyIsEnumerable;
  var w7 = (t6, e9, r8) => e9 in t6 ? K7(t6, e9, { enumerable: true, configurable: true, writable: true, value: r8 }) : t6[e9] = r8;
  var Y5 = (t6, e9) => {
    for (var r8 in e9 || (e9 = {}))
      R6.call(e9, r8) && w7(t6, r8, e9[r8]);
    if (h9)
      for (var r8 of h9(e9))
        X7.call(e9, r8) && w7(t6, r8, e9[r8]);
    return t6;
  };
  function ne6() {
    const [t6, e9] = (0, import_react.useState)(pe3.state);
    return (0, import_react.useEffect)(() => {
      const r8 = pe3.subscribe((o9) => e9(Y5({}, o9)));
      return () => {
        r8();
      };
    }, []), { isOpen: t6.open, open: pe3.open, close: pe3.close, setDefaultChain: b6.setSelectedChain };
  }

  // node_modules/@tanstack/query-sync-storage-persister/build/lib/index.mjs
  function createSyncStoragePersister({
    storage,
    key: key2 = "REACT_QUERY_OFFLINE_CACHE",
    throttleTime = 1e3,
    serialize: serialize4 = JSON.stringify,
    deserialize: deserialize2 = JSON.parse,
    retry
  }) {
    if (storage) {
      const trySave = (persistedClient) => {
        try {
          storage.setItem(key2, serialize4(persistedClient));
          return;
        } catch (error) {
          return error;
        }
      };
      return {
        persistClient: throttle((persistedClient) => {
          let client = persistedClient;
          let error = trySave(client);
          let errorCount = 0;
          while (error && client) {
            errorCount++;
            client = retry == null ? void 0 : retry({
              persistedClient: client,
              error,
              errorCount
            });
            if (client) {
              error = trySave(client);
            }
          }
        }, throttleTime),
        restoreClient: () => {
          const cacheString = storage.getItem(key2);
          if (!cacheString) {
            return;
          }
          return deserialize2(cacheString);
        },
        removeClient: () => {
          storage.removeItem(key2);
        }
      };
    }
    return {
      persistClient: noop2,
      restoreClient: () => void 0,
      removeClient: noop2
    };
  }
  function throttle(func, wait2 = 100) {
    let timer2 = null;
    let params;
    return function(...args) {
      params = args;
      if (timer2 === null) {
        timer2 = setTimeout(() => {
          func(...params);
          timer2 = null;
        }, wait2);
      }
    };
  }
  function noop2() {
  }

  // node_modules/@tanstack/query-core/build/lib/subscribable.mjs
  var Subscribable = class {
    constructor() {
      this.listeners = /* @__PURE__ */ new Set();
      this.subscribe = this.subscribe.bind(this);
    }
    subscribe(listener) {
      const identity3 = {
        listener
      };
      this.listeners.add(identity3);
      this.onSubscribe();
      return () => {
        this.listeners.delete(identity3);
        this.onUnsubscribe();
      };
    }
    hasListeners() {
      return this.listeners.size > 0;
    }
    onSubscribe() {
    }
    onUnsubscribe() {
    }
  };

  // node_modules/@tanstack/query-core/build/lib/utils.mjs
  var isServer = typeof window === "undefined" || "Deno" in window;
  function noop3() {
    return void 0;
  }
  function functionalUpdate(updater, input) {
    return typeof updater === "function" ? updater(input) : updater;
  }
  function isValidTimeout(value) {
    return typeof value === "number" && value >= 0 && value !== Infinity;
  }
  function timeUntilStale(updatedAt, staleTime) {
    return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);
  }
  function parseQueryArgs(arg1, arg2, arg3) {
    if (!isQueryKey(arg1)) {
      return arg1;
    }
    if (typeof arg2 === "function") {
      return {
        ...arg3,
        queryKey: arg1,
        queryFn: arg2
      };
    }
    return {
      ...arg2,
      queryKey: arg1
    };
  }
  function parseMutationArgs(arg1, arg2, arg3) {
    if (isQueryKey(arg1)) {
      if (typeof arg2 === "function") {
        return {
          ...arg3,
          mutationKey: arg1,
          mutationFn: arg2
        };
      }
      return {
        ...arg2,
        mutationKey: arg1
      };
    }
    if (typeof arg1 === "function") {
      return {
        ...arg2,
        mutationFn: arg1
      };
    }
    return {
      ...arg1
    };
  }
  function parseFilterArgs(arg1, arg2, arg3) {
    return isQueryKey(arg1) ? [{
      ...arg2,
      queryKey: arg1
    }, arg3] : [arg1 || {}, arg2];
  }
  function matchQuery(filters, query) {
    const {
      type = "all",
      exact,
      fetchStatus,
      predicate,
      queryKey,
      stale
    } = filters;
    if (isQueryKey(queryKey)) {
      if (exact) {
        if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {
          return false;
        }
      } else if (!partialMatchKey(query.queryKey, queryKey)) {
        return false;
      }
    }
    if (type !== "all") {
      const isActive = query.isActive();
      if (type === "active" && !isActive) {
        return false;
      }
      if (type === "inactive" && isActive) {
        return false;
      }
    }
    if (typeof stale === "boolean" && query.isStale() !== stale) {
      return false;
    }
    if (typeof fetchStatus !== "undefined" && fetchStatus !== query.state.fetchStatus) {
      return false;
    }
    if (predicate && !predicate(query)) {
      return false;
    }
    return true;
  }
  function matchMutation(filters, mutation) {
    const {
      exact,
      fetching,
      predicate,
      mutationKey
    } = filters;
    if (isQueryKey(mutationKey)) {
      if (!mutation.options.mutationKey) {
        return false;
      }
      if (exact) {
        if (hashQueryKey(mutation.options.mutationKey) !== hashQueryKey(mutationKey)) {
          return false;
        }
      } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {
        return false;
      }
    }
    if (typeof fetching === "boolean" && mutation.state.status === "loading" !== fetching) {
      return false;
    }
    if (predicate && !predicate(mutation)) {
      return false;
    }
    return true;
  }
  function hashQueryKeyByOptions(queryKey, options2) {
    const hashFn = (options2 == null ? void 0 : options2.queryKeyHashFn) || hashQueryKey;
    return hashFn(queryKey);
  }
  function hashQueryKey(queryKey) {
    return JSON.stringify(queryKey, (_8, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key2) => {
      result[key2] = val[key2];
      return result;
    }, {}) : val);
  }
  function partialMatchKey(a6, b7) {
    return partialDeepEqual(a6, b7);
  }
  function partialDeepEqual(a6, b7) {
    if (a6 === b7) {
      return true;
    }
    if (typeof a6 !== typeof b7) {
      return false;
    }
    if (a6 && b7 && typeof a6 === "object" && typeof b7 === "object") {
      return !Object.keys(b7).some((key2) => !partialDeepEqual(a6[key2], b7[key2]));
    }
    return false;
  }
  function replaceEqualDeep(a6, b7) {
    if (a6 === b7) {
      return a6;
    }
    const array = isPlainArray(a6) && isPlainArray(b7);
    if (array || isPlainObject(a6) && isPlainObject(b7)) {
      const aSize = array ? a6.length : Object.keys(a6).length;
      const bItems = array ? b7 : Object.keys(b7);
      const bSize = bItems.length;
      const copy = array ? [] : {};
      let equalItems = 0;
      for (let i7 = 0; i7 < bSize; i7++) {
        const key2 = array ? i7 : bItems[i7];
        copy[key2] = replaceEqualDeep(a6[key2], b7[key2]);
        if (copy[key2] === a6[key2]) {
          equalItems++;
        }
      }
      return aSize === bSize && equalItems === aSize ? a6 : copy;
    }
    return b7;
  }
  function shallowEqualObjects(a6, b7) {
    if (a6 && !b7 || b7 && !a6) {
      return false;
    }
    for (const key2 in a6) {
      if (a6[key2] !== b7[key2]) {
        return false;
      }
    }
    return true;
  }
  function isPlainArray(value) {
    return Array.isArray(value) && value.length === Object.keys(value).length;
  }
  function isPlainObject(o9) {
    if (!hasObjectPrototype(o9)) {
      return false;
    }
    const ctor = o9.constructor;
    if (typeof ctor === "undefined") {
      return true;
    }
    const prot = ctor.prototype;
    if (!hasObjectPrototype(prot)) {
      return false;
    }
    if (!prot.hasOwnProperty("isPrototypeOf")) {
      return false;
    }
    return true;
  }
  function hasObjectPrototype(o9) {
    return Object.prototype.toString.call(o9) === "[object Object]";
  }
  function isQueryKey(value) {
    return Array.isArray(value);
  }
  function sleep(timeout) {
    return new Promise((resolve) => {
      setTimeout(resolve, timeout);
    });
  }
  function scheduleMicrotask(callback) {
    sleep(0).then(callback);
  }
  function getAbortController() {
    if (typeof AbortController === "function") {
      return new AbortController();
    }
    return;
  }
  function replaceData(prevData, data2, options2) {
    if (options2.isDataEqual != null && options2.isDataEqual(prevData, data2)) {
      return prevData;
    } else if (typeof options2.structuralSharing === "function") {
      return options2.structuralSharing(prevData, data2);
    } else if (options2.structuralSharing !== false) {
      return replaceEqualDeep(prevData, data2);
    }
    return data2;
  }

  // node_modules/@tanstack/query-core/build/lib/focusManager.mjs
  var FocusManager = class extends Subscribable {
    constructor() {
      super();
      this.setup = (onFocus) => {
        if (!isServer && window.addEventListener) {
          const listener = () => onFocus();
          window.addEventListener("visibilitychange", listener, false);
          window.addEventListener("focus", listener, false);
          return () => {
            window.removeEventListener("visibilitychange", listener);
            window.removeEventListener("focus", listener);
          };
        }
        return;
      };
    }
    onSubscribe() {
      if (!this.cleanup) {
        this.setEventListener(this.setup);
      }
    }
    onUnsubscribe() {
      if (!this.hasListeners()) {
        var _this$cleanup;
        (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);
        this.cleanup = void 0;
      }
    }
    setEventListener(setup) {
      var _this$cleanup2;
      this.setup = setup;
      (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);
      this.cleanup = setup((focused) => {
        if (typeof focused === "boolean") {
          this.setFocused(focused);
        } else {
          this.onFocus();
        }
      });
    }
    setFocused(focused) {
      const changed = this.focused !== focused;
      if (changed) {
        this.focused = focused;
        this.onFocus();
      }
    }
    onFocus() {
      this.listeners.forEach(({
        listener
      }) => {
        listener();
      });
    }
    isFocused() {
      if (typeof this.focused === "boolean") {
        return this.focused;
      }
      if (typeof document === "undefined") {
        return true;
      }
      return [void 0, "visible", "prerender"].includes(document.visibilityState);
    }
  };
  var focusManager = new FocusManager();

  // node_modules/@tanstack/query-core/build/lib/onlineManager.mjs
  var onlineEvents = ["online", "offline"];
  var OnlineManager = class extends Subscribable {
    constructor() {
      super();
      this.setup = (onOnline) => {
        if (!isServer && window.addEventListener) {
          const listener = () => onOnline();
          onlineEvents.forEach((event) => {
            window.addEventListener(event, listener, false);
          });
          return () => {
            onlineEvents.forEach((event) => {
              window.removeEventListener(event, listener);
            });
          };
        }
        return;
      };
    }
    onSubscribe() {
      if (!this.cleanup) {
        this.setEventListener(this.setup);
      }
    }
    onUnsubscribe() {
      if (!this.hasListeners()) {
        var _this$cleanup;
        (_this$cleanup = this.cleanup) == null ? void 0 : _this$cleanup.call(this);
        this.cleanup = void 0;
      }
    }
    setEventListener(setup) {
      var _this$cleanup2;
      this.setup = setup;
      (_this$cleanup2 = this.cleanup) == null ? void 0 : _this$cleanup2.call(this);
      this.cleanup = setup((online) => {
        if (typeof online === "boolean") {
          this.setOnline(online);
        } else {
          this.onOnline();
        }
      });
    }
    setOnline(online) {
      const changed = this.online !== online;
      if (changed) {
        this.online = online;
        this.onOnline();
      }
    }
    onOnline() {
      this.listeners.forEach(({
        listener
      }) => {
        listener();
      });
    }
    isOnline() {
      if (typeof this.online === "boolean") {
        return this.online;
      }
      if (typeof navigator === "undefined" || typeof navigator.onLine === "undefined") {
        return true;
      }
      return navigator.onLine;
    }
  };
  var onlineManager = new OnlineManager();

  // node_modules/@tanstack/query-core/build/lib/retryer.mjs
  function defaultRetryDelay(failureCount) {
    return Math.min(1e3 * 2 ** failureCount, 3e4);
  }
  function canFetch(networkMode) {
    return (networkMode != null ? networkMode : "online") === "online" ? onlineManager.isOnline() : true;
  }
  var CancelledError = class {
    constructor(options2) {
      this.revert = options2 == null ? void 0 : options2.revert;
      this.silent = options2 == null ? void 0 : options2.silent;
    }
  };
  function isCancelledError(value) {
    return value instanceof CancelledError;
  }
  function createRetryer(config2) {
    let isRetryCancelled = false;
    let failureCount = 0;
    let isResolved = false;
    let continueFn;
    let promiseResolve;
    let promiseReject;
    const promise = new Promise((outerResolve, outerReject) => {
      promiseResolve = outerResolve;
      promiseReject = outerReject;
    });
    const cancel = (cancelOptions) => {
      if (!isResolved) {
        reject(new CancelledError(cancelOptions));
        config2.abort == null ? void 0 : config2.abort();
      }
    };
    const cancelRetry = () => {
      isRetryCancelled = true;
    };
    const continueRetry = () => {
      isRetryCancelled = false;
    };
    const shouldPause = () => !focusManager.isFocused() || config2.networkMode !== "always" && !onlineManager.isOnline();
    const resolve = (value) => {
      if (!isResolved) {
        isResolved = true;
        config2.onSuccess == null ? void 0 : config2.onSuccess(value);
        continueFn == null ? void 0 : continueFn();
        promiseResolve(value);
      }
    };
    const reject = (value) => {
      if (!isResolved) {
        isResolved = true;
        config2.onError == null ? void 0 : config2.onError(value);
        continueFn == null ? void 0 : continueFn();
        promiseReject(value);
      }
    };
    const pause = () => {
      return new Promise((continueResolve) => {
        continueFn = (value) => {
          const canContinue = isResolved || !shouldPause();
          if (canContinue) {
            continueResolve(value);
          }
          return canContinue;
        };
        config2.onPause == null ? void 0 : config2.onPause();
      }).then(() => {
        continueFn = void 0;
        if (!isResolved) {
          config2.onContinue == null ? void 0 : config2.onContinue();
        }
      });
    };
    const run = () => {
      if (isResolved) {
        return;
      }
      let promiseOrValue;
      try {
        promiseOrValue = config2.fn();
      } catch (error) {
        promiseOrValue = Promise.reject(error);
      }
      Promise.resolve(promiseOrValue).then(resolve).catch((error) => {
        var _config$retry, _config$retryDelay;
        if (isResolved) {
          return;
        }
        const retry = (_config$retry = config2.retry) != null ? _config$retry : 3;
        const retryDelay = (_config$retryDelay = config2.retryDelay) != null ? _config$retryDelay : defaultRetryDelay;
        const delay = typeof retryDelay === "function" ? retryDelay(failureCount, error) : retryDelay;
        const shouldRetry = retry === true || typeof retry === "number" && failureCount < retry || typeof retry === "function" && retry(failureCount, error);
        if (isRetryCancelled || !shouldRetry) {
          reject(error);
          return;
        }
        failureCount++;
        config2.onFail == null ? void 0 : config2.onFail(failureCount, error);
        sleep(delay).then(() => {
          if (shouldPause()) {
            return pause();
          }
          return;
        }).then(() => {
          if (isRetryCancelled) {
            reject(error);
          } else {
            run();
          }
        });
      });
    };
    if (canFetch(config2.networkMode)) {
      run();
    } else {
      pause().then(run);
    }
    return {
      promise,
      cancel,
      continue: () => {
        const didContinue = continueFn == null ? void 0 : continueFn();
        return didContinue ? promise : Promise.resolve();
      },
      cancelRetry,
      continueRetry
    };
  }

  // node_modules/@tanstack/query-core/build/lib/logger.mjs
  var defaultLogger = console;

  // node_modules/@tanstack/query-core/build/lib/notifyManager.mjs
  function createNotifyManager() {
    let queue = [];
    let transactions = 0;
    let notifyFn = (callback) => {
      callback();
    };
    let batchNotifyFn = (callback) => {
      callback();
    };
    const batch = (callback) => {
      let result;
      transactions++;
      try {
        result = callback();
      } finally {
        transactions--;
        if (!transactions) {
          flush();
        }
      }
      return result;
    };
    const schedule = (callback) => {
      if (transactions) {
        queue.push(callback);
      } else {
        scheduleMicrotask(() => {
          notifyFn(callback);
        });
      }
    };
    const batchCalls = (callback) => {
      return (...args) => {
        schedule(() => {
          callback(...args);
        });
      };
    };
    const flush = () => {
      const originalQueue = queue;
      queue = [];
      if (originalQueue.length) {
        scheduleMicrotask(() => {
          batchNotifyFn(() => {
            originalQueue.forEach((callback) => {
              notifyFn(callback);
            });
          });
        });
      }
    };
    const setNotifyFunction = (fn2) => {
      notifyFn = fn2;
    };
    const setBatchNotifyFunction = (fn2) => {
      batchNotifyFn = fn2;
    };
    return {
      batch,
      batchCalls,
      schedule,
      setNotifyFunction,
      setBatchNotifyFunction
    };
  }
  var notifyManager = createNotifyManager();

  // node_modules/@tanstack/query-core/build/lib/removable.mjs
  var Removable = class {
    destroy() {
      this.clearGcTimeout();
    }
    scheduleGc() {
      this.clearGcTimeout();
      if (isValidTimeout(this.cacheTime)) {
        this.gcTimeout = setTimeout(() => {
          this.optionalRemove();
        }, this.cacheTime);
      }
    }
    updateCacheTime(newCacheTime) {
      this.cacheTime = Math.max(this.cacheTime || 0, newCacheTime != null ? newCacheTime : isServer ? Infinity : 5 * 60 * 1e3);
    }
    clearGcTimeout() {
      if (this.gcTimeout) {
        clearTimeout(this.gcTimeout);
        this.gcTimeout = void 0;
      }
    }
  };

  // node_modules/@tanstack/query-core/build/lib/query.mjs
  var Query = class extends Removable {
    constructor(config2) {
      super();
      this.abortSignalConsumed = false;
      this.defaultOptions = config2.defaultOptions;
      this.setOptions(config2.options);
      this.observers = [];
      this.cache = config2.cache;
      this.logger = config2.logger || defaultLogger;
      this.queryKey = config2.queryKey;
      this.queryHash = config2.queryHash;
      this.initialState = config2.state || getDefaultState(this.options);
      this.state = this.initialState;
      this.scheduleGc();
    }
    get meta() {
      return this.options.meta;
    }
    setOptions(options2) {
      this.options = {
        ...this.defaultOptions,
        ...options2
      };
      this.updateCacheTime(this.options.cacheTime);
    }
    optionalRemove() {
      if (!this.observers.length && this.state.fetchStatus === "idle") {
        this.cache.remove(this);
      }
    }
    setData(newData, options2) {
      const data2 = replaceData(this.state.data, newData, this.options);
      this.dispatch({
        data: data2,
        type: "success",
        dataUpdatedAt: options2 == null ? void 0 : options2.updatedAt,
        manual: options2 == null ? void 0 : options2.manual
      });
      return data2;
    }
    setState(state, setStateOptions) {
      this.dispatch({
        type: "setState",
        state,
        setStateOptions
      });
    }
    cancel(options2) {
      var _this$retryer;
      const promise = this.promise;
      (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.cancel(options2);
      return promise ? promise.then(noop3).catch(noop3) : Promise.resolve();
    }
    destroy() {
      super.destroy();
      this.cancel({
        silent: true
      });
    }
    reset() {
      this.destroy();
      this.setState(this.initialState);
    }
    isActive() {
      return this.observers.some((observer) => observer.options.enabled !== false);
    }
    isDisabled() {
      return this.getObserversCount() > 0 && !this.isActive();
    }
    isStale() {
      return this.state.isInvalidated || !this.state.dataUpdatedAt || this.observers.some((observer) => observer.getCurrentResult().isStale);
    }
    isStaleByTime(staleTime = 0) {
      return this.state.isInvalidated || !this.state.dataUpdatedAt || !timeUntilStale(this.state.dataUpdatedAt, staleTime);
    }
    onFocus() {
      var _this$retryer2;
      const observer = this.observers.find((x4) => x4.shouldFetchOnWindowFocus());
      if (observer) {
        observer.refetch({
          cancelRefetch: false
        });
      }
      (_this$retryer2 = this.retryer) == null ? void 0 : _this$retryer2.continue();
    }
    onOnline() {
      var _this$retryer3;
      const observer = this.observers.find((x4) => x4.shouldFetchOnReconnect());
      if (observer) {
        observer.refetch({
          cancelRefetch: false
        });
      }
      (_this$retryer3 = this.retryer) == null ? void 0 : _this$retryer3.continue();
    }
    addObserver(observer) {
      if (!this.observers.includes(observer)) {
        this.observers.push(observer);
        this.clearGcTimeout();
        this.cache.notify({
          type: "observerAdded",
          query: this,
          observer
        });
      }
    }
    removeObserver(observer) {
      if (this.observers.includes(observer)) {
        this.observers = this.observers.filter((x4) => x4 !== observer);
        if (!this.observers.length) {
          if (this.retryer) {
            if (this.abortSignalConsumed) {
              this.retryer.cancel({
                revert: true
              });
            } else {
              this.retryer.cancelRetry();
            }
          }
          this.scheduleGc();
        }
        this.cache.notify({
          type: "observerRemoved",
          query: this,
          observer
        });
      }
    }
    getObserversCount() {
      return this.observers.length;
    }
    invalidate() {
      if (!this.state.isInvalidated) {
        this.dispatch({
          type: "invalidate"
        });
      }
    }
    fetch(options2, fetchOptions) {
      var _this$options$behavio, _context$fetchOptions;
      if (this.state.fetchStatus !== "idle") {
        if (this.state.dataUpdatedAt && fetchOptions != null && fetchOptions.cancelRefetch) {
          this.cancel({
            silent: true
          });
        } else if (this.promise) {
          var _this$retryer4;
          (_this$retryer4 = this.retryer) == null ? void 0 : _this$retryer4.continueRetry();
          return this.promise;
        }
      }
      if (options2) {
        this.setOptions(options2);
      }
      if (!this.options.queryFn) {
        const observer = this.observers.find((x4) => x4.options.queryFn);
        if (observer) {
          this.setOptions(observer.options);
        }
      }
      if (true) {
        if (!Array.isArray(this.options.queryKey)) {
          this.logger.error("As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']");
        }
      }
      const abortController = getAbortController();
      const queryFnContext = {
        queryKey: this.queryKey,
        pageParam: void 0,
        meta: this.meta
      };
      const addSignalProperty = (object) => {
        Object.defineProperty(object, "signal", {
          enumerable: true,
          get: () => {
            if (abortController) {
              this.abortSignalConsumed = true;
              return abortController.signal;
            }
            return void 0;
          }
        });
      };
      addSignalProperty(queryFnContext);
      const fetchFn = () => {
        if (!this.options.queryFn) {
          return Promise.reject("Missing queryFn for queryKey '" + this.options.queryHash + "'");
        }
        this.abortSignalConsumed = false;
        return this.options.queryFn(queryFnContext);
      };
      const context = {
        fetchOptions,
        options: this.options,
        queryKey: this.queryKey,
        state: this.state,
        fetchFn
      };
      addSignalProperty(context);
      (_this$options$behavio = this.options.behavior) == null ? void 0 : _this$options$behavio.onFetch(context);
      this.revertState = this.state;
      if (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((_context$fetchOptions = context.fetchOptions) == null ? void 0 : _context$fetchOptions.meta)) {
        var _context$fetchOptions2;
        this.dispatch({
          type: "fetch",
          meta: (_context$fetchOptions2 = context.fetchOptions) == null ? void 0 : _context$fetchOptions2.meta
        });
      }
      const onError2 = (error) => {
        if (!(isCancelledError(error) && error.silent)) {
          this.dispatch({
            type: "error",
            error
          });
        }
        if (!isCancelledError(error)) {
          var _this$cache$config$on, _this$cache$config, _this$cache$config$on2, _this$cache$config2;
          (_this$cache$config$on = (_this$cache$config = this.cache.config).onError) == null ? void 0 : _this$cache$config$on.call(_this$cache$config, error, this);
          (_this$cache$config$on2 = (_this$cache$config2 = this.cache.config).onSettled) == null ? void 0 : _this$cache$config$on2.call(_this$cache$config2, this.state.data, error, this);
          if (true) {
            this.logger.error(error);
          }
        }
        if (!this.isFetchingOptimistic) {
          this.scheduleGc();
        }
        this.isFetchingOptimistic = false;
      };
      this.retryer = createRetryer({
        fn: context.fetchFn,
        abort: abortController == null ? void 0 : abortController.abort.bind(abortController),
        onSuccess: (data2) => {
          var _this$cache$config$on3, _this$cache$config3, _this$cache$config$on4, _this$cache$config4;
          if (typeof data2 === "undefined") {
            if (true) {
              this.logger.error("Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: " + this.queryHash);
            }
            onError2(new Error(this.queryHash + " data is undefined"));
            return;
          }
          this.setData(data2);
          (_this$cache$config$on3 = (_this$cache$config3 = this.cache.config).onSuccess) == null ? void 0 : _this$cache$config$on3.call(_this$cache$config3, data2, this);
          (_this$cache$config$on4 = (_this$cache$config4 = this.cache.config).onSettled) == null ? void 0 : _this$cache$config$on4.call(_this$cache$config4, data2, this.state.error, this);
          if (!this.isFetchingOptimistic) {
            this.scheduleGc();
          }
          this.isFetchingOptimistic = false;
        },
        onError: onError2,
        onFail: (failureCount, error) => {
          this.dispatch({
            type: "failed",
            failureCount,
            error
          });
        },
        onPause: () => {
          this.dispatch({
            type: "pause"
          });
        },
        onContinue: () => {
          this.dispatch({
            type: "continue"
          });
        },
        retry: context.options.retry,
        retryDelay: context.options.retryDelay,
        networkMode: context.options.networkMode
      });
      this.promise = this.retryer.promise;
      return this.promise;
    }
    dispatch(action) {
      const reducer = (state) => {
        var _action$meta, _action$dataUpdatedAt;
        switch (action.type) {
          case "failed":
            return {
              ...state,
              fetchFailureCount: action.failureCount,
              fetchFailureReason: action.error
            };
          case "pause":
            return {
              ...state,
              fetchStatus: "paused"
            };
          case "continue":
            return {
              ...state,
              fetchStatus: "fetching"
            };
          case "fetch":
            return {
              ...state,
              fetchFailureCount: 0,
              fetchFailureReason: null,
              fetchMeta: (_action$meta = action.meta) != null ? _action$meta : null,
              fetchStatus: canFetch(this.options.networkMode) ? "fetching" : "paused",
              ...!state.dataUpdatedAt && {
                error: null,
                status: "loading"
              }
            };
          case "success":
            return {
              ...state,
              data: action.data,
              dataUpdateCount: state.dataUpdateCount + 1,
              dataUpdatedAt: (_action$dataUpdatedAt = action.dataUpdatedAt) != null ? _action$dataUpdatedAt : Date.now(),
              error: null,
              isInvalidated: false,
              status: "success",
              ...!action.manual && {
                fetchStatus: "idle",
                fetchFailureCount: 0,
                fetchFailureReason: null
              }
            };
          case "error":
            const error = action.error;
            if (isCancelledError(error) && error.revert && this.revertState) {
              return {
                ...this.revertState,
                fetchStatus: "idle"
              };
            }
            return {
              ...state,
              error,
              errorUpdateCount: state.errorUpdateCount + 1,
              errorUpdatedAt: Date.now(),
              fetchFailureCount: state.fetchFailureCount + 1,
              fetchFailureReason: error,
              fetchStatus: "idle",
              status: "error"
            };
          case "invalidate":
            return {
              ...state,
              isInvalidated: true
            };
          case "setState":
            return {
              ...state,
              ...action.state
            };
        }
      };
      this.state = reducer(this.state);
      notifyManager.batch(() => {
        this.observers.forEach((observer) => {
          observer.onQueryUpdate(action);
        });
        this.cache.notify({
          query: this,
          type: "updated",
          action
        });
      });
    }
  };
  function getDefaultState(options2) {
    const data2 = typeof options2.initialData === "function" ? options2.initialData() : options2.initialData;
    const hasData = typeof data2 !== "undefined";
    const initialDataUpdatedAt = hasData ? typeof options2.initialDataUpdatedAt === "function" ? options2.initialDataUpdatedAt() : options2.initialDataUpdatedAt : 0;
    return {
      data: data2,
      dataUpdateCount: 0,
      dataUpdatedAt: hasData ? initialDataUpdatedAt != null ? initialDataUpdatedAt : Date.now() : 0,
      error: null,
      errorUpdateCount: 0,
      errorUpdatedAt: 0,
      fetchFailureCount: 0,
      fetchFailureReason: null,
      fetchMeta: null,
      isInvalidated: false,
      status: hasData ? "success" : "loading",
      fetchStatus: "idle"
    };
  }

  // node_modules/@tanstack/query-core/build/lib/queryCache.mjs
  var QueryCache = class extends Subscribable {
    constructor(config2) {
      super();
      this.config = config2 || {};
      this.queries = [];
      this.queriesMap = {};
    }
    build(client, options2, state) {
      var _options$queryHash;
      const queryKey = options2.queryKey;
      const queryHash = (_options$queryHash = options2.queryHash) != null ? _options$queryHash : hashQueryKeyByOptions(queryKey, options2);
      let query = this.get(queryHash);
      if (!query) {
        query = new Query({
          cache: this,
          logger: client.getLogger(),
          queryKey,
          queryHash,
          options: client.defaultQueryOptions(options2),
          state,
          defaultOptions: client.getQueryDefaults(queryKey)
        });
        this.add(query);
      }
      return query;
    }
    add(query) {
      if (!this.queriesMap[query.queryHash]) {
        this.queriesMap[query.queryHash] = query;
        this.queries.push(query);
        this.notify({
          type: "added",
          query
        });
      }
    }
    remove(query) {
      const queryInMap = this.queriesMap[query.queryHash];
      if (queryInMap) {
        query.destroy();
        this.queries = this.queries.filter((x4) => x4 !== query);
        if (queryInMap === query) {
          delete this.queriesMap[query.queryHash];
        }
        this.notify({
          type: "removed",
          query
        });
      }
    }
    clear() {
      notifyManager.batch(() => {
        this.queries.forEach((query) => {
          this.remove(query);
        });
      });
    }
    get(queryHash) {
      return this.queriesMap[queryHash];
    }
    getAll() {
      return this.queries;
    }
    find(arg1, arg2) {
      const [filters] = parseFilterArgs(arg1, arg2);
      if (typeof filters.exact === "undefined") {
        filters.exact = true;
      }
      return this.queries.find((query) => matchQuery(filters, query));
    }
    findAll(arg1, arg2) {
      const [filters] = parseFilterArgs(arg1, arg2);
      return Object.keys(filters).length > 0 ? this.queries.filter((query) => matchQuery(filters, query)) : this.queries;
    }
    notify(event) {
      notifyManager.batch(() => {
        this.listeners.forEach(({
          listener
        }) => {
          listener(event);
        });
      });
    }
    onFocus() {
      notifyManager.batch(() => {
        this.queries.forEach((query) => {
          query.onFocus();
        });
      });
    }
    onOnline() {
      notifyManager.batch(() => {
        this.queries.forEach((query) => {
          query.onOnline();
        });
      });
    }
  };

  // node_modules/@tanstack/query-core/build/lib/mutation.mjs
  var Mutation = class extends Removable {
    constructor(config2) {
      super();
      this.defaultOptions = config2.defaultOptions;
      this.mutationId = config2.mutationId;
      this.mutationCache = config2.mutationCache;
      this.logger = config2.logger || defaultLogger;
      this.observers = [];
      this.state = config2.state || getDefaultState2();
      this.setOptions(config2.options);
      this.scheduleGc();
    }
    setOptions(options2) {
      this.options = {
        ...this.defaultOptions,
        ...options2
      };
      this.updateCacheTime(this.options.cacheTime);
    }
    get meta() {
      return this.options.meta;
    }
    setState(state) {
      this.dispatch({
        type: "setState",
        state
      });
    }
    addObserver(observer) {
      if (!this.observers.includes(observer)) {
        this.observers.push(observer);
        this.clearGcTimeout();
        this.mutationCache.notify({
          type: "observerAdded",
          mutation: this,
          observer
        });
      }
    }
    removeObserver(observer) {
      this.observers = this.observers.filter((x4) => x4 !== observer);
      this.scheduleGc();
      this.mutationCache.notify({
        type: "observerRemoved",
        mutation: this,
        observer
      });
    }
    optionalRemove() {
      if (!this.observers.length) {
        if (this.state.status === "loading") {
          this.scheduleGc();
        } else {
          this.mutationCache.remove(this);
        }
      }
    }
    continue() {
      var _this$retryer$continu, _this$retryer;
      return (_this$retryer$continu = (_this$retryer = this.retryer) == null ? void 0 : _this$retryer.continue()) != null ? _this$retryer$continu : this.execute();
    }
    async execute() {
      const executeMutation = () => {
        var _this$options$retry;
        this.retryer = createRetryer({
          fn: () => {
            if (!this.options.mutationFn) {
              return Promise.reject("No mutationFn found");
            }
            return this.options.mutationFn(this.state.variables);
          },
          onFail: (failureCount, error) => {
            this.dispatch({
              type: "failed",
              failureCount,
              error
            });
          },
          onPause: () => {
            this.dispatch({
              type: "pause"
            });
          },
          onContinue: () => {
            this.dispatch({
              type: "continue"
            });
          },
          retry: (_this$options$retry = this.options.retry) != null ? _this$options$retry : 0,
          retryDelay: this.options.retryDelay,
          networkMode: this.options.networkMode
        });
        return this.retryer.promise;
      };
      const restored = this.state.status === "loading";
      try {
        var _this$mutationCache$c3, _this$mutationCache$c4, _this$options$onSucce, _this$options2, _this$mutationCache$c5, _this$mutationCache$c6, _this$options$onSettl, _this$options3;
        if (!restored) {
          var _this$mutationCache$c, _this$mutationCache$c2, _this$options$onMutat, _this$options;
          this.dispatch({
            type: "loading",
            variables: this.options.variables
          });
          await ((_this$mutationCache$c = (_this$mutationCache$c2 = this.mutationCache.config).onMutate) == null ? void 0 : _this$mutationCache$c.call(_this$mutationCache$c2, this.state.variables, this));
          const context = await ((_this$options$onMutat = (_this$options = this.options).onMutate) == null ? void 0 : _this$options$onMutat.call(_this$options, this.state.variables));
          if (context !== this.state.context) {
            this.dispatch({
              type: "loading",
              context,
              variables: this.state.variables
            });
          }
        }
        const data2 = await executeMutation();
        await ((_this$mutationCache$c3 = (_this$mutationCache$c4 = this.mutationCache.config).onSuccess) == null ? void 0 : _this$mutationCache$c3.call(_this$mutationCache$c4, data2, this.state.variables, this.state.context, this));
        await ((_this$options$onSucce = (_this$options2 = this.options).onSuccess) == null ? void 0 : _this$options$onSucce.call(_this$options2, data2, this.state.variables, this.state.context));
        await ((_this$mutationCache$c5 = (_this$mutationCache$c6 = this.mutationCache.config).onSettled) == null ? void 0 : _this$mutationCache$c5.call(_this$mutationCache$c6, data2, null, this.state.variables, this.state.context, this));
        await ((_this$options$onSettl = (_this$options3 = this.options).onSettled) == null ? void 0 : _this$options$onSettl.call(_this$options3, data2, null, this.state.variables, this.state.context));
        this.dispatch({
          type: "success",
          data: data2
        });
        return data2;
      } catch (error) {
        try {
          var _this$mutationCache$c7, _this$mutationCache$c8, _this$options$onError, _this$options4, _this$mutationCache$c9, _this$mutationCache$c10, _this$options$onSettl2, _this$options5;
          await ((_this$mutationCache$c7 = (_this$mutationCache$c8 = this.mutationCache.config).onError) == null ? void 0 : _this$mutationCache$c7.call(_this$mutationCache$c8, error, this.state.variables, this.state.context, this));
          if (true) {
            this.logger.error(error);
          }
          await ((_this$options$onError = (_this$options4 = this.options).onError) == null ? void 0 : _this$options$onError.call(_this$options4, error, this.state.variables, this.state.context));
          await ((_this$mutationCache$c9 = (_this$mutationCache$c10 = this.mutationCache.config).onSettled) == null ? void 0 : _this$mutationCache$c9.call(_this$mutationCache$c10, void 0, error, this.state.variables, this.state.context, this));
          await ((_this$options$onSettl2 = (_this$options5 = this.options).onSettled) == null ? void 0 : _this$options$onSettl2.call(_this$options5, void 0, error, this.state.variables, this.state.context));
          throw error;
        } finally {
          this.dispatch({
            type: "error",
            error
          });
        }
      }
    }
    dispatch(action) {
      const reducer = (state) => {
        switch (action.type) {
          case "failed":
            return {
              ...state,
              failureCount: action.failureCount,
              failureReason: action.error
            };
          case "pause":
            return {
              ...state,
              isPaused: true
            };
          case "continue":
            return {
              ...state,
              isPaused: false
            };
          case "loading":
            return {
              ...state,
              context: action.context,
              data: void 0,
              failureCount: 0,
              failureReason: null,
              error: null,
              isPaused: !canFetch(this.options.networkMode),
              status: "loading",
              variables: action.variables
            };
          case "success":
            return {
              ...state,
              data: action.data,
              failureCount: 0,
              failureReason: null,
              error: null,
              status: "success",
              isPaused: false
            };
          case "error":
            return {
              ...state,
              data: void 0,
              error: action.error,
              failureCount: state.failureCount + 1,
              failureReason: action.error,
              isPaused: false,
              status: "error"
            };
          case "setState":
            return {
              ...state,
              ...action.state
            };
        }
      };
      this.state = reducer(this.state);
      notifyManager.batch(() => {
        this.observers.forEach((observer) => {
          observer.onMutationUpdate(action);
        });
        this.mutationCache.notify({
          mutation: this,
          type: "updated",
          action
        });
      });
    }
  };
  function getDefaultState2() {
    return {
      context: void 0,
      data: void 0,
      error: null,
      failureCount: 0,
      failureReason: null,
      isPaused: false,
      status: "idle",
      variables: void 0
    };
  }

  // node_modules/@tanstack/query-core/build/lib/mutationCache.mjs
  var MutationCache = class extends Subscribable {
    constructor(config2) {
      super();
      this.config = config2 || {};
      this.mutations = [];
      this.mutationId = 0;
    }
    build(client, options2, state) {
      const mutation = new Mutation({
        mutationCache: this,
        logger: client.getLogger(),
        mutationId: ++this.mutationId,
        options: client.defaultMutationOptions(options2),
        state,
        defaultOptions: options2.mutationKey ? client.getMutationDefaults(options2.mutationKey) : void 0
      });
      this.add(mutation);
      return mutation;
    }
    add(mutation) {
      this.mutations.push(mutation);
      this.notify({
        type: "added",
        mutation
      });
    }
    remove(mutation) {
      this.mutations = this.mutations.filter((x4) => x4 !== mutation);
      this.notify({
        type: "removed",
        mutation
      });
    }
    clear() {
      notifyManager.batch(() => {
        this.mutations.forEach((mutation) => {
          this.remove(mutation);
        });
      });
    }
    getAll() {
      return this.mutations;
    }
    find(filters) {
      if (typeof filters.exact === "undefined") {
        filters.exact = true;
      }
      return this.mutations.find((mutation) => matchMutation(filters, mutation));
    }
    findAll(filters) {
      return this.mutations.filter((mutation) => matchMutation(filters, mutation));
    }
    notify(event) {
      notifyManager.batch(() => {
        this.listeners.forEach(({
          listener
        }) => {
          listener(event);
        });
      });
    }
    resumePausedMutations() {
      var _this$resuming;
      this.resuming = ((_this$resuming = this.resuming) != null ? _this$resuming : Promise.resolve()).then(() => {
        const pausedMutations = this.mutations.filter((x4) => x4.state.isPaused);
        return notifyManager.batch(() => pausedMutations.reduce((promise, mutation) => promise.then(() => mutation.continue().catch(noop3)), Promise.resolve()));
      }).then(() => {
        this.resuming = void 0;
      });
      return this.resuming;
    }
  };

  // node_modules/@tanstack/query-core/build/lib/infiniteQueryBehavior.mjs
  function infiniteQueryBehavior() {
    return {
      onFetch: (context) => {
        context.fetchFn = () => {
          var _context$fetchOptions, _context$fetchOptions2, _context$fetchOptions3, _context$fetchOptions4, _context$state$data, _context$state$data2;
          const refetchPage = (_context$fetchOptions = context.fetchOptions) == null ? void 0 : (_context$fetchOptions2 = _context$fetchOptions.meta) == null ? void 0 : _context$fetchOptions2.refetchPage;
          const fetchMore = (_context$fetchOptions3 = context.fetchOptions) == null ? void 0 : (_context$fetchOptions4 = _context$fetchOptions3.meta) == null ? void 0 : _context$fetchOptions4.fetchMore;
          const pageParam = fetchMore == null ? void 0 : fetchMore.pageParam;
          const isFetchingNextPage = (fetchMore == null ? void 0 : fetchMore.direction) === "forward";
          const isFetchingPreviousPage = (fetchMore == null ? void 0 : fetchMore.direction) === "backward";
          const oldPages = ((_context$state$data = context.state.data) == null ? void 0 : _context$state$data.pages) || [];
          const oldPageParams = ((_context$state$data2 = context.state.data) == null ? void 0 : _context$state$data2.pageParams) || [];
          let newPageParams = oldPageParams;
          let cancelled = false;
          const addSignalProperty = (object) => {
            Object.defineProperty(object, "signal", {
              enumerable: true,
              get: () => {
                var _context$signal;
                if ((_context$signal = context.signal) != null && _context$signal.aborted) {
                  cancelled = true;
                } else {
                  var _context$signal2;
                  (_context$signal2 = context.signal) == null ? void 0 : _context$signal2.addEventListener("abort", () => {
                    cancelled = true;
                  });
                }
                return context.signal;
              }
            });
          };
          const queryFn = context.options.queryFn || (() => Promise.reject("Missing queryFn for queryKey '" + context.options.queryHash + "'"));
          const buildNewPages = (pages, param, page, previous) => {
            newPageParams = previous ? [param, ...newPageParams] : [...newPageParams, param];
            return previous ? [page, ...pages] : [...pages, page];
          };
          const fetchPage = (pages, manual, param, previous) => {
            if (cancelled) {
              return Promise.reject("Cancelled");
            }
            if (typeof param === "undefined" && !manual && pages.length) {
              return Promise.resolve(pages);
            }
            const queryFnContext = {
              queryKey: context.queryKey,
              pageParam: param,
              meta: context.options.meta
            };
            addSignalProperty(queryFnContext);
            const queryFnResult = queryFn(queryFnContext);
            const promise2 = Promise.resolve(queryFnResult).then((page) => buildNewPages(pages, param, page, previous));
            return promise2;
          };
          let promise;
          if (!oldPages.length) {
            promise = fetchPage([]);
          } else if (isFetchingNextPage) {
            const manual = typeof pageParam !== "undefined";
            const param = manual ? pageParam : getNextPageParam(context.options, oldPages);
            promise = fetchPage(oldPages, manual, param);
          } else if (isFetchingPreviousPage) {
            const manual = typeof pageParam !== "undefined";
            const param = manual ? pageParam : getPreviousPageParam(context.options, oldPages);
            promise = fetchPage(oldPages, manual, param, true);
          } else {
            newPageParams = [];
            const manual = typeof context.options.getNextPageParam === "undefined";
            const shouldFetchFirstPage = refetchPage && oldPages[0] ? refetchPage(oldPages[0], 0, oldPages) : true;
            promise = shouldFetchFirstPage ? fetchPage([], manual, oldPageParams[0]) : Promise.resolve(buildNewPages([], oldPageParams[0], oldPages[0]));
            for (let i7 = 1; i7 < oldPages.length; i7++) {
              promise = promise.then((pages) => {
                const shouldFetchNextPage = refetchPage && oldPages[i7] ? refetchPage(oldPages[i7], i7, oldPages) : true;
                if (shouldFetchNextPage) {
                  const param = manual ? oldPageParams[i7] : getNextPageParam(context.options, pages);
                  return fetchPage(pages, manual, param);
                }
                return Promise.resolve(buildNewPages(pages, oldPageParams[i7], oldPages[i7]));
              });
            }
          }
          const finalPromise = promise.then((pages) => ({
            pages,
            pageParams: newPageParams
          }));
          return finalPromise;
        };
      }
    };
  }
  function getNextPageParam(options2, pages) {
    return options2.getNextPageParam == null ? void 0 : options2.getNextPageParam(pages[pages.length - 1], pages);
  }
  function getPreviousPageParam(options2, pages) {
    return options2.getPreviousPageParam == null ? void 0 : options2.getPreviousPageParam(pages[0], pages);
  }

  // node_modules/@tanstack/query-core/build/lib/queryClient.mjs
  var QueryClient = class {
    constructor(config2 = {}) {
      this.queryCache = config2.queryCache || new QueryCache();
      this.mutationCache = config2.mutationCache || new MutationCache();
      this.logger = config2.logger || defaultLogger;
      this.defaultOptions = config2.defaultOptions || {};
      this.queryDefaults = [];
      this.mutationDefaults = [];
      this.mountCount = 0;
      if (config2.logger) {
        this.logger.error("Passing a custom logger has been deprecated and will be removed in the next major version.");
      }
    }
    mount() {
      this.mountCount++;
      if (this.mountCount !== 1)
        return;
      this.unsubscribeFocus = focusManager.subscribe(() => {
        if (focusManager.isFocused()) {
          this.resumePausedMutations();
          this.queryCache.onFocus();
        }
      });
      this.unsubscribeOnline = onlineManager.subscribe(() => {
        if (onlineManager.isOnline()) {
          this.resumePausedMutations();
          this.queryCache.onOnline();
        }
      });
    }
    unmount() {
      var _this$unsubscribeFocu, _this$unsubscribeOnli;
      this.mountCount--;
      if (this.mountCount !== 0)
        return;
      (_this$unsubscribeFocu = this.unsubscribeFocus) == null ? void 0 : _this$unsubscribeFocu.call(this);
      this.unsubscribeFocus = void 0;
      (_this$unsubscribeOnli = this.unsubscribeOnline) == null ? void 0 : _this$unsubscribeOnli.call(this);
      this.unsubscribeOnline = void 0;
    }
    isFetching(arg1, arg2) {
      const [filters] = parseFilterArgs(arg1, arg2);
      filters.fetchStatus = "fetching";
      return this.queryCache.findAll(filters).length;
    }
    isMutating(filters) {
      return this.mutationCache.findAll({
        ...filters,
        fetching: true
      }).length;
    }
    getQueryData(queryKey, filters) {
      var _this$queryCache$find;
      return (_this$queryCache$find = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find.state.data;
    }
    ensureQueryData(arg1, arg2, arg3) {
      const parsedOptions = parseQueryArgs(arg1, arg2, arg3);
      const cachedData = this.getQueryData(parsedOptions.queryKey);
      return cachedData ? Promise.resolve(cachedData) : this.fetchQuery(parsedOptions);
    }
    getQueriesData(queryKeyOrFilters) {
      return this.getQueryCache().findAll(queryKeyOrFilters).map(({
        queryKey,
        state
      }) => {
        const data2 = state.data;
        return [queryKey, data2];
      });
    }
    setQueryData(queryKey, updater, options2) {
      const query = this.queryCache.find(queryKey);
      const prevData = query == null ? void 0 : query.state.data;
      const data2 = functionalUpdate(updater, prevData);
      if (typeof data2 === "undefined") {
        return void 0;
      }
      const parsedOptions = parseQueryArgs(queryKey);
      const defaultedOptions = this.defaultQueryOptions(parsedOptions);
      return this.queryCache.build(this, defaultedOptions).setData(data2, {
        ...options2,
        manual: true
      });
    }
    setQueriesData(queryKeyOrFilters, updater, options2) {
      return notifyManager.batch(() => this.getQueryCache().findAll(queryKeyOrFilters).map(({
        queryKey
      }) => [queryKey, this.setQueryData(queryKey, updater, options2)]));
    }
    getQueryState(queryKey, filters) {
      var _this$queryCache$find2;
      return (_this$queryCache$find2 = this.queryCache.find(queryKey, filters)) == null ? void 0 : _this$queryCache$find2.state;
    }
    removeQueries(arg1, arg2) {
      const [filters] = parseFilterArgs(arg1, arg2);
      const queryCache = this.queryCache;
      notifyManager.batch(() => {
        queryCache.findAll(filters).forEach((query) => {
          queryCache.remove(query);
        });
      });
    }
    resetQueries(arg1, arg2, arg3) {
      const [filters, options2] = parseFilterArgs(arg1, arg2, arg3);
      const queryCache = this.queryCache;
      const refetchFilters = {
        type: "active",
        ...filters
      };
      return notifyManager.batch(() => {
        queryCache.findAll(filters).forEach((query) => {
          query.reset();
        });
        return this.refetchQueries(refetchFilters, options2);
      });
    }
    cancelQueries(arg1, arg2, arg3) {
      const [filters, cancelOptions = {}] = parseFilterArgs(arg1, arg2, arg3);
      if (typeof cancelOptions.revert === "undefined") {
        cancelOptions.revert = true;
      }
      const promises = notifyManager.batch(() => this.queryCache.findAll(filters).map((query) => query.cancel(cancelOptions)));
      return Promise.all(promises).then(noop3).catch(noop3);
    }
    invalidateQueries(arg1, arg2, arg3) {
      const [filters, options2] = parseFilterArgs(arg1, arg2, arg3);
      return notifyManager.batch(() => {
        var _ref, _filters$refetchType;
        this.queryCache.findAll(filters).forEach((query) => {
          query.invalidate();
        });
        if (filters.refetchType === "none") {
          return Promise.resolve();
        }
        const refetchFilters = {
          ...filters,
          type: (_ref = (_filters$refetchType = filters.refetchType) != null ? _filters$refetchType : filters.type) != null ? _ref : "active"
        };
        return this.refetchQueries(refetchFilters, options2);
      });
    }
    refetchQueries(arg1, arg2, arg3) {
      const [filters, options2] = parseFilterArgs(arg1, arg2, arg3);
      const promises = notifyManager.batch(() => this.queryCache.findAll(filters).filter((query) => !query.isDisabled()).map((query) => {
        var _options$cancelRefetc;
        return query.fetch(void 0, {
          ...options2,
          cancelRefetch: (_options$cancelRefetc = options2 == null ? void 0 : options2.cancelRefetch) != null ? _options$cancelRefetc : true,
          meta: {
            refetchPage: filters.refetchPage
          }
        });
      }));
      let promise = Promise.all(promises).then(noop3);
      if (!(options2 != null && options2.throwOnError)) {
        promise = promise.catch(noop3);
      }
      return promise;
    }
    fetchQuery(arg1, arg2, arg3) {
      const parsedOptions = parseQueryArgs(arg1, arg2, arg3);
      const defaultedOptions = this.defaultQueryOptions(parsedOptions);
      if (typeof defaultedOptions.retry === "undefined") {
        defaultedOptions.retry = false;
      }
      const query = this.queryCache.build(this, defaultedOptions);
      return query.isStaleByTime(defaultedOptions.staleTime) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);
    }
    prefetchQuery(arg1, arg2, arg3) {
      return this.fetchQuery(arg1, arg2, arg3).then(noop3).catch(noop3);
    }
    fetchInfiniteQuery(arg1, arg2, arg3) {
      const parsedOptions = parseQueryArgs(arg1, arg2, arg3);
      parsedOptions.behavior = infiniteQueryBehavior();
      return this.fetchQuery(parsedOptions);
    }
    prefetchInfiniteQuery(arg1, arg2, arg3) {
      return this.fetchInfiniteQuery(arg1, arg2, arg3).then(noop3).catch(noop3);
    }
    resumePausedMutations() {
      return this.mutationCache.resumePausedMutations();
    }
    getQueryCache() {
      return this.queryCache;
    }
    getMutationCache() {
      return this.mutationCache;
    }
    getLogger() {
      return this.logger;
    }
    getDefaultOptions() {
      return this.defaultOptions;
    }
    setDefaultOptions(options2) {
      this.defaultOptions = options2;
    }
    setQueryDefaults(queryKey, options2) {
      const result = this.queryDefaults.find((x4) => hashQueryKey(queryKey) === hashQueryKey(x4.queryKey));
      if (result) {
        result.defaultOptions = options2;
      } else {
        this.queryDefaults.push({
          queryKey,
          defaultOptions: options2
        });
      }
    }
    getQueryDefaults(queryKey) {
      if (!queryKey) {
        return void 0;
      }
      const firstMatchingDefaults = this.queryDefaults.find((x4) => partialMatchKey(queryKey, x4.queryKey));
      if (true) {
        const matchingDefaults = this.queryDefaults.filter((x4) => partialMatchKey(queryKey, x4.queryKey));
        if (matchingDefaults.length > 1) {
          this.logger.error("[QueryClient] Several query defaults match with key '" + JSON.stringify(queryKey) + "'. The first matching query defaults are used. Please check how query defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetquerydefaults.");
        }
      }
      return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;
    }
    setMutationDefaults(mutationKey, options2) {
      const result = this.mutationDefaults.find((x4) => hashQueryKey(mutationKey) === hashQueryKey(x4.mutationKey));
      if (result) {
        result.defaultOptions = options2;
      } else {
        this.mutationDefaults.push({
          mutationKey,
          defaultOptions: options2
        });
      }
    }
    getMutationDefaults(mutationKey) {
      if (!mutationKey) {
        return void 0;
      }
      const firstMatchingDefaults = this.mutationDefaults.find((x4) => partialMatchKey(mutationKey, x4.mutationKey));
      if (true) {
        const matchingDefaults = this.mutationDefaults.filter((x4) => partialMatchKey(mutationKey, x4.mutationKey));
        if (matchingDefaults.length > 1) {
          this.logger.error("[QueryClient] Several mutation defaults match with key '" + JSON.stringify(mutationKey) + "'. The first matching mutation defaults are used. Please check how mutation defaults are registered. Order does matter here. cf. https://react-query.tanstack.com/reference/QueryClient#queryclientsetmutationdefaults.");
        }
      }
      return firstMatchingDefaults == null ? void 0 : firstMatchingDefaults.defaultOptions;
    }
    defaultQueryOptions(options2) {
      if (options2 != null && options2._defaulted) {
        return options2;
      }
      const defaultedOptions = {
        ...this.defaultOptions.queries,
        ...this.getQueryDefaults(options2 == null ? void 0 : options2.queryKey),
        ...options2,
        _defaulted: true
      };
      if (!defaultedOptions.queryHash && defaultedOptions.queryKey) {
        defaultedOptions.queryHash = hashQueryKeyByOptions(defaultedOptions.queryKey, defaultedOptions);
      }
      if (typeof defaultedOptions.refetchOnReconnect === "undefined") {
        defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== "always";
      }
      if (typeof defaultedOptions.useErrorBoundary === "undefined") {
        defaultedOptions.useErrorBoundary = !!defaultedOptions.suspense;
      }
      return defaultedOptions;
    }
    defaultMutationOptions(options2) {
      if (options2 != null && options2._defaulted) {
        return options2;
      }
      return {
        ...this.defaultOptions.mutations,
        ...this.getMutationDefaults(options2 == null ? void 0 : options2.mutationKey),
        ...options2,
        _defaulted: true
      };
    }
    clear() {
      this.queryCache.clear();
      this.mutationCache.clear();
    }
  };

  // node_modules/@tanstack/query-core/build/lib/mutationObserver.mjs
  var MutationObserver = class extends Subscribable {
    constructor(client, options2) {
      super();
      this.client = client;
      this.setOptions(options2);
      this.bindMethods();
      this.updateResult();
    }
    bindMethods() {
      this.mutate = this.mutate.bind(this);
      this.reset = this.reset.bind(this);
    }
    setOptions(options2) {
      var _this$currentMutation;
      const prevOptions = this.options;
      this.options = this.client.defaultMutationOptions(options2);
      if (!shallowEqualObjects(prevOptions, this.options)) {
        this.client.getMutationCache().notify({
          type: "observerOptionsUpdated",
          mutation: this.currentMutation,
          observer: this
        });
      }
      (_this$currentMutation = this.currentMutation) == null ? void 0 : _this$currentMutation.setOptions(this.options);
    }
    onUnsubscribe() {
      if (!this.hasListeners()) {
        var _this$currentMutation2;
        (_this$currentMutation2 = this.currentMutation) == null ? void 0 : _this$currentMutation2.removeObserver(this);
      }
    }
    onMutationUpdate(action) {
      this.updateResult();
      const notifyOptions = {
        listeners: true
      };
      if (action.type === "success") {
        notifyOptions.onSuccess = true;
      } else if (action.type === "error") {
        notifyOptions.onError = true;
      }
      this.notify(notifyOptions);
    }
    getCurrentResult() {
      return this.currentResult;
    }
    reset() {
      this.currentMutation = void 0;
      this.updateResult();
      this.notify({
        listeners: true
      });
    }
    mutate(variables, options2) {
      this.mutateOptions = options2;
      if (this.currentMutation) {
        this.currentMutation.removeObserver(this);
      }
      this.currentMutation = this.client.getMutationCache().build(this.client, {
        ...this.options,
        variables: typeof variables !== "undefined" ? variables : this.options.variables
      });
      this.currentMutation.addObserver(this);
      return this.currentMutation.execute();
    }
    updateResult() {
      const state = this.currentMutation ? this.currentMutation.state : getDefaultState2();
      const result = {
        ...state,
        isLoading: state.status === "loading",
        isSuccess: state.status === "success",
        isError: state.status === "error",
        isIdle: state.status === "idle",
        mutate: this.mutate,
        reset: this.reset
      };
      this.currentResult = result;
    }
    notify(options2) {
      notifyManager.batch(() => {
        if (this.mutateOptions && this.hasListeners()) {
          if (options2.onSuccess) {
            var _this$mutateOptions$o, _this$mutateOptions, _this$mutateOptions$o2, _this$mutateOptions2;
            (_this$mutateOptions$o = (_this$mutateOptions = this.mutateOptions).onSuccess) == null ? void 0 : _this$mutateOptions$o.call(_this$mutateOptions, this.currentResult.data, this.currentResult.variables, this.currentResult.context);
            (_this$mutateOptions$o2 = (_this$mutateOptions2 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o2.call(_this$mutateOptions2, this.currentResult.data, null, this.currentResult.variables, this.currentResult.context);
          } else if (options2.onError) {
            var _this$mutateOptions$o3, _this$mutateOptions3, _this$mutateOptions$o4, _this$mutateOptions4;
            (_this$mutateOptions$o3 = (_this$mutateOptions3 = this.mutateOptions).onError) == null ? void 0 : _this$mutateOptions$o3.call(_this$mutateOptions3, this.currentResult.error, this.currentResult.variables, this.currentResult.context);
            (_this$mutateOptions$o4 = (_this$mutateOptions4 = this.mutateOptions).onSettled) == null ? void 0 : _this$mutateOptions$o4.call(_this$mutateOptions4, void 0, this.currentResult.error, this.currentResult.variables, this.currentResult.context);
          }
        }
        if (options2.listeners) {
          this.listeners.forEach(({
            listener
          }) => {
            listener(this.currentResult);
          });
        }
      });
    }
  };

  // node_modules/@tanstack/query-core/build/lib/hydration.mjs
  function dehydrateMutation(mutation) {
    return {
      mutationKey: mutation.options.mutationKey,
      state: mutation.state
    };
  }
  function dehydrateQuery(query) {
    return {
      state: query.state,
      queryKey: query.queryKey,
      queryHash: query.queryHash
    };
  }
  function defaultShouldDehydrateMutation(mutation) {
    return mutation.state.isPaused;
  }
  function defaultShouldDehydrateQuery(query) {
    return query.state.status === "success";
  }
  function dehydrate(client, options2 = {}) {
    const mutations = [];
    const queries = [];
    if (options2.dehydrateMutations !== false) {
      const shouldDehydrateMutation = options2.shouldDehydrateMutation || defaultShouldDehydrateMutation;
      client.getMutationCache().getAll().forEach((mutation) => {
        if (shouldDehydrateMutation(mutation)) {
          mutations.push(dehydrateMutation(mutation));
        }
      });
    }
    if (options2.dehydrateQueries !== false) {
      const shouldDehydrateQuery = options2.shouldDehydrateQuery || defaultShouldDehydrateQuery;
      client.getQueryCache().getAll().forEach((query) => {
        if (shouldDehydrateQuery(query)) {
          queries.push(dehydrateQuery(query));
        }
      });
    }
    return {
      mutations,
      queries
    };
  }
  function hydrate(client, dehydratedState, options2) {
    if (typeof dehydratedState !== "object" || dehydratedState === null) {
      return;
    }
    const mutationCache = client.getMutationCache();
    const queryCache = client.getQueryCache();
    const mutations = dehydratedState.mutations || [];
    const queries = dehydratedState.queries || [];
    mutations.forEach((dehydratedMutation) => {
      var _options$defaultOptio;
      mutationCache.build(client, {
        ...options2 == null ? void 0 : (_options$defaultOptio = options2.defaultOptions) == null ? void 0 : _options$defaultOptio.mutations,
        mutationKey: dehydratedMutation.mutationKey
      }, dehydratedMutation.state);
    });
    queries.forEach(({
      queryKey,
      state,
      queryHash
    }) => {
      var _options$defaultOptio2;
      const query = queryCache.get(queryHash);
      if (query) {
        if (query.state.dataUpdatedAt < state.dataUpdatedAt) {
          const {
            fetchStatus: _ignored,
            ...dehydratedQueryState
          } = state;
          query.setState(dehydratedQueryState);
        }
        return;
      }
      queryCache.build(
        client,
        {
          ...options2 == null ? void 0 : (_options$defaultOptio2 = options2.defaultOptions) == null ? void 0 : _options$defaultOptio2.queries,
          queryKey,
          queryHash
        },
        // Reset fetch status to idle to avoid
        // query being stuck in fetching state upon hydration
        {
          ...state,
          fetchStatus: "idle"
        }
      );
    });
  }

  // node_modules/@tanstack/react-query/build/lib/useSyncExternalStore.mjs
  var import_shim = __toESM(require_shim(), 1);
  var useSyncExternalStore = import_shim.useSyncExternalStore;

  // node_modules/@tanstack/react-query/build/lib/QueryClientProvider.mjs
  var React = __toESM(require_react(), 1);
  var defaultContext = /* @__PURE__ */ React.createContext(void 0);
  var QueryClientSharingContext = /* @__PURE__ */ React.createContext(false);
  function getQueryClientContext(context, contextSharing) {
    if (context) {
      return context;
    }
    if (contextSharing && typeof window !== "undefined") {
      if (!window.ReactQueryClientContext) {
        window.ReactQueryClientContext = defaultContext;
      }
      return window.ReactQueryClientContext;
    }
    return defaultContext;
  }
  var useQueryClient = ({
    context
  } = {}) => {
    const queryClient = React.useContext(getQueryClientContext(context, React.useContext(QueryClientSharingContext)));
    if (!queryClient) {
      throw new Error("No QueryClient set, use QueryClientProvider to set one");
    }
    return queryClient;
  };
  var QueryClientProvider = ({
    client,
    children,
    context,
    contextSharing = false
  }) => {
    React.useEffect(() => {
      client.mount();
      return () => {
        client.unmount();
      };
    }, [client]);
    if (contextSharing) {
      client.getLogger().error("The contextSharing option has been deprecated and will be removed in the next major version");
    }
    const Context2 = getQueryClientContext(context, contextSharing);
    return /* @__PURE__ */ React.createElement(QueryClientSharingContext.Provider, {
      value: !context && contextSharing
    }, /* @__PURE__ */ React.createElement(Context2.Provider, {
      value: client
    }, children));
  };

  // node_modules/@tanstack/react-query/build/lib/utils.mjs
  function shouldThrowError(_useErrorBoundary, params) {
    if (typeof _useErrorBoundary === "function") {
      return _useErrorBoundary(...params);
    }
    return !!_useErrorBoundary;
  }

  // node_modules/@tanstack/react-query/build/lib/useMutation.mjs
  var React2 = __toESM(require_react(), 1);
  function useMutation(arg1, arg2, arg3) {
    const options2 = parseMutationArgs(arg1, arg2, arg3);
    const queryClient = useQueryClient({
      context: options2.context
    });
    const [observer] = React2.useState(() => new MutationObserver(queryClient, options2));
    React2.useEffect(() => {
      observer.setOptions(options2);
    }, [observer, options2]);
    const result = useSyncExternalStore(React2.useCallback((onStoreChange) => observer.subscribe(notifyManager.batchCalls(onStoreChange)), [observer]), () => observer.getCurrentResult(), () => observer.getCurrentResult());
    const mutate = React2.useCallback((variables, mutateOptions) => {
      observer.mutate(variables, mutateOptions).catch(noop4);
    }, [observer]);
    if (result.error && shouldThrowError(observer.options.useErrorBoundary, [result.error])) {
      throw result.error;
    }
    return {
      ...result,
      mutate,
      mutateAsync: result.mutate
    };
  }
  function noop4() {
  }

  // node_modules/@tanstack/query-persist-client-core/build/lib/persist.mjs
  var cacheableEventTypes = ["added", "removed", "updated"];
  function isCacheableEventType(eventType) {
    return cacheableEventTypes.includes(eventType);
  }
  async function persistQueryClientRestore({
    queryClient,
    persister,
    maxAge = 1e3 * 60 * 60 * 24,
    buster = "",
    hydrateOptions
  }) {
    try {
      const persistedClient = await persister.restoreClient();
      if (persistedClient) {
        if (persistedClient.timestamp) {
          const expired = Date.now() - persistedClient.timestamp > maxAge;
          const busted = persistedClient.buster !== buster;
          if (expired || busted) {
            persister.removeClient();
          } else {
            hydrate(queryClient, persistedClient.clientState, hydrateOptions);
          }
        } else {
          persister.removeClient();
        }
      }
    } catch (err) {
      if (true) {
        queryClient.getLogger().error(err);
        queryClient.getLogger().warn("Encountered an error attempting to restore client cache from persisted location. As a precaution, the persisted cache will be discarded.");
      }
      persister.removeClient();
    }
  }
  async function persistQueryClientSave({
    queryClient,
    persister,
    buster = "",
    dehydrateOptions
  }) {
    const persistClient = {
      buster,
      timestamp: Date.now(),
      clientState: dehydrate(queryClient, dehydrateOptions)
    };
    await persister.persistClient(persistClient);
  }
  function persistQueryClientSubscribe(props) {
    const unsubscribeQueryCache = props.queryClient.getQueryCache().subscribe((event) => {
      if (isCacheableEventType(event.type)) {
        persistQueryClientSave(props);
      }
    });
    const unusbscribeMutationCache = props.queryClient.getMutationCache().subscribe((event) => {
      if (isCacheableEventType(event.type)) {
        persistQueryClientSave(props);
      }
    });
    return () => {
      unsubscribeQueryCache();
      unusbscribeMutationCache();
    };
  }
  function persistQueryClient(props) {
    let hasUnsubscribed = false;
    let persistQueryClientUnsubscribe;
    const unsubscribe = () => {
      hasUnsubscribed = true;
      persistQueryClientUnsubscribe == null ? void 0 : persistQueryClientUnsubscribe();
    };
    const restorePromise = persistQueryClientRestore(props).then(() => {
      if (!hasUnsubscribed) {
        persistQueryClientUnsubscribe = persistQueryClientSubscribe(props);
      }
    });
    return [unsubscribe, restorePromise];
  }

  // node_modules/wagmi/dist/index.js
  var React3 = __toESM(require_react(), 1);
  var React9 = __toESM(require_react(), 1);
  var React22 = __toESM(require_react(), 1);
  var pkg = __toESM(require_shim(), 1);
  var import_with_selector = __toESM(require_with_selector(), 1);
  var React32 = __toESM(require_react(), 1);
  var import_with_selector2 = __toESM(require_with_selector(), 1);
  var React4 = __toESM(require_react(), 1);
  var React7 = __toESM(require_react(), 1);
  var React5 = __toESM(require_react(), 1);
  var React6 = __toESM(require_react(), 1);
  var React8 = __toESM(require_react(), 1);
  var import_with_selector3 = __toESM(require_with_selector(), 1);
  var React10 = __toESM(require_react(), 1);
  var React11 = __toESM(require_react(), 1);
  var import_react2 = __toESM(require_react(), 1);
  var React12 = __toESM(require_react(), 1);
  var React13 = __toESM(require_react(), 1);
  var React14 = __toESM(require_react(), 1);
  var React15 = __toESM(require_react(), 1);
  var React16 = __toESM(require_react(), 1);
  var React17 = __toESM(require_react(), 1);
  var React18 = __toESM(require_react(), 1);
  var React19 = __toESM(require_react(), 1);
  var React20 = __toESM(require_react(), 1);
  var React21 = __toESM(require_react(), 1);
  function createConfig2({
    queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          cacheTime: 1e3 * 60 * 60 * 24,
          networkMode: "offlineFirst",
          refetchOnWindowFocus: false,
          retry: 0
        },
        mutations: {
          networkMode: "offlineFirst"
        }
      }
    }),
    storage = createStorage({
      storage: typeof window !== "undefined" && window.localStorage ? window.localStorage : noopStorage
    }),
    persister = typeof window !== "undefined" ? createSyncStoragePersister({
      key: "cache",
      storage,
      serialize: (x4) => x4,
      deserialize: (x4) => x4
    }) : void 0,
    ...args
  }) {
    const config2 = createConfig({
      ...args,
      storage
    });
    if (persister)
      persistQueryClient({
        queryClient,
        persister,
        dehydrateOptions: {
          shouldDehydrateQuery: (query) => query.cacheTime !== 0 && query.queryKey[0].persist !== false
        }
      });
    return Object.assign(config2, { queryClient });
  }
  var Context = React3.createContext(void 0);
  var queryClientContext = React3.createContext(
    void 0
  );
  function WagmiConfig({
    children,
    config: config2
  }) {
    return React3.createElement(Context.Provider, {
      children: React3.createElement(QueryClientProvider, {
        children,
        client: config2.queryClient,
        context: queryClientContext
      }),
      value: config2
    });
  }
  function useConfig() {
    const config2 = React3.useContext(Context);
    if (!config2)
      throw new Error(
        [
          "`useConfig` must be used within `WagmiConfig`.\n",
          "Read more: https://wagmi.sh/react/WagmiConfig"
        ].join("\n")
      );
    return config2;
  }
  function useMutation2(arg1, arg2, arg3) {
    const options2 = parseMutationArgs(arg1, arg2, arg3);
    return useMutation({ context: queryClientContext, ...options2 });
  }
  var isPlainObject2 = (obj) => typeof obj === "object" && !Array.isArray(obj);
  function useSyncExternalStoreWithTracked(subscribe3, getSnapshot, getServerSnapshot = getSnapshot, isEqual = deepEqual) {
    const trackedKeys = React8.useRef([]);
    const result = (0, import_with_selector3.useSyncExternalStoreWithSelector)(
      subscribe3,
      getSnapshot,
      getServerSnapshot,
      (x4) => x4,
      (a6, b7) => {
        if (isPlainObject2(a6) && isPlainObject2(b7) && trackedKeys.current.length) {
          for (const key2 of trackedKeys.current) {
            const equal = isEqual(
              a6[key2],
              b7[key2]
            );
            if (!equal)
              return false;
          }
          return true;
        }
        return isEqual(a6, b7);
      }
    );
    if (isPlainObject2(result)) {
      const trackedResult = { ...result };
      Object.defineProperties(
        trackedResult,
        Object.entries(trackedResult).reduce(
          (res, [key2, value]) => {
            return {
              ...res,
              [key2]: {
                configurable: false,
                enumerable: true,
                get: () => {
                  if (!trackedKeys.current.includes(key2)) {
                    trackedKeys.current.push(key2);
                  }
                  return value;
                }
              }
            };
          },
          {}
        )
      );
      return trackedResult;
    }
    return result;
  }
  function useAccount({ onConnect, onDisconnect } = {}) {
    const config2 = useConfig();
    const watchAccount_ = React9.useCallback(
      (callback) => watchAccount(callback),
      [config2]
    );
    const account = useSyncExternalStoreWithTracked(watchAccount_, getAccount);
    const previousAccountRef = React9.useRef();
    const previousAccount = previousAccountRef.current;
    React9.useEffect(() => {
      if (previousAccount?.status !== "connected" && account.status === "connected") {
        onConnect?.({
          address: account.address,
          connector: account.connector,
          isReconnected: previousAccount?.status === "reconnecting" || previousAccount?.status === void 0
        });
      }
      if (previousAccount?.status === "connected" && account.status === "disconnected") {
        onDisconnect?.();
      }
      previousAccountRef.current = account;
    }, [onConnect, onDisconnect, previousAccount, account]);
    return account;
  }
  var mutationKey2 = [{ entity: "disconnect" }];
  var mutationFn2 = () => disconnect();
  function useDisconnect({
    onError: onError2,
    onMutate,
    onSettled,
    onSuccess
  } = {}) {
    const {
      error,
      isError: isError2,
      isIdle,
      isLoading,
      isSuccess,
      mutate: disconnect2,
      mutateAsync: disconnectAsync,
      reset: reset2,
      status
    } = useMutation2(mutationKey2, mutationFn2, {
      ...onError2 ? {
        onError(error2, _variables, context) {
          onError2(error2, context);
        }
      } : {},
      onMutate,
      ...onSettled ? {
        onSettled(_data, error2, _variables, context) {
          onSettled(error2, context);
        }
      } : {},
      ...onSuccess ? {
        onSuccess(_data, _variables, context) {
          onSuccess(context);
        }
      } : {}
    });
    return {
      disconnect: disconnect2,
      disconnectAsync,
      error,
      isError: isError2,
      isIdle,
      isLoading,
      isSuccess,
      reset: reset2,
      status
    };
  }
  function useNetwork() {
    const config2 = useConfig();
    const watchNetwork_ = (0, import_react2.useCallback)(
      (callback) => watchNetwork(callback),
      [config2]
    );
    return useSyncExternalStoreWithTracked(watchNetwork_, getNetwork);
  }

  // src/components/Router.tsx
  var import_react22 = __toESM(require_react());

  // src/pages/Viewer.tsx
  var import_react17 = __toESM(require_react());

  // src/components/Header.tsx
  var import_react8 = __toESM(require_react());

  // node_modules/zustand/esm/index.mjs
  var import_react3 = __toESM(require_react(), 1);
  var import_with_selector4 = __toESM(require_with_selector(), 1);
  var import_meta5 = {};
  var { useDebugValue } = import_react3.default;
  var { useSyncExternalStoreWithSelector: useSyncExternalStoreWithSelector4 } = import_with_selector4.default;
  var didWarnAboutEqualityFn = false;
  function useStore(api, selector = api.getState, equalityFn) {
    if ((import_meta5.env ? import_meta5.env.MODE : void 0) !== "production" && equalityFn && !didWarnAboutEqualityFn) {
      console.warn(
        "[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"
      );
      didWarnAboutEqualityFn = true;
    }
    const slice2 = useSyncExternalStoreWithSelector4(
      api.subscribe,
      api.getState,
      api.getServerState || api.getState,
      selector,
      equalityFn
    );
    useDebugValue(slice2);
    return slice2;
  }
  var createImpl = (createState) => {
    if ((import_meta5.env ? import_meta5.env.MODE : void 0) !== "production" && typeof createState !== "function") {
      console.warn(
        "[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`."
      );
    }
    const api = typeof createState === "function" ? createStore(createState) : createState;
    const useBoundStore = (selector, equalityFn) => useStore(api, selector, equalityFn);
    Object.assign(useBoundStore, api);
    return useBoundStore;
  };
  var create2 = (createState) => createState ? createImpl(createState) : createImpl;

  // node_modules/axios/lib/helpers/bind.js
  function bind(fn2, thisArg) {
    return function wrap2() {
      return fn2.apply(thisArg, arguments);
    };
  }

  // node_modules/axios/lib/utils.js
  var { toString: toString3 } = Object.prototype;
  var { getPrototypeOf } = Object;
  var kindOf = ((cache) => (thing) => {
    const str = toString3.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
  })(/* @__PURE__ */ Object.create(null));
  var kindOfTest = (type) => {
    type = type.toLowerCase();
    return (thing) => kindOf(thing) === type;
  };
  var typeOfTest = (type) => (thing) => typeof thing === type;
  var { isArray } = Array;
  var isUndefined = typeOfTest("undefined");
  function isBuffer(val) {
    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction2(val.constructor.isBuffer) && val.constructor.isBuffer(val);
  }
  var isArrayBuffer = kindOfTest("ArrayBuffer");
  function isArrayBufferView(val) {
    let result;
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
      result = ArrayBuffer.isView(val);
    } else {
      result = val && val.buffer && isArrayBuffer(val.buffer);
    }
    return result;
  }
  var isString2 = typeOfTest("string");
  var isFunction2 = typeOfTest("function");
  var isNumber2 = typeOfTest("number");
  var isObject3 = (thing) => thing !== null && typeof thing === "object";
  var isBoolean = (thing) => thing === true || thing === false;
  var isPlainObject3 = (val) => {
    if (kindOf(val) !== "object") {
      return false;
    }
    const prototype3 = getPrototypeOf(val);
    return (prototype3 === null || prototype3 === Object.prototype || Object.getPrototypeOf(prototype3) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
  };
  var isDate = kindOfTest("Date");
  var isFile = kindOfTest("File");
  var isBlob = kindOfTest("Blob");
  var isFileList = kindOfTest("FileList");
  var isStream = (val) => isObject3(val) && isFunction2(val.pipe);
  var isFormData = (thing) => {
    let kind;
    return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction2(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
    kind === "object" && isFunction2(thing.toString) && thing.toString() === "[object FormData]"));
  };
  var isURLSearchParams = kindOfTest("URLSearchParams");
  var trim2 = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
  function forEach(obj, fn2, { allOwnKeys = false } = {}) {
    if (obj === null || typeof obj === "undefined") {
      return;
    }
    let i7;
    let l9;
    if (typeof obj !== "object") {
      obj = [obj];
    }
    if (isArray(obj)) {
      for (i7 = 0, l9 = obj.length; i7 < l9; i7++) {
        fn2.call(null, obj[i7], i7, obj);
      }
    } else {
      const keys2 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
      const len = keys2.length;
      let key2;
      for (i7 = 0; i7 < len; i7++) {
        key2 = keys2[i7];
        fn2.call(null, obj[key2], key2, obj);
      }
    }
  }
  function findKey(obj, key2) {
    key2 = key2.toLowerCase();
    const keys2 = Object.keys(obj);
    let i7 = keys2.length;
    let _key;
    while (i7-- > 0) {
      _key = keys2[i7];
      if (key2 === _key.toLowerCase()) {
        return _key;
      }
    }
    return null;
  }
  var _global = (() => {
    if (typeof globalThis !== "undefined")
      return globalThis;
    return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
  })();
  var isContextDefined = (context) => !isUndefined(context) && context !== _global;
  function merge() {
    const { caseless } = isContextDefined(this) && this || {};
    const result = {};
    const assignValue = (val, key2) => {
      const targetKey = caseless && findKey(result, key2) || key2;
      if (isPlainObject3(result[targetKey]) && isPlainObject3(val)) {
        result[targetKey] = merge(result[targetKey], val);
      } else if (isPlainObject3(val)) {
        result[targetKey] = merge({}, val);
      } else if (isArray(val)) {
        result[targetKey] = val.slice();
      } else {
        result[targetKey] = val;
      }
    };
    for (let i7 = 0, l9 = arguments.length; i7 < l9; i7++) {
      arguments[i7] && forEach(arguments[i7], assignValue);
    }
    return result;
  }
  var extend = (a6, b7, thisArg, { allOwnKeys } = {}) => {
    forEach(b7, (val, key2) => {
      if (thisArg && isFunction2(val)) {
        a6[key2] = bind(val, thisArg);
      } else {
        a6[key2] = val;
      }
    }, { allOwnKeys });
    return a6;
  };
  var stripBOM = (content) => {
    if (content.charCodeAt(0) === 65279) {
      content = content.slice(1);
    }
    return content;
  };
  var inherits = (constructor, superConstructor, props, descriptors2) => {
    constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
    constructor.prototype.constructor = constructor;
    Object.defineProperty(constructor, "super", {
      value: superConstructor.prototype
    });
    props && Object.assign(constructor.prototype, props);
  };
  var toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
    let props;
    let i7;
    let prop;
    const merged = {};
    destObj = destObj || {};
    if (sourceObj == null)
      return destObj;
    do {
      props = Object.getOwnPropertyNames(sourceObj);
      i7 = props.length;
      while (i7-- > 0) {
        prop = props[i7];
        if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
          destObj[prop] = sourceObj[prop];
          merged[prop] = true;
        }
      }
      sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
    } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
    return destObj;
  };
  var endsWith = (str, searchString, position) => {
    str = String(str);
    if (position === void 0 || position > str.length) {
      position = str.length;
    }
    position -= searchString.length;
    const lastIndex = str.indexOf(searchString, position);
    return lastIndex !== -1 && lastIndex === position;
  };
  var toArray = (thing) => {
    if (!thing)
      return null;
    if (isArray(thing))
      return thing;
    let i7 = thing.length;
    if (!isNumber2(i7))
      return null;
    const arr = new Array(i7);
    while (i7-- > 0) {
      arr[i7] = thing[i7];
    }
    return arr;
  };
  var isTypedArray = ((TypedArray) => {
    return (thing) => {
      return TypedArray && thing instanceof TypedArray;
    };
  })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
  var forEachEntry = (obj, fn2) => {
    const generator = obj && obj[Symbol.iterator];
    const iterator = generator.call(obj);
    let result;
    while ((result = iterator.next()) && !result.done) {
      const pair = result.value;
      fn2.call(obj, pair[0], pair[1]);
    }
  };
  var matchAll = (regExp, str) => {
    let matches;
    const arr = [];
    while ((matches = regExp.exec(str)) !== null) {
      arr.push(matches);
    }
    return arr;
  };
  var isHTMLForm = kindOfTest("HTMLFormElement");
  var toCamelCase = (str) => {
    return str.toLowerCase().replace(
      /[-_\s]([a-z\d])(\w*)/g,
      function replacer(m6, p1, p22) {
        return p1.toUpperCase() + p22;
      }
    );
  };
  var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
  var isRegExp = kindOfTest("RegExp");
  var reduceDescriptors = (obj, reducer) => {
    const descriptors2 = Object.getOwnPropertyDescriptors(obj);
    const reducedDescriptors = {};
    forEach(descriptors2, (descriptor, name2) => {
      let ret;
      if ((ret = reducer(descriptor, name2, obj)) !== false) {
        reducedDescriptors[name2] = ret || descriptor;
      }
    });
    Object.defineProperties(obj, reducedDescriptors);
  };
  var freezeMethods = (obj) => {
    reduceDescriptors(obj, (descriptor, name2) => {
      if (isFunction2(obj) && ["arguments", "caller", "callee"].indexOf(name2) !== -1) {
        return false;
      }
      const value = obj[name2];
      if (!isFunction2(value))
        return;
      descriptor.enumerable = false;
      if ("writable" in descriptor) {
        descriptor.writable = false;
        return;
      }
      if (!descriptor.set) {
        descriptor.set = () => {
          throw Error("Can not rewrite read-only method '" + name2 + "'");
        };
      }
    });
  };
  var toObjectSet = (arrayOrString, delimiter) => {
    const obj = {};
    const define2 = (arr) => {
      arr.forEach((value) => {
        obj[value] = true;
      });
    };
    isArray(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter));
    return obj;
  };
  var noop5 = () => {
  };
  var toFiniteNumber = (value, defaultValue) => {
    value = +value;
    return Number.isFinite(value) ? value : defaultValue;
  };
  var ALPHA = "abcdefghijklmnopqrstuvwxyz";
  var DIGIT = "0123456789";
  var ALPHABET = {
    DIGIT,
    ALPHA,
    ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
  };
  var generateString = (size3 = 16, alphabet2 = ALPHABET.ALPHA_DIGIT) => {
    let str = "";
    const { length: length2 } = alphabet2;
    while (size3--) {
      str += alphabet2[Math.random() * length2 | 0];
    }
    return str;
  };
  function isSpecCompliantForm(thing) {
    return !!(thing && isFunction2(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
  }
  var toJSONObject = (obj) => {
    const stack = new Array(10);
    const visit = (source, i7) => {
      if (isObject3(source)) {
        if (stack.indexOf(source) >= 0) {
          return;
        }
        if (!("toJSON" in source)) {
          stack[i7] = source;
          const target = isArray(source) ? [] : {};
          forEach(source, (value, key2) => {
            const reducedValue = visit(value, i7 + 1);
            !isUndefined(reducedValue) && (target[key2] = reducedValue);
          });
          stack[i7] = void 0;
          return target;
        }
      }
      return source;
    };
    return visit(obj, 0);
  };
  var isAsyncFn = kindOfTest("AsyncFunction");
  var isThenable = (thing) => thing && (isObject3(thing) || isFunction2(thing)) && isFunction2(thing.then) && isFunction2(thing.catch);
  var utils_default = {
    isArray,
    isArrayBuffer,
    isBuffer,
    isFormData,
    isArrayBufferView,
    isString: isString2,
    isNumber: isNumber2,
    isBoolean,
    isObject: isObject3,
    isPlainObject: isPlainObject3,
    isUndefined,
    isDate,
    isFile,
    isBlob,
    isRegExp,
    isFunction: isFunction2,
    isStream,
    isURLSearchParams,
    isTypedArray,
    isFileList,
    forEach,
    merge,
    extend,
    trim: trim2,
    stripBOM,
    inherits,
    toFlatObject,
    kindOf,
    kindOfTest,
    endsWith,
    toArray,
    forEachEntry,
    matchAll,
    isHTMLForm,
    hasOwnProperty,
    hasOwnProp: hasOwnProperty,
    // an alias to avoid ESLint no-prototype-builtins detection
    reduceDescriptors,
    freezeMethods,
    toObjectSet,
    toCamelCase,
    noop: noop5,
    toFiniteNumber,
    findKey,
    global: _global,
    isContextDefined,
    ALPHABET,
    generateString,
    isSpecCompliantForm,
    toJSONObject,
    isAsyncFn,
    isThenable
  };

  // node_modules/axios/lib/core/AxiosError.js
  function AxiosError(message, code2, config2, request, response) {
    Error.call(this);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error().stack;
    }
    this.message = message;
    this.name = "AxiosError";
    code2 && (this.code = code2);
    config2 && (this.config = config2);
    request && (this.request = request);
    response && (this.response = response);
  }
  utils_default.inherits(AxiosError, Error, {
    toJSON: function toJSON() {
      return {
        // Standard
        message: this.message,
        name: this.name,
        // Microsoft
        description: this.description,
        number: this.number,
        // Mozilla
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        // Axios
        config: utils_default.toJSONObject(this.config),
        code: this.code,
        status: this.response && this.response.status ? this.response.status : null
      };
    }
  });
  var prototype = AxiosError.prototype;
  var descriptors = {};
  [
    "ERR_BAD_OPTION_VALUE",
    "ERR_BAD_OPTION",
    "ECONNABORTED",
    "ETIMEDOUT",
    "ERR_NETWORK",
    "ERR_FR_TOO_MANY_REDIRECTS",
    "ERR_DEPRECATED",
    "ERR_BAD_RESPONSE",
    "ERR_BAD_REQUEST",
    "ERR_CANCELED",
    "ERR_NOT_SUPPORT",
    "ERR_INVALID_URL"
    // eslint-disable-next-line func-names
  ].forEach((code2) => {
    descriptors[code2] = { value: code2 };
  });
  Object.defineProperties(AxiosError, descriptors);
  Object.defineProperty(prototype, "isAxiosError", { value: true });
  AxiosError.from = (error, code2, config2, request, response, customProps) => {
    const axiosError = Object.create(prototype);
    utils_default.toFlatObject(error, axiosError, function filter2(obj) {
      return obj !== Error.prototype;
    }, (prop) => {
      return prop !== "isAxiosError";
    });
    AxiosError.call(axiosError, error.message, code2, config2, request, response);
    axiosError.cause = error;
    axiosError.name = error.name;
    customProps && Object.assign(axiosError, customProps);
    return axiosError;
  };
  var AxiosError_default = AxiosError;

  // node_modules/axios/lib/helpers/null.js
  var null_default = null;

  // node_modules/axios/lib/helpers/toFormData.js
  function isVisitable(thing) {
    return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
  }
  function removeBrackets(key2) {
    return utils_default.endsWith(key2, "[]") ? key2.slice(0, -2) : key2;
  }
  function renderKey(path, key2, dots) {
    if (!path)
      return key2;
    return path.concat(key2).map(function each(token, i7) {
      token = removeBrackets(token);
      return !dots && i7 ? "[" + token + "]" : token;
    }).join(dots ? "." : "");
  }
  function isFlatArray(arr) {
    return utils_default.isArray(arr) && !arr.some(isVisitable);
  }
  var predicates = utils_default.toFlatObject(utils_default, {}, null, function filter(prop) {
    return /^is[A-Z]/.test(prop);
  });
  function toFormData(obj, formData, options2) {
    if (!utils_default.isObject(obj)) {
      throw new TypeError("target must be an object");
    }
    formData = formData || new (null_default || FormData)();
    options2 = utils_default.toFlatObject(options2, {
      metaTokens: true,
      dots: false,
      indexes: false
    }, false, function defined(option, source) {
      return !utils_default.isUndefined(source[option]);
    });
    const metaTokens = options2.metaTokens;
    const visitor = options2.visitor || defaultVisitor;
    const dots = options2.dots;
    const indexes = options2.indexes;
    const _Blob = options2.Blob || typeof Blob !== "undefined" && Blob;
    const useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
    if (!utils_default.isFunction(visitor)) {
      throw new TypeError("visitor must be a function");
    }
    function convertValue(value) {
      if (value === null)
        return "";
      if (utils_default.isDate(value)) {
        return value.toISOString();
      }
      if (!useBlob && utils_default.isBlob(value)) {
        throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
      }
      if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
        return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
      }
      return value;
    }
    function defaultVisitor(value, key2, path) {
      let arr = value;
      if (value && !path && typeof value === "object") {
        if (utils_default.endsWith(key2, "{}")) {
          key2 = metaTokens ? key2 : key2.slice(0, -2);
          value = JSON.stringify(value);
        } else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key2, "[]")) && (arr = utils_default.toArray(value))) {
          key2 = removeBrackets(key2);
          arr.forEach(function each(el, index2) {
            !(utils_default.isUndefined(el) || el === null) && formData.append(
              // eslint-disable-next-line no-nested-ternary
              indexes === true ? renderKey([key2], index2, dots) : indexes === null ? key2 : key2 + "[]",
              convertValue(el)
            );
          });
          return false;
        }
      }
      if (isVisitable(value)) {
        return true;
      }
      formData.append(renderKey(path, key2, dots), convertValue(value));
      return false;
    }
    const stack = [];
    const exposedHelpers = Object.assign(predicates, {
      defaultVisitor,
      convertValue,
      isVisitable
    });
    function build(value, path) {
      if (utils_default.isUndefined(value))
        return;
      if (stack.indexOf(value) !== -1) {
        throw Error("Circular reference detected in " + path.join("."));
      }
      stack.push(value);
      utils_default.forEach(value, function each(el, key2) {
        const result = !(utils_default.isUndefined(el) || el === null) && visitor.call(
          formData,
          el,
          utils_default.isString(key2) ? key2.trim() : key2,
          path,
          exposedHelpers
        );
        if (result === true) {
          build(el, path ? path.concat(key2) : [key2]);
        }
      });
      stack.pop();
    }
    if (!utils_default.isObject(obj)) {
      throw new TypeError("data must be an object");
    }
    build(obj);
    return formData;
  }
  var toFormData_default = toFormData;

  // node_modules/axios/lib/helpers/AxiosURLSearchParams.js
  function encode5(str) {
    const charMap = {
      "!": "%21",
      "'": "%27",
      "(": "%28",
      ")": "%29",
      "~": "%7E",
      "%20": "+",
      "%00": "\0"
    };
    return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
      return charMap[match];
    });
  }
  function AxiosURLSearchParams(params, options2) {
    this._pairs = [];
    params && toFormData_default(params, this, options2);
  }
  var prototype2 = AxiosURLSearchParams.prototype;
  prototype2.append = function append(name2, value) {
    this._pairs.push([name2, value]);
  };
  prototype2.toString = function toString4(encoder3) {
    const _encode3 = encoder3 ? function(value) {
      return encoder3.call(this, value, encode5);
    } : encode5;
    return this._pairs.map(function each(pair) {
      return _encode3(pair[0]) + "=" + _encode3(pair[1]);
    }, "").join("&");
  };
  var AxiosURLSearchParams_default = AxiosURLSearchParams;

  // node_modules/axios/lib/helpers/buildURL.js
  function encode6(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
  }
  function buildURL(url, params, options2) {
    if (!params) {
      return url;
    }
    const _encode3 = options2 && options2.encode || encode6;
    const serializeFn = options2 && options2.serialize;
    let serializedParams;
    if (serializeFn) {
      serializedParams = serializeFn(params, options2);
    } else {
      serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, options2).toString(_encode3);
    }
    if (serializedParams) {
      const hashmarkIndex = url.indexOf("#");
      if (hashmarkIndex !== -1) {
        url = url.slice(0, hashmarkIndex);
      }
      url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
    }
    return url;
  }

  // node_modules/axios/lib/core/InterceptorManager.js
  var InterceptorManager = class {
    constructor() {
      this.handlers = [];
    }
    /**
     * Add a new interceptor to the stack
     *
     * @param {Function} fulfilled The function to handle `then` for a `Promise`
     * @param {Function} rejected The function to handle `reject` for a `Promise`
     *
     * @return {Number} An ID used to remove interceptor later
     */
    use(fulfilled, rejected, options2) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options2 ? options2.synchronous : false,
        runWhen: options2 ? options2.runWhen : null
      });
      return this.handlers.length - 1;
    }
    /**
     * Remove an interceptor from the stack
     *
     * @param {Number} id The ID that was returned by `use`
     *
     * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
     */
    eject(id3) {
      if (this.handlers[id3]) {
        this.handlers[id3] = null;
      }
    }
    /**
     * Clear all interceptors from the stack
     *
     * @returns {void}
     */
    clear() {
      if (this.handlers) {
        this.handlers = [];
      }
    }
    /**
     * Iterate over all the registered interceptors
     *
     * This method is particularly useful for skipping over any
     * interceptors that may have become `null` calling `eject`.
     *
     * @param {Function} fn The function to call for each interceptor
     *
     * @returns {void}
     */
    forEach(fn2) {
      utils_default.forEach(this.handlers, function forEachHandler(h10) {
        if (h10 !== null) {
          fn2(h10);
        }
      });
    }
  };
  var InterceptorManager_default = InterceptorManager;

  // node_modules/axios/lib/defaults/transitional.js
  var transitional_default = {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  };

  // node_modules/axios/lib/platform/browser/classes/URLSearchParams.js
  var URLSearchParams_default = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams_default;

  // node_modules/axios/lib/platform/browser/classes/FormData.js
  var FormData_default = typeof FormData !== "undefined" ? FormData : null;

  // node_modules/axios/lib/platform/browser/classes/Blob.js
  var Blob_default = typeof Blob !== "undefined" ? Blob : null;

  // node_modules/axios/lib/platform/browser/index.js
  var browser_default2 = {
    isBrowser: true,
    classes: {
      URLSearchParams: URLSearchParams_default,
      FormData: FormData_default,
      Blob: Blob_default
    },
    protocols: ["http", "https", "file", "blob", "url", "data"]
  };

  // node_modules/axios/lib/platform/common/utils.js
  var utils_exports = {};
  __export(utils_exports, {
    hasBrowserEnv: () => hasBrowserEnv,
    hasStandardBrowserEnv: () => hasStandardBrowserEnv,
    hasStandardBrowserWebWorkerEnv: () => hasStandardBrowserWebWorkerEnv
  });
  var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
  var hasStandardBrowserEnv = ((product) => {
    return hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf(product) < 0;
  })(typeof navigator !== "undefined" && navigator.product);
  var hasStandardBrowserWebWorkerEnv = (() => {
    return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
  })();

  // node_modules/axios/lib/platform/index.js
  var platform_default = {
    ...utils_exports,
    ...browser_default2
  };

  // node_modules/axios/lib/helpers/toURLEncodedForm.js
  function toURLEncodedForm(data2, options2) {
    return toFormData_default(data2, new platform_default.classes.URLSearchParams(), Object.assign({
      visitor: function(value, key2, path, helpers) {
        if (platform_default.isNode && utils_default.isBuffer(value)) {
          this.append(key2, value.toString("base64"));
          return false;
        }
        return helpers.defaultVisitor.apply(this, arguments);
      }
    }, options2));
  }

  // node_modules/axios/lib/helpers/formDataToJSON.js
  function parsePropPath(name2) {
    return utils_default.matchAll(/\w+|\[(\w*)]/g, name2).map((match) => {
      return match[0] === "[]" ? "" : match[1] || match[0];
    });
  }
  function arrayToObject(arr) {
    const obj = {};
    const keys2 = Object.keys(arr);
    let i7;
    const len = keys2.length;
    let key2;
    for (i7 = 0; i7 < len; i7++) {
      key2 = keys2[i7];
      obj[key2] = arr[key2];
    }
    return obj;
  }
  function formDataToJSON(formData) {
    function buildPath(path, value, target, index2) {
      let name2 = path[index2++];
      const isNumericKey = Number.isFinite(+name2);
      const isLast = index2 >= path.length;
      name2 = !name2 && utils_default.isArray(target) ? target.length : name2;
      if (isLast) {
        if (utils_default.hasOwnProp(target, name2)) {
          target[name2] = [target[name2], value];
        } else {
          target[name2] = value;
        }
        return !isNumericKey;
      }
      if (!target[name2] || !utils_default.isObject(target[name2])) {
        target[name2] = [];
      }
      const result = buildPath(path, value, target[name2], index2);
      if (result && utils_default.isArray(target[name2])) {
        target[name2] = arrayToObject(target[name2]);
      }
      return !isNumericKey;
    }
    if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
      const obj = {};
      utils_default.forEachEntry(formData, (name2, value) => {
        buildPath(parsePropPath(name2), value, obj, 0);
      });
      return obj;
    }
    return null;
  }
  var formDataToJSON_default = formDataToJSON;

  // node_modules/axios/lib/defaults/index.js
  function stringifySafely(rawValue, parser2, encoder3) {
    if (utils_default.isString(rawValue)) {
      try {
        (parser2 || JSON.parse)(rawValue);
        return utils_default.trim(rawValue);
      } catch (e9) {
        if (e9.name !== "SyntaxError") {
          throw e9;
        }
      }
    }
    return (encoder3 || JSON.stringify)(rawValue);
  }
  var defaults2 = {
    transitional: transitional_default,
    adapter: ["xhr", "http"],
    transformRequest: [function transformRequest(data2, headers) {
      const contentType = headers.getContentType() || "";
      const hasJSONContentType = contentType.indexOf("application/json") > -1;
      const isObjectPayload = utils_default.isObject(data2);
      if (isObjectPayload && utils_default.isHTMLForm(data2)) {
        data2 = new FormData(data2);
      }
      const isFormData2 = utils_default.isFormData(data2);
      if (isFormData2) {
        if (!hasJSONContentType) {
          return data2;
        }
        return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data2)) : data2;
      }
      if (utils_default.isArrayBuffer(data2) || utils_default.isBuffer(data2) || utils_default.isStream(data2) || utils_default.isFile(data2) || utils_default.isBlob(data2)) {
        return data2;
      }
      if (utils_default.isArrayBufferView(data2)) {
        return data2.buffer;
      }
      if (utils_default.isURLSearchParams(data2)) {
        headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
        return data2.toString();
      }
      let isFileList2;
      if (isObjectPayload) {
        if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
          return toURLEncodedForm(data2, this.formSerializer).toString();
        }
        if ((isFileList2 = utils_default.isFileList(data2)) || contentType.indexOf("multipart/form-data") > -1) {
          const _FormData = this.env && this.env.FormData;
          return toFormData_default(
            isFileList2 ? { "files[]": data2 } : data2,
            _FormData && new _FormData(),
            this.formSerializer
          );
        }
      }
      if (isObjectPayload || hasJSONContentType) {
        headers.setContentType("application/json", false);
        return stringifySafely(data2);
      }
      return data2;
    }],
    transformResponse: [function transformResponse(data2) {
      const transitional2 = this.transitional || defaults2.transitional;
      const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
      const JSONRequested = this.responseType === "json";
      if (data2 && utils_default.isString(data2) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
        const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
        const strictJSONParsing = !silentJSONParsing && JSONRequested;
        try {
          return JSON.parse(data2);
        } catch (e9) {
          if (strictJSONParsing) {
            if (e9.name === "SyntaxError") {
              throw AxiosError_default.from(e9, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
            }
            throw e9;
          }
        }
      }
      return data2;
    }],
    /**
     * A timeout in milliseconds to abort a request. If set to 0 (default) a
     * timeout is not created.
     */
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
      FormData: platform_default.classes.FormData,
      Blob: platform_default.classes.Blob
    },
    validateStatus: function validateStatus(status) {
      return status >= 200 && status < 300;
    },
    headers: {
      common: {
        "Accept": "application/json, text/plain, */*",
        "Content-Type": void 0
      }
    }
  };
  utils_default.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
    defaults2.headers[method] = {};
  });
  var defaults_default = defaults2;

  // node_modules/axios/lib/helpers/parseHeaders.js
  var ignoreDuplicateOf = utils_default.toObjectSet([
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ]);
  var parseHeaders_default = (rawHeaders) => {
    const parsed = {};
    let key2;
    let val;
    let i7;
    rawHeaders && rawHeaders.split("\n").forEach(function parser2(line) {
      i7 = line.indexOf(":");
      key2 = line.substring(0, i7).trim().toLowerCase();
      val = line.substring(i7 + 1).trim();
      if (!key2 || parsed[key2] && ignoreDuplicateOf[key2]) {
        return;
      }
      if (key2 === "set-cookie") {
        if (parsed[key2]) {
          parsed[key2].push(val);
        } else {
          parsed[key2] = [val];
        }
      } else {
        parsed[key2] = parsed[key2] ? parsed[key2] + ", " + val : val;
      }
    });
    return parsed;
  };

  // node_modules/axios/lib/core/AxiosHeaders.js
  var $internals = Symbol("internals");
  function normalizeHeader(header) {
    return header && String(header).trim().toLowerCase();
  }
  function normalizeValue(value) {
    if (value === false || value == null) {
      return value;
    }
    return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
  }
  function parseTokens(str) {
    const tokens = /* @__PURE__ */ Object.create(null);
    const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let match;
    while (match = tokensRE.exec(str)) {
      tokens[match[1]] = match[2];
    }
    return tokens;
  }
  var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
  function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
    if (utils_default.isFunction(filter2)) {
      return filter2.call(this, value, header);
    }
    if (isHeaderNameFilter) {
      value = header;
    }
    if (!utils_default.isString(value))
      return;
    if (utils_default.isString(filter2)) {
      return value.indexOf(filter2) !== -1;
    }
    if (utils_default.isRegExp(filter2)) {
      return filter2.test(value);
    }
  }
  function formatHeader(header) {
    return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w8, char, str) => {
      return char.toUpperCase() + str;
    });
  }
  function buildAccessors(obj, header) {
    const accessorName = utils_default.toCamelCase(" " + header);
    ["get", "set", "has"].forEach((methodName) => {
      Object.defineProperty(obj, methodName + accessorName, {
        value: function(arg1, arg2, arg3) {
          return this[methodName].call(this, header, arg1, arg2, arg3);
        },
        configurable: true
      });
    });
  }
  var AxiosHeaders = class {
    constructor(headers) {
      headers && this.set(headers);
    }
    set(header, valueOrRewrite, rewrite) {
      const self2 = this;
      function setHeader(_value, _header, _rewrite) {
        const lHeader = normalizeHeader(_header);
        if (!lHeader) {
          throw new Error("header name must be a non-empty string");
        }
        const key2 = utils_default.findKey(self2, lHeader);
        if (!key2 || self2[key2] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key2] !== false) {
          self2[key2 || _header] = normalizeValue(_value);
        }
      }
      const setHeaders = (headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
      if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
        setHeaders(header, valueOrRewrite);
      } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
        setHeaders(parseHeaders_default(header), valueOrRewrite);
      } else {
        header != null && setHeader(valueOrRewrite, header, rewrite);
      }
      return this;
    }
    get(header, parser2) {
      header = normalizeHeader(header);
      if (header) {
        const key2 = utils_default.findKey(this, header);
        if (key2) {
          const value = this[key2];
          if (!parser2) {
            return value;
          }
          if (parser2 === true) {
            return parseTokens(value);
          }
          if (utils_default.isFunction(parser2)) {
            return parser2.call(this, value, key2);
          }
          if (utils_default.isRegExp(parser2)) {
            return parser2.exec(value);
          }
          throw new TypeError("parser must be boolean|regexp|function");
        }
      }
    }
    has(header, matcher) {
      header = normalizeHeader(header);
      if (header) {
        const key2 = utils_default.findKey(this, header);
        return !!(key2 && this[key2] !== void 0 && (!matcher || matchHeaderValue(this, this[key2], key2, matcher)));
      }
      return false;
    }
    delete(header, matcher) {
      const self2 = this;
      let deleted = false;
      function deleteHeader(_header) {
        _header = normalizeHeader(_header);
        if (_header) {
          const key2 = utils_default.findKey(self2, _header);
          if (key2 && (!matcher || matchHeaderValue(self2, self2[key2], key2, matcher))) {
            delete self2[key2];
            deleted = true;
          }
        }
      }
      if (utils_default.isArray(header)) {
        header.forEach(deleteHeader);
      } else {
        deleteHeader(header);
      }
      return deleted;
    }
    clear(matcher) {
      const keys2 = Object.keys(this);
      let i7 = keys2.length;
      let deleted = false;
      while (i7--) {
        const key2 = keys2[i7];
        if (!matcher || matchHeaderValue(this, this[key2], key2, matcher, true)) {
          delete this[key2];
          deleted = true;
        }
      }
      return deleted;
    }
    normalize(format2) {
      const self2 = this;
      const headers = {};
      utils_default.forEach(this, (value, header) => {
        const key2 = utils_default.findKey(headers, header);
        if (key2) {
          self2[key2] = normalizeValue(value);
          delete self2[header];
          return;
        }
        const normalized = format2 ? formatHeader(header) : String(header).trim();
        if (normalized !== header) {
          delete self2[header];
        }
        self2[normalized] = normalizeValue(value);
        headers[normalized] = true;
      });
      return this;
    }
    concat(...targets) {
      return this.constructor.concat(this, ...targets);
    }
    toJSON(asStrings) {
      const obj = /* @__PURE__ */ Object.create(null);
      utils_default.forEach(this, (value, header) => {
        value != null && value !== false && (obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
      });
      return obj;
    }
    [Symbol.iterator]() {
      return Object.entries(this.toJSON())[Symbol.iterator]();
    }
    toString() {
      return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
    }
    get [Symbol.toStringTag]() {
      return "AxiosHeaders";
    }
    static from(thing) {
      return thing instanceof this ? thing : new this(thing);
    }
    static concat(first, ...targets) {
      const computed = new this(first);
      targets.forEach((target) => computed.set(target));
      return computed;
    }
    static accessor(header) {
      const internals = this[$internals] = this[$internals] = {
        accessors: {}
      };
      const accessors = internals.accessors;
      const prototype3 = this.prototype;
      function defineAccessor(_header) {
        const lHeader = normalizeHeader(_header);
        if (!accessors[lHeader]) {
          buildAccessors(prototype3, _header);
          accessors[lHeader] = true;
        }
      }
      utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
      return this;
    }
  };
  AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
  utils_default.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key2) => {
    let mapped = key2[0].toUpperCase() + key2.slice(1);
    return {
      get: () => value,
      set(headerValue) {
        this[mapped] = headerValue;
      }
    };
  });
  utils_default.freezeMethods(AxiosHeaders);
  var AxiosHeaders_default = AxiosHeaders;

  // node_modules/axios/lib/core/transformData.js
  function transformData(fns, response) {
    const config2 = this || defaults_default;
    const context = response || config2;
    const headers = AxiosHeaders_default.from(context.headers);
    let data2 = context.data;
    utils_default.forEach(fns, function transform(fn2) {
      data2 = fn2.call(config2, data2, headers.normalize(), response ? response.status : void 0);
    });
    headers.normalize();
    return data2;
  }

  // node_modules/axios/lib/cancel/isCancel.js
  function isCancel(value) {
    return !!(value && value.__CANCEL__);
  }

  // node_modules/axios/lib/cancel/CanceledError.js
  function CanceledError(message, config2, request) {
    AxiosError_default.call(this, message == null ? "canceled" : message, AxiosError_default.ERR_CANCELED, config2, request);
    this.name = "CanceledError";
  }
  utils_default.inherits(CanceledError, AxiosError_default, {
    __CANCEL__: true
  });
  var CanceledError_default = CanceledError;

  // node_modules/axios/lib/core/settle.js
  function settle(resolve, reject, response) {
    const validateStatus2 = response.config.validateStatus;
    if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
      resolve(response);
    } else {
      reject(new AxiosError_default(
        "Request failed with status code " + response.status,
        [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
        response.config,
        response.request,
        response
      ));
    }
  }

  // node_modules/axios/lib/helpers/cookies.js
  var cookies_default = platform_default.hasStandardBrowserEnv ? (
    // Standard browser envs support document.cookie
    {
      write(name2, value, expires, path, domain2, secure) {
        const cookie = [name2 + "=" + encodeURIComponent(value)];
        utils_default.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
        utils_default.isString(path) && cookie.push("path=" + path);
        utils_default.isString(domain2) && cookie.push("domain=" + domain2);
        secure === true && cookie.push("secure");
        document.cookie = cookie.join("; ");
      },
      read(name2) {
        const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"));
        return match ? decodeURIComponent(match[3]) : null;
      },
      remove(name2) {
        this.write(name2, "", Date.now() - 864e5);
      }
    }
  ) : (
    // Non-standard browser env (web workers, react-native) lack needed support.
    {
      write() {
      },
      read() {
        return null;
      },
      remove() {
      }
    }
  );

  // node_modules/axios/lib/helpers/isAbsoluteURL.js
  function isAbsoluteURL(url) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
  }

  // node_modules/axios/lib/helpers/combineURLs.js
  function combineURLs(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
  }

  // node_modules/axios/lib/core/buildFullPath.js
  function buildFullPath(baseURL, requestedURL) {
    if (baseURL && !isAbsoluteURL(requestedURL)) {
      return combineURLs(baseURL, requestedURL);
    }
    return requestedURL;
  }

  // node_modules/axios/lib/helpers/isURLSameOrigin.js
  var isURLSameOrigin_default = platform_default.hasStandardBrowserEnv ? (
    // Standard browser envs have full support of the APIs needed to test
    // whether the request URL is of the same origin as current location.
    function standardBrowserEnv() {
      const msie = /(msie|trident)/i.test(navigator.userAgent);
      const urlParsingNode = document.createElement("a");
      let originURL;
      function resolveURL(url) {
        let href = url;
        if (msie) {
          urlParsingNode.setAttribute("href", href);
          href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
      }
      originURL = resolveURL(window.location.href);
      return function isURLSameOrigin(requestURL) {
        const parsed = utils_default.isString(requestURL) ? resolveURL(requestURL) : requestURL;
        return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
      };
    }()
  ) : (
    // Non standard browser envs (web workers, react-native) lack needed support.
    function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    }()
  );

  // node_modules/axios/lib/helpers/parseProtocol.js
  function parseProtocol(url) {
    const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
    return match && match[1] || "";
  }

  // node_modules/axios/lib/helpers/speedometer.js
  function speedometer(samplesCount, min) {
    samplesCount = samplesCount || 10;
    const bytes3 = new Array(samplesCount);
    const timestamps = new Array(samplesCount);
    let head = 0;
    let tail = 0;
    let firstSampleTS;
    min = min !== void 0 ? min : 1e3;
    return function push(chunkLength) {
      const now2 = Date.now();
      const startedAt = timestamps[tail];
      if (!firstSampleTS) {
        firstSampleTS = now2;
      }
      bytes3[head] = chunkLength;
      timestamps[head] = now2;
      let i7 = tail;
      let bytesCount = 0;
      while (i7 !== head) {
        bytesCount += bytes3[i7++];
        i7 = i7 % samplesCount;
      }
      head = (head + 1) % samplesCount;
      if (head === tail) {
        tail = (tail + 1) % samplesCount;
      }
      if (now2 - firstSampleTS < min) {
        return;
      }
      const passed = startedAt && now2 - startedAt;
      return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
    };
  }
  var speedometer_default = speedometer;

  // node_modules/axios/lib/adapters/xhr.js
  function progressEventReducer(listener, isDownloadStream) {
    let bytesNotified = 0;
    const _speedometer = speedometer_default(50, 250);
    return (e9) => {
      const loaded = e9.loaded;
      const total = e9.lengthComputable ? e9.total : void 0;
      const progressBytes = loaded - bytesNotified;
      const rate = _speedometer(progressBytes);
      const inRange = loaded <= total;
      bytesNotified = loaded;
      const data2 = {
        loaded,
        total,
        progress: total ? loaded / total : void 0,
        bytes: progressBytes,
        rate: rate ? rate : void 0,
        estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
        event: e9
      };
      data2[isDownloadStream ? "download" : "upload"] = true;
      listener(data2);
    };
  }
  var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
  var xhr_default = isXHRAdapterSupported && function(config2) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
      let requestData = config2.data;
      const requestHeaders = AxiosHeaders_default.from(config2.headers).normalize();
      let { responseType, withXSRFToken } = config2;
      let onCanceled;
      function done() {
        if (config2.cancelToken) {
          config2.cancelToken.unsubscribe(onCanceled);
        }
        if (config2.signal) {
          config2.signal.removeEventListener("abort", onCanceled);
        }
      }
      let contentType;
      if (utils_default.isFormData(requestData)) {
        if (platform_default.hasStandardBrowserEnv || platform_default.hasStandardBrowserWebWorkerEnv) {
          requestHeaders.setContentType(false);
        } else if ((contentType = requestHeaders.getContentType()) !== false) {
          const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
          requestHeaders.setContentType([type || "multipart/form-data", ...tokens].join("; "));
        }
      }
      let request = new XMLHttpRequest();
      if (config2.auth) {
        const username = config2.auth.username || "";
        const password = config2.auth.password ? unescape(encodeURIComponent(config2.auth.password)) : "";
        requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
      }
      const fullPath = buildFullPath(config2.baseURL, config2.url);
      request.open(config2.method.toUpperCase(), buildURL(fullPath, config2.params, config2.paramsSerializer), true);
      request.timeout = config2.timeout;
      function onloadend() {
        if (!request) {
          return;
        }
        const responseHeaders = AxiosHeaders_default.from(
          "getAllResponseHeaders" in request && request.getAllResponseHeaders()
        );
        const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
        const response = {
          data: responseData,
          status: request.status,
          statusText: request.statusText,
          headers: responseHeaders,
          config: config2,
          request
        };
        settle(function _resolve(value) {
          resolve(value);
          done();
        }, function _reject(err) {
          reject(err);
          done();
        }, response);
        request = null;
      }
      if ("onloadend" in request) {
        request.onloadend = onloadend;
      } else {
        request.onreadystatechange = function handleLoad() {
          if (!request || request.readyState !== 4) {
            return;
          }
          if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
            return;
          }
          setTimeout(onloadend);
        };
      }
      request.onabort = function handleAbort() {
        if (!request) {
          return;
        }
        reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config2, request));
        request = null;
      };
      request.onerror = function handleError() {
        reject(new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config2, request));
        request = null;
      };
      request.ontimeout = function handleTimeout() {
        let timeoutErrorMessage = config2.timeout ? "timeout of " + config2.timeout + "ms exceeded" : "timeout exceeded";
        const transitional2 = config2.transitional || transitional_default;
        if (config2.timeoutErrorMessage) {
          timeoutErrorMessage = config2.timeoutErrorMessage;
        }
        reject(new AxiosError_default(
          timeoutErrorMessage,
          transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
          config2,
          request
        ));
        request = null;
      };
      if (platform_default.hasStandardBrowserEnv) {
        withXSRFToken && utils_default.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(config2));
        if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin_default(fullPath)) {
          const xsrfValue = config2.xsrfHeaderName && config2.xsrfCookieName && cookies_default.read(config2.xsrfCookieName);
          if (xsrfValue) {
            requestHeaders.set(config2.xsrfHeaderName, xsrfValue);
          }
        }
      }
      requestData === void 0 && requestHeaders.setContentType(null);
      if ("setRequestHeader" in request) {
        utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key2) {
          request.setRequestHeader(key2, val);
        });
      }
      if (!utils_default.isUndefined(config2.withCredentials)) {
        request.withCredentials = !!config2.withCredentials;
      }
      if (responseType && responseType !== "json") {
        request.responseType = config2.responseType;
      }
      if (typeof config2.onDownloadProgress === "function") {
        request.addEventListener("progress", progressEventReducer(config2.onDownloadProgress, true));
      }
      if (typeof config2.onUploadProgress === "function" && request.upload) {
        request.upload.addEventListener("progress", progressEventReducer(config2.onUploadProgress));
      }
      if (config2.cancelToken || config2.signal) {
        onCanceled = (cancel) => {
          if (!request) {
            return;
          }
          reject(!cancel || cancel.type ? new CanceledError_default(null, config2, request) : cancel);
          request.abort();
          request = null;
        };
        config2.cancelToken && config2.cancelToken.subscribe(onCanceled);
        if (config2.signal) {
          config2.signal.aborted ? onCanceled() : config2.signal.addEventListener("abort", onCanceled);
        }
      }
      const protocol2 = parseProtocol(fullPath);
      if (protocol2 && platform_default.protocols.indexOf(protocol2) === -1) {
        reject(new AxiosError_default("Unsupported protocol " + protocol2 + ":", AxiosError_default.ERR_BAD_REQUEST, config2));
        return;
      }
      request.send(requestData || null);
    });
  };

  // node_modules/axios/lib/adapters/adapters.js
  var knownAdapters = {
    http: null_default,
    xhr: xhr_default
  };
  utils_default.forEach(knownAdapters, (fn2, value) => {
    if (fn2) {
      try {
        Object.defineProperty(fn2, "name", { value });
      } catch (e9) {
      }
      Object.defineProperty(fn2, "adapterName", { value });
    }
  });
  var renderReason = (reason) => `- ${reason}`;
  var isResolvedHandle = (adapter) => utils_default.isFunction(adapter) || adapter === null || adapter === false;
  var adapters_default = {
    getAdapter: (adapters) => {
      adapters = utils_default.isArray(adapters) ? adapters : [adapters];
      const { length: length2 } = adapters;
      let nameOrAdapter;
      let adapter;
      const rejectedReasons = {};
      for (let i7 = 0; i7 < length2; i7++) {
        nameOrAdapter = adapters[i7];
        let id3;
        adapter = nameOrAdapter;
        if (!isResolvedHandle(nameOrAdapter)) {
          adapter = knownAdapters[(id3 = String(nameOrAdapter)).toLowerCase()];
          if (adapter === void 0) {
            throw new AxiosError_default(`Unknown adapter '${id3}'`);
          }
        }
        if (adapter) {
          break;
        }
        rejectedReasons[id3 || "#" + i7] = adapter;
      }
      if (!adapter) {
        const reasons = Object.entries(rejectedReasons).map(
          ([id3, state]) => `adapter ${id3} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
        );
        let s7 = length2 ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
        throw new AxiosError_default(
          `There is no suitable adapter to dispatch the request ` + s7,
          "ERR_NOT_SUPPORT"
        );
      }
      return adapter;
    },
    adapters: knownAdapters
  };

  // node_modules/axios/lib/core/dispatchRequest.js
  function throwIfCancellationRequested(config2) {
    if (config2.cancelToken) {
      config2.cancelToken.throwIfRequested();
    }
    if (config2.signal && config2.signal.aborted) {
      throw new CanceledError_default(null, config2);
    }
  }
  function dispatchRequest(config2) {
    throwIfCancellationRequested(config2);
    config2.headers = AxiosHeaders_default.from(config2.headers);
    config2.data = transformData.call(
      config2,
      config2.transformRequest
    );
    if (["post", "put", "patch"].indexOf(config2.method) !== -1) {
      config2.headers.setContentType("application/x-www-form-urlencoded", false);
    }
    const adapter = adapters_default.getAdapter(config2.adapter || defaults_default.adapter);
    return adapter(config2).then(function onAdapterResolution(response) {
      throwIfCancellationRequested(config2);
      response.data = transformData.call(
        config2,
        config2.transformResponse,
        response
      );
      response.headers = AxiosHeaders_default.from(response.headers);
      return response;
    }, function onAdapterRejection(reason) {
      if (!isCancel(reason)) {
        throwIfCancellationRequested(config2);
        if (reason && reason.response) {
          reason.response.data = transformData.call(
            config2,
            config2.transformResponse,
            reason.response
          );
          reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
        }
      }
      return Promise.reject(reason);
    });
  }

  // node_modules/axios/lib/core/mergeConfig.js
  var headersToObject = (thing) => thing instanceof AxiosHeaders_default ? thing.toJSON() : thing;
  function mergeConfig(config1, config2) {
    config2 = config2 || {};
    const config3 = {};
    function getMergedValue(target, source, caseless) {
      if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
        return utils_default.merge.call({ caseless }, target, source);
      } else if (utils_default.isPlainObject(source)) {
        return utils_default.merge({}, source);
      } else if (utils_default.isArray(source)) {
        return source.slice();
      }
      return source;
    }
    function mergeDeepProperties(a6, b7, caseless) {
      if (!utils_default.isUndefined(b7)) {
        return getMergedValue(a6, b7, caseless);
      } else if (!utils_default.isUndefined(a6)) {
        return getMergedValue(void 0, a6, caseless);
      }
    }
    function valueFromConfig2(a6, b7) {
      if (!utils_default.isUndefined(b7)) {
        return getMergedValue(void 0, b7);
      }
    }
    function defaultToConfig2(a6, b7) {
      if (!utils_default.isUndefined(b7)) {
        return getMergedValue(void 0, b7);
      } else if (!utils_default.isUndefined(a6)) {
        return getMergedValue(void 0, a6);
      }
    }
    function mergeDirectKeys(a6, b7, prop) {
      if (prop in config2) {
        return getMergedValue(a6, b7);
      } else if (prop in config1) {
        return getMergedValue(void 0, a6);
      }
    }
    const mergeMap = {
      url: valueFromConfig2,
      method: valueFromConfig2,
      data: valueFromConfig2,
      baseURL: defaultToConfig2,
      transformRequest: defaultToConfig2,
      transformResponse: defaultToConfig2,
      paramsSerializer: defaultToConfig2,
      timeout: defaultToConfig2,
      timeoutMessage: defaultToConfig2,
      withCredentials: defaultToConfig2,
      withXSRFToken: defaultToConfig2,
      adapter: defaultToConfig2,
      responseType: defaultToConfig2,
      xsrfCookieName: defaultToConfig2,
      xsrfHeaderName: defaultToConfig2,
      onUploadProgress: defaultToConfig2,
      onDownloadProgress: defaultToConfig2,
      decompress: defaultToConfig2,
      maxContentLength: defaultToConfig2,
      maxBodyLength: defaultToConfig2,
      beforeRedirect: defaultToConfig2,
      transport: defaultToConfig2,
      httpAgent: defaultToConfig2,
      httpsAgent: defaultToConfig2,
      cancelToken: defaultToConfig2,
      socketPath: defaultToConfig2,
      responseEncoding: defaultToConfig2,
      validateStatus: mergeDirectKeys,
      headers: (a6, b7) => mergeDeepProperties(headersToObject(a6), headersToObject(b7), true)
    };
    utils_default.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
      const merge2 = mergeMap[prop] || mergeDeepProperties;
      const configValue = merge2(config1[prop], config2[prop], prop);
      utils_default.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config3[prop] = configValue);
    });
    return config3;
  }

  // node_modules/axios/lib/env/data.js
  var VERSION = "1.6.2";

  // node_modules/axios/lib/helpers/validator.js
  var validators = {};
  ["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i7) => {
    validators[type] = function validator(thing) {
      return typeof thing === type || "a" + (i7 < 1 ? "n " : " ") + type;
    };
  });
  var deprecatedWarnings = {};
  validators.transitional = function transitional(validator, version30, message) {
    function formatMessage(opt, desc) {
      return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
    }
    return (value, opt, opts) => {
      if (validator === false) {
        throw new AxiosError_default(
          formatMessage(opt, " has been removed" + (version30 ? " in " + version30 : "")),
          AxiosError_default.ERR_DEPRECATED
        );
      }
      if (version30 && !deprecatedWarnings[opt]) {
        deprecatedWarnings[opt] = true;
        console.warn(
          formatMessage(
            opt,
            " has been deprecated since v" + version30 + " and will be removed in the near future"
          )
        );
      }
      return validator ? validator(value, opt, opts) : true;
    };
  };
  function assertOptions(options2, schema, allowUnknown) {
    if (typeof options2 !== "object") {
      throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
    }
    const keys2 = Object.keys(options2);
    let i7 = keys2.length;
    while (i7-- > 0) {
      const opt = keys2[i7];
      const validator = schema[opt];
      if (validator) {
        const value = options2[opt];
        const result = value === void 0 || validator(value, opt, options2);
        if (result !== true) {
          throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
        }
        continue;
      }
      if (allowUnknown !== true) {
        throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
      }
    }
  }
  var validator_default = {
    assertOptions,
    validators
  };

  // node_modules/axios/lib/core/Axios.js
  var validators2 = validator_default.validators;
  var Axios = class {
    constructor(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager_default(),
        response: new InterceptorManager_default()
      };
    }
    /**
     * Dispatch a request
     *
     * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
     * @param {?Object} config
     *
     * @returns {Promise} The Promise to be fulfilled
     */
    request(configOrUrl, config2) {
      if (typeof configOrUrl === "string") {
        config2 = config2 || {};
        config2.url = configOrUrl;
      } else {
        config2 = configOrUrl || {};
      }
      config2 = mergeConfig(this.defaults, config2);
      const { transitional: transitional2, paramsSerializer, headers } = config2;
      if (transitional2 !== void 0) {
        validator_default.assertOptions(transitional2, {
          silentJSONParsing: validators2.transitional(validators2.boolean),
          forcedJSONParsing: validators2.transitional(validators2.boolean),
          clarifyTimeoutError: validators2.transitional(validators2.boolean)
        }, false);
      }
      if (paramsSerializer != null) {
        if (utils_default.isFunction(paramsSerializer)) {
          config2.paramsSerializer = {
            serialize: paramsSerializer
          };
        } else {
          validator_default.assertOptions(paramsSerializer, {
            encode: validators2.function,
            serialize: validators2.function
          }, true);
        }
      }
      config2.method = (config2.method || this.defaults.method || "get").toLowerCase();
      let contextHeaders = headers && utils_default.merge(
        headers.common,
        headers[config2.method]
      );
      headers && utils_default.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        (method) => {
          delete headers[method];
        }
      );
      config2.headers = AxiosHeaders_default.concat(contextHeaders, headers);
      const requestInterceptorChain = [];
      let synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      const responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      let promise;
      let i7 = 0;
      let len;
      if (!synchronousRequestInterceptors) {
        const chain = [dispatchRequest.bind(this), void 0];
        chain.unshift.apply(chain, requestInterceptorChain);
        chain.push.apply(chain, responseInterceptorChain);
        len = chain.length;
        promise = Promise.resolve(config2);
        while (i7 < len) {
          promise = promise.then(chain[i7++], chain[i7++]);
        }
        return promise;
      }
      len = requestInterceptorChain.length;
      let newConfig = config2;
      i7 = 0;
      while (i7 < len) {
        const onFulfilled = requestInterceptorChain[i7++];
        const onRejected = requestInterceptorChain[i7++];
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected.call(this, error);
          break;
        }
      }
      try {
        promise = dispatchRequest.call(this, newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      i7 = 0;
      len = responseInterceptorChain.length;
      while (i7 < len) {
        promise = promise.then(responseInterceptorChain[i7++], responseInterceptorChain[i7++]);
      }
      return promise;
    }
    getUri(config2) {
      config2 = mergeConfig(this.defaults, config2);
      const fullPath = buildFullPath(config2.baseURL, config2.url);
      return buildURL(fullPath, config2.params, config2.paramsSerializer);
    }
  };
  utils_default.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
    Axios.prototype[method] = function(url, config2) {
      return this.request(mergeConfig(config2 || {}, {
        method,
        url,
        data: (config2 || {}).data
      }));
    };
  });
  utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
    function generateHTTPMethod(isForm) {
      return function httpMethod(url, data2, config2) {
        return this.request(mergeConfig(config2 || {}, {
          method,
          headers: isForm ? {
            "Content-Type": "multipart/form-data"
          } : {},
          url,
          data: data2
        }));
      };
    }
    Axios.prototype[method] = generateHTTPMethod();
    Axios.prototype[method + "Form"] = generateHTTPMethod(true);
  });
  var Axios_default = Axios;

  // node_modules/axios/lib/cancel/CancelToken.js
  var CancelToken = class {
    constructor(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      let resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });
      const token = this;
      this.promise.then((cancel) => {
        if (!token._listeners)
          return;
        let i7 = token._listeners.length;
        while (i7-- > 0) {
          token._listeners[i7](cancel);
        }
        token._listeners = null;
      });
      this.promise.then = (onfulfilled) => {
        let _resolve;
        const promise = new Promise((resolve) => {
          token.subscribe(resolve);
          _resolve = resolve;
        }).then(onfulfilled);
        promise.cancel = function reject() {
          token.unsubscribe(_resolve);
        };
        return promise;
      };
      executor(function cancel(message, config2, request) {
        if (token.reason) {
          return;
        }
        token.reason = new CanceledError_default(message, config2, request);
        resolvePromise(token.reason);
      });
    }
    /**
     * Throws a `CanceledError` if cancellation has been requested.
     */
    throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    }
    /**
     * Subscribe to the cancel signal
     */
    subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    }
    /**
     * Unsubscribe from the cancel signal
     */
    unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      const index2 = this._listeners.indexOf(listener);
      if (index2 !== -1) {
        this._listeners.splice(index2, 1);
      }
    }
    /**
     * Returns an object that contains a new `CancelToken` and a function that, when called,
     * cancels the `CancelToken`.
     */
    static source() {
      let cancel;
      const token = new CancelToken(function executor(c9) {
        cancel = c9;
      });
      return {
        token,
        cancel
      };
    }
  };
  var CancelToken_default = CancelToken;

  // node_modules/axios/lib/helpers/spread.js
  function spread(callback) {
    return function wrap2(arr) {
      return callback.apply(null, arr);
    };
  }

  // node_modules/axios/lib/helpers/isAxiosError.js
  function isAxiosError(payload) {
    return utils_default.isObject(payload) && payload.isAxiosError === true;
  }

  // node_modules/axios/lib/helpers/HttpStatusCode.js
  var HttpStatusCode = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
  };
  Object.entries(HttpStatusCode).forEach(([key2, value]) => {
    HttpStatusCode[value] = key2;
  });
  var HttpStatusCode_default = HttpStatusCode;

  // node_modules/axios/lib/axios.js
  function createInstance(defaultConfig) {
    const context = new Axios_default(defaultConfig);
    const instance = bind(Axios_default.prototype.request, context);
    utils_default.extend(instance, Axios_default.prototype, context, { allOwnKeys: true });
    utils_default.extend(instance, context, null, { allOwnKeys: true });
    instance.create = function create3(instanceConfig) {
      return createInstance(mergeConfig(defaultConfig, instanceConfig));
    };
    return instance;
  }
  var axios = createInstance(defaults_default);
  axios.Axios = Axios_default;
  axios.CanceledError = CanceledError_default;
  axios.CancelToken = CancelToken_default;
  axios.isCancel = isCancel;
  axios.VERSION = VERSION;
  axios.toFormData = toFormData_default;
  axios.AxiosError = AxiosError_default;
  axios.Cancel = axios.CanceledError;
  axios.all = function all(promises) {
    return Promise.all(promises);
  };
  axios.spread = spread;
  axios.isAxiosError = isAxiosError;
  axios.mergeConfig = mergeConfig;
  axios.AxiosHeaders = AxiosHeaders_default;
  axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
  axios.getAdapter = adapters_default.getAdapter;
  axios.HttpStatusCode = HttpStatusCode_default;
  axios.default = axios;
  var axios_default = axios;

  // node_modules/axios/index.js
  var {
    Axios: Axios2,
    AxiosError: AxiosError2,
    CanceledError: CanceledError2,
    isCancel: isCancel2,
    CancelToken: CancelToken2,
    VERSION: VERSION2,
    all: all2,
    Cancel,
    isAxiosError: isAxiosError2,
    spread: spread2,
    toFormData: toFormData2,
    AxiosHeaders: AxiosHeaders2,
    HttpStatusCode: HttpStatusCode2,
    formToJSON,
    getAdapter,
    mergeConfig: mergeConfig2
  } = axios_default;

  // src/stores/applicationStore.tsx
  var import_url_parse = __toESM(require_url_parse());

  // node_modules/ethers/lib.esm/ethers.js
  var ethers_exports = {};
  __export(ethers_exports, {
    BaseContract: () => BaseContract,
    BigNumber: () => BigNumber,
    Contract: () => Contract,
    ContractFactory: () => ContractFactory,
    FixedNumber: () => FixedNumber,
    Signer: () => Signer,
    VoidSigner: () => VoidSigner,
    Wallet: () => Wallet,
    Wordlist: () => Wordlist,
    constants: () => lib_exports2,
    errors: () => ErrorCode,
    getDefaultProvider: () => getDefaultProvider,
    logger: () => logger46,
    providers: () => lib_exports4,
    utils: () => utils_exports2,
    version: () => version29,
    wordlists: () => wordlists
  });

  // node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
  var import_bn = __toESM(require_bn());

  // node_modules/@ethersproject/logger/lib.esm/_version.js
  var version4 = "logger/5.7.0";

  // node_modules/@ethersproject/logger/lib.esm/index.js
  var _permanentCensorErrors = false;
  var _censorErrors = false;
  var LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
  var _logLevel = LogLevels["default"];
  var _globalLogger = null;
  function _checkNormalize() {
    try {
      const missing = [];
      ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
        try {
          if ("test".normalize(form) !== "test") {
            throw new Error("bad normalize");
          }
          ;
        } catch (error) {
          missing.push(form);
        }
      });
      if (missing.length) {
        throw new Error("missing " + missing.join(", "));
      }
      if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) {
        throw new Error("broken implementation");
      }
    } catch (error) {
      return error.message;
    }
    return null;
  }
  var _normalizeError = _checkNormalize();
  var LogLevel;
  (function(LogLevel2) {
    LogLevel2["DEBUG"] = "DEBUG";
    LogLevel2["INFO"] = "INFO";
    LogLevel2["WARNING"] = "WARNING";
    LogLevel2["ERROR"] = "ERROR";
    LogLevel2["OFF"] = "OFF";
  })(LogLevel || (LogLevel = {}));
  var ErrorCode;
  (function(ErrorCode2) {
    ErrorCode2["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
    ErrorCode2["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
    ErrorCode2["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
    ErrorCode2["NETWORK_ERROR"] = "NETWORK_ERROR";
    ErrorCode2["SERVER_ERROR"] = "SERVER_ERROR";
    ErrorCode2["TIMEOUT"] = "TIMEOUT";
    ErrorCode2["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
    ErrorCode2["NUMERIC_FAULT"] = "NUMERIC_FAULT";
    ErrorCode2["MISSING_NEW"] = "MISSING_NEW";
    ErrorCode2["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
    ErrorCode2["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
    ErrorCode2["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
    ErrorCode2["CALL_EXCEPTION"] = "CALL_EXCEPTION";
    ErrorCode2["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
    ErrorCode2["NONCE_EXPIRED"] = "NONCE_EXPIRED";
    ErrorCode2["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
    ErrorCode2["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
    ErrorCode2["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
    ErrorCode2["ACTION_REJECTED"] = "ACTION_REJECTED";
  })(ErrorCode || (ErrorCode = {}));
  var HEX = "0123456789abcdef";
  var Logger = class {
    constructor(version30) {
      Object.defineProperty(this, "version", {
        enumerable: true,
        value: version30,
        writable: false
      });
    }
    _log(logLevel, args) {
      const level = logLevel.toLowerCase();
      if (LogLevels[level] == null) {
        this.throwArgumentError("invalid log level name", "logLevel", logLevel);
      }
      if (_logLevel > LogLevels[level]) {
        return;
      }
      console.log.apply(console, args);
    }
    debug(...args) {
      this._log(Logger.levels.DEBUG, args);
    }
    info(...args) {
      this._log(Logger.levels.INFO, args);
    }
    warn(...args) {
      this._log(Logger.levels.WARNING, args);
    }
    makeError(message, code2, params) {
      if (_censorErrors) {
        return this.makeError("censored error", code2, {});
      }
      if (!code2) {
        code2 = Logger.errors.UNKNOWN_ERROR;
      }
      if (!params) {
        params = {};
      }
      const messageDetails = [];
      Object.keys(params).forEach((key2) => {
        const value = params[key2];
        try {
          if (value instanceof Uint8Array) {
            let hex = "";
            for (let i7 = 0; i7 < value.length; i7++) {
              hex += HEX[value[i7] >> 4];
              hex += HEX[value[i7] & 15];
            }
            messageDetails.push(key2 + "=Uint8Array(0x" + hex + ")");
          } else {
            messageDetails.push(key2 + "=" + JSON.stringify(value));
          }
        } catch (error2) {
          messageDetails.push(key2 + "=" + JSON.stringify(params[key2].toString()));
        }
      });
      messageDetails.push(`code=${code2}`);
      messageDetails.push(`version=${this.version}`);
      const reason = message;
      let url = "";
      switch (code2) {
        case ErrorCode.NUMERIC_FAULT: {
          url = "NUMERIC_FAULT";
          const fault = message;
          switch (fault) {
            case "overflow":
            case "underflow":
            case "division-by-zero":
              url += "-" + fault;
              break;
            case "negative-power":
            case "negative-width":
              url += "-unsupported";
              break;
            case "unbound-bitwise-result":
              url += "-unbound-result";
              break;
          }
          break;
        }
        case ErrorCode.CALL_EXCEPTION:
        case ErrorCode.INSUFFICIENT_FUNDS:
        case ErrorCode.MISSING_NEW:
        case ErrorCode.NONCE_EXPIRED:
        case ErrorCode.REPLACEMENT_UNDERPRICED:
        case ErrorCode.TRANSACTION_REPLACED:
        case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
          url = code2;
          break;
      }
      if (url) {
        message += " [ See: https://links.ethers.org/v5-errors-" + url + " ]";
      }
      if (messageDetails.length) {
        message += " (" + messageDetails.join(", ") + ")";
      }
      const error = new Error(message);
      error.reason = reason;
      error.code = code2;
      Object.keys(params).forEach(function(key2) {
        error[key2] = params[key2];
      });
      return error;
    }
    throwError(message, code2, params) {
      throw this.makeError(message, code2, params);
    }
    throwArgumentError(message, name2, value) {
      return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {
        argument: name2,
        value
      });
    }
    assert(condition, message, code2, params) {
      if (!!condition) {
        return;
      }
      this.throwError(message, code2, params);
    }
    assertArgument(condition, message, name2, value) {
      if (!!condition) {
        return;
      }
      this.throwArgumentError(message, name2, value);
    }
    checkNormalize(message) {
      if (message == null) {
        message = "platform missing String.prototype.normalize";
      }
      if (_normalizeError) {
        this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "String.prototype.normalize",
          form: _normalizeError
        });
      }
    }
    checkSafeUint53(value, message) {
      if (typeof value !== "number") {
        return;
      }
      if (message == null) {
        message = "value not safe";
      }
      if (value < 0 || value >= 9007199254740991) {
        this.throwError(message, Logger.errors.NUMERIC_FAULT, {
          operation: "checkSafeInteger",
          fault: "out-of-safe-range",
          value
        });
      }
      if (value % 1) {
        this.throwError(message, Logger.errors.NUMERIC_FAULT, {
          operation: "checkSafeInteger",
          fault: "non-integer",
          value
        });
      }
    }
    checkArgumentCount(count, expectedCount, message) {
      if (message) {
        message = ": " + message;
      } else {
        message = "";
      }
      if (count < expectedCount) {
        this.throwError("missing argument" + message, Logger.errors.MISSING_ARGUMENT, {
          count,
          expectedCount
        });
      }
      if (count > expectedCount) {
        this.throwError("too many arguments" + message, Logger.errors.UNEXPECTED_ARGUMENT, {
          count,
          expectedCount
        });
      }
    }
    checkNew(target, kind) {
      if (target === Object || target == null) {
        this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
      }
    }
    checkAbstract(target, kind) {
      if (target === kind) {
        this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
      } else if (target === Object || target == null) {
        this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
      }
    }
    static globalLogger() {
      if (!_globalLogger) {
        _globalLogger = new Logger(version4);
      }
      return _globalLogger;
    }
    static setCensorship(censorship, permanent) {
      if (!censorship && permanent) {
        this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "setCensorship"
        });
      }
      if (_permanentCensorErrors) {
        if (!censorship) {
          return;
        }
        this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "setCensorship"
        });
      }
      _censorErrors = !!censorship;
      _permanentCensorErrors = !!permanent;
    }
    static setLogLevel(logLevel) {
      const level = LogLevels[logLevel.toLowerCase()];
      if (level == null) {
        Logger.globalLogger().warn("invalid log level - " + logLevel);
        return;
      }
      _logLevel = level;
    }
    static from(version30) {
      return new Logger(version30);
    }
  };
  Logger.errors = ErrorCode;
  Logger.levels = LogLevel;

  // node_modules/@ethersproject/bytes/lib.esm/_version.js
  var version5 = "bytes/5.7.0";

  // node_modules/@ethersproject/bytes/lib.esm/index.js
  var logger = new Logger(version5);
  function isHexable(value) {
    return !!value.toHexString;
  }
  function addSlice(array) {
    if (array.slice) {
      return array;
    }
    array.slice = function() {
      const args = Array.prototype.slice.call(arguments);
      return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
    };
    return array;
  }
  function isBytesLike(value) {
    return isHexString(value) && !(value.length % 2) || isBytes2(value);
  }
  function isInteger(value) {
    return typeof value === "number" && value == value && value % 1 === 0;
  }
  function isBytes2(value) {
    if (value == null) {
      return false;
    }
    if (value.constructor === Uint8Array) {
      return true;
    }
    if (typeof value === "string") {
      return false;
    }
    if (!isInteger(value.length) || value.length < 0) {
      return false;
    }
    for (let i7 = 0; i7 < value.length; i7++) {
      const v6 = value[i7];
      if (!isInteger(v6) || v6 < 0 || v6 >= 256) {
        return false;
      }
    }
    return true;
  }
  function arrayify(value, options2) {
    if (!options2) {
      options2 = {};
    }
    if (typeof value === "number") {
      logger.checkSafeUint53(value, "invalid arrayify value");
      const result = [];
      while (value) {
        result.unshift(value & 255);
        value = parseInt(String(value / 256));
      }
      if (result.length === 0) {
        result.push(0);
      }
      return addSlice(new Uint8Array(result));
    }
    if (options2.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
      value = "0x" + value;
    }
    if (isHexable(value)) {
      value = value.toHexString();
    }
    if (isHexString(value)) {
      let hex = value.substring(2);
      if (hex.length % 2) {
        if (options2.hexPad === "left") {
          hex = "0" + hex;
        } else if (options2.hexPad === "right") {
          hex += "0";
        } else {
          logger.throwArgumentError("hex data is odd-length", "value", value);
        }
      }
      const result = [];
      for (let i7 = 0; i7 < hex.length; i7 += 2) {
        result.push(parseInt(hex.substring(i7, i7 + 2), 16));
      }
      return addSlice(new Uint8Array(result));
    }
    if (isBytes2(value)) {
      return addSlice(new Uint8Array(value));
    }
    return logger.throwArgumentError("invalid arrayify value", "value", value);
  }
  function concat3(items) {
    const objects = items.map((item) => arrayify(item));
    const length2 = objects.reduce((accum, item) => accum + item.length, 0);
    const result = new Uint8Array(length2);
    objects.reduce((offset, object) => {
      result.set(object, offset);
      return offset + object.length;
    }, 0);
    return addSlice(result);
  }
  function stripZeros(value) {
    let result = arrayify(value);
    if (result.length === 0) {
      return result;
    }
    let start = 0;
    while (start < result.length && result[start] === 0) {
      start++;
    }
    if (start) {
      result = result.slice(start);
    }
    return result;
  }
  function zeroPad(value, length2) {
    value = arrayify(value);
    if (value.length > length2) {
      logger.throwArgumentError("value out of range", "value", arguments[0]);
    }
    const result = new Uint8Array(length2);
    result.set(value, length2 - value.length);
    return addSlice(result);
  }
  function isHexString(value, length2) {
    if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
      return false;
    }
    if (length2 && value.length !== 2 + 2 * length2) {
      return false;
    }
    return true;
  }
  var HexCharacters = "0123456789abcdef";
  function hexlify(value, options2) {
    if (!options2) {
      options2 = {};
    }
    if (typeof value === "number") {
      logger.checkSafeUint53(value, "invalid hexlify value");
      let hex = "";
      while (value) {
        hex = HexCharacters[value & 15] + hex;
        value = Math.floor(value / 16);
      }
      if (hex.length) {
        if (hex.length % 2) {
          hex = "0" + hex;
        }
        return "0x" + hex;
      }
      return "0x00";
    }
    if (typeof value === "bigint") {
      value = value.toString(16);
      if (value.length % 2) {
        return "0x0" + value;
      }
      return "0x" + value;
    }
    if (options2.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
      value = "0x" + value;
    }
    if (isHexable(value)) {
      return value.toHexString();
    }
    if (isHexString(value)) {
      if (value.length % 2) {
        if (options2.hexPad === "left") {
          value = "0x0" + value.substring(2);
        } else if (options2.hexPad === "right") {
          value += "0";
        } else {
          logger.throwArgumentError("hex data is odd-length", "value", value);
        }
      }
      return value.toLowerCase();
    }
    if (isBytes2(value)) {
      let result = "0x";
      for (let i7 = 0; i7 < value.length; i7++) {
        let v6 = value[i7];
        result += HexCharacters[(v6 & 240) >> 4] + HexCharacters[v6 & 15];
      }
      return result;
    }
    return logger.throwArgumentError("invalid hexlify value", "value", value);
  }
  function hexDataLength(data2) {
    if (typeof data2 !== "string") {
      data2 = hexlify(data2);
    } else if (!isHexString(data2) || data2.length % 2) {
      return null;
    }
    return (data2.length - 2) / 2;
  }
  function hexDataSlice(data2, offset, endOffset) {
    if (typeof data2 !== "string") {
      data2 = hexlify(data2);
    } else if (!isHexString(data2) || data2.length % 2) {
      logger.throwArgumentError("invalid hexData", "value", data2);
    }
    offset = 2 + 2 * offset;
    if (endOffset != null) {
      return "0x" + data2.substring(offset, 2 + 2 * endOffset);
    }
    return "0x" + data2.substring(offset);
  }
  function hexConcat(items) {
    let result = "0x";
    items.forEach((item) => {
      result += hexlify(item).substring(2);
    });
    return result;
  }
  function hexValue(value) {
    const trimmed = hexStripZeros(hexlify(value, { hexPad: "left" }));
    if (trimmed === "0x") {
      return "0x0";
    }
    return trimmed;
  }
  function hexStripZeros(value) {
    if (typeof value !== "string") {
      value = hexlify(value);
    }
    if (!isHexString(value)) {
      logger.throwArgumentError("invalid hex string", "value", value);
    }
    value = value.substring(2);
    let offset = 0;
    while (offset < value.length && value[offset] === "0") {
      offset++;
    }
    return "0x" + value.substring(offset);
  }
  function hexZeroPad(value, length2) {
    if (typeof value !== "string") {
      value = hexlify(value);
    } else if (!isHexString(value)) {
      logger.throwArgumentError("invalid hex string", "value", value);
    }
    if (value.length > 2 * length2 + 2) {
      logger.throwArgumentError("value out of range", "value", arguments[1]);
    }
    while (value.length < 2 * length2 + 2) {
      value = "0x0" + value.substring(2);
    }
    return value;
  }
  function splitSignature(signature2) {
    const result = {
      r: "0x",
      s: "0x",
      _vs: "0x",
      recoveryParam: 0,
      v: 0,
      yParityAndS: "0x",
      compact: "0x"
    };
    if (isBytesLike(signature2)) {
      let bytes3 = arrayify(signature2);
      if (bytes3.length === 64) {
        result.v = 27 + (bytes3[32] >> 7);
        bytes3[32] &= 127;
        result.r = hexlify(bytes3.slice(0, 32));
        result.s = hexlify(bytes3.slice(32, 64));
      } else if (bytes3.length === 65) {
        result.r = hexlify(bytes3.slice(0, 32));
        result.s = hexlify(bytes3.slice(32, 64));
        result.v = bytes3[64];
      } else {
        logger.throwArgumentError("invalid signature string", "signature", signature2);
      }
      if (result.v < 27) {
        if (result.v === 0 || result.v === 1) {
          result.v += 27;
        } else {
          logger.throwArgumentError("signature invalid v byte", "signature", signature2);
        }
      }
      result.recoveryParam = 1 - result.v % 2;
      if (result.recoveryParam) {
        bytes3[32] |= 128;
      }
      result._vs = hexlify(bytes3.slice(32, 64));
    } else {
      result.r = signature2.r;
      result.s = signature2.s;
      result.v = signature2.v;
      result.recoveryParam = signature2.recoveryParam;
      result._vs = signature2._vs;
      if (result._vs != null) {
        const vs3 = zeroPad(arrayify(result._vs), 32);
        result._vs = hexlify(vs3);
        const recoveryParam = vs3[0] >= 128 ? 1 : 0;
        if (result.recoveryParam == null) {
          result.recoveryParam = recoveryParam;
        } else if (result.recoveryParam !== recoveryParam) {
          logger.throwArgumentError("signature recoveryParam mismatch _vs", "signature", signature2);
        }
        vs3[0] &= 127;
        const s7 = hexlify(vs3);
        if (result.s == null) {
          result.s = s7;
        } else if (result.s !== s7) {
          logger.throwArgumentError("signature v mismatch _vs", "signature", signature2);
        }
      }
      if (result.recoveryParam == null) {
        if (result.v == null) {
          logger.throwArgumentError("signature missing v and recoveryParam", "signature", signature2);
        } else if (result.v === 0 || result.v === 1) {
          result.recoveryParam = result.v;
        } else {
          result.recoveryParam = 1 - result.v % 2;
        }
      } else {
        if (result.v == null) {
          result.v = 27 + result.recoveryParam;
        } else {
          const recId = result.v === 0 || result.v === 1 ? result.v : 1 - result.v % 2;
          if (result.recoveryParam !== recId) {
            logger.throwArgumentError("signature recoveryParam mismatch v", "signature", signature2);
          }
        }
      }
      if (result.r == null || !isHexString(result.r)) {
        logger.throwArgumentError("signature missing or invalid r", "signature", signature2);
      } else {
        result.r = hexZeroPad(result.r, 32);
      }
      if (result.s == null || !isHexString(result.s)) {
        logger.throwArgumentError("signature missing or invalid s", "signature", signature2);
      } else {
        result.s = hexZeroPad(result.s, 32);
      }
      const vs2 = arrayify(result.s);
      if (vs2[0] >= 128) {
        logger.throwArgumentError("signature s out of range", "signature", signature2);
      }
      if (result.recoveryParam) {
        vs2[0] |= 128;
      }
      const _vs = hexlify(vs2);
      if (result._vs) {
        if (!isHexString(result._vs)) {
          logger.throwArgumentError("signature invalid _vs", "signature", signature2);
        }
        result._vs = hexZeroPad(result._vs, 32);
      }
      if (result._vs == null) {
        result._vs = _vs;
      } else if (result._vs !== _vs) {
        logger.throwArgumentError("signature _vs mismatch v and s", "signature", signature2);
      }
    }
    result.yParityAndS = result._vs;
    result.compact = result.r + result.yParityAndS.substring(2);
    return result;
  }
  function joinSignature(signature2) {
    signature2 = splitSignature(signature2);
    return hexlify(concat3([
      signature2.r,
      signature2.s,
      signature2.recoveryParam ? "0x1c" : "0x1b"
    ]));
  }

  // node_modules/@ethersproject/bignumber/lib.esm/_version.js
  var version6 = "bignumber/5.7.0";

  // node_modules/@ethersproject/bignumber/lib.esm/bignumber.js
  var BN = import_bn.default.BN;
  var logger2 = new Logger(version6);
  var _constructorGuard = {};
  var MAX_SAFE = 9007199254740991;
  function isBigNumberish(value) {
    return value != null && (BigNumber.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || isHexString(value) || typeof value === "bigint" || isBytes2(value));
  }
  var _warnedToStringRadix = false;
  var BigNumber = class {
    constructor(constructorGuard, hex) {
      if (constructorGuard !== _constructorGuard) {
        logger2.throwError("cannot call constructor directly; use BigNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "new (BigNumber)"
        });
      }
      this._hex = hex;
      this._isBigNumber = true;
      Object.freeze(this);
    }
    fromTwos(value) {
      return toBigNumber(toBN(this).fromTwos(value));
    }
    toTwos(value) {
      return toBigNumber(toBN(this).toTwos(value));
    }
    abs() {
      if (this._hex[0] === "-") {
        return BigNumber.from(this._hex.substring(1));
      }
      return this;
    }
    add(other) {
      return toBigNumber(toBN(this).add(toBN(other)));
    }
    sub(other) {
      return toBigNumber(toBN(this).sub(toBN(other)));
    }
    div(other) {
      const o9 = BigNumber.from(other);
      if (o9.isZero()) {
        throwFault("division-by-zero", "div");
      }
      return toBigNumber(toBN(this).div(toBN(other)));
    }
    mul(other) {
      return toBigNumber(toBN(this).mul(toBN(other)));
    }
    mod(other) {
      const value = toBN(other);
      if (value.isNeg()) {
        throwFault("division-by-zero", "mod");
      }
      return toBigNumber(toBN(this).umod(value));
    }
    pow(other) {
      const value = toBN(other);
      if (value.isNeg()) {
        throwFault("negative-power", "pow");
      }
      return toBigNumber(toBN(this).pow(value));
    }
    and(other) {
      const value = toBN(other);
      if (this.isNegative() || value.isNeg()) {
        throwFault("unbound-bitwise-result", "and");
      }
      return toBigNumber(toBN(this).and(value));
    }
    or(other) {
      const value = toBN(other);
      if (this.isNegative() || value.isNeg()) {
        throwFault("unbound-bitwise-result", "or");
      }
      return toBigNumber(toBN(this).or(value));
    }
    xor(other) {
      const value = toBN(other);
      if (this.isNegative() || value.isNeg()) {
        throwFault("unbound-bitwise-result", "xor");
      }
      return toBigNumber(toBN(this).xor(value));
    }
    mask(value) {
      if (this.isNegative() || value < 0) {
        throwFault("negative-width", "mask");
      }
      return toBigNumber(toBN(this).maskn(value));
    }
    shl(value) {
      if (this.isNegative() || value < 0) {
        throwFault("negative-width", "shl");
      }
      return toBigNumber(toBN(this).shln(value));
    }
    shr(value) {
      if (this.isNegative() || value < 0) {
        throwFault("negative-width", "shr");
      }
      return toBigNumber(toBN(this).shrn(value));
    }
    eq(other) {
      return toBN(this).eq(toBN(other));
    }
    lt(other) {
      return toBN(this).lt(toBN(other));
    }
    lte(other) {
      return toBN(this).lte(toBN(other));
    }
    gt(other) {
      return toBN(this).gt(toBN(other));
    }
    gte(other) {
      return toBN(this).gte(toBN(other));
    }
    isNegative() {
      return this._hex[0] === "-";
    }
    isZero() {
      return toBN(this).isZero();
    }
    toNumber() {
      try {
        return toBN(this).toNumber();
      } catch (error) {
        throwFault("overflow", "toNumber", this.toString());
      }
      return null;
    }
    toBigInt() {
      try {
        return BigInt(this.toString());
      } catch (e9) {
      }
      return logger2.throwError("this platform does not support BigInt", Logger.errors.UNSUPPORTED_OPERATION, {
        value: this.toString()
      });
    }
    toString() {
      if (arguments.length > 0) {
        if (arguments[0] === 10) {
          if (!_warnedToStringRadix) {
            _warnedToStringRadix = true;
            logger2.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
          }
        } else if (arguments[0] === 16) {
          logger2.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", Logger.errors.UNEXPECTED_ARGUMENT, {});
        } else {
          logger2.throwError("BigNumber.toString does not accept parameters", Logger.errors.UNEXPECTED_ARGUMENT, {});
        }
      }
      return toBN(this).toString(10);
    }
    toHexString() {
      return this._hex;
    }
    toJSON(key2) {
      return { type: "BigNumber", hex: this.toHexString() };
    }
    static from(value) {
      if (value instanceof BigNumber) {
        return value;
      }
      if (typeof value === "string") {
        if (value.match(/^-?0x[0-9a-f]+$/i)) {
          return new BigNumber(_constructorGuard, toHex2(value));
        }
        if (value.match(/^-?[0-9]+$/)) {
          return new BigNumber(_constructorGuard, toHex2(new BN(value)));
        }
        return logger2.throwArgumentError("invalid BigNumber string", "value", value);
      }
      if (typeof value === "number") {
        if (value % 1) {
          throwFault("underflow", "BigNumber.from", value);
        }
        if (value >= MAX_SAFE || value <= -MAX_SAFE) {
          throwFault("overflow", "BigNumber.from", value);
        }
        return BigNumber.from(String(value));
      }
      const anyValue = value;
      if (typeof anyValue === "bigint") {
        return BigNumber.from(anyValue.toString());
      }
      if (isBytes2(anyValue)) {
        return BigNumber.from(hexlify(anyValue));
      }
      if (anyValue) {
        if (anyValue.toHexString) {
          const hex = anyValue.toHexString();
          if (typeof hex === "string") {
            return BigNumber.from(hex);
          }
        } else {
          let hex = anyValue._hex;
          if (hex == null && anyValue.type === "BigNumber") {
            hex = anyValue.hex;
          }
          if (typeof hex === "string") {
            if (isHexString(hex) || hex[0] === "-" && isHexString(hex.substring(1))) {
              return BigNumber.from(hex);
            }
          }
        }
      }
      return logger2.throwArgumentError("invalid BigNumber value", "value", value);
    }
    static isBigNumber(value) {
      return !!(value && value._isBigNumber);
    }
  };
  function toHex2(value) {
    if (typeof value !== "string") {
      return toHex2(value.toString(16));
    }
    if (value[0] === "-") {
      value = value.substring(1);
      if (value[0] === "-") {
        logger2.throwArgumentError("invalid hex", "value", value);
      }
      value = toHex2(value);
      if (value === "0x00") {
        return value;
      }
      return "-" + value;
    }
    if (value.substring(0, 2) !== "0x") {
      value = "0x" + value;
    }
    if (value === "0x") {
      return "0x00";
    }
    if (value.length % 2) {
      value = "0x0" + value.substring(2);
    }
    while (value.length > 4 && value.substring(0, 4) === "0x00") {
      value = "0x" + value.substring(4);
    }
    return value;
  }
  function toBigNumber(value) {
    return BigNumber.from(toHex2(value));
  }
  function toBN(value) {
    const hex = BigNumber.from(value).toHexString();
    if (hex[0] === "-") {
      return new BN("-" + hex.substring(3), 16);
    }
    return new BN(hex.substring(2), 16);
  }
  function throwFault(fault, operation, value) {
    const params = { fault, operation };
    if (value != null) {
      params.value = value;
    }
    return logger2.throwError(fault, Logger.errors.NUMERIC_FAULT, params);
  }
  function _base36To16(value) {
    return new BN(value, 36).toString(16);
  }
  function _base16To36(value) {
    return new BN(value, 16).toString(36);
  }

  // node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js
  var logger3 = new Logger(version6);
  var _constructorGuard2 = {};
  var Zero = BigNumber.from(0);
  var NegativeOne = BigNumber.from(-1);
  function throwFault2(message, fault, operation, value) {
    const params = { fault, operation };
    if (value !== void 0) {
      params.value = value;
    }
    return logger3.throwError(message, Logger.errors.NUMERIC_FAULT, params);
  }
  var zeros = "0";
  while (zeros.length < 256) {
    zeros += zeros;
  }
  function getMultiplier(decimals) {
    if (typeof decimals !== "number") {
      try {
        decimals = BigNumber.from(decimals).toNumber();
      } catch (e9) {
      }
    }
    if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
      return "1" + zeros.substring(0, decimals);
    }
    return logger3.throwArgumentError("invalid decimal size", "decimals", decimals);
  }
  function formatFixed(value, decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    const multiplier = getMultiplier(decimals);
    value = BigNumber.from(value);
    const negative = value.lt(Zero);
    if (negative) {
      value = value.mul(NegativeOne);
    }
    let fraction = value.mod(multiplier).toString();
    while (fraction.length < multiplier.length - 1) {
      fraction = "0" + fraction;
    }
    fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
    const whole = value.div(multiplier).toString();
    if (multiplier.length === 1) {
      value = whole;
    } else {
      value = whole + "." + fraction;
    }
    if (negative) {
      value = "-" + value;
    }
    return value;
  }
  function parseFixed(value, decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    const multiplier = getMultiplier(decimals);
    if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) {
      logger3.throwArgumentError("invalid decimal value", "value", value);
    }
    const negative = value.substring(0, 1) === "-";
    if (negative) {
      value = value.substring(1);
    }
    if (value === ".") {
      logger3.throwArgumentError("missing value", "value", value);
    }
    const comps = value.split(".");
    if (comps.length > 2) {
      logger3.throwArgumentError("too many decimal points", "value", value);
    }
    let whole = comps[0], fraction = comps[1];
    if (!whole) {
      whole = "0";
    }
    if (!fraction) {
      fraction = "0";
    }
    while (fraction[fraction.length - 1] === "0") {
      fraction = fraction.substring(0, fraction.length - 1);
    }
    if (fraction.length > multiplier.length - 1) {
      throwFault2("fractional component exceeds decimals", "underflow", "parseFixed");
    }
    if (fraction === "") {
      fraction = "0";
    }
    while (fraction.length < multiplier.length - 1) {
      fraction += "0";
    }
    const wholeValue = BigNumber.from(whole);
    const fractionValue = BigNumber.from(fraction);
    let wei = wholeValue.mul(multiplier).add(fractionValue);
    if (negative) {
      wei = wei.mul(NegativeOne);
    }
    return wei;
  }
  var FixedFormat = class {
    constructor(constructorGuard, signed3, width, decimals) {
      if (constructorGuard !== _constructorGuard2) {
        logger3.throwError("cannot use FixedFormat constructor; use FixedFormat.from", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "new FixedFormat"
        });
      }
      this.signed = signed3;
      this.width = width;
      this.decimals = decimals;
      this.name = (signed3 ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
      this._multiplier = getMultiplier(decimals);
      Object.freeze(this);
    }
    static from(value) {
      if (value instanceof FixedFormat) {
        return value;
      }
      if (typeof value === "number") {
        value = `fixed128x${value}`;
      }
      let signed3 = true;
      let width = 128;
      let decimals = 18;
      if (typeof value === "string") {
        if (value === "fixed") {
        } else if (value === "ufixed") {
          signed3 = false;
        } else {
          const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
          if (!match) {
            logger3.throwArgumentError("invalid fixed format", "format", value);
          }
          signed3 = match[1] !== "u";
          width = parseInt(match[2]);
          decimals = parseInt(match[3]);
        }
      } else if (value) {
        const check = (key2, type, defaultValue) => {
          if (value[key2] == null) {
            return defaultValue;
          }
          if (typeof value[key2] !== type) {
            logger3.throwArgumentError("invalid fixed format (" + key2 + " not " + type + ")", "format." + key2, value[key2]);
          }
          return value[key2];
        };
        signed3 = check("signed", "boolean", signed3);
        width = check("width", "number", width);
        decimals = check("decimals", "number", decimals);
      }
      if (width % 8) {
        logger3.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
      }
      if (decimals > 80) {
        logger3.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
      }
      return new FixedFormat(_constructorGuard2, signed3, width, decimals);
    }
  };
  var FixedNumber = class {
    constructor(constructorGuard, hex, value, format2) {
      if (constructorGuard !== _constructorGuard2) {
        logger3.throwError("cannot use FixedNumber constructor; use FixedNumber.from", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "new FixedFormat"
        });
      }
      this.format = format2;
      this._hex = hex;
      this._value = value;
      this._isFixedNumber = true;
      Object.freeze(this);
    }
    _checkFormat(other) {
      if (this.format.name !== other.format.name) {
        logger3.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
      }
    }
    addUnsafe(other) {
      this._checkFormat(other);
      const a6 = parseFixed(this._value, this.format.decimals);
      const b7 = parseFixed(other._value, other.format.decimals);
      return FixedNumber.fromValue(a6.add(b7), this.format.decimals, this.format);
    }
    subUnsafe(other) {
      this._checkFormat(other);
      const a6 = parseFixed(this._value, this.format.decimals);
      const b7 = parseFixed(other._value, other.format.decimals);
      return FixedNumber.fromValue(a6.sub(b7), this.format.decimals, this.format);
    }
    mulUnsafe(other) {
      this._checkFormat(other);
      const a6 = parseFixed(this._value, this.format.decimals);
      const b7 = parseFixed(other._value, other.format.decimals);
      return FixedNumber.fromValue(a6.mul(b7).div(this.format._multiplier), this.format.decimals, this.format);
    }
    divUnsafe(other) {
      this._checkFormat(other);
      const a6 = parseFixed(this._value, this.format.decimals);
      const b7 = parseFixed(other._value, other.format.decimals);
      return FixedNumber.fromValue(a6.mul(this.format._multiplier).div(b7), this.format.decimals, this.format);
    }
    floor() {
      const comps = this.toString().split(".");
      if (comps.length === 1) {
        comps.push("0");
      }
      let result = FixedNumber.from(comps[0], this.format);
      const hasFraction = !comps[1].match(/^(0*)$/);
      if (this.isNegative() && hasFraction) {
        result = result.subUnsafe(ONE.toFormat(result.format));
      }
      return result;
    }
    ceiling() {
      const comps = this.toString().split(".");
      if (comps.length === 1) {
        comps.push("0");
      }
      let result = FixedNumber.from(comps[0], this.format);
      const hasFraction = !comps[1].match(/^(0*)$/);
      if (!this.isNegative() && hasFraction) {
        result = result.addUnsafe(ONE.toFormat(result.format));
      }
      return result;
    }
    // @TODO: Support other rounding algorithms
    round(decimals) {
      if (decimals == null) {
        decimals = 0;
      }
      const comps = this.toString().split(".");
      if (comps.length === 1) {
        comps.push("0");
      }
      if (decimals < 0 || decimals > 80 || decimals % 1) {
        logger3.throwArgumentError("invalid decimal count", "decimals", decimals);
      }
      if (comps[1].length <= decimals) {
        return this;
      }
      const factor = FixedNumber.from("1" + zeros.substring(0, decimals), this.format);
      const bump = BUMP.toFormat(this.format);
      return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
    }
    isZero() {
      return this._value === "0.0" || this._value === "0";
    }
    isNegative() {
      return this._value[0] === "-";
    }
    toString() {
      return this._value;
    }
    toHexString(width) {
      if (width == null) {
        return this._hex;
      }
      if (width % 8) {
        logger3.throwArgumentError("invalid byte width", "width", width);
      }
      const hex = BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
      return hexZeroPad(hex, width / 8);
    }
    toUnsafeFloat() {
      return parseFloat(this.toString());
    }
    toFormat(format2) {
      return FixedNumber.fromString(this._value, format2);
    }
    static fromValue(value, decimals, format2) {
      if (format2 == null && decimals != null && !isBigNumberish(decimals)) {
        format2 = decimals;
        decimals = null;
      }
      if (decimals == null) {
        decimals = 0;
      }
      if (format2 == null) {
        format2 = "fixed";
      }
      return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format2));
    }
    static fromString(value, format2) {
      if (format2 == null) {
        format2 = "fixed";
      }
      const fixedFormat = FixedFormat.from(format2);
      const numeric = parseFixed(value, fixedFormat.decimals);
      if (!fixedFormat.signed && numeric.lt(Zero)) {
        throwFault2("unsigned value cannot be negative", "overflow", "value", value);
      }
      let hex = null;
      if (fixedFormat.signed) {
        hex = numeric.toTwos(fixedFormat.width).toHexString();
      } else {
        hex = numeric.toHexString();
        hex = hexZeroPad(hex, fixedFormat.width / 8);
      }
      const decimal = formatFixed(numeric, fixedFormat.decimals);
      return new FixedNumber(_constructorGuard2, hex, decimal, fixedFormat);
    }
    static fromBytes(value, format2) {
      if (format2 == null) {
        format2 = "fixed";
      }
      const fixedFormat = FixedFormat.from(format2);
      if (arrayify(value).length > fixedFormat.width / 8) {
        throw new Error("overflow");
      }
      let numeric = BigNumber.from(value);
      if (fixedFormat.signed) {
        numeric = numeric.fromTwos(fixedFormat.width);
      }
      const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
      const decimal = formatFixed(numeric, fixedFormat.decimals);
      return new FixedNumber(_constructorGuard2, hex, decimal, fixedFormat);
    }
    static from(value, format2) {
      if (typeof value === "string") {
        return FixedNumber.fromString(value, format2);
      }
      if (isBytes2(value)) {
        return FixedNumber.fromBytes(value, format2);
      }
      try {
        return FixedNumber.fromValue(value, 0, format2);
      } catch (error) {
        if (error.code !== Logger.errors.INVALID_ARGUMENT) {
          throw error;
        }
      }
      return logger3.throwArgumentError("invalid FixedNumber value", "value", value);
    }
    static isFixedNumber(value) {
      return !!(value && value._isFixedNumber);
    }
  };
  var ONE = FixedNumber.from(1);
  var BUMP = FixedNumber.from("0.5");

  // node_modules/@ethersproject/properties/lib.esm/_version.js
  var version7 = "properties/5.7.0";

  // node_modules/@ethersproject/properties/lib.esm/index.js
  var __awaiter2 = function(thisArg, _arguments, P7, generator) {
    function adopt(value) {
      return value instanceof P7 ? value : new P7(function(resolve) {
        resolve(value);
      });
    }
    return new (P7 || (P7 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e9) {
          reject(e9);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e9) {
          reject(e9);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var logger4 = new Logger(version7);
  function defineReadOnly(object, name2, value) {
    Object.defineProperty(object, name2, {
      enumerable: true,
      value,
      writable: false
    });
  }
  function getStatic(ctor, key2) {
    for (let i7 = 0; i7 < 32; i7++) {
      if (ctor[key2]) {
        return ctor[key2];
      }
      if (!ctor.prototype || typeof ctor.prototype !== "object") {
        break;
      }
      ctor = Object.getPrototypeOf(ctor.prototype).constructor;
    }
    return null;
  }
  function resolveProperties(object) {
    return __awaiter2(this, void 0, void 0, function* () {
      const promises = Object.keys(object).map((key2) => {
        const value = object[key2];
        return Promise.resolve(value).then((v6) => ({ key: key2, value: v6 }));
      });
      const results2 = yield Promise.all(promises);
      return results2.reduce((accum, result) => {
        accum[result.key] = result.value;
        return accum;
      }, {});
    });
  }
  function checkProperties(object, properties) {
    if (!object || typeof object !== "object") {
      logger4.throwArgumentError("invalid object", "object", object);
    }
    Object.keys(object).forEach((key2) => {
      if (!properties[key2]) {
        logger4.throwArgumentError("invalid object key - " + key2, "transaction:" + key2, object);
      }
    });
  }
  function shallowCopy(object) {
    const result = {};
    for (const key2 in object) {
      result[key2] = object[key2];
    }
    return result;
  }
  var opaque = { bigint: true, boolean: true, "function": true, number: true, string: true };
  function _isFrozen(object) {
    if (object === void 0 || object === null || opaque[typeof object]) {
      return true;
    }
    if (Array.isArray(object) || typeof object === "object") {
      if (!Object.isFrozen(object)) {
        return false;
      }
      const keys2 = Object.keys(object);
      for (let i7 = 0; i7 < keys2.length; i7++) {
        let value = null;
        try {
          value = object[keys2[i7]];
        } catch (error) {
          continue;
        }
        if (!_isFrozen(value)) {
          return false;
        }
      }
      return true;
    }
    return logger4.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
  }
  function _deepCopy(object) {
    if (_isFrozen(object)) {
      return object;
    }
    if (Array.isArray(object)) {
      return Object.freeze(object.map((item) => deepCopy(item)));
    }
    if (typeof object === "object") {
      const result = {};
      for (const key2 in object) {
        const value = object[key2];
        if (value === void 0) {
          continue;
        }
        defineReadOnly(result, key2, deepCopy(value));
      }
      return result;
    }
    return logger4.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
  }
  function deepCopy(object) {
    return _deepCopy(object);
  }
  var Description = class {
    constructor(info) {
      for (const key2 in info) {
        this[key2] = deepCopy(info[key2]);
      }
    }
  };

  // node_modules/@ethersproject/abi/lib.esm/_version.js
  var version8 = "abi/5.7.0";

  // node_modules/@ethersproject/abi/lib.esm/fragments.js
  var logger5 = new Logger(version8);
  var _constructorGuard3 = {};
  var ModifiersBytes = { calldata: true, memory: true, storage: true };
  var ModifiersNest = { calldata: true, memory: true };
  function checkModifier(type, name2) {
    if (type === "bytes" || type === "string") {
      if (ModifiersBytes[name2]) {
        return true;
      }
    } else if (type === "address") {
      if (name2 === "payable") {
        return true;
      }
    } else if (type.indexOf("[") >= 0 || type === "tuple") {
      if (ModifiersNest[name2]) {
        return true;
      }
    }
    if (ModifiersBytes[name2] || name2 === "payable") {
      logger5.throwArgumentError("invalid modifier", "name", name2);
    }
    return false;
  }
  function parseParamType(param, allowIndexed) {
    let originalParam = param;
    function throwError(i7) {
      logger5.throwArgumentError(`unexpected character at position ${i7}`, "param", param);
    }
    param = param.replace(/\s/g, " ");
    function newNode(parent2) {
      let node2 = { type: "", name: "", parent: parent2, state: { allowType: true } };
      if (allowIndexed) {
        node2.indexed = false;
      }
      return node2;
    }
    let parent = { type: "", name: "", state: { allowType: true } };
    let node = parent;
    for (let i7 = 0; i7 < param.length; i7++) {
      let c9 = param[i7];
      switch (c9) {
        case "(":
          if (node.state.allowType && node.type === "") {
            node.type = "tuple";
          } else if (!node.state.allowParams) {
            throwError(i7);
          }
          node.state.allowType = false;
          node.type = verifyType(node.type);
          node.components = [newNode(node)];
          node = node.components[0];
          break;
        case ")":
          delete node.state;
          if (node.name === "indexed") {
            if (!allowIndexed) {
              throwError(i7);
            }
            node.indexed = true;
            node.name = "";
          }
          if (checkModifier(node.type, node.name)) {
            node.name = "";
          }
          node.type = verifyType(node.type);
          let child = node;
          node = node.parent;
          if (!node) {
            throwError(i7);
          }
          delete child.parent;
          node.state.allowParams = false;
          node.state.allowName = true;
          node.state.allowArray = true;
          break;
        case ",":
          delete node.state;
          if (node.name === "indexed") {
            if (!allowIndexed) {
              throwError(i7);
            }
            node.indexed = true;
            node.name = "";
          }
          if (checkModifier(node.type, node.name)) {
            node.name = "";
          }
          node.type = verifyType(node.type);
          let sibling = newNode(node.parent);
          node.parent.components.push(sibling);
          delete node.parent;
          node = sibling;
          break;
        case " ":
          if (node.state.allowType) {
            if (node.type !== "") {
              node.type = verifyType(node.type);
              delete node.state.allowType;
              node.state.allowName = true;
              node.state.allowParams = true;
            }
          }
          if (node.state.allowName) {
            if (node.name !== "") {
              if (node.name === "indexed") {
                if (!allowIndexed) {
                  throwError(i7);
                }
                if (node.indexed) {
                  throwError(i7);
                }
                node.indexed = true;
                node.name = "";
              } else if (checkModifier(node.type, node.name)) {
                node.name = "";
              } else {
                node.state.allowName = false;
              }
            }
          }
          break;
        case "[":
          if (!node.state.allowArray) {
            throwError(i7);
          }
          node.type += c9;
          node.state.allowArray = false;
          node.state.allowName = false;
          node.state.readArray = true;
          break;
        case "]":
          if (!node.state.readArray) {
            throwError(i7);
          }
          node.type += c9;
          node.state.readArray = false;
          node.state.allowArray = true;
          node.state.allowName = true;
          break;
        default:
          if (node.state.allowType) {
            node.type += c9;
            node.state.allowParams = true;
            node.state.allowArray = true;
          } else if (node.state.allowName) {
            node.name += c9;
            delete node.state.allowArray;
          } else if (node.state.readArray) {
            node.type += c9;
          } else {
            throwError(i7);
          }
      }
    }
    if (node.parent) {
      logger5.throwArgumentError("unexpected eof", "param", param);
    }
    delete parent.state;
    if (node.name === "indexed") {
      if (!allowIndexed) {
        throwError(originalParam.length - 7);
      }
      if (node.indexed) {
        throwError(originalParam.length - 7);
      }
      node.indexed = true;
      node.name = "";
    } else if (checkModifier(node.type, node.name)) {
      node.name = "";
    }
    parent.type = verifyType(parent.type);
    return parent;
  }
  function populate(object, params) {
    for (let key2 in params) {
      defineReadOnly(object, key2, params[key2]);
    }
  }
  var FormatTypes = Object.freeze({
    // Bare formatting, as is needed for computing a sighash of an event or function
    sighash: "sighash",
    // Human-Readable with Minimal spacing and without names (compact human-readable)
    minimal: "minimal",
    // Human-Readable with nice spacing, including all names
    full: "full",
    // JSON-format a la Solidity
    json: "json"
  });
  var paramTypeArray = new RegExp(/^(.*)\[([0-9]*)\]$/);
  var ParamType = class {
    constructor(constructorGuard, params) {
      if (constructorGuard !== _constructorGuard3) {
        logger5.throwError("use fromString", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "new ParamType()"
        });
      }
      populate(this, params);
      let match = this.type.match(paramTypeArray);
      if (match) {
        populate(this, {
          arrayLength: parseInt(match[2] || "-1"),
          arrayChildren: ParamType.fromObject({
            type: match[1],
            components: this.components
          }),
          baseType: "array"
        });
      } else {
        populate(this, {
          arrayLength: null,
          arrayChildren: null,
          baseType: this.components != null ? "tuple" : this.type
        });
      }
      this._isParamType = true;
      Object.freeze(this);
    }
    // Format the parameter fragment
    //   - sighash: "(uint256,address)"
    //   - minimal: "tuple(uint256,address) indexed"
    //   - full:    "tuple(uint256 foo, address bar) indexed baz"
    format(format2) {
      if (!format2) {
        format2 = FormatTypes.sighash;
      }
      if (!FormatTypes[format2]) {
        logger5.throwArgumentError("invalid format type", "format", format2);
      }
      if (format2 === FormatTypes.json) {
        let result2 = {
          type: this.baseType === "tuple" ? "tuple" : this.type,
          name: this.name || void 0
        };
        if (typeof this.indexed === "boolean") {
          result2.indexed = this.indexed;
        }
        if (this.components) {
          result2.components = this.components.map((comp) => JSON.parse(comp.format(format2)));
        }
        return JSON.stringify(result2);
      }
      let result = "";
      if (this.baseType === "array") {
        result += this.arrayChildren.format(format2);
        result += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]";
      } else {
        if (this.baseType === "tuple") {
          if (format2 !== FormatTypes.sighash) {
            result += this.type;
          }
          result += "(" + this.components.map((comp) => comp.format(format2)).join(format2 === FormatTypes.full ? ", " : ",") + ")";
        } else {
          result += this.type;
        }
      }
      if (format2 !== FormatTypes.sighash) {
        if (this.indexed === true) {
          result += " indexed";
        }
        if (format2 === FormatTypes.full && this.name) {
          result += " " + this.name;
        }
      }
      return result;
    }
    static from(value, allowIndexed) {
      if (typeof value === "string") {
        return ParamType.fromString(value, allowIndexed);
      }
      return ParamType.fromObject(value);
    }
    static fromObject(value) {
      if (ParamType.isParamType(value)) {
        return value;
      }
      return new ParamType(_constructorGuard3, {
        name: value.name || null,
        type: verifyType(value.type),
        indexed: value.indexed == null ? null : !!value.indexed,
        components: value.components ? value.components.map(ParamType.fromObject) : null
      });
    }
    static fromString(value, allowIndexed) {
      function ParamTypify(node) {
        return ParamType.fromObject({
          name: node.name,
          type: node.type,
          indexed: node.indexed,
          components: node.components
        });
      }
      return ParamTypify(parseParamType(value, !!allowIndexed));
    }
    static isParamType(value) {
      return !!(value != null && value._isParamType);
    }
  };
  function parseParams(value, allowIndex) {
    return splitNesting(value).map((param) => ParamType.fromString(param, allowIndex));
  }
  var Fragment = class {
    constructor(constructorGuard, params) {
      if (constructorGuard !== _constructorGuard3) {
        logger5.throwError("use a static from method", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "new Fragment()"
        });
      }
      populate(this, params);
      this._isFragment = true;
      Object.freeze(this);
    }
    static from(value) {
      if (Fragment.isFragment(value)) {
        return value;
      }
      if (typeof value === "string") {
        return Fragment.fromString(value);
      }
      return Fragment.fromObject(value);
    }
    static fromObject(value) {
      if (Fragment.isFragment(value)) {
        return value;
      }
      switch (value.type) {
        case "function":
          return FunctionFragment.fromObject(value);
        case "event":
          return EventFragment.fromObject(value);
        case "constructor":
          return ConstructorFragment.fromObject(value);
        case "error":
          return ErrorFragment.fromObject(value);
        case "fallback":
        case "receive":
          return null;
      }
      return logger5.throwArgumentError("invalid fragment object", "value", value);
    }
    static fromString(value) {
      value = value.replace(/\s/g, " ");
      value = value.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ");
      value = value.trim();
      if (value.split(" ")[0] === "event") {
        return EventFragment.fromString(value.substring(5).trim());
      } else if (value.split(" ")[0] === "function") {
        return FunctionFragment.fromString(value.substring(8).trim());
      } else if (value.split("(")[0].trim() === "constructor") {
        return ConstructorFragment.fromString(value.trim());
      } else if (value.split(" ")[0] === "error") {
        return ErrorFragment.fromString(value.substring(5).trim());
      }
      return logger5.throwArgumentError("unsupported fragment", "value", value);
    }
    static isFragment(value) {
      return !!(value && value._isFragment);
    }
  };
  var EventFragment = class extends Fragment {
    format(format2) {
      if (!format2) {
        format2 = FormatTypes.sighash;
      }
      if (!FormatTypes[format2]) {
        logger5.throwArgumentError("invalid format type", "format", format2);
      }
      if (format2 === FormatTypes.json) {
        return JSON.stringify({
          type: "event",
          anonymous: this.anonymous,
          name: this.name,
          inputs: this.inputs.map((input) => JSON.parse(input.format(format2)))
        });
      }
      let result = "";
      if (format2 !== FormatTypes.sighash) {
        result += "event ";
      }
      result += this.name + "(" + this.inputs.map((input) => input.format(format2)).join(format2 === FormatTypes.full ? ", " : ",") + ") ";
      if (format2 !== FormatTypes.sighash) {
        if (this.anonymous) {
          result += "anonymous ";
        }
      }
      return result.trim();
    }
    static from(value) {
      if (typeof value === "string") {
        return EventFragment.fromString(value);
      }
      return EventFragment.fromObject(value);
    }
    static fromObject(value) {
      if (EventFragment.isEventFragment(value)) {
        return value;
      }
      if (value.type !== "event") {
        logger5.throwArgumentError("invalid event object", "value", value);
      }
      const params = {
        name: verifyIdentifier(value.name),
        anonymous: value.anonymous,
        inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
        type: "event"
      };
      return new EventFragment(_constructorGuard3, params);
    }
    static fromString(value) {
      let match = value.match(regexParen);
      if (!match) {
        logger5.throwArgumentError("invalid event string", "value", value);
      }
      let anonymous = false;
      match[3].split(" ").forEach((modifier) => {
        switch (modifier.trim()) {
          case "anonymous":
            anonymous = true;
            break;
          case "":
            break;
          default:
            logger5.warn("unknown modifier: " + modifier);
        }
      });
      return EventFragment.fromObject({
        name: match[1].trim(),
        anonymous,
        inputs: parseParams(match[2], true),
        type: "event"
      });
    }
    static isEventFragment(value) {
      return value && value._isFragment && value.type === "event";
    }
  };
  function parseGas(value, params) {
    params.gas = null;
    let comps = value.split("@");
    if (comps.length !== 1) {
      if (comps.length > 2) {
        logger5.throwArgumentError("invalid human-readable ABI signature", "value", value);
      }
      if (!comps[1].match(/^[0-9]+$/)) {
        logger5.throwArgumentError("invalid human-readable ABI signature gas", "value", value);
      }
      params.gas = BigNumber.from(comps[1]);
      return comps[0];
    }
    return value;
  }
  function parseModifiers(value, params) {
    params.constant = false;
    params.payable = false;
    params.stateMutability = "nonpayable";
    value.split(" ").forEach((modifier) => {
      switch (modifier.trim()) {
        case "constant":
          params.constant = true;
          break;
        case "payable":
          params.payable = true;
          params.stateMutability = "payable";
          break;
        case "nonpayable":
          params.payable = false;
          params.stateMutability = "nonpayable";
          break;
        case "pure":
          params.constant = true;
          params.stateMutability = "pure";
          break;
        case "view":
          params.constant = true;
          params.stateMutability = "view";
          break;
        case "external":
        case "public":
        case "":
          break;
        default:
          console.log("unknown modifier: " + modifier);
      }
    });
  }
  function verifyState(value) {
    let result = {
      constant: false,
      payable: true,
      stateMutability: "payable"
    };
    if (value.stateMutability != null) {
      result.stateMutability = value.stateMutability;
      result.constant = result.stateMutability === "view" || result.stateMutability === "pure";
      if (value.constant != null) {
        if (!!value.constant !== result.constant) {
          logger5.throwArgumentError("cannot have constant function with mutability " + result.stateMutability, "value", value);
        }
      }
      result.payable = result.stateMutability === "payable";
      if (value.payable != null) {
        if (!!value.payable !== result.payable) {
          logger5.throwArgumentError("cannot have payable function with mutability " + result.stateMutability, "value", value);
        }
      }
    } else if (value.payable != null) {
      result.payable = !!value.payable;
      if (value.constant == null && !result.payable && value.type !== "constructor") {
        logger5.throwArgumentError("unable to determine stateMutability", "value", value);
      }
      result.constant = !!value.constant;
      if (result.constant) {
        result.stateMutability = "view";
      } else {
        result.stateMutability = result.payable ? "payable" : "nonpayable";
      }
      if (result.payable && result.constant) {
        logger5.throwArgumentError("cannot have constant payable function", "value", value);
      }
    } else if (value.constant != null) {
      result.constant = !!value.constant;
      result.payable = !result.constant;
      result.stateMutability = result.constant ? "view" : "payable";
    } else if (value.type !== "constructor") {
      logger5.throwArgumentError("unable to determine stateMutability", "value", value);
    }
    return result;
  }
  var ConstructorFragment = class extends Fragment {
    format(format2) {
      if (!format2) {
        format2 = FormatTypes.sighash;
      }
      if (!FormatTypes[format2]) {
        logger5.throwArgumentError("invalid format type", "format", format2);
      }
      if (format2 === FormatTypes.json) {
        return JSON.stringify({
          type: "constructor",
          stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
          payable: this.payable,
          gas: this.gas ? this.gas.toNumber() : void 0,
          inputs: this.inputs.map((input) => JSON.parse(input.format(format2)))
        });
      }
      if (format2 === FormatTypes.sighash) {
        logger5.throwError("cannot format a constructor for sighash", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "format(sighash)"
        });
      }
      let result = "constructor(" + this.inputs.map((input) => input.format(format2)).join(format2 === FormatTypes.full ? ", " : ",") + ") ";
      if (this.stateMutability && this.stateMutability !== "nonpayable") {
        result += this.stateMutability + " ";
      }
      return result.trim();
    }
    static from(value) {
      if (typeof value === "string") {
        return ConstructorFragment.fromString(value);
      }
      return ConstructorFragment.fromObject(value);
    }
    static fromObject(value) {
      if (ConstructorFragment.isConstructorFragment(value)) {
        return value;
      }
      if (value.type !== "constructor") {
        logger5.throwArgumentError("invalid constructor object", "value", value);
      }
      let state = verifyState(value);
      if (state.constant) {
        logger5.throwArgumentError("constructor cannot be constant", "value", value);
      }
      const params = {
        name: null,
        type: value.type,
        inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
        payable: state.payable,
        stateMutability: state.stateMutability,
        gas: value.gas ? BigNumber.from(value.gas) : null
      };
      return new ConstructorFragment(_constructorGuard3, params);
    }
    static fromString(value) {
      let params = { type: "constructor" };
      value = parseGas(value, params);
      let parens = value.match(regexParen);
      if (!parens || parens[1].trim() !== "constructor") {
        logger5.throwArgumentError("invalid constructor string", "value", value);
      }
      params.inputs = parseParams(parens[2].trim(), false);
      parseModifiers(parens[3].trim(), params);
      return ConstructorFragment.fromObject(params);
    }
    static isConstructorFragment(value) {
      return value && value._isFragment && value.type === "constructor";
    }
  };
  var FunctionFragment = class extends ConstructorFragment {
    format(format2) {
      if (!format2) {
        format2 = FormatTypes.sighash;
      }
      if (!FormatTypes[format2]) {
        logger5.throwArgumentError("invalid format type", "format", format2);
      }
      if (format2 === FormatTypes.json) {
        return JSON.stringify({
          type: "function",
          name: this.name,
          constant: this.constant,
          stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
          payable: this.payable,
          gas: this.gas ? this.gas.toNumber() : void 0,
          inputs: this.inputs.map((input) => JSON.parse(input.format(format2))),
          outputs: this.outputs.map((output2) => JSON.parse(output2.format(format2)))
        });
      }
      let result = "";
      if (format2 !== FormatTypes.sighash) {
        result += "function ";
      }
      result += this.name + "(" + this.inputs.map((input) => input.format(format2)).join(format2 === FormatTypes.full ? ", " : ",") + ") ";
      if (format2 !== FormatTypes.sighash) {
        if (this.stateMutability) {
          if (this.stateMutability !== "nonpayable") {
            result += this.stateMutability + " ";
          }
        } else if (this.constant) {
          result += "view ";
        }
        if (this.outputs && this.outputs.length) {
          result += "returns (" + this.outputs.map((output2) => output2.format(format2)).join(", ") + ") ";
        }
        if (this.gas != null) {
          result += "@" + this.gas.toString() + " ";
        }
      }
      return result.trim();
    }
    static from(value) {
      if (typeof value === "string") {
        return FunctionFragment.fromString(value);
      }
      return FunctionFragment.fromObject(value);
    }
    static fromObject(value) {
      if (FunctionFragment.isFunctionFragment(value)) {
        return value;
      }
      if (value.type !== "function") {
        logger5.throwArgumentError("invalid function object", "value", value);
      }
      let state = verifyState(value);
      const params = {
        type: value.type,
        name: verifyIdentifier(value.name),
        constant: state.constant,
        inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
        outputs: value.outputs ? value.outputs.map(ParamType.fromObject) : [],
        payable: state.payable,
        stateMutability: state.stateMutability,
        gas: value.gas ? BigNumber.from(value.gas) : null
      };
      return new FunctionFragment(_constructorGuard3, params);
    }
    static fromString(value) {
      let params = { type: "function" };
      value = parseGas(value, params);
      let comps = value.split(" returns ");
      if (comps.length > 2) {
        logger5.throwArgumentError("invalid function string", "value", value);
      }
      let parens = comps[0].match(regexParen);
      if (!parens) {
        logger5.throwArgumentError("invalid function signature", "value", value);
      }
      params.name = parens[1].trim();
      if (params.name) {
        verifyIdentifier(params.name);
      }
      params.inputs = parseParams(parens[2], false);
      parseModifiers(parens[3].trim(), params);
      if (comps.length > 1) {
        let returns = comps[1].match(regexParen);
        if (returns[1].trim() != "" || returns[3].trim() != "") {
          logger5.throwArgumentError("unexpected tokens", "value", value);
        }
        params.outputs = parseParams(returns[2], false);
      } else {
        params.outputs = [];
      }
      return FunctionFragment.fromObject(params);
    }
    static isFunctionFragment(value) {
      return value && value._isFragment && value.type === "function";
    }
  };
  function checkForbidden(fragment) {
    const sig = fragment.format();
    if (sig === "Error(string)" || sig === "Panic(uint256)") {
      logger5.throwArgumentError(`cannot specify user defined ${sig} error`, "fragment", fragment);
    }
    return fragment;
  }
  var ErrorFragment = class extends Fragment {
    format(format2) {
      if (!format2) {
        format2 = FormatTypes.sighash;
      }
      if (!FormatTypes[format2]) {
        logger5.throwArgumentError("invalid format type", "format", format2);
      }
      if (format2 === FormatTypes.json) {
        return JSON.stringify({
          type: "error",
          name: this.name,
          inputs: this.inputs.map((input) => JSON.parse(input.format(format2)))
        });
      }
      let result = "";
      if (format2 !== FormatTypes.sighash) {
        result += "error ";
      }
      result += this.name + "(" + this.inputs.map((input) => input.format(format2)).join(format2 === FormatTypes.full ? ", " : ",") + ") ";
      return result.trim();
    }
    static from(value) {
      if (typeof value === "string") {
        return ErrorFragment.fromString(value);
      }
      return ErrorFragment.fromObject(value);
    }
    static fromObject(value) {
      if (ErrorFragment.isErrorFragment(value)) {
        return value;
      }
      if (value.type !== "error") {
        logger5.throwArgumentError("invalid error object", "value", value);
      }
      const params = {
        type: value.type,
        name: verifyIdentifier(value.name),
        inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : []
      };
      return checkForbidden(new ErrorFragment(_constructorGuard3, params));
    }
    static fromString(value) {
      let params = { type: "error" };
      let parens = value.match(regexParen);
      if (!parens) {
        logger5.throwArgumentError("invalid error signature", "value", value);
      }
      params.name = parens[1].trim();
      if (params.name) {
        verifyIdentifier(params.name);
      }
      params.inputs = parseParams(parens[2], false);
      return checkForbidden(ErrorFragment.fromObject(params));
    }
    static isErrorFragment(value) {
      return value && value._isFragment && value.type === "error";
    }
  };
  function verifyType(type) {
    if (type.match(/^uint($|[^1-9])/)) {
      type = "uint256" + type.substring(4);
    } else if (type.match(/^int($|[^1-9])/)) {
      type = "int256" + type.substring(3);
    }
    return type;
  }
  var regexIdentifier = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
  function verifyIdentifier(value) {
    if (!value || !value.match(regexIdentifier)) {
      logger5.throwArgumentError(`invalid identifier "${value}"`, "value", value);
    }
    return value;
  }
  var regexParen = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
  function splitNesting(value) {
    value = value.trim();
    let result = [];
    let accum = "";
    let depth = 0;
    for (let offset = 0; offset < value.length; offset++) {
      let c9 = value[offset];
      if (c9 === "," && depth === 0) {
        result.push(accum);
        accum = "";
      } else {
        accum += c9;
        if (c9 === "(") {
          depth++;
        } else if (c9 === ")") {
          depth--;
          if (depth === -1) {
            logger5.throwArgumentError("unbalanced parenthesis", "value", value);
          }
        }
      }
    }
    if (accum) {
      result.push(accum);
    }
    return result;
  }

  // node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js
  var logger6 = new Logger(version8);
  function checkResultErrors(result) {
    const errors = [];
    const checkErrors = function(path, object) {
      if (!Array.isArray(object)) {
        return;
      }
      for (let key2 in object) {
        const childPath = path.slice();
        childPath.push(key2);
        try {
          checkErrors(childPath, object[key2]);
        } catch (error) {
          errors.push({ path: childPath, error });
        }
      }
    };
    checkErrors([], result);
    return errors;
  }
  var Coder = class {
    constructor(name2, type, localName, dynamic) {
      this.name = name2;
      this.type = type;
      this.localName = localName;
      this.dynamic = dynamic;
    }
    _throwError(message, value) {
      logger6.throwArgumentError(message, this.localName, value);
    }
  };
  var Writer = class {
    constructor(wordSize) {
      defineReadOnly(this, "wordSize", wordSize || 32);
      this._data = [];
      this._dataLength = 0;
      this._padding = new Uint8Array(wordSize);
    }
    get data() {
      return hexConcat(this._data);
    }
    get length() {
      return this._dataLength;
    }
    _writeData(data2) {
      this._data.push(data2);
      this._dataLength += data2.length;
      return data2.length;
    }
    appendWriter(writer) {
      return this._writeData(concat3(writer._data));
    }
    // Arrayish items; padded on the right to wordSize
    writeBytes(value) {
      let bytes3 = arrayify(value);
      const paddingOffset = bytes3.length % this.wordSize;
      if (paddingOffset) {
        bytes3 = concat3([bytes3, this._padding.slice(paddingOffset)]);
      }
      return this._writeData(bytes3);
    }
    _getValue(value) {
      let bytes3 = arrayify(BigNumber.from(value));
      if (bytes3.length > this.wordSize) {
        logger6.throwError("value out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
          length: this.wordSize,
          offset: bytes3.length
        });
      }
      if (bytes3.length % this.wordSize) {
        bytes3 = concat3([this._padding.slice(bytes3.length % this.wordSize), bytes3]);
      }
      return bytes3;
    }
    // BigNumberish items; padded on the left to wordSize
    writeValue(value) {
      return this._writeData(this._getValue(value));
    }
    writeUpdatableValue() {
      const offset = this._data.length;
      this._data.push(this._padding);
      this._dataLength += this.wordSize;
      return (value) => {
        this._data[offset] = this._getValue(value);
      };
    }
  };
  var Reader = class {
    constructor(data2, wordSize, coerceFunc, allowLoose) {
      defineReadOnly(this, "_data", arrayify(data2));
      defineReadOnly(this, "wordSize", wordSize || 32);
      defineReadOnly(this, "_coerceFunc", coerceFunc);
      defineReadOnly(this, "allowLoose", allowLoose);
      this._offset = 0;
    }
    get data() {
      return hexlify(this._data);
    }
    get consumed() {
      return this._offset;
    }
    // The default Coerce function
    static coerce(name2, value) {
      let match = name2.match("^u?int([0-9]+)$");
      if (match && parseInt(match[1]) <= 48) {
        value = value.toNumber();
      }
      return value;
    }
    coerce(name2, value) {
      if (this._coerceFunc) {
        return this._coerceFunc(name2, value);
      }
      return Reader.coerce(name2, value);
    }
    _peekBytes(offset, length2, loose) {
      let alignedLength = Math.ceil(length2 / this.wordSize) * this.wordSize;
      if (this._offset + alignedLength > this._data.length) {
        if (this.allowLoose && loose && this._offset + length2 <= this._data.length) {
          alignedLength = length2;
        } else {
          logger6.throwError("data out-of-bounds", Logger.errors.BUFFER_OVERRUN, {
            length: this._data.length,
            offset: this._offset + alignedLength
          });
        }
      }
      return this._data.slice(this._offset, this._offset + alignedLength);
    }
    subReader(offset) {
      return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);
    }
    readBytes(length2, loose) {
      let bytes3 = this._peekBytes(0, length2, !!loose);
      this._offset += bytes3.length;
      return bytes3.slice(0, length2);
    }
    readValue() {
      return BigNumber.from(this.readBytes(this.wordSize));
    }
  };

  // node_modules/@ethersproject/keccak256/lib.esm/index.js
  var import_js_sha3 = __toESM(require_sha3());
  function keccak2562(data2) {
    return "0x" + import_js_sha3.default.keccak_256(arrayify(data2));
  }

  // node_modules/@ethersproject/rlp/lib.esm/index.js
  var lib_exports = {};
  __export(lib_exports, {
    decode: () => decode6,
    encode: () => encode7
  });

  // node_modules/@ethersproject/rlp/lib.esm/_version.js
  var version9 = "rlp/5.7.0";

  // node_modules/@ethersproject/rlp/lib.esm/index.js
  var logger7 = new Logger(version9);
  function arrayifyInteger(value) {
    const result = [];
    while (value) {
      result.unshift(value & 255);
      value >>= 8;
    }
    return result;
  }
  function unarrayifyInteger(data2, offset, length2) {
    let result = 0;
    for (let i7 = 0; i7 < length2; i7++) {
      result = result * 256 + data2[offset + i7];
    }
    return result;
  }
  function _encode(object) {
    if (Array.isArray(object)) {
      let payload = [];
      object.forEach(function(child) {
        payload = payload.concat(_encode(child));
      });
      if (payload.length <= 55) {
        payload.unshift(192 + payload.length);
        return payload;
      }
      const length3 = arrayifyInteger(payload.length);
      length3.unshift(247 + length3.length);
      return length3.concat(payload);
    }
    if (!isBytesLike(object)) {
      logger7.throwArgumentError("RLP object must be BytesLike", "object", object);
    }
    const data2 = Array.prototype.slice.call(arrayify(object));
    if (data2.length === 1 && data2[0] <= 127) {
      return data2;
    } else if (data2.length <= 55) {
      data2.unshift(128 + data2.length);
      return data2;
    }
    const length2 = arrayifyInteger(data2.length);
    length2.unshift(183 + length2.length);
    return length2.concat(data2);
  }
  function encode7(object) {
    return hexlify(_encode(object));
  }
  function _decodeChildren(data2, offset, childOffset, length2) {
    const result = [];
    while (childOffset < offset + 1 + length2) {
      const decoded = _decode(data2, childOffset);
      result.push(decoded.result);
      childOffset += decoded.consumed;
      if (childOffset > offset + 1 + length2) {
        logger7.throwError("child data too short", Logger.errors.BUFFER_OVERRUN, {});
      }
    }
    return { consumed: 1 + length2, result };
  }
  function _decode(data2, offset) {
    if (data2.length === 0) {
      logger7.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {});
    }
    if (data2[offset] >= 248) {
      const lengthLength = data2[offset] - 247;
      if (offset + 1 + lengthLength > data2.length) {
        logger7.throwError("data short segment too short", Logger.errors.BUFFER_OVERRUN, {});
      }
      const length2 = unarrayifyInteger(data2, offset + 1, lengthLength);
      if (offset + 1 + lengthLength + length2 > data2.length) {
        logger7.throwError("data long segment too short", Logger.errors.BUFFER_OVERRUN, {});
      }
      return _decodeChildren(data2, offset, offset + 1 + lengthLength, lengthLength + length2);
    } else if (data2[offset] >= 192) {
      const length2 = data2[offset] - 192;
      if (offset + 1 + length2 > data2.length) {
        logger7.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
      }
      return _decodeChildren(data2, offset, offset + 1, length2);
    } else if (data2[offset] >= 184) {
      const lengthLength = data2[offset] - 183;
      if (offset + 1 + lengthLength > data2.length) {
        logger7.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
      }
      const length2 = unarrayifyInteger(data2, offset + 1, lengthLength);
      if (offset + 1 + lengthLength + length2 > data2.length) {
        logger7.throwError("data array too short", Logger.errors.BUFFER_OVERRUN, {});
      }
      const result = hexlify(data2.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length2));
      return { consumed: 1 + lengthLength + length2, result };
    } else if (data2[offset] >= 128) {
      const length2 = data2[offset] - 128;
      if (offset + 1 + length2 > data2.length) {
        logger7.throwError("data too short", Logger.errors.BUFFER_OVERRUN, {});
      }
      const result = hexlify(data2.slice(offset + 1, offset + 1 + length2));
      return { consumed: 1 + length2, result };
    }
    return { consumed: 1, result: hexlify(data2[offset]) };
  }
  function decode6(data2) {
    const bytes3 = arrayify(data2);
    const decoded = _decode(bytes3, 0);
    if (decoded.consumed !== bytes3.length) {
      logger7.throwArgumentError("invalid rlp data", "data", data2);
    }
    return decoded.result;
  }

  // node_modules/@ethersproject/address/lib.esm/_version.js
  var version10 = "address/5.7.0";

  // node_modules/@ethersproject/address/lib.esm/index.js
  var logger8 = new Logger(version10);
  function getChecksumAddress(address) {
    if (!isHexString(address, 20)) {
      logger8.throwArgumentError("invalid address", "address", address);
    }
    address = address.toLowerCase();
    const chars = address.substring(2).split("");
    const expanded = new Uint8Array(40);
    for (let i7 = 0; i7 < 40; i7++) {
      expanded[i7] = chars[i7].charCodeAt(0);
    }
    const hashed = arrayify(keccak2562(expanded));
    for (let i7 = 0; i7 < 40; i7 += 2) {
      if (hashed[i7 >> 1] >> 4 >= 8) {
        chars[i7] = chars[i7].toUpperCase();
      }
      if ((hashed[i7 >> 1] & 15) >= 8) {
        chars[i7 + 1] = chars[i7 + 1].toUpperCase();
      }
    }
    return "0x" + chars.join("");
  }
  var MAX_SAFE_INTEGER = 9007199254740991;
  function log10(x4) {
    if (Math.log10) {
      return Math.log10(x4);
    }
    return Math.log(x4) / Math.LN10;
  }
  var ibanLookup = {};
  for (let i7 = 0; i7 < 10; i7++) {
    ibanLookup[String(i7)] = String(i7);
  }
  for (let i7 = 0; i7 < 26; i7++) {
    ibanLookup[String.fromCharCode(65 + i7)] = String(10 + i7);
  }
  var safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));
  function ibanChecksum(address) {
    address = address.toUpperCase();
    address = address.substring(4) + address.substring(0, 2) + "00";
    let expanded = address.split("").map((c9) => {
      return ibanLookup[c9];
    }).join("");
    while (expanded.length >= safeDigits) {
      let block2 = expanded.substring(0, safeDigits);
      expanded = parseInt(block2, 10) % 97 + expanded.substring(block2.length);
    }
    let checksum = String(98 - parseInt(expanded, 10) % 97);
    while (checksum.length < 2) {
      checksum = "0" + checksum;
    }
    return checksum;
  }
  function getAddress2(address) {
    let result = null;
    if (typeof address !== "string") {
      logger8.throwArgumentError("invalid address", "address", address);
    }
    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
      if (address.substring(0, 2) !== "0x") {
        address = "0x" + address;
      }
      result = getChecksumAddress(address);
      if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
        logger8.throwArgumentError("bad address checksum", "address", address);
      }
    } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
      if (address.substring(2, 4) !== ibanChecksum(address)) {
        logger8.throwArgumentError("bad icap checksum", "address", address);
      }
      result = _base36To16(address.substring(4));
      while (result.length < 40) {
        result = "0" + result;
      }
      result = getChecksumAddress("0x" + result);
    } else {
      logger8.throwArgumentError("invalid address", "address", address);
    }
    return result;
  }
  function isAddress2(address) {
    try {
      getAddress2(address);
      return true;
    } catch (error) {
    }
    return false;
  }
  function getIcapAddress(address) {
    let base362 = _base16To36(getAddress2(address).substring(2)).toUpperCase();
    while (base362.length < 30) {
      base362 = "0" + base362;
    }
    return "XE" + ibanChecksum("XE00" + base362) + base362;
  }
  function getContractAddress3(transaction) {
    let from3 = null;
    try {
      from3 = getAddress2(transaction.from);
    } catch (error) {
      logger8.throwArgumentError("missing from address", "transaction", transaction);
    }
    const nonce = stripZeros(arrayify(BigNumber.from(transaction.nonce).toHexString()));
    return getAddress2(hexDataSlice(keccak2562(encode7([from3, nonce])), 12));
  }
  function getCreate2Address2(from3, salt, initCodeHash) {
    if (hexDataLength(salt) !== 32) {
      logger8.throwArgumentError("salt must be 32 bytes", "salt", salt);
    }
    if (hexDataLength(initCodeHash) !== 32) {
      logger8.throwArgumentError("initCodeHash must be 32 bytes", "initCodeHash", initCodeHash);
    }
    return getAddress2(hexDataSlice(keccak2562(concat3(["0xff", getAddress2(from3), salt, initCodeHash])), 12));
  }

  // node_modules/@ethersproject/abi/lib.esm/coders/address.js
  var AddressCoder = class extends Coder {
    constructor(localName) {
      super("address", "address", localName, false);
    }
    defaultValue() {
      return "0x0000000000000000000000000000000000000000";
    }
    encode(writer, value) {
      try {
        value = getAddress2(value);
      } catch (error) {
        this._throwError(error.message, value);
      }
      return writer.writeValue(value);
    }
    decode(reader) {
      return getAddress2(hexZeroPad(reader.readValue().toHexString(), 20));
    }
  };

  // node_modules/@ethersproject/abi/lib.esm/coders/anonymous.js
  var AnonymousCoder = class extends Coder {
    constructor(coder) {
      super(coder.name, coder.type, void 0, coder.dynamic);
      this.coder = coder;
    }
    defaultValue() {
      return this.coder.defaultValue();
    }
    encode(writer, value) {
      return this.coder.encode(writer, value);
    }
    decode(reader) {
      return this.coder.decode(reader);
    }
  };

  // node_modules/@ethersproject/abi/lib.esm/coders/array.js
  var logger9 = new Logger(version8);
  function pack(writer, coders, values) {
    let arrayValues = null;
    if (Array.isArray(values)) {
      arrayValues = values;
    } else if (values && typeof values === "object") {
      let unique = {};
      arrayValues = coders.map((coder) => {
        const name2 = coder.localName;
        if (!name2) {
          logger9.throwError("cannot encode object for signature with missing names", Logger.errors.INVALID_ARGUMENT, {
            argument: "values",
            coder,
            value: values
          });
        }
        if (unique[name2]) {
          logger9.throwError("cannot encode object for signature with duplicate names", Logger.errors.INVALID_ARGUMENT, {
            argument: "values",
            coder,
            value: values
          });
        }
        unique[name2] = true;
        return values[name2];
      });
    } else {
      logger9.throwArgumentError("invalid tuple value", "tuple", values);
    }
    if (coders.length !== arrayValues.length) {
      logger9.throwArgumentError("types/value length mismatch", "tuple", values);
    }
    let staticWriter = new Writer(writer.wordSize);
    let dynamicWriter = new Writer(writer.wordSize);
    let updateFuncs = [];
    coders.forEach((coder, index2) => {
      let value = arrayValues[index2];
      if (coder.dynamic) {
        let dynamicOffset = dynamicWriter.length;
        coder.encode(dynamicWriter, value);
        let updateFunc = staticWriter.writeUpdatableValue();
        updateFuncs.push((baseOffset) => {
          updateFunc(baseOffset + dynamicOffset);
        });
      } else {
        coder.encode(staticWriter, value);
      }
    });
    updateFuncs.forEach((func) => {
      func(staticWriter.length);
    });
    let length2 = writer.appendWriter(staticWriter);
    length2 += writer.appendWriter(dynamicWriter);
    return length2;
  }
  function unpack(reader, coders) {
    let values = [];
    let baseReader = reader.subReader(0);
    coders.forEach((coder) => {
      let value = null;
      if (coder.dynamic) {
        let offset = reader.readValue();
        let offsetReader = baseReader.subReader(offset.toNumber());
        try {
          value = coder.decode(offsetReader);
        } catch (error) {
          if (error.code === Logger.errors.BUFFER_OVERRUN) {
            throw error;
          }
          value = error;
          value.baseType = coder.name;
          value.name = coder.localName;
          value.type = coder.type;
        }
      } else {
        try {
          value = coder.decode(reader);
        } catch (error) {
          if (error.code === Logger.errors.BUFFER_OVERRUN) {
            throw error;
          }
          value = error;
          value.baseType = coder.name;
          value.name = coder.localName;
          value.type = coder.type;
        }
      }
      if (value != void 0) {
        values.push(value);
      }
    });
    const uniqueNames = coders.reduce((accum, coder) => {
      const name2 = coder.localName;
      if (name2) {
        if (!accum[name2]) {
          accum[name2] = 0;
        }
        accum[name2]++;
      }
      return accum;
    }, {});
    coders.forEach((coder, index2) => {
      let name2 = coder.localName;
      if (!name2 || uniqueNames[name2] !== 1) {
        return;
      }
      if (name2 === "length") {
        name2 = "_length";
      }
      if (values[name2] != null) {
        return;
      }
      const value = values[index2];
      if (value instanceof Error) {
        Object.defineProperty(values, name2, {
          enumerable: true,
          get: () => {
            throw value;
          }
        });
      } else {
        values[name2] = value;
      }
    });
    for (let i7 = 0; i7 < values.length; i7++) {
      const value = values[i7];
      if (value instanceof Error) {
        Object.defineProperty(values, i7, {
          enumerable: true,
          get: () => {
            throw value;
          }
        });
      }
    }
    return Object.freeze(values);
  }
  var ArrayCoder = class extends Coder {
    constructor(coder, length2, localName) {
      const type = coder.type + "[" + (length2 >= 0 ? length2 : "") + "]";
      const dynamic = length2 === -1 || coder.dynamic;
      super("array", type, localName, dynamic);
      this.coder = coder;
      this.length = length2;
    }
    defaultValue() {
      const defaultChild = this.coder.defaultValue();
      const result = [];
      for (let i7 = 0; i7 < this.length; i7++) {
        result.push(defaultChild);
      }
      return result;
    }
    encode(writer, value) {
      if (!Array.isArray(value)) {
        this._throwError("expected array value", value);
      }
      let count = this.length;
      if (count === -1) {
        count = value.length;
        writer.writeValue(value.length);
      }
      logger9.checkArgumentCount(value.length, count, "coder array" + (this.localName ? " " + this.localName : ""));
      let coders = [];
      for (let i7 = 0; i7 < value.length; i7++) {
        coders.push(this.coder);
      }
      return pack(writer, coders, value);
    }
    decode(reader) {
      let count = this.length;
      if (count === -1) {
        count = reader.readValue().toNumber();
        if (count * 32 > reader._data.length) {
          logger9.throwError("insufficient data length", Logger.errors.BUFFER_OVERRUN, {
            length: reader._data.length,
            count
          });
        }
      }
      let coders = [];
      for (let i7 = 0; i7 < count; i7++) {
        coders.push(new AnonymousCoder(this.coder));
      }
      return reader.coerce(this.name, unpack(reader, coders));
    }
  };

  // node_modules/@ethersproject/abi/lib.esm/coders/boolean.js
  var BooleanCoder = class extends Coder {
    constructor(localName) {
      super("bool", "bool", localName, false);
    }
    defaultValue() {
      return false;
    }
    encode(writer, value) {
      return writer.writeValue(value ? 1 : 0);
    }
    decode(reader) {
      return reader.coerce(this.type, !reader.readValue().isZero());
    }
  };

  // node_modules/@ethersproject/abi/lib.esm/coders/bytes.js
  var DynamicBytesCoder = class extends Coder {
    constructor(type, localName) {
      super(type, type, localName, true);
    }
    defaultValue() {
      return "0x";
    }
    encode(writer, value) {
      value = arrayify(value);
      let length2 = writer.writeValue(value.length);
      length2 += writer.writeBytes(value);
      return length2;
    }
    decode(reader) {
      return reader.readBytes(reader.readValue().toNumber(), true);
    }
  };
  var BytesCoder = class extends DynamicBytesCoder {
    constructor(localName) {
      super("bytes", localName);
    }
    decode(reader) {
      return reader.coerce(this.name, hexlify(super.decode(reader)));
    }
  };

  // node_modules/@ethersproject/abi/lib.esm/coders/fixed-bytes.js
  var FixedBytesCoder = class extends Coder {
    constructor(size3, localName) {
      let name2 = "bytes" + String(size3);
      super(name2, name2, localName, false);
      this.size = size3;
    }
    defaultValue() {
      return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
    }
    encode(writer, value) {
      let data2 = arrayify(value);
      if (data2.length !== this.size) {
        this._throwError("incorrect data length", value);
      }
      return writer.writeBytes(data2);
    }
    decode(reader) {
      return reader.coerce(this.name, hexlify(reader.readBytes(this.size)));
    }
  };

  // node_modules/@ethersproject/abi/lib.esm/coders/null.js
  var NullCoder = class extends Coder {
    constructor(localName) {
      super("null", "", localName, false);
    }
    defaultValue() {
      return null;
    }
    encode(writer, value) {
      if (value != null) {
        this._throwError("not null", value);
      }
      return writer.writeBytes([]);
    }
    decode(reader) {
      reader.readBytes(0);
      return reader.coerce(this.name, null);
    }
  };

  // node_modules/@ethersproject/constants/lib.esm/index.js
  var lib_exports2 = {};
  __export(lib_exports2, {
    AddressZero: () => AddressZero,
    EtherSymbol: () => EtherSymbol,
    HashZero: () => HashZero,
    MaxInt256: () => MaxInt256,
    MaxUint256: () => MaxUint256,
    MinInt256: () => MinInt256,
    NegativeOne: () => NegativeOne2,
    One: () => One,
    Two: () => Two,
    WeiPerEther: () => WeiPerEther,
    Zero: () => Zero2
  });

  // node_modules/@ethersproject/constants/lib.esm/addresses.js
  var AddressZero = "0x0000000000000000000000000000000000000000";

  // node_modules/@ethersproject/constants/lib.esm/bignumbers.js
  var NegativeOne2 = /* @__PURE__ */ BigNumber.from(-1);
  var Zero2 = /* @__PURE__ */ BigNumber.from(0);
  var One = /* @__PURE__ */ BigNumber.from(1);
  var Two = /* @__PURE__ */ BigNumber.from(2);
  var WeiPerEther = /* @__PURE__ */ BigNumber.from("1000000000000000000");
  var MaxUint256 = /* @__PURE__ */ BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
  var MinInt256 = /* @__PURE__ */ BigNumber.from("-0x8000000000000000000000000000000000000000000000000000000000000000");
  var MaxInt256 = /* @__PURE__ */ BigNumber.from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

  // node_modules/@ethersproject/constants/lib.esm/hashes.js
  var HashZero = "0x0000000000000000000000000000000000000000000000000000000000000000";

  // node_modules/@ethersproject/constants/lib.esm/strings.js
  var EtherSymbol = "\u039E";

  // node_modules/@ethersproject/abi/lib.esm/coders/number.js
  var NumberCoder = class extends Coder {
    constructor(size3, signed3, localName) {
      const name2 = (signed3 ? "int" : "uint") + size3 * 8;
      super(name2, name2, localName, false);
      this.size = size3;
      this.signed = signed3;
    }
    defaultValue() {
      return 0;
    }
    encode(writer, value) {
      let v6 = BigNumber.from(value);
      let maxUintValue = MaxUint256.mask(writer.wordSize * 8);
      if (this.signed) {
        let bounds = maxUintValue.mask(this.size * 8 - 1);
        if (v6.gt(bounds) || v6.lt(bounds.add(One).mul(NegativeOne2))) {
          this._throwError("value out-of-bounds", value);
        }
      } else if (v6.lt(Zero2) || v6.gt(maxUintValue.mask(this.size * 8))) {
        this._throwError("value out-of-bounds", value);
      }
      v6 = v6.toTwos(this.size * 8).mask(this.size * 8);
      if (this.signed) {
        v6 = v6.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);
      }
      return writer.writeValue(v6);
    }
    decode(reader) {
      let value = reader.readValue().mask(this.size * 8);
      if (this.signed) {
        value = value.fromTwos(this.size * 8);
      }
      return reader.coerce(this.name, value);
    }
  };

  // node_modules/@ethersproject/strings/lib.esm/_version.js
  var version11 = "strings/5.7.0";

  // node_modules/@ethersproject/strings/lib.esm/utf8.js
  var logger10 = new Logger(version11);
  var UnicodeNormalizationForm;
  (function(UnicodeNormalizationForm2) {
    UnicodeNormalizationForm2["current"] = "";
    UnicodeNormalizationForm2["NFC"] = "NFC";
    UnicodeNormalizationForm2["NFD"] = "NFD";
    UnicodeNormalizationForm2["NFKC"] = "NFKC";
    UnicodeNormalizationForm2["NFKD"] = "NFKD";
  })(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));
  var Utf8ErrorReason;
  (function(Utf8ErrorReason2) {
    Utf8ErrorReason2["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
    Utf8ErrorReason2["BAD_PREFIX"] = "bad codepoint prefix";
    Utf8ErrorReason2["OVERRUN"] = "string overrun";
    Utf8ErrorReason2["MISSING_CONTINUE"] = "missing continuation byte";
    Utf8ErrorReason2["OUT_OF_RANGE"] = "out of UTF-8 range";
    Utf8ErrorReason2["UTF16_SURROGATE"] = "UTF-16 surrogate";
    Utf8ErrorReason2["OVERLONG"] = "overlong representation";
  })(Utf8ErrorReason || (Utf8ErrorReason = {}));
  function errorFunc(reason, offset, bytes3, output2, badCodepoint) {
    return logger10.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes3);
  }
  function ignoreFunc(reason, offset, bytes3, output2, badCodepoint) {
    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {
      let i7 = 0;
      for (let o9 = offset + 1; o9 < bytes3.length; o9++) {
        if (bytes3[o9] >> 6 !== 2) {
          break;
        }
        i7++;
      }
      return i7;
    }
    if (reason === Utf8ErrorReason.OVERRUN) {
      return bytes3.length - offset - 1;
    }
    return 0;
  }
  function replaceFunc(reason, offset, bytes3, output2, badCodepoint) {
    if (reason === Utf8ErrorReason.OVERLONG) {
      output2.push(badCodepoint);
      return 0;
    }
    output2.push(65533);
    return ignoreFunc(reason, offset, bytes3, output2, badCodepoint);
  }
  var Utf8ErrorFuncs = Object.freeze({
    error: errorFunc,
    ignore: ignoreFunc,
    replace: replaceFunc
  });
  function getUtf8CodePoints(bytes3, onError2) {
    if (onError2 == null) {
      onError2 = Utf8ErrorFuncs.error;
    }
    bytes3 = arrayify(bytes3);
    const result = [];
    let i7 = 0;
    while (i7 < bytes3.length) {
      const c9 = bytes3[i7++];
      if (c9 >> 7 === 0) {
        result.push(c9);
        continue;
      }
      let extraLength = null;
      let overlongMask = null;
      if ((c9 & 224) === 192) {
        extraLength = 1;
        overlongMask = 127;
      } else if ((c9 & 240) === 224) {
        extraLength = 2;
        overlongMask = 2047;
      } else if ((c9 & 248) === 240) {
        extraLength = 3;
        overlongMask = 65535;
      } else {
        if ((c9 & 192) === 128) {
          i7 += onError2(Utf8ErrorReason.UNEXPECTED_CONTINUE, i7 - 1, bytes3, result);
        } else {
          i7 += onError2(Utf8ErrorReason.BAD_PREFIX, i7 - 1, bytes3, result);
        }
        continue;
      }
      if (i7 - 1 + extraLength >= bytes3.length) {
        i7 += onError2(Utf8ErrorReason.OVERRUN, i7 - 1, bytes3, result);
        continue;
      }
      let res = c9 & (1 << 8 - extraLength - 1) - 1;
      for (let j7 = 0; j7 < extraLength; j7++) {
        let nextChar = bytes3[i7];
        if ((nextChar & 192) != 128) {
          i7 += onError2(Utf8ErrorReason.MISSING_CONTINUE, i7, bytes3, result);
          res = null;
          break;
        }
        ;
        res = res << 6 | nextChar & 63;
        i7++;
      }
      if (res === null) {
        continue;
      }
      if (res > 1114111) {
        i7 += onError2(Utf8ErrorReason.OUT_OF_RANGE, i7 - 1 - extraLength, bytes3, result, res);
        continue;
      }
      if (res >= 55296 && res <= 57343) {
        i7 += onError2(Utf8ErrorReason.UTF16_SURROGATE, i7 - 1 - extraLength, bytes3, result, res);
        continue;
      }
      if (res <= overlongMask) {
        i7 += onError2(Utf8ErrorReason.OVERLONG, i7 - 1 - extraLength, bytes3, result, res);
        continue;
      }
      result.push(res);
    }
    return result;
  }
  function toUtf8Bytes(str, form = UnicodeNormalizationForm.current) {
    if (form != UnicodeNormalizationForm.current) {
      logger10.checkNormalize();
      str = str.normalize(form);
    }
    let result = [];
    for (let i7 = 0; i7 < str.length; i7++) {
      const c9 = str.charCodeAt(i7);
      if (c9 < 128) {
        result.push(c9);
      } else if (c9 < 2048) {
        result.push(c9 >> 6 | 192);
        result.push(c9 & 63 | 128);
      } else if ((c9 & 64512) == 55296) {
        i7++;
        const c22 = str.charCodeAt(i7);
        if (i7 >= str.length || (c22 & 64512) !== 56320) {
          throw new Error("invalid utf-8 string");
        }
        const pair = 65536 + ((c9 & 1023) << 10) + (c22 & 1023);
        result.push(pair >> 18 | 240);
        result.push(pair >> 12 & 63 | 128);
        result.push(pair >> 6 & 63 | 128);
        result.push(pair & 63 | 128);
      } else {
        result.push(c9 >> 12 | 224);
        result.push(c9 >> 6 & 63 | 128);
        result.push(c9 & 63 | 128);
      }
    }
    return arrayify(result);
  }
  function escapeChar(value) {
    const hex = "0000" + value.toString(16);
    return "\\u" + hex.substring(hex.length - 4);
  }
  function _toEscapedUtf8String(bytes3, onError2) {
    return '"' + getUtf8CodePoints(bytes3, onError2).map((codePoint) => {
      if (codePoint < 256) {
        switch (codePoint) {
          case 8:
            return "\\b";
          case 9:
            return "\\t";
          case 10:
            return "\\n";
          case 13:
            return "\\r";
          case 34:
            return '\\"';
          case 92:
            return "\\\\";
        }
        if (codePoint >= 32 && codePoint < 127) {
          return String.fromCharCode(codePoint);
        }
      }
      if (codePoint <= 65535) {
        return escapeChar(codePoint);
      }
      codePoint -= 65536;
      return escapeChar((codePoint >> 10 & 1023) + 55296) + escapeChar((codePoint & 1023) + 56320);
    }).join("") + '"';
  }
  function _toUtf8String(codePoints) {
    return codePoints.map((codePoint) => {
      if (codePoint <= 65535) {
        return String.fromCharCode(codePoint);
      }
      codePoint -= 65536;
      return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
    }).join("");
  }
  function toUtf8String(bytes3, onError2) {
    return _toUtf8String(getUtf8CodePoints(bytes3, onError2));
  }
  function toUtf8CodePoints(str, form = UnicodeNormalizationForm.current) {
    return getUtf8CodePoints(toUtf8Bytes(str, form));
  }

  // node_modules/@ethersproject/strings/lib.esm/bytes32.js
  function formatBytes32String(text) {
    const bytes3 = toUtf8Bytes(text);
    if (bytes3.length > 31) {
      throw new Error("bytes32 string must be less than 32 bytes");
    }
    return hexlify(concat3([bytes3, HashZero]).slice(0, 32));
  }
  function parseBytes32String(bytes3) {
    const data2 = arrayify(bytes3);
    if (data2.length !== 32) {
      throw new Error("invalid bytes32 - not 32 bytes long");
    }
    if (data2[31] !== 0) {
      throw new Error("invalid bytes32 string - no null terminator");
    }
    let length2 = 31;
    while (data2[length2 - 1] === 0) {
      length2--;
    }
    return toUtf8String(data2.slice(0, length2));
  }

  // node_modules/@ethersproject/strings/lib.esm/idna.js
  function bytes2(data2) {
    if (data2.length % 4 !== 0) {
      throw new Error("bad data");
    }
    let result = [];
    for (let i7 = 0; i7 < data2.length; i7 += 4) {
      result.push(parseInt(data2.substring(i7, i7 + 4), 16));
    }
    return result;
  }
  function createTable(data2, func) {
    if (!func) {
      func = function(value) {
        return [parseInt(value, 16)];
      };
    }
    let lo3 = 0;
    let result = {};
    data2.split(",").forEach((pair) => {
      let comps = pair.split(":");
      lo3 += parseInt(comps[0], 16);
      result[lo3] = func(comps[1]);
    });
    return result;
  }
  function createRangeTable(data2) {
    let hi2 = 0;
    return data2.split(",").map((v6) => {
      let comps = v6.split("-");
      if (comps.length === 1) {
        comps[1] = "0";
      } else if (comps[1] === "") {
        comps[1] = "1";
      }
      let lo3 = hi2 + parseInt(comps[0], 16);
      hi2 = parseInt(comps[1], 16);
      return { l: lo3, h: hi2 };
    });
  }
  function matchMap(value, ranges) {
    let lo3 = 0;
    for (let i7 = 0; i7 < ranges.length; i7++) {
      let range = ranges[i7];
      lo3 += range.l;
      if (value >= lo3 && value <= lo3 + range.h && (value - lo3) % (range.d || 1) === 0) {
        if (range.e && range.e.indexOf(value - lo3) !== -1) {
          continue;
        }
        return range;
      }
    }
    return null;
  }
  var Table_A_1_ranges = createRangeTable("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d");
  var Table_B_1_flags = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map((v6) => parseInt(v6, 16));
  var Table_B_2_ranges = [
    { h: 25, s: 32, l: 65 },
    { h: 30, s: 32, e: [23], l: 127 },
    { h: 54, s: 1, e: [48], l: 64, d: 2 },
    { h: 14, s: 1, l: 57, d: 2 },
    { h: 44, s: 1, l: 17, d: 2 },
    { h: 10, s: 1, e: [2, 6, 8], l: 61, d: 2 },
    { h: 16, s: 1, l: 68, d: 2 },
    { h: 84, s: 1, e: [18, 24, 66], l: 19, d: 2 },
    { h: 26, s: 32, e: [17], l: 435 },
    { h: 22, s: 1, l: 71, d: 2 },
    { h: 15, s: 80, l: 40 },
    { h: 31, s: 32, l: 16 },
    { h: 32, s: 1, l: 80, d: 2 },
    { h: 52, s: 1, l: 42, d: 2 },
    { h: 12, s: 1, l: 55, d: 2 },
    { h: 40, s: 1, e: [38], l: 15, d: 2 },
    { h: 14, s: 1, l: 48, d: 2 },
    { h: 37, s: 48, l: 49 },
    { h: 148, s: 1, l: 6351, d: 2 },
    { h: 88, s: 1, l: 160, d: 2 },
    { h: 15, s: 16, l: 704 },
    { h: 25, s: 26, l: 854 },
    { h: 25, s: 32, l: 55915 },
    { h: 37, s: 40, l: 1247 },
    { h: 25, s: -119711, l: 53248 },
    { h: 25, s: -119763, l: 52 },
    { h: 25, s: -119815, l: 52 },
    { h: 25, s: -119867, e: [1, 4, 5, 7, 8, 11, 12, 17], l: 52 },
    { h: 25, s: -119919, l: 52 },
    { h: 24, s: -119971, e: [2, 7, 8, 17], l: 52 },
    { h: 24, s: -120023, e: [2, 7, 13, 15, 16, 17], l: 52 },
    { h: 25, s: -120075, l: 52 },
    { h: 25, s: -120127, l: 52 },
    { h: 25, s: -120179, l: 52 },
    { h: 25, s: -120231, l: 52 },
    { h: 25, s: -120283, l: 52 },
    { h: 25, s: -120335, l: 52 },
    { h: 24, s: -119543, e: [17], l: 56 },
    { h: 24, s: -119601, e: [17], l: 58 },
    { h: 24, s: -119659, e: [17], l: 58 },
    { h: 24, s: -119717, e: [17], l: 58 },
    { h: 24, s: -119775, e: [17], l: 58 }
  ];
  var Table_B_2_lut_abs = createTable("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3");
  var Table_B_2_lut_rel = createTable("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7");
  var Table_B_2_complex = createTable("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", bytes2);
  var Table_C_ranges = createRangeTable("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");
  function flatten2(values) {
    return values.reduce((accum, value) => {
      value.forEach((value2) => {
        accum.push(value2);
      });
      return accum;
    }, []);
  }
  function _nameprepTableA1(codepoint) {
    return !!matchMap(codepoint, Table_A_1_ranges);
  }
  function _nameprepTableB2(codepoint) {
    let range = matchMap(codepoint, Table_B_2_ranges);
    if (range) {
      return [codepoint + range.s];
    }
    let codes = Table_B_2_lut_abs[codepoint];
    if (codes) {
      return codes;
    }
    let shift = Table_B_2_lut_rel[codepoint];
    if (shift) {
      return [codepoint + shift[0]];
    }
    let complex = Table_B_2_complex[codepoint];
    if (complex) {
      return complex;
    }
    return null;
  }
  function _nameprepTableC(codepoint) {
    return !!matchMap(codepoint, Table_C_ranges);
  }
  function nameprep(value) {
    if (value.match(/^[a-z0-9-]*$/i) && value.length <= 59) {
      return value.toLowerCase();
    }
    let codes = toUtf8CodePoints(value);
    codes = flatten2(codes.map((code2) => {
      if (Table_B_1_flags.indexOf(code2) >= 0) {
        return [];
      }
      if (code2 >= 65024 && code2 <= 65039) {
        return [];
      }
      let codesTableB2 = _nameprepTableB2(code2);
      if (codesTableB2) {
        return codesTableB2;
      }
      return [code2];
    }));
    codes = toUtf8CodePoints(_toUtf8String(codes), UnicodeNormalizationForm.NFKC);
    codes.forEach((code2) => {
      if (_nameprepTableC(code2)) {
        throw new Error("STRINGPREP_CONTAINS_PROHIBITED");
      }
    });
    codes.forEach((code2) => {
      if (_nameprepTableA1(code2)) {
        throw new Error("STRINGPREP_CONTAINS_UNASSIGNED");
      }
    });
    let name2 = _toUtf8String(codes);
    if (name2.substring(0, 1) === "-" || name2.substring(2, 4) === "--" || name2.substring(name2.length - 1) === "-") {
      throw new Error("invalid hyphen");
    }
    return name2;
  }

  // node_modules/@ethersproject/abi/lib.esm/coders/string.js
  var StringCoder = class extends DynamicBytesCoder {
    constructor(localName) {
      super("string", localName);
    }
    defaultValue() {
      return "";
    }
    encode(writer, value) {
      return super.encode(writer, toUtf8Bytes(value));
    }
    decode(reader) {
      return toUtf8String(super.decode(reader));
    }
  };

  // node_modules/@ethersproject/abi/lib.esm/coders/tuple.js
  var TupleCoder = class extends Coder {
    constructor(coders, localName) {
      let dynamic = false;
      const types = [];
      coders.forEach((coder) => {
        if (coder.dynamic) {
          dynamic = true;
        }
        types.push(coder.type);
      });
      const type = "tuple(" + types.join(",") + ")";
      super("tuple", type, localName, dynamic);
      this.coders = coders;
    }
    defaultValue() {
      const values = [];
      this.coders.forEach((coder) => {
        values.push(coder.defaultValue());
      });
      const uniqueNames = this.coders.reduce((accum, coder) => {
        const name2 = coder.localName;
        if (name2) {
          if (!accum[name2]) {
            accum[name2] = 0;
          }
          accum[name2]++;
        }
        return accum;
      }, {});
      this.coders.forEach((coder, index2) => {
        let name2 = coder.localName;
        if (!name2 || uniqueNames[name2] !== 1) {
          return;
        }
        if (name2 === "length") {
          name2 = "_length";
        }
        if (values[name2] != null) {
          return;
        }
        values[name2] = values[index2];
      });
      return Object.freeze(values);
    }
    encode(writer, value) {
      return pack(writer, this.coders, value);
    }
    decode(reader) {
      return reader.coerce(this.name, unpack(reader, this.coders));
    }
  };

  // node_modules/@ethersproject/abi/lib.esm/abi-coder.js
  var logger11 = new Logger(version8);
  var paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
  var paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
  var AbiCoder = class {
    constructor(coerceFunc) {
      defineReadOnly(this, "coerceFunc", coerceFunc || null);
    }
    _getCoder(param) {
      switch (param.baseType) {
        case "address":
          return new AddressCoder(param.name);
        case "bool":
          return new BooleanCoder(param.name);
        case "string":
          return new StringCoder(param.name);
        case "bytes":
          return new BytesCoder(param.name);
        case "array":
          return new ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);
        case "tuple":
          return new TupleCoder((param.components || []).map((component) => {
            return this._getCoder(component);
          }), param.name);
        case "":
          return new NullCoder(param.name);
      }
      let match = param.type.match(paramTypeNumber);
      if (match) {
        let size3 = parseInt(match[2] || "256");
        if (size3 === 0 || size3 > 256 || size3 % 8 !== 0) {
          logger11.throwArgumentError("invalid " + match[1] + " bit length", "param", param);
        }
        return new NumberCoder(size3 / 8, match[1] === "int", param.name);
      }
      match = param.type.match(paramTypeBytes);
      if (match) {
        let size3 = parseInt(match[1]);
        if (size3 === 0 || size3 > 32) {
          logger11.throwArgumentError("invalid bytes length", "param", param);
        }
        return new FixedBytesCoder(size3, param.name);
      }
      return logger11.throwArgumentError("invalid type", "type", param.type);
    }
    _getWordSize() {
      return 32;
    }
    _getReader(data2, allowLoose) {
      return new Reader(data2, this._getWordSize(), this.coerceFunc, allowLoose);
    }
    _getWriter() {
      return new Writer(this._getWordSize());
    }
    getDefaultValue(types) {
      const coders = types.map((type) => this._getCoder(ParamType.from(type)));
      const coder = new TupleCoder(coders, "_");
      return coder.defaultValue();
    }
    encode(types, values) {
      if (types.length !== values.length) {
        logger11.throwError("types/values length mismatch", Logger.errors.INVALID_ARGUMENT, {
          count: { types: types.length, values: values.length },
          value: { types, values }
        });
      }
      const coders = types.map((type) => this._getCoder(ParamType.from(type)));
      const coder = new TupleCoder(coders, "_");
      const writer = this._getWriter();
      coder.encode(writer, values);
      return writer.data;
    }
    decode(types, data2, loose) {
      const coders = types.map((type) => this._getCoder(ParamType.from(type)));
      const coder = new TupleCoder(coders, "_");
      return coder.decode(this._getReader(arrayify(data2), loose));
    }
  };
  var defaultAbiCoder = new AbiCoder();

  // node_modules/@ethersproject/hash/lib.esm/id.js
  function id2(text) {
    return keccak2562(toUtf8Bytes(text));
  }

  // node_modules/@ethersproject/hash/lib.esm/_version.js
  var version12 = "hash/5.7.0";

  // node_modules/@ethersproject/base64/lib.esm/index.js
  var lib_exports3 = {};
  __export(lib_exports3, {
    decode: () => decode7,
    encode: () => encode8
  });

  // node_modules/@ethersproject/base64/lib.esm/base64.js
  function decode7(textData) {
    textData = atob(textData);
    const data2 = [];
    for (let i7 = 0; i7 < textData.length; i7++) {
      data2.push(textData.charCodeAt(i7));
    }
    return arrayify(data2);
  }
  function encode8(data2) {
    data2 = arrayify(data2);
    let textData = "";
    for (let i7 = 0; i7 < data2.length; i7++) {
      textData += String.fromCharCode(data2[i7]);
    }
    return btoa(textData);
  }

  // node_modules/@ethersproject/hash/lib.esm/ens-normalize/decoder.js
  function flat(array, depth) {
    if (depth == null) {
      depth = 1;
    }
    const result = [];
    const forEach2 = result.forEach;
    const flatDeep = function(arr, depth2) {
      forEach2.call(arr, function(val) {
        if (depth2 > 0 && Array.isArray(val)) {
          flatDeep(val, depth2 - 1);
        } else {
          result.push(val);
        }
      });
    };
    flatDeep(array, depth);
    return result;
  }
  function fromEntries(array) {
    const result = {};
    for (let i7 = 0; i7 < array.length; i7++) {
      const value = array[i7];
      result[value[0]] = value[1];
    }
    return result;
  }
  function decode_arithmetic2(bytes3) {
    let pos = 0;
    function u16() {
      return bytes3[pos++] << 8 | bytes3[pos++];
    }
    let symbol_count = u16();
    let total = 1;
    let acc = [0, 1];
    for (let i7 = 1; i7 < symbol_count; i7++) {
      acc.push(total += u16());
    }
    let skip = u16();
    let pos_payload = pos;
    pos += skip;
    let read_width = 0;
    let read_buffer = 0;
    function read_bit() {
      if (read_width == 0) {
        read_buffer = read_buffer << 8 | bytes3[pos++];
        read_width = 8;
      }
      return read_buffer >> --read_width & 1;
    }
    const N17 = 31;
    const FULL = Math.pow(2, N17);
    const HALF = FULL >>> 1;
    const QRTR = HALF >> 1;
    const MASK = FULL - 1;
    let register = 0;
    for (let i7 = 0; i7 < N17; i7++)
      register = register << 1 | read_bit();
    let symbols = [];
    let low = 0;
    let range = FULL;
    while (true) {
      let value = Math.floor(((register - low + 1) * total - 1) / range);
      let start = 0;
      let end = symbol_count;
      while (end - start > 1) {
        let mid = start + end >>> 1;
        if (value < acc[mid]) {
          end = mid;
        } else {
          start = mid;
        }
      }
      if (start == 0)
        break;
      symbols.push(start);
      let a6 = low + Math.floor(range * acc[start] / total);
      let b7 = low + Math.floor(range * acc[start + 1] / total) - 1;
      while (((a6 ^ b7) & HALF) == 0) {
        register = register << 1 & MASK | read_bit();
        a6 = a6 << 1 & MASK;
        b7 = b7 << 1 & MASK | 1;
      }
      while (a6 & ~b7 & QRTR) {
        register = register & HALF | register << 1 & MASK >>> 1 | read_bit();
        a6 = a6 << 1 ^ HALF;
        b7 = (b7 ^ HALF) << 1 | HALF | 1;
      }
      low = a6;
      range = 1 + b7 - a6;
    }
    let offset = symbol_count - 4;
    return symbols.map((x4) => {
      switch (x4 - offset) {
        case 3:
          return offset + 65792 + (bytes3[pos_payload++] << 16 | bytes3[pos_payload++] << 8 | bytes3[pos_payload++]);
        case 2:
          return offset + 256 + (bytes3[pos_payload++] << 8 | bytes3[pos_payload++]);
        case 1:
          return offset + bytes3[pos_payload++];
        default:
          return x4 - 1;
      }
    });
  }
  function read_payload2(v6) {
    let pos = 0;
    return () => v6[pos++];
  }
  function read_compressed_payload2(bytes3) {
    return read_payload2(decode_arithmetic2(bytes3));
  }
  function signed2(i7) {
    return i7 & 1 ? ~i7 >> 1 : i7 >> 1;
  }
  function read_counts(n9, next) {
    let v6 = Array(n9);
    for (let i7 = 0; i7 < n9; i7++)
      v6[i7] = 1 + next();
    return v6;
  }
  function read_ascending(n9, next) {
    let v6 = Array(n9);
    for (let i7 = 0, x4 = -1; i7 < n9; i7++)
      v6[i7] = x4 += 1 + next();
    return v6;
  }
  function read_deltas2(n9, next) {
    let v6 = Array(n9);
    for (let i7 = 0, x4 = 0; i7 < n9; i7++)
      v6[i7] = x4 += signed2(next());
    return v6;
  }
  function read_member_array(next, lookup) {
    let v6 = read_ascending(next(), next);
    let n9 = next();
    let vX = read_ascending(n9, next);
    let vN = read_counts(n9, next);
    for (let i7 = 0; i7 < n9; i7++) {
      for (let j7 = 0; j7 < vN[i7]; j7++) {
        v6.push(vX[i7] + j7);
      }
    }
    return lookup ? v6.map((x4) => lookup[x4]) : v6;
  }
  function read_mapped_map(next) {
    let ret = [];
    while (true) {
      let w8 = next();
      if (w8 == 0)
        break;
      ret.push(read_linear_table2(w8, next));
    }
    while (true) {
      let w8 = next() - 1;
      if (w8 < 0)
        break;
      ret.push(read_replacement_table2(w8, next));
    }
    return fromEntries(flat(ret));
  }
  function read_zero_terminated_array(next) {
    let v6 = [];
    while (true) {
      let i7 = next();
      if (i7 == 0)
        break;
      v6.push(i7);
    }
    return v6;
  }
  function read_transposed2(n9, w8, next) {
    let m6 = Array(n9).fill(void 0).map(() => []);
    for (let i7 = 0; i7 < w8; i7++) {
      read_deltas2(n9, next).forEach((x4, j7) => m6[j7].push(x4));
    }
    return m6;
  }
  function read_linear_table2(w8, next) {
    let dx = 1 + next();
    let dy = next();
    let vN = read_zero_terminated_array(next);
    let m6 = read_transposed2(vN.length, 1 + w8, next);
    return flat(m6.map((v6, i7) => {
      const x4 = v6[0], ys2 = v6.slice(1);
      return Array(vN[i7]).fill(void 0).map((_8, j7) => {
        let j_dy = j7 * dy;
        return [x4 + j7 * dx, ys2.map((y11) => y11 + j_dy)];
      });
    }));
  }
  function read_replacement_table2(w8, next) {
    let n9 = 1 + next();
    let m6 = read_transposed2(n9, 1 + w8, next);
    return m6.map((v6) => [v6[0], v6.slice(1)]);
  }
  function read_emoji_trie2(next) {
    let sorted = read_member_array(next).sort((a6, b7) => a6 - b7);
    return read2();
    function read2() {
      let branches = [];
      while (true) {
        let keys2 = read_member_array(next, sorted);
        if (keys2.length == 0)
          break;
        branches.push({ set: new Set(keys2), node: read2() });
      }
      branches.sort((a6, b7) => b7.set.size - a6.set.size);
      let temp = next();
      let valid = temp % 3;
      temp = temp / 3 | 0;
      let fe0f = !!(temp & 1);
      temp >>= 1;
      let save = temp == 1;
      let check = temp == 2;
      return { branches, valid, fe0f, save, check };
    }
  }

  // node_modules/@ethersproject/hash/lib.esm/ens-normalize/include.js
  function getData() {
    return read_compressed_payload2(decode7("AEQF2AO2DEsA2wIrAGsBRABxAN8AZwCcAEwAqgA0AGwAUgByADcATAAVAFYAIQAyACEAKAAYAFgAGwAjABQAMAAmADIAFAAfABQAKwATACoADgAbAA8AHQAYABoAGQAxADgALAAoADwAEwA9ABMAGgARAA4ADwAWABMAFgAIAA8AHgQXBYMA5BHJAS8JtAYoAe4AExozi0UAH21tAaMnBT8CrnIyhrMDhRgDygIBUAEHcoFHUPe8AXBjAewCjgDQR8IICIcEcQLwATXCDgzvHwBmBoHNAqsBdBcUAykgDhAMShskMgo8AY8jqAQfAUAfHw8BDw87MioGlCIPBwZCa4ELatMAAMspJVgsDl8AIhckSg8XAHdvTwBcIQEiDT4OPhUqbyECAEoAS34Aej8Ybx83JgT/Xw8gHxZ/7w8RICxPHA9vBw+Pfw8PHwAPFv+fAsAvCc8vEr8ivwD/EQ8Bol8OEBa/A78hrwAPCU8vESNvvwWfHwNfAVoDHr+ZAAED34YaAdJPAK7PLwSEgDLHAGo1Pz8Pvx9fUwMrpb8O/58VTzAPIBoXIyQJNF8hpwIVAT8YGAUADDNBaX3RAMomJCg9EhUeA29MABsZBTMNJipjOhc19gcIDR8bBwQHEggCWi6DIgLuAQYA+BAFCha3A5XiAEsqM7UFFgFLhAMjFTMYE1Klnw74nRVBG/ASCm0BYRN/BrsU3VoWy+S0vV8LQx+vN8gF2AC2AK5EAWwApgYDKmAAroQ0NDQ0AT+OCg7wAAIHRAbpNgVcBV0APTA5BfbPFgMLzcYL/QqqA82eBALKCjQCjqYCht0/k2+OAsXQAoP3ASTKDgDw6ACKAUYCMpIKJpRaAE4A5womABzZvs0REEKiACIQAd5QdAECAj4Ywg/wGqY2AVgAYADYvAoCGAEubA0gvAY2ALAAbpbvqpyEAGAEpgQAJgAG7gAgAEACmghUFwCqAMpAINQIwC4DthRAAPcycKgApoIdABwBfCisABoATwBqASIAvhnSBP8aH/ECeAKXAq40NjgDBTwFYQU6AXs3oABgAD4XNgmcCY1eCl5tIFZeUqGgyoNHABgAEQAaABNwWQAmABMATPMa3T34ADldyprmM1M2XociUQgLzvwAXT3xABgAEQAaABNwIGFAnADD8AAgAD4BBJWzaCcIAIEBFMAWwKoAAdq9BWAF5wLQpALEtQAKUSGkahR4GnJM+gsAwCgeFAiUAECQ0BQuL8AAIAAAADKeIheclvFqQAAETr4iAMxIARMgAMIoHhQIAn0E0pDQFC4HhznoAAAAIAI2C0/4lvFqQAAETgBJJwYCAy4ABgYAFAA8MBKYEH4eRhTkAjYeFcgACAYAeABsOqyQ5gRwDayqugEgaIIAtgoACgDmEABmBAWGme5OBJJA2m4cDeoAmITWAXwrMgOgAGwBCh6CBXYF1Tzg1wKAAFdiuABRAFwAXQBsAG8AdgBrAHYAbwCEAHEwfxQBVE5TEQADVFhTBwBDANILAqcCzgLTApQCrQL6vAAMAL8APLhNBKkE6glGKTAU4Dr4N2EYEwBCkABKk8rHAbYBmwIoAiU4Ajf/Aq4CowCAANIChzgaNBsCsTgeODcFXrgClQKdAqQBiQGYAqsCsjTsNHsfNPA0ixsAWTWiOAMFPDQSNCk2BDZHNow2TTZUNhk28Jk9VzI3QkEoAoICoQKwAqcAQAAxBV4FXbS9BW47YkIXP1ciUqs05DS/FwABUwJW11e6nHuYZmSh/RAYA8oMKvZ8KASoUAJYWAJ6ILAsAZSoqjpgA0ocBIhmDgDWAAawRDQoAAcuAj5iAHABZiR2AIgiHgCaAU68ACxuHAG0ygM8MiZIAlgBdF4GagJqAPZOHAMuBgoATkYAsABiAHgAMLoGDPj0HpKEBAAOJgAuALggTAHWAeAMEDbd20Uege0ADwAWADkAQgA9OHd+2MUQZBBhBgNNDkxxPxUQArEPqwvqERoM1irQ090ANK4H8ANYB/ADWANYB/AH8ANYB/ADWANYA1gDWBwP8B/YxRBkD00EcgWTBZAE2wiIJk4RhgctCNdUEnQjHEwDSgEBIypJITuYMxAlR0wRTQgIATZHbKx9PQNMMbBU+pCnA9AyVDlxBgMedhKlAC8PeCE1uk6DekxxpQpQT7NX9wBFBgASqwAS5gBJDSgAUCwGPQBI4zTYABNGAE2bAE3KAExdGABKaAbgAFBXAFCOAFBJABI2SWdObALDOq0//QomCZhvwHdTBkIQHCemEPgMNAG2ATwN7kvZBPIGPATKH34ZGg/OlZ0Ipi3eDO4m5C6igFsj9iqEBe5L9TzeC05RaQ9aC2YJ5DpkgU8DIgEOIowK3g06CG4Q9ArKbA3mEUYHOgPWSZsApgcCCxIdNhW2JhFirQsKOXgG/Br3C5AmsBMqev0F1BoiBk4BKhsAANAu6IWxWjJcHU9gBgQLJiPIFKlQIQ0mQLh4SRocBxYlqgKSQ3FKiFE3HpQh9zw+DWcuFFF9B/Y8BhlQC4I8n0asRQ8R0z6OPUkiSkwtBDaALDAnjAnQD4YMunxzAVoJIgmyDHITMhEYN8YIOgcaLpclJxYIIkaWYJsE+KAD9BPSAwwFQAlCBxQDthwuEy8VKgUOgSXYAvQ21i60ApBWgQEYBcwPJh/gEFFH4Q7qCJwCZgOEJewALhUiABginAhEZABgj9lTBi7MCMhqbSN1A2gU6GIRdAeSDlgHqBw0FcAc4nDJXgyGCSiksAlcAXYJmgFgBOQICjVcjKEgQmdUi1kYnCBiQUBd/QIyDGYVoES+h3kCjA9sEhwBNgF0BzoNAgJ4Ee4RbBCWCOyGBTW2M/k6JgRQIYQgEgooA1BszwsoJvoM+WoBpBJjAw00PnfvZ6xgtyUX/gcaMsZBYSHyC5NPzgydGsIYQ1QvGeUHwAP0GvQn60FYBgADpAQUOk4z7wS+C2oIjAlAAEoOpBgH2BhrCnKM0QEyjAG4mgNYkoQCcJAGOAcMAGgMiAV65gAeAqgIpAAGANADWAA6Aq4HngAaAIZCAT4DKDABIuYCkAOUCDLMAZYwAfQqBBzEDBYA+DhuSwLDsgKAa2ajBd5ZAo8CSjYBTiYEBk9IUgOwcuIA3ABMBhTgSAEWrEvMG+REAeBwLADIAPwABjYHBkIBzgH0bgC4AWALMgmjtLYBTuoqAIQAFmwB2AKKAN4ANgCA8gFUAE4FWvoF1AJQSgESMhksWGIBvAMgATQBDgB6BsyOpsoIIARuB9QCEBwV4gLvLwe2AgMi4BPOQsYCvd9WADIXUu5eZwqoCqdeaAC0YTQHMnM9UQAPH6k+yAdy/BZIiQImSwBQ5gBQQzSaNTFWSTYBpwGqKQK38AFtqwBI/wK37gK3rQK3sAK6280C0gK33AK3zxAAUEIAUD9SklKDArekArw5AEQAzAHCO147WTteO1k7XjtZO147WTteO1kDmChYI03AVU0oJqkKbV9GYewMpw3VRMk6ShPcYFJgMxPJLbgUwhXPJVcZPhq9JwYl5VUKDwUt1GYxCC00dhe9AEApaYNCY4ceMQpMHOhTklT5LRwAskujM7ANrRsWREEFSHXuYisWDwojAmSCAmJDXE6wXDchAqH4AmiZAmYKAp+FOBwMAmY8AmYnBG8EgAN/FAN+kzkHOXgYOYM6JCQCbB4CMjc4CwJtyAJtr/CLADRoRiwBaADfAOIASwYHmQyOAP8MwwAOtgJ3MAJ2o0ACeUxEAni7Hl3cRa9G9AJ8QAJ6yQJ9CgJ88UgBSH5kJQAsFklZSlwWGErNAtECAtDNSygDiFADh+dExpEzAvKiXQQDA69Lz0wuJgTQTU1NsAKLQAKK2cIcCB5EaAa4Ao44Ao5dQZiCAo7aAo5deVG1UzYLUtVUhgKT/AKTDQDqAB1VH1WwVdEHLBwplocy4nhnRTw6ApegAu+zWCKpAFomApaQApZ9nQCqWa1aCoJOADwClrYClk9cRVzSApnMApllXMtdCBoCnJw5wzqeApwXAp+cAp65iwAeEDIrEAKd8gKekwC2PmE1YfACntQCoG8BqgKeoCACnk+mY8lkKCYsAiewAiZ/AqD8AqBN2AKmMAKlzwKoAAB+AqfzaH1osgAESmodatICrOQCrK8CrWgCrQMCVx4CVd0CseLYAx9PbJgCsr4OArLpGGzhbWRtSWADJc4Ctl08QG6RAylGArhfArlIFgK5K3hwN3DiAr0aAy2zAzISAr6JcgMDM3ICvhtzI3NQAsPMAsMFc4N0TDZGdOEDPKgDPJsDPcACxX0CxkgCxhGKAshqUgLIRQLJUALJLwJkngLd03h6YniveSZL0QMYpGcDAmH1GfSVJXsMXpNevBICz2wCz20wTFTT9BSgAMeuAs90ASrrA04TfkwGAtwoAtuLAtJQA1JdA1NgAQIDVY2AikABzBfuYUZ2AILPg44C2sgC2d+EEYRKpz0DhqYAMANkD4ZyWvoAVgLfZgLeuXR4AuIw7RUB8zEoAfScAfLTiALr9ALpcXoAAur6AurlAPpIAboC7ooC652Wq5cEAu5AA4XhmHpw4XGiAvMEAGoDjheZlAL3FAORbwOSiAL3mQL52gL4Z5odmqy8OJsfA52EAv77ARwAOp8dn7QDBY4DpmsDptoA0sYDBmuhiaIGCgMMSgFgASACtgNGAJwEgLpoBgC8BGzAEowcggCEDC6kdjoAJAM0C5IKRoABZCgiAIzw3AYBLACkfng9ogigkgNmWAN6AEQCvrkEVqTGAwCsBRbAA+4iQkMCHR072jI2PTbUNsk2RjY5NvA23TZKNiU3EDcZN5I+RTxDRTBCJkK5VBYKFhZfwQCWygU3AJBRHpu+OytgNxa61A40GMsYjsn7BVwFXQVcBV0FaAVdBVwFXQVcBV0FXAVdBVwFXUsaCNyKAK4AAQUHBwKU7oICoW1e7jAEzgPxA+YDwgCkBFDAwADABKzAAOxFLhitA1UFTDeyPkM+bj51QkRCuwTQWWQ8X+0AWBYzsACNA8xwzAGm7EZ/QisoCTAbLDs6fnLfb8H2GccsbgFw13M1HAVkBW/Jxsm9CNRO8E8FDD0FBQw9FkcClOYCoMFegpDfADgcMiA2AJQACB8AsigKAIzIEAJKeBIApY5yPZQIAKQiHb4fvj5BKSRPQrZCOz0oXyxgOywfKAnGbgMClQaCAkILXgdeCD9IIGUgQj5fPoY+dT52Ao5CM0dAX9BTVG9SDzFwWTQAbxBzJF/lOEIQQglCCkKJIAls5AcClQICoKPMODEFxhi6KSAbiyfIRrMjtCgdWCAkPlFBIitCsEJRzAbMAV/OEyQzDg0OAQQEJ36i328/Mk9AybDJsQlq3tDRApUKAkFzXf1d/j9uALYP6hCoFgCTGD8kPsFKQiobrm0+zj0KSD8kPnVCRBwMDyJRTHFgMTJa5rwXQiQ2YfI/JD7BMEJEHGINTw4TOFlIRzwJO0icMQpyPyQ+wzJCRBv6DVgnKB01NgUKj2bwYzMqCoBkznBgEF+zYDIocwRIX+NgHj4HICNfh2C4CwdwFWpTG/lgUhYGAwRfv2Ts8mAaXzVgml/XYIJfuWC4HI1gUF9pYJZgMR6ilQHMAOwLAlDRefC0in4AXAEJA6PjCwc0IamOANMMCAECRQDFNRTZBgd+CwQlRA+r6+gLBDEFBnwUBXgKATIArwAGRAAHA3cDdAN2A3kDdwN9A3oDdQN7A30DfAN4A3oDfQAYEAAlAtYASwMAUAFsAHcKAHcAmgB3AHUAdQB2AHVu8UgAygDAAHcAdQB1AHYAdQALCgB3AAsAmgB3AAsCOwB3AAtu8UgAygDAAHgKAJoAdwB3AHUAdQB2AHUAeAB1AHUAdgB1bvFIAMoAwAALCgCaAHcACwB3AAsCOwB3AAtu8UgAygDAAH4ACwGgALcBpwC6AahdAu0COwLtbvFIAMoAwAALCgCaAu0ACwLtAAsCOwLtAAtu8UgAygDAA24ACwNvAAu0VsQAAzsAABCkjUIpAAsAUIusOggWcgMeBxVsGwL67U/2HlzmWOEeOgALASvuAAseAfpKUpnpGgYJDCIZM6YyARUE9ThqAD5iXQgnAJYJPnOzw0ZAEZxEKsIAkA4DhAHnTAIDxxUDK0lxCQlPYgIvIQVYJQBVqE1GakUAKGYiDToSBA1EtAYAXQJYAIF8GgMHRyAAIAjOe9YncekRAA0KACUrjwE7Ayc6AAYWAqaiKG4McEcqANoN3+Mg9TwCBhIkuCny+JwUQ29L008JluRxu3K+oAdqiHOqFH0AG5SUIfUJ5SxCGfxdipRzqTmT4V5Zb+r1Uo4Vm+NqSSEl2mNvR2JhIa8SpYO6ntdwFXHCWTCK8f2+Hxo7uiG3drDycAuKIMP5bhi06ACnqArH1rz4Rqg//lm6SgJGEVbF9xJHISaR6HxqxSnkw6shDnelHKNEfGUXSJRJ1GcsmtJw25xrZMDK9gXSm1/YMkdX4/6NKYOdtk/NQ3/NnDASjTc3fPjIjW/5sVfVObX2oTDWkr1dF9f3kxBsD3/3aQO8hPfRz+e0uEiJqt1161griu7gz8hDDwtpy+F+BWtefnKHZPAxcZoWbnznhJpy0e842j36bcNzGnIEusgGX0a8ZxsnjcSsPDZ09yZ36fCQbriHeQ72JRMILNl6ePPf2HWoVwgWAm1fb3V2sAY0+B6rAXqSwPBgseVmoqsBTSrm91+XasMYYySI8eeRxH3ZvHkMz3BQ5aJ3iUVbYPNM3/7emRtjlsMgv/9VyTsyt/mK+8fgWeT6SoFaclXqn42dAIsvAarF5vNNWHzKSkKQ/8Hfk5ZWK7r9yliOsooyBjRhfkHP4Q2DkWXQi6FG/9r/IwbmkV5T7JSopHKn1pJwm9tb5Ot0oyN1Z2mPpKXHTxx2nlK08fKk1hEYA8WgVVWL5lgx0iTv+KdojJeU23ZDjmiubXOxVXJKKi2Wjuh2HLZOFLiSC7Tls5SMh4f+Pj6xUSrNjFqLGehRNB8lC0QSLNmkJJx/wSG3MnjE9T1CkPwJI0wH2lfzwETIiVqUxg0dfu5q39Gt+hwdcxkhhNvQ4TyrBceof3Mhs/IxFci1HmHr4FMZgXEEczPiGCx0HRwzAqDq2j9AVm1kwN0mRVLWLylgtoPNapF5cY4Y1wJh/e0BBwZj44YgZrDNqvD/9Hv7GFYdUQeDJuQ3EWI4HaKqavU1XjC/n41kT4L79kqGq0kLhdTZvgP3TA3fS0ozVz+5piZsoOtIvBUFoMKbNcmBL6YxxaUAusHB38XrS8dQMnQwJfUUkpRoGr5AUeWicvBTzyK9g77+yCkf5PAysL7r/JjcZgrbvRpMW9iyaxZvKO6ceZN2EwIxKwVFPuvFuiEPGCoagbMo+SpydLrXqBzNCDGFCrO/rkcwa2xhokQZ5CdZ0AsU3JfSqJ6n5I14YA+P/uAgfhPU84Tlw7cEFfp7AEE8ey4sP12PTt4Cods1GRgDOB5xvyiR5m+Bx8O5nBCNctU8BevfV5A08x6RHd5jcwPTMDSZJOedIZ1cGQ704lxbAzqZOP05ZxaOghzSdvFBHYqomATARyAADK4elP8Ly3IrUZKfWh23Xy20uBUmLS4Pfagu9+oyVa2iPgqRP3F2CTUsvJ7+RYnN8fFZbU/HVvxvcFFDKkiTqV5UBZ3Gz54JAKByi9hkKMZJvuGgcSYXFmw08UyoQyVdfTD1/dMkCHXcTGAKeROgArsvmRrQTLUOXioOHGK2QkjHuoYFgXciZoTJd6Fs5q1QX1G+p/e26hYsEf7QZD1nnIyl/SFkNtYYmmBhpBrxl9WbY0YpHWRuw2Ll/tj9mD8P4snVzJl4F9J+1arVeTb9E5r2ILH04qStjxQNwn3m4YNqxmaNbLAqW2TN6LidwuJRqS+NXbtqxoeDXpxeGWmxzSkWxjkyCkX4NQRme6q5SAcC+M7+9ETfA/EwrzQajKakCwYyeunP6ZFlxU2oMEn1Pz31zeStW74G406ZJFCl1wAXIoUKkWotYEpOuXB1uVNxJ63dpJEqfxBeptwIHNrPz8BllZoIcBoXwgfJ+8VAUnVPvRvexnw0Ma/WiGYuJO5y8QTvEYBigFmhUxY5RqzE8OcywN/8m4UYrlaniJO75XQ6KSo9+tWHlu+hMi0UVdiKQp7NelnoZUzNaIyBPVeOwK6GNp+FfHuPOoyhaWuNvTYFkvxscMQWDh+zeFCFkgwbXftiV23ywJ4+uwRqmg9k3KzwIQpzppt8DBBOMbrqwQM5Gb05sEwdKzMiAqOloaA/lr0KA+1pr0/+HiWoiIjHA/wir2nIuS3PeU/ji3O6ZwoxcR1SZ9FhtLC5S0FIzFhbBWcGVP/KpxOPSiUoAdWUpqKH++6Scz507iCcxYI6rdMBICPJZea7OcmeFw5mObJSiqpjg2UoWNIs+cFhyDSt6geV5qgi3FunmwwDoGSMgerFOZGX1m0dMCYo5XOruxO063dwENK9DbnVM9wYFREzh4vyU1WYYJ/LRRp6oxgjqP/X5a8/4Af6p6NWkQferzBmXme0zY/4nwMJm/wd1tIqSwGz+E3xPEAOoZlJit3XddD7/BT1pllzOx+8bmQtANQ/S6fZexc6qi3W+Q2xcmXTUhuS5mpHQRvcxZUN0S5+PL9lXWUAaRZhEH8hTdAcuNMMCuVNKTEGtSUKNi3O6KhSaTzck8csZ2vWRZ+d7mW8c4IKwXIYd25S/zIftPkwPzufjEvOHWVD1m+FjpDVUTV0DGDuHj6QnaEwLu/dEgdLQOg9E1Sro9XHJ8ykLAwtPu+pxqKDuFexqON1sKQm7rwbE1E68UCfA/erovrTCG+DBSNg0l4goDQvZN6uNlbyLpcZAwj2UclycvLpIZMgv4yRlpb3YuMftozorbcGVHt/VeDV3+Fdf1TP0iuaCsPi2G4XeGhsyF1ubVDxkoJhmniQ0/jSg/eYML9KLfnCFgISWkp91eauR3IQvED0nAPXK+6hPCYs+n3+hCZbiskmVMG2da+0EsZPonUeIY8EbfusQXjsK/eFDaosbPjEfQS0RKG7yj5GG69M7MeO1HmiUYocgygJHL6M1qzUDDwUSmr99V7Sdr2F3JjQAJY+F0yH33Iv3+C9M38eML7gTgmNu/r2bUMiPvpYbZ6v1/IaESirBHNa7mPKn4dEmYg7v/+HQgPN1G79jBQ1+soydfDC2r+h2Bl/KIc5KjMK7OH6nb1jLsNf0EHVe2KBiE51ox636uyG6Lho0t3J34L5QY/ilE3mikaF4HKXG1mG1rCevT1Vv6GavltxoQe/bMrpZvRggnBxSEPEeEzkEdOxTnPXHVjUYdw8JYvjB/o7Eegc3Ma+NUxLLnsK0kJlinPmUHzHGtrk5+CAbVzFOBqpyy3QVUnzTDfC/0XD94/okH+OB+i7g9lolhWIjSnfIb+Eq43ZXOWmwvjyV/qqD+t0e+7mTEM74qP/Ozt8nmC7mRpyu63OB4KnUzFc074SqoyPUAgM+/TJGFo6T44EHnQU4X4z6qannVqgw/U7zCpwcmXV1AubIrvOmkKHazJAR55ePjp5tLBsN8vAqs3NAHdcEHOR2xQ0lsNAFzSUuxFQCFYvXLZJdOj9p4fNq6p0HBGUik2YzaI4xySy91KzhQ0+q1hjxvImRwPRf76tChlRkhRCi74NXZ9qUNeIwP+s5p+3m5nwPdNOHgSLD79n7O9m1n1uDHiMntq4nkYwV5OZ1ENbXxFd4PgrlvavZsyUO4MqYlqqn1O8W/I1dEZq5dXhrbETLaZIbC2Kj/Aa/QM+fqUOHdf0tXAQ1huZ3cmWECWSXy/43j35+Mvq9xws7JKseriZ1pEWKc8qlzNrGPUGcVgOa9cPJYIJsGnJTAUsEcDOEVULO5x0rXBijc1lgXEzQQKhROf8zIV82w8eswc78YX11KYLWQRcgHNJElBxfXr72lS2RBSl07qTKorO2uUDZr3sFhYsvnhLZn0A94KRzJ/7DEGIAhW5ZWFpL8gEwu1aLA9MuWZzNwl8Oze9Y+bX+v9gywRVnoB5I/8kXTXU3141yRLYrIOOz6SOnyHNy4SieqzkBXharjfjqq1q6tklaEbA8Qfm2DaIPs7OTq/nvJBjKfO2H9bH2cCMh1+5gspfycu8f/cuuRmtDjyqZ7uCIMyjdV3a+p3fqmXsRx4C8lujezIFHnQiVTXLXuI1XrwN3+siYYj2HHTvESUx8DlOTXpak9qFRK+L3mgJ1WsD7F4cu1aJoFoYQnu+wGDMOjJM3kiBQWHCcvhJ/HRdxodOQp45YZaOTA22Nb4XKCVxqkbwMYFhzYQYIAnCW8FW14uf98jhUG2zrKhQQ0q0CEq0t5nXyvUyvR8DvD69LU+g3i+HFWQMQ8PqZuHD+sNKAV0+M6EJC0szq7rEr7B5bQ8BcNHzvDMc9eqB5ZCQdTf80Obn4uzjwpYU7SISdtV0QGa9D3Wrh2BDQtpBKxaNFV+/Cy2P/Sv+8s7Ud0Fd74X4+o/TNztWgETUapy+majNQ68Lq3ee0ZO48VEbTZYiH1Co4OlfWef82RWeyUXo7woM03PyapGfikTnQinoNq5z5veLpeMV3HCAMTaZmA1oGLAn7XS3XYsz+XK7VMQsc4XKrmDXOLU/pSXVNUq8dIqTba///3x6LiLS6xs1xuCAYSfcQ3+rQgmu7uvf3THKt5Ooo97TqcbRqxx7EASizaQCBQllG/rYxVapMLgtLbZS64w1MDBMXX+PQpBKNwqUKOf2DDRDUXQf9EhOS0Qj4nTmlA8dzSLz/G1d+Ud8MTy/6ghhdiLpeerGY/UlDOfiuqFsMUU5/UYlP+BAmgRLuNpvrUaLlVkrqDievNVEAwF+4CoM1MZTmjxjJMsKJq+u8Zd7tNCUFy6LiyYXRJQ4VyvEQFFaCGKsxIwQkk7EzZ6LTJq2hUuPhvAW+gQnSG6J+MszC+7QCRHcnqDdyNRJ6T9xyS87A6MDutbzKGvGktpbXqtzWtXb9HsfK2cBMomjN9a4y+TaJLnXxAeX/HWzmf4cR4vALt/P4w4qgKY04ml4ZdLOinFYS6cup3G/1ie4+t1eOnpBNlqGqs75ilzkT4+DsZQxNvaSKJ//6zIbbk/M7LOhFmRc/1R+kBtz7JFGdZm/COotIdvQoXpTqP/1uqEUmCb/QWoGLMwO5ANcHzxdY48IGP5+J+zKOTBFZ4Pid+GTM+Wq12MV/H86xEJptBa6T+p3kgpwLedManBHC2GgNrFpoN2xnrMz9WFWX/8/ygSBkavq2Uv7FdCsLEYLu9LLIvAU0bNRDtzYl+/vXmjpIvuJFYjmI0im6QEYqnIeMsNjXG4vIutIGHijeAG/9EDBozKV5cldkHbLxHh25vT+ZEzbhXlqvpzKJwcEgfNwLAKFeo0/pvEE10XDB+EXRTXtSzJozQKFFAJhMxYkVaCW+E9AL7tMeU8acxidHqzb6lX4691UsDpy/LLRmT+epgW56+5Cw8tB4kMUv6s9lh3eRKbyGs+H/4mQMaYzPTf2OOdokEn+zzgvoD3FqNKk8QqGAXVsqcGdXrT62fSPkR2vROFi68A6se86UxRUk4cajfPyCC4G5wDhD+zNq4jodQ4u4n/m37Lr36n4LIAAsVr02dFi9AiwA81MYs2rm4eDlDNmdMRvEKRHfBwW5DdMNp0jPFZMeARqF/wL4XBfd+EMLBfMzpH5GH6NaW+1vrvMdg+VxDzatk3MXgO3ro3P/DpcC6+Mo4MySJhKJhSR01SGGGp5hPWmrrUgrv3lDnP+HhcI3nt3YqBoVAVTBAQT5iuhTg8nvPtd8ZeYj6w1x6RqGUBrSku7+N1+BaasZvjTk64RoIDlL8brpEcJx3OmY7jLoZsswdtmhfC/G21llXhITOwmvRDDeTTPbyASOa16cF5/A1fZAidJpqju3wYAy9avPR1ya6eNp9K8XYrrtuxlqi+bDKwlfrYdR0RRiKRVTLOH85+ZY7XSmzRpfZBJjaTa81VDcJHpZnZnSQLASGYW9l51ZV/h7eVzTi3Hv6hUsgc/51AqJRTkpbFVLXXszoBL8nBX0u/0jBLT8nH+fJePbrwURT58OY+UieRjd1vs04w0VG5VN2U6MoGZkQzKN/ptz0Q366dxoTGmj7i1NQGHi9GgnquXFYdrCfZBmeb7s0T6yrdlZH5cZuwHFyIJ/kAtGsTg0xH5taAAq44BAk1CPk9KVVbqQzrCUiFdF/6gtlPQ8bHHc1G1W92MXGZ5HEHftyLYs8mbD/9xYRUWkHmlM0zC2ilJlnNgV4bfALpQghxOUoZL7VTqtCHIaQSXm+YUMnpkXybnV+A6xlm2CVy8fn0Xlm2XRa0+zzOa21JWWmixfiPMSCZ7qA4rS93VN3pkpF1s5TonQjisHf7iU9ZGvUPOAKZcR1pbeVf/Ul7OhepGCaId9wOtqo7pJ7yLcBZ0pFkOF28y4zEI/kcUNmutBHaQpBdNM8vjCS6HZRokkeo88TBAjGyG7SR+6vUgTcyK9Imalj0kuxz0wmK+byQU11AiJFk/ya5dNduRClcnU64yGu/ieWSeOos1t3ep+RPIWQ2pyTYVbZltTbsb7NiwSi3AV+8KLWk7LxCnfZUetEM8ThnsSoGH38/nyAwFguJp8FjvlHtcWZuU4hPva0rHfr0UhOOJ/F6vS62FW7KzkmRll2HEc7oUq4fyi5T70Vl7YVIfsPHUCdHesf9Lk7WNVWO75JDkYbMI8TOW8JKVtLY9d6UJRITO8oKo0xS+o99Yy04iniGHAaGj88kEWgwv0OrHdY/nr76DOGNS59hXCGXzTKUvDl9iKpLSWYN1lxIeyywdNpTkhay74w2jFT6NS8qkjo5CxA1yfSYwp6AJIZNKIeEK5PJAW7ORgWgwp0VgzYpqovMrWxbu+DGZ6Lhie1RAqpzm8VUzKJOH3mCzWuTOLsN3VT/dv2eeYe9UjbR8YTBsLz7q60VN1sU51k+um1f8JxD5pPhbhSC8rRaB454tmh6YUWrJI3+GWY0qeWioj/tbkYITOkJaeuGt4JrJvHA+l0Gu7kY7XOaa05alMnRWVCXqFgLIwSY4uF59Ue5SU4QKuc/HamDxbr0x6csCetXGoP7Qn1Bk/J9DsynO/UD6iZ1Hyrz+jit0hDCwi/E9OjgKTbB3ZQKQ/0ZOvevfNHG0NK4Aj3Cp7NpRk07RT1i/S0EL93Ag8GRgKI9CfpajKyK6+Jj/PI1KO5/85VAwz2AwzP8FTBb075IxCXv6T9RVvWT2tUaqxDS92zrGUbWzUYk9mSs82pECH+fkqsDt93VW++4YsR/dHCYcQSYTO/KaBMDj9LSD/J/+z20Kq8XvZUAIHtm9hRPP3ItbuAu2Hm5lkPs92pd7kCxgRs0xOVBnZ13ccdA0aunrwv9SdqElJRC3g+oCu+nXyCgmXUs9yMjTMAIHfxZV+aPKcZeUBWt057Xo85Ks1Ir5gzEHCWqZEhrLZMuF11ziGtFQUds/EESajhagzcKsxamcSZxGth4UII+adPhQkUnx2WyN+4YWR+r3f8MnkyGFuR4zjzxJS8WsQYR5PTyRaD9ixa6Mh741nBHbzfjXHskGDq179xaRNrCIB1z1xRfWfjqw2pHc1zk9xlPpL8sQWAIuETZZhbnmL54rceXVNRvUiKrrqIkeogsl0XXb17ylNb0f4GA9Wd44vffEG8FSZGHEL2fbaTGRcSiCeA8PmA/f6Hz8HCS76fXUHwgwkzSwlI71ekZ7Fapmlk/KC+Hs8hUcw3N2LN5LhkVYyizYFl/uPeVP5lsoJHhhfWvvSWruCUW1ZcJOeuTbrDgywJ/qG07gZJplnTvLcYdNaH0KMYOYMGX+rB4NGPFmQsNaIwlWrfCezxre8zXBrsMT+edVLbLqN1BqB76JH4BvZTqUIMfGwPGEn+EnmTV86fPBaYbFL3DFEhjB45CewkXEAtJxk4/Ms2pPXnaRqdky0HOYdcUcE2zcXq4vaIvW2/v0nHFJH2XXe22ueDmq/18XGtELSq85j9X8q0tcNSSKJIX8FTuJF/Pf8j5PhqG2u+osvsLxYrvvfeVJL+4tkcXcr9JV7v0ERmj/X6fM3NC4j6dS1+9Umr2oPavqiAydTZPLMNRGY23LO9zAVDly7jD+70G5TPPLdhRIl4WxcYjLnM+SNcJ26FOrkrISUtPObIz5Zb3AG612krnpy15RMW+1cQjlnWFI6538qky9axd2oJmHIHP08KyP0ubGO+TQNOYuv2uh17yCIvR8VcStw7o1g0NM60sk+8Tq7YfIBJrtp53GkvzXH7OA0p8/n/u1satf/VJhtR1l8Wa6Gmaug7haSpaCaYQax6ta0mkutlb+eAOSG1aobM81D9A4iS1RRlzBBoVX6tU1S6WE2N9ORY6DfeLRC4l9Rvr5h95XDWB2mR1d4WFudpsgVYwiTwT31ljskD8ZyDOlm5DkGh9N/UB/0AI5Xvb8ZBmai2hQ4BWMqFwYnzxwB26YHSOv9WgY3JXnvoN+2R4rqGVh/LLDMtpFP+SpMGJNWvbIl5SOodbCczW2RKleksPoUeGEzrjtKHVdtZA+kfqO+rVx/iclCqwoopepvJpSTDjT+b9GWylGRF8EDbGlw6eUzmJM95Ovoz+kwLX3c2fTjFeYEsE7vUZm3mqdGJuKh2w9/QGSaqRHs99aScGOdDqkFcACoqdbBoQqqjamhH6Q9ng39JCg3lrGJwd50Qk9ovnqBTr8MME7Ps2wiVfygUmPoUBJJfJWX5Nda0nuncbFkA=="));
  }

  // node_modules/@ethersproject/hash/lib.esm/ens-normalize/lib.js
  var r7 = getData();
  var VALID2 = new Set(read_member_array(r7));
  var IGNORED2 = new Set(read_member_array(r7));
  var MAPPED2 = read_mapped_map(r7);
  var EMOJI_ROOT2 = read_emoji_trie2(r7);
  var HYPHEN2 = 45;
  var UNDERSCORE = 95;
  function explode_cp2(name2) {
    return toUtf8CodePoints(name2);
  }
  function filter_fe0f2(cps) {
    return cps.filter((cp) => cp != 65039);
  }
  function ens_normalize_post_check(name2) {
    for (let label of name2.split(".")) {
      let cps = explode_cp2(label);
      try {
        for (let i7 = cps.lastIndexOf(UNDERSCORE) - 1; i7 >= 0; i7--) {
          if (cps[i7] !== UNDERSCORE) {
            throw new Error(`underscore only allowed at start`);
          }
        }
        if (cps.length >= 4 && cps.every((cp) => cp < 128) && cps[2] === HYPHEN2 && cps[3] === HYPHEN2) {
          throw new Error(`invalid label extension`);
        }
      } catch (err) {
        throw new Error(`Invalid label "${label}": ${err.message}`);
      }
    }
    return name2;
  }
  function ens_normalize2(name2) {
    return ens_normalize_post_check(normalize2(name2, filter_fe0f2));
  }
  function normalize2(name2, emoji_filter) {
    let input = explode_cp2(name2).reverse();
    let output2 = [];
    while (input.length) {
      let emoji = consume_emoji_reversed2(input);
      if (emoji) {
        output2.push(...emoji_filter(emoji));
        continue;
      }
      let cp = input.pop();
      if (VALID2.has(cp)) {
        output2.push(cp);
        continue;
      }
      if (IGNORED2.has(cp)) {
        continue;
      }
      let cps = MAPPED2[cp];
      if (cps) {
        output2.push(...cps);
        continue;
      }
      throw new Error(`Disallowed codepoint: 0x${cp.toString(16).toUpperCase()}`);
    }
    return ens_normalize_post_check(nfc2(String.fromCodePoint(...output2)));
  }
  function nfc2(s7) {
    return s7.normalize("NFC");
  }
  function consume_emoji_reversed2(cps, eaten) {
    var _a2;
    let node = EMOJI_ROOT2;
    let emoji;
    let saved;
    let stack = [];
    let pos = cps.length;
    if (eaten)
      eaten.length = 0;
    while (pos) {
      let cp = cps[--pos];
      node = (_a2 = node.branches.find((x4) => x4.set.has(cp))) === null || _a2 === void 0 ? void 0 : _a2.node;
      if (!node)
        break;
      if (node.save) {
        saved = cp;
      } else if (node.check) {
        if (cp === saved)
          break;
      }
      stack.push(cp);
      if (node.fe0f) {
        stack.push(65039);
        if (pos > 0 && cps[pos - 1] == 65039)
          pos--;
      }
      if (node.valid) {
        emoji = stack.slice();
        if (node.valid == 2)
          emoji.splice(1, 1);
        if (eaten)
          eaten.push(...cps.slice(pos).reverse());
        cps.length = pos;
      }
    }
    return emoji;
  }

  // node_modules/@ethersproject/hash/lib.esm/namehash.js
  var logger12 = new Logger(version12);
  var Zeros = new Uint8Array(32);
  Zeros.fill(0);
  function checkComponent(comp) {
    if (comp.length === 0) {
      throw new Error("invalid ENS name; empty component");
    }
    return comp;
  }
  function ensNameSplit(name2) {
    const bytes3 = toUtf8Bytes(ens_normalize2(name2));
    const comps = [];
    if (name2.length === 0) {
      return comps;
    }
    let last = 0;
    for (let i7 = 0; i7 < bytes3.length; i7++) {
      const d7 = bytes3[i7];
      if (d7 === 46) {
        comps.push(checkComponent(bytes3.slice(last, i7)));
        last = i7 + 1;
      }
    }
    if (last >= bytes3.length) {
      throw new Error("invalid ENS name; empty component");
    }
    comps.push(checkComponent(bytes3.slice(last)));
    return comps;
  }
  function isValidName(name2) {
    try {
      return ensNameSplit(name2).length !== 0;
    } catch (error) {
    }
    return false;
  }
  function namehash2(name2) {
    if (typeof name2 !== "string") {
      logger12.throwArgumentError("invalid ENS name; not a string", "name", name2);
    }
    let result = Zeros;
    const comps = ensNameSplit(name2);
    while (comps.length) {
      result = keccak2562(concat3([result, keccak2562(comps.pop())]));
    }
    return hexlify(result);
  }
  function dnsEncode(name2) {
    return hexlify(concat3(ensNameSplit(name2).map((comp) => {
      if (comp.length > 63) {
        throw new Error("invalid DNS encoded entry; length exceeds 63 bytes");
      }
      const bytes3 = new Uint8Array(comp.length + 1);
      bytes3.set(comp, 1);
      bytes3[0] = bytes3.length - 1;
      return bytes3;
    }))) + "00";
  }

  // node_modules/@ethersproject/hash/lib.esm/message.js
  var messagePrefix = "Ethereum Signed Message:\n";
  function hashMessage2(message) {
    if (typeof message === "string") {
      message = toUtf8Bytes(message);
    }
    return keccak2562(concat3([
      toUtf8Bytes(messagePrefix),
      toUtf8Bytes(String(message.length)),
      message
    ]));
  }

  // node_modules/@ethersproject/hash/lib.esm/typed-data.js
  var __awaiter3 = function(thisArg, _arguments, P7, generator) {
    function adopt(value) {
      return value instanceof P7 ? value : new P7(function(resolve) {
        resolve(value);
      });
    }
    return new (P7 || (P7 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e9) {
          reject(e9);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e9) {
          reject(e9);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var logger13 = new Logger(version12);
  var padding = new Uint8Array(32);
  padding.fill(0);
  var NegativeOne3 = BigNumber.from(-1);
  var Zero3 = BigNumber.from(0);
  var One2 = BigNumber.from(1);
  var MaxUint2562 = BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
  function hexPadRight(value) {
    const bytes3 = arrayify(value);
    const padOffset = bytes3.length % 32;
    if (padOffset) {
      return hexConcat([bytes3, padding.slice(padOffset)]);
    }
    return hexlify(bytes3);
  }
  var hexTrue = hexZeroPad(One2.toHexString(), 32);
  var hexFalse = hexZeroPad(Zero3.toHexString(), 32);
  var domainFieldTypes = {
    name: "string",
    version: "string",
    chainId: "uint256",
    verifyingContract: "address",
    salt: "bytes32"
  };
  var domainFieldNames = [
    "name",
    "version",
    "chainId",
    "verifyingContract",
    "salt"
  ];
  function checkString(key2) {
    return function(value) {
      if (typeof value !== "string") {
        logger13.throwArgumentError(`invalid domain value for ${JSON.stringify(key2)}`, `domain.${key2}`, value);
      }
      return value;
    };
  }
  var domainChecks = {
    name: checkString("name"),
    version: checkString("version"),
    chainId: function(value) {
      try {
        return BigNumber.from(value).toString();
      } catch (error) {
      }
      return logger13.throwArgumentError(`invalid domain value for "chainId"`, "domain.chainId", value);
    },
    verifyingContract: function(value) {
      try {
        return getAddress2(value).toLowerCase();
      } catch (error) {
      }
      return logger13.throwArgumentError(`invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
    },
    salt: function(value) {
      try {
        const bytes3 = arrayify(value);
        if (bytes3.length !== 32) {
          throw new Error("bad length");
        }
        return hexlify(bytes3);
      } catch (error) {
      }
      return logger13.throwArgumentError(`invalid domain value "salt"`, "domain.salt", value);
    }
  };
  function getBaseEncoder(type) {
    {
      const match = type.match(/^(u?)int(\d*)$/);
      if (match) {
        const signed3 = match[1] === "";
        const width = parseInt(match[2] || "256");
        if (width % 8 !== 0 || width > 256 || match[2] && match[2] !== String(width)) {
          logger13.throwArgumentError("invalid numeric width", "type", type);
        }
        const boundsUpper = MaxUint2562.mask(signed3 ? width - 1 : width);
        const boundsLower = signed3 ? boundsUpper.add(One2).mul(NegativeOne3) : Zero3;
        return function(value) {
          const v6 = BigNumber.from(value);
          if (v6.lt(boundsLower) || v6.gt(boundsUpper)) {
            logger13.throwArgumentError(`value out-of-bounds for ${type}`, "value", value);
          }
          return hexZeroPad(v6.toTwos(256).toHexString(), 32);
        };
      }
    }
    {
      const match = type.match(/^bytes(\d+)$/);
      if (match) {
        const width = parseInt(match[1]);
        if (width === 0 || width > 32 || match[1] !== String(width)) {
          logger13.throwArgumentError("invalid bytes width", "type", type);
        }
        return function(value) {
          const bytes3 = arrayify(value);
          if (bytes3.length !== width) {
            logger13.throwArgumentError(`invalid length for ${type}`, "value", value);
          }
          return hexPadRight(value);
        };
      }
    }
    switch (type) {
      case "address":
        return function(value) {
          return hexZeroPad(getAddress2(value), 32);
        };
      case "bool":
        return function(value) {
          return !value ? hexFalse : hexTrue;
        };
      case "bytes":
        return function(value) {
          return keccak2562(value);
        };
      case "string":
        return function(value) {
          return id2(value);
        };
    }
    return null;
  }
  function encodeType2(name2, fields) {
    return `${name2}(${fields.map(({ name: name3, type }) => type + " " + name3).join(",")})`;
  }
  var TypedDataEncoder = class {
    constructor(types) {
      defineReadOnly(this, "types", Object.freeze(deepCopy(types)));
      defineReadOnly(this, "_encoderCache", {});
      defineReadOnly(this, "_types", {});
      const links = {};
      const parents = {};
      const subtypes = {};
      Object.keys(types).forEach((type) => {
        links[type] = {};
        parents[type] = [];
        subtypes[type] = {};
      });
      for (const name2 in types) {
        const uniqueNames = {};
        types[name2].forEach((field) => {
          if (uniqueNames[field.name]) {
            logger13.throwArgumentError(`duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name2)}`, "types", types);
          }
          uniqueNames[field.name] = true;
          const baseType = field.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
          if (baseType === name2) {
            logger13.throwArgumentError(`circular type reference to ${JSON.stringify(baseType)}`, "types", types);
          }
          const encoder3 = getBaseEncoder(baseType);
          if (encoder3) {
            return;
          }
          if (!parents[baseType]) {
            logger13.throwArgumentError(`unknown type ${JSON.stringify(baseType)}`, "types", types);
          }
          parents[baseType].push(name2);
          links[name2][baseType] = true;
        });
      }
      const primaryTypes = Object.keys(parents).filter((n9) => parents[n9].length === 0);
      if (primaryTypes.length === 0) {
        logger13.throwArgumentError("missing primary type", "types", types);
      } else if (primaryTypes.length > 1) {
        logger13.throwArgumentError(`ambiguous primary types or unused types: ${primaryTypes.map((t6) => JSON.stringify(t6)).join(", ")}`, "types", types);
      }
      defineReadOnly(this, "primaryType", primaryTypes[0]);
      function checkCircular(type, found) {
        if (found[type]) {
          logger13.throwArgumentError(`circular type reference to ${JSON.stringify(type)}`, "types", types);
        }
        found[type] = true;
        Object.keys(links[type]).forEach((child) => {
          if (!parents[child]) {
            return;
          }
          checkCircular(child, found);
          Object.keys(found).forEach((subtype) => {
            subtypes[subtype][child] = true;
          });
        });
        delete found[type];
      }
      checkCircular(this.primaryType, {});
      for (const name2 in subtypes) {
        const st4 = Object.keys(subtypes[name2]);
        st4.sort();
        this._types[name2] = encodeType2(name2, types[name2]) + st4.map((t6) => encodeType2(t6, types[t6])).join("");
      }
    }
    getEncoder(type) {
      let encoder3 = this._encoderCache[type];
      if (!encoder3) {
        encoder3 = this._encoderCache[type] = this._getEncoder(type);
      }
      return encoder3;
    }
    _getEncoder(type) {
      {
        const encoder3 = getBaseEncoder(type);
        if (encoder3) {
          return encoder3;
        }
      }
      const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
      if (match) {
        const subtype = match[1];
        const subEncoder = this.getEncoder(subtype);
        const length2 = parseInt(match[3]);
        return (value) => {
          if (length2 >= 0 && value.length !== length2) {
            logger13.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
          }
          let result = value.map(subEncoder);
          if (this._types[subtype]) {
            result = result.map(keccak2562);
          }
          return keccak2562(hexConcat(result));
        };
      }
      const fields = this.types[type];
      if (fields) {
        const encodedType = id2(this._types[type]);
        return (value) => {
          const values = fields.map(({ name: name2, type: type2 }) => {
            const result = this.getEncoder(type2)(value[name2]);
            if (this._types[type2]) {
              return keccak2562(result);
            }
            return result;
          });
          values.unshift(encodedType);
          return hexConcat(values);
        };
      }
      return logger13.throwArgumentError(`unknown type: ${type}`, "type", type);
    }
    encodeType(name2) {
      const result = this._types[name2];
      if (!result) {
        logger13.throwArgumentError(`unknown type: ${JSON.stringify(name2)}`, "name", name2);
      }
      return result;
    }
    encodeData(type, value) {
      return this.getEncoder(type)(value);
    }
    hashStruct(name2, value) {
      return keccak2562(this.encodeData(name2, value));
    }
    encode(value) {
      return this.encodeData(this.primaryType, value);
    }
    hash(value) {
      return this.hashStruct(this.primaryType, value);
    }
    _visit(type, value, callback) {
      {
        const encoder3 = getBaseEncoder(type);
        if (encoder3) {
          return callback(type, value);
        }
      }
      const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
      if (match) {
        const subtype = match[1];
        const length2 = parseInt(match[3]);
        if (length2 >= 0 && value.length !== length2) {
          logger13.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
        }
        return value.map((v6) => this._visit(subtype, v6, callback));
      }
      const fields = this.types[type];
      if (fields) {
        return fields.reduce((accum, { name: name2, type: type2 }) => {
          accum[name2] = this._visit(type2, value[name2], callback);
          return accum;
        }, {});
      }
      return logger13.throwArgumentError(`unknown type: ${type}`, "type", type);
    }
    visit(value, callback) {
      return this._visit(this.primaryType, value, callback);
    }
    static from(types) {
      return new TypedDataEncoder(types);
    }
    static getPrimaryType(types) {
      return TypedDataEncoder.from(types).primaryType;
    }
    static hashStruct(name2, types, value) {
      return TypedDataEncoder.from(types).hashStruct(name2, value);
    }
    static hashDomain(domain2) {
      const domainFields = [];
      for (const name2 in domain2) {
        const type = domainFieldTypes[name2];
        if (!type) {
          logger13.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(name2)}`, "domain", domain2);
        }
        domainFields.push({ name: name2, type });
      }
      domainFields.sort((a6, b7) => {
        return domainFieldNames.indexOf(a6.name) - domainFieldNames.indexOf(b7.name);
      });
      return TypedDataEncoder.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain2);
    }
    static encode(domain2, types, value) {
      return hexConcat([
        "0x1901",
        TypedDataEncoder.hashDomain(domain2),
        TypedDataEncoder.from(types).hash(value)
      ]);
    }
    static hash(domain2, types, value) {
      return keccak2562(TypedDataEncoder.encode(domain2, types, value));
    }
    // Replaces all address types with ENS names with their looked up address
    static resolveNames(domain2, types, value, resolveName2) {
      return __awaiter3(this, void 0, void 0, function* () {
        domain2 = shallowCopy(domain2);
        const ensCache = {};
        if (domain2.verifyingContract && !isHexString(domain2.verifyingContract, 20)) {
          ensCache[domain2.verifyingContract] = "0x";
        }
        const encoder3 = TypedDataEncoder.from(types);
        encoder3.visit(value, (type, value2) => {
          if (type === "address" && !isHexString(value2, 20)) {
            ensCache[value2] = "0x";
          }
          return value2;
        });
        for (const name2 in ensCache) {
          ensCache[name2] = yield resolveName2(name2);
        }
        if (domain2.verifyingContract && ensCache[domain2.verifyingContract]) {
          domain2.verifyingContract = ensCache[domain2.verifyingContract];
        }
        value = encoder3.visit(value, (type, value2) => {
          if (type === "address" && ensCache[value2]) {
            return ensCache[value2];
          }
          return value2;
        });
        return { domain: domain2, value };
      });
    }
    static getPayload(domain2, types, value) {
      TypedDataEncoder.hashDomain(domain2);
      const domainValues = {};
      const domainTypes = [];
      domainFieldNames.forEach((name2) => {
        const value2 = domain2[name2];
        if (value2 == null) {
          return;
        }
        domainValues[name2] = domainChecks[name2](value2);
        domainTypes.push({ name: name2, type: domainFieldTypes[name2] });
      });
      const encoder3 = TypedDataEncoder.from(types);
      const typesWithDomain = shallowCopy(types);
      if (typesWithDomain.EIP712Domain) {
        logger13.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", types);
      } else {
        typesWithDomain.EIP712Domain = domainTypes;
      }
      encoder3.encode(value);
      return {
        types: typesWithDomain,
        domain: domainValues,
        primaryType: encoder3.primaryType,
        message: encoder3.visit(value, (type, value2) => {
          if (type.match(/^bytes(\d*)/)) {
            return hexlify(arrayify(value2));
          }
          if (type.match(/^u?int/)) {
            return BigNumber.from(value2).toString();
          }
          switch (type) {
            case "address":
              return value2.toLowerCase();
            case "bool":
              return !!value2;
            case "string":
              if (typeof value2 !== "string") {
                logger13.throwArgumentError(`invalid string`, "value", value2);
              }
              return value2;
          }
          return logger13.throwArgumentError("unsupported type", "type", type);
        })
      };
    }
  };

  // node_modules/@ethersproject/abi/lib.esm/interface.js
  var logger14 = new Logger(version8);
  var LogDescription = class extends Description {
  };
  var TransactionDescription = class extends Description {
  };
  var ErrorDescription = class extends Description {
  };
  var Indexed = class extends Description {
    static isIndexed(value) {
      return !!(value && value._isIndexed);
    }
  };
  var BuiltinErrors = {
    "0x08c379a0": { signature: "Error(string)", name: "Error", inputs: ["string"], reason: true },
    "0x4e487b71": { signature: "Panic(uint256)", name: "Panic", inputs: ["uint256"] }
  };
  function wrapAccessError(property, error) {
    const wrap2 = new Error(`deferred error during ABI decoding triggered accessing ${property}`);
    wrap2.error = error;
    return wrap2;
  }
  var Interface = class {
    constructor(fragments) {
      let abi = [];
      if (typeof fragments === "string") {
        abi = JSON.parse(fragments);
      } else {
        abi = fragments;
      }
      defineReadOnly(this, "fragments", abi.map((fragment) => {
        return Fragment.from(fragment);
      }).filter((fragment) => fragment != null));
      defineReadOnly(this, "_abiCoder", getStatic(new.target, "getAbiCoder")());
      defineReadOnly(this, "functions", {});
      defineReadOnly(this, "errors", {});
      defineReadOnly(this, "events", {});
      defineReadOnly(this, "structs", {});
      this.fragments.forEach((fragment) => {
        let bucket = null;
        switch (fragment.type) {
          case "constructor":
            if (this.deploy) {
              logger14.warn("duplicate definition - constructor");
              return;
            }
            defineReadOnly(this, "deploy", fragment);
            return;
          case "function":
            bucket = this.functions;
            break;
          case "event":
            bucket = this.events;
            break;
          case "error":
            bucket = this.errors;
            break;
          default:
            return;
        }
        let signature2 = fragment.format();
        if (bucket[signature2]) {
          logger14.warn("duplicate definition - " + signature2);
          return;
        }
        bucket[signature2] = fragment;
      });
      if (!this.deploy) {
        defineReadOnly(this, "deploy", ConstructorFragment.from({
          payable: false,
          type: "constructor"
        }));
      }
      defineReadOnly(this, "_isInterface", true);
    }
    format(format2) {
      if (!format2) {
        format2 = FormatTypes.full;
      }
      if (format2 === FormatTypes.sighash) {
        logger14.throwArgumentError("interface does not support formatting sighash", "format", format2);
      }
      const abi = this.fragments.map((fragment) => fragment.format(format2));
      if (format2 === FormatTypes.json) {
        return JSON.stringify(abi.map((j7) => JSON.parse(j7)));
      }
      return abi;
    }
    // Sub-classes can override these to handle other blockchains
    static getAbiCoder() {
      return defaultAbiCoder;
    }
    static getAddress(address) {
      return getAddress2(address);
    }
    static getSighash(fragment) {
      return hexDataSlice(id2(fragment.format()), 0, 4);
    }
    static getEventTopic(eventFragment) {
      return id2(eventFragment.format());
    }
    // Find a function definition by any means necessary (unless it is ambiguous)
    getFunction(nameOrSignatureOrSighash) {
      if (isHexString(nameOrSignatureOrSighash)) {
        for (const name2 in this.functions) {
          if (nameOrSignatureOrSighash === this.getSighash(name2)) {
            return this.functions[name2];
          }
        }
        logger14.throwArgumentError("no matching function", "sighash", nameOrSignatureOrSighash);
      }
      if (nameOrSignatureOrSighash.indexOf("(") === -1) {
        const name2 = nameOrSignatureOrSighash.trim();
        const matching = Object.keys(this.functions).filter((f7) => f7.split(
          "("
          /* fix:) */
        )[0] === name2);
        if (matching.length === 0) {
          logger14.throwArgumentError("no matching function", "name", name2);
        } else if (matching.length > 1) {
          logger14.throwArgumentError("multiple matching functions", "name", name2);
        }
        return this.functions[matching[0]];
      }
      const result = this.functions[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
      if (!result) {
        logger14.throwArgumentError("no matching function", "signature", nameOrSignatureOrSighash);
      }
      return result;
    }
    // Find an event definition by any means necessary (unless it is ambiguous)
    getEvent(nameOrSignatureOrTopic) {
      if (isHexString(nameOrSignatureOrTopic)) {
        const topichash = nameOrSignatureOrTopic.toLowerCase();
        for (const name2 in this.events) {
          if (topichash === this.getEventTopic(name2)) {
            return this.events[name2];
          }
        }
        logger14.throwArgumentError("no matching event", "topichash", topichash);
      }
      if (nameOrSignatureOrTopic.indexOf("(") === -1) {
        const name2 = nameOrSignatureOrTopic.trim();
        const matching = Object.keys(this.events).filter((f7) => f7.split(
          "("
          /* fix:) */
        )[0] === name2);
        if (matching.length === 0) {
          logger14.throwArgumentError("no matching event", "name", name2);
        } else if (matching.length > 1) {
          logger14.throwArgumentError("multiple matching events", "name", name2);
        }
        return this.events[matching[0]];
      }
      const result = this.events[EventFragment.fromString(nameOrSignatureOrTopic).format()];
      if (!result) {
        logger14.throwArgumentError("no matching event", "signature", nameOrSignatureOrTopic);
      }
      return result;
    }
    // Find a function definition by any means necessary (unless it is ambiguous)
    getError(nameOrSignatureOrSighash) {
      if (isHexString(nameOrSignatureOrSighash)) {
        const getSighash = getStatic(this.constructor, "getSighash");
        for (const name2 in this.errors) {
          const error = this.errors[name2];
          if (nameOrSignatureOrSighash === getSighash(error)) {
            return this.errors[name2];
          }
        }
        logger14.throwArgumentError("no matching error", "sighash", nameOrSignatureOrSighash);
      }
      if (nameOrSignatureOrSighash.indexOf("(") === -1) {
        const name2 = nameOrSignatureOrSighash.trim();
        const matching = Object.keys(this.errors).filter((f7) => f7.split(
          "("
          /* fix:) */
        )[0] === name2);
        if (matching.length === 0) {
          logger14.throwArgumentError("no matching error", "name", name2);
        } else if (matching.length > 1) {
          logger14.throwArgumentError("multiple matching errors", "name", name2);
        }
        return this.errors[matching[0]];
      }
      const result = this.errors[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
      if (!result) {
        logger14.throwArgumentError("no matching error", "signature", nameOrSignatureOrSighash);
      }
      return result;
    }
    // Get the sighash (the bytes4 selector) used by Solidity to identify a function
    getSighash(fragment) {
      if (typeof fragment === "string") {
        try {
          fragment = this.getFunction(fragment);
        } catch (error) {
          try {
            fragment = this.getError(fragment);
          } catch (_8) {
            throw error;
          }
        }
      }
      return getStatic(this.constructor, "getSighash")(fragment);
    }
    // Get the topic (the bytes32 hash) used by Solidity to identify an event
    getEventTopic(eventFragment) {
      if (typeof eventFragment === "string") {
        eventFragment = this.getEvent(eventFragment);
      }
      return getStatic(this.constructor, "getEventTopic")(eventFragment);
    }
    _decodeParams(params, data2) {
      return this._abiCoder.decode(params, data2);
    }
    _encodeParams(params, values) {
      return this._abiCoder.encode(params, values);
    }
    encodeDeploy(values) {
      return this._encodeParams(this.deploy.inputs, values || []);
    }
    decodeErrorResult(fragment, data2) {
      if (typeof fragment === "string") {
        fragment = this.getError(fragment);
      }
      const bytes3 = arrayify(data2);
      if (hexlify(bytes3.slice(0, 4)) !== this.getSighash(fragment)) {
        logger14.throwArgumentError(`data signature does not match error ${fragment.name}.`, "data", hexlify(bytes3));
      }
      return this._decodeParams(fragment.inputs, bytes3.slice(4));
    }
    encodeErrorResult(fragment, values) {
      if (typeof fragment === "string") {
        fragment = this.getError(fragment);
      }
      return hexlify(concat3([
        this.getSighash(fragment),
        this._encodeParams(fragment.inputs, values || [])
      ]));
    }
    // Decode the data for a function call (e.g. tx.data)
    decodeFunctionData(functionFragment, data2) {
      if (typeof functionFragment === "string") {
        functionFragment = this.getFunction(functionFragment);
      }
      const bytes3 = arrayify(data2);
      if (hexlify(bytes3.slice(0, 4)) !== this.getSighash(functionFragment)) {
        logger14.throwArgumentError(`data signature does not match function ${functionFragment.name}.`, "data", hexlify(bytes3));
      }
      return this._decodeParams(functionFragment.inputs, bytes3.slice(4));
    }
    // Encode the data for a function call (e.g. tx.data)
    encodeFunctionData(functionFragment, values) {
      if (typeof functionFragment === "string") {
        functionFragment = this.getFunction(functionFragment);
      }
      return hexlify(concat3([
        this.getSighash(functionFragment),
        this._encodeParams(functionFragment.inputs, values || [])
      ]));
    }
    // Decode the result from a function call (e.g. from eth_call)
    decodeFunctionResult(functionFragment, data2) {
      if (typeof functionFragment === "string") {
        functionFragment = this.getFunction(functionFragment);
      }
      let bytes3 = arrayify(data2);
      let reason = null;
      let message = "";
      let errorArgs = null;
      let errorName = null;
      let errorSignature = null;
      switch (bytes3.length % this._abiCoder._getWordSize()) {
        case 0:
          try {
            return this._abiCoder.decode(functionFragment.outputs, bytes3);
          } catch (error) {
          }
          break;
        case 4: {
          const selector = hexlify(bytes3.slice(0, 4));
          const builtin = BuiltinErrors[selector];
          if (builtin) {
            errorArgs = this._abiCoder.decode(builtin.inputs, bytes3.slice(4));
            errorName = builtin.name;
            errorSignature = builtin.signature;
            if (builtin.reason) {
              reason = errorArgs[0];
            }
            if (errorName === "Error") {
              message = `; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(errorArgs[0])}`;
            } else if (errorName === "Panic") {
              message = `; VM Exception while processing transaction: reverted with panic code ${errorArgs[0]}`;
            }
          } else {
            try {
              const error = this.getError(selector);
              errorArgs = this._abiCoder.decode(error.inputs, bytes3.slice(4));
              errorName = error.name;
              errorSignature = error.format();
            } catch (error) {
            }
          }
          break;
        }
      }
      return logger14.throwError("call revert exception" + message, Logger.errors.CALL_EXCEPTION, {
        method: functionFragment.format(),
        data: hexlify(data2),
        errorArgs,
        errorName,
        errorSignature,
        reason
      });
    }
    // Encode the result for a function call (e.g. for eth_call)
    encodeFunctionResult(functionFragment, values) {
      if (typeof functionFragment === "string") {
        functionFragment = this.getFunction(functionFragment);
      }
      return hexlify(this._abiCoder.encode(functionFragment.outputs, values || []));
    }
    // Create the filter for the event with search criteria (e.g. for eth_filterLog)
    encodeFilterTopics(eventFragment, values) {
      if (typeof eventFragment === "string") {
        eventFragment = this.getEvent(eventFragment);
      }
      if (values.length > eventFragment.inputs.length) {
        logger14.throwError("too many arguments for " + eventFragment.format(), Logger.errors.UNEXPECTED_ARGUMENT, {
          argument: "values",
          value: values
        });
      }
      let topics = [];
      if (!eventFragment.anonymous) {
        topics.push(this.getEventTopic(eventFragment));
      }
      const encodeTopic = (param, value) => {
        if (param.type === "string") {
          return id2(value);
        } else if (param.type === "bytes") {
          return keccak2562(hexlify(value));
        }
        if (param.type === "bool" && typeof value === "boolean") {
          value = value ? "0x01" : "0x00";
        }
        if (param.type.match(/^u?int/)) {
          value = BigNumber.from(value).toHexString();
        }
        if (param.type === "address") {
          this._abiCoder.encode(["address"], [value]);
        }
        return hexZeroPad(hexlify(value), 32);
      };
      values.forEach((value, index2) => {
        let param = eventFragment.inputs[index2];
        if (!param.indexed) {
          if (value != null) {
            logger14.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
          }
          return;
        }
        if (value == null) {
          topics.push(null);
        } else if (param.baseType === "array" || param.baseType === "tuple") {
          logger14.throwArgumentError("filtering with tuples or arrays not supported", "contract." + param.name, value);
        } else if (Array.isArray(value)) {
          topics.push(value.map((value2) => encodeTopic(param, value2)));
        } else {
          topics.push(encodeTopic(param, value));
        }
      });
      while (topics.length && topics[topics.length - 1] === null) {
        topics.pop();
      }
      return topics;
    }
    encodeEventLog(eventFragment, values) {
      if (typeof eventFragment === "string") {
        eventFragment = this.getEvent(eventFragment);
      }
      const topics = [];
      const dataTypes = [];
      const dataValues = [];
      if (!eventFragment.anonymous) {
        topics.push(this.getEventTopic(eventFragment));
      }
      if (values.length !== eventFragment.inputs.length) {
        logger14.throwArgumentError("event arguments/values mismatch", "values", values);
      }
      eventFragment.inputs.forEach((param, index2) => {
        const value = values[index2];
        if (param.indexed) {
          if (param.type === "string") {
            topics.push(id2(value));
          } else if (param.type === "bytes") {
            topics.push(keccak2562(value));
          } else if (param.baseType === "tuple" || param.baseType === "array") {
            throw new Error("not implemented");
          } else {
            topics.push(this._abiCoder.encode([param.type], [value]));
          }
        } else {
          dataTypes.push(param);
          dataValues.push(value);
        }
      });
      return {
        data: this._abiCoder.encode(dataTypes, dataValues),
        topics
      };
    }
    // Decode a filter for the event and the search criteria
    decodeEventLog(eventFragment, data2, topics) {
      if (typeof eventFragment === "string") {
        eventFragment = this.getEvent(eventFragment);
      }
      if (topics != null && !eventFragment.anonymous) {
        let topicHash = this.getEventTopic(eventFragment);
        if (!isHexString(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {
          logger14.throwError("fragment/topic mismatch", Logger.errors.INVALID_ARGUMENT, { argument: "topics[0]", expected: topicHash, value: topics[0] });
        }
        topics = topics.slice(1);
      }
      let indexed = [];
      let nonIndexed = [];
      let dynamic = [];
      eventFragment.inputs.forEach((param, index2) => {
        if (param.indexed) {
          if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
            indexed.push(ParamType.fromObject({ type: "bytes32", name: param.name }));
            dynamic.push(true);
          } else {
            indexed.push(param);
            dynamic.push(false);
          }
        } else {
          nonIndexed.push(param);
          dynamic.push(false);
        }
      });
      let resultIndexed = topics != null ? this._abiCoder.decode(indexed, concat3(topics)) : null;
      let resultNonIndexed = this._abiCoder.decode(nonIndexed, data2, true);
      let result = [];
      let nonIndexedIndex = 0, indexedIndex = 0;
      eventFragment.inputs.forEach((param, index2) => {
        if (param.indexed) {
          if (resultIndexed == null) {
            result[index2] = new Indexed({ _isIndexed: true, hash: null });
          } else if (dynamic[index2]) {
            result[index2] = new Indexed({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });
          } else {
            try {
              result[index2] = resultIndexed[indexedIndex++];
            } catch (error) {
              result[index2] = error;
            }
          }
        } else {
          try {
            result[index2] = resultNonIndexed[nonIndexedIndex++];
          } catch (error) {
            result[index2] = error;
          }
        }
        if (param.name && result[param.name] == null) {
          const value = result[index2];
          if (value instanceof Error) {
            Object.defineProperty(result, param.name, {
              enumerable: true,
              get: () => {
                throw wrapAccessError(`property ${JSON.stringify(param.name)}`, value);
              }
            });
          } else {
            result[param.name] = value;
          }
        }
      });
      for (let i7 = 0; i7 < result.length; i7++) {
        const value = result[i7];
        if (value instanceof Error) {
          Object.defineProperty(result, i7, {
            enumerable: true,
            get: () => {
              throw wrapAccessError(`index ${i7}`, value);
            }
          });
        }
      }
      return Object.freeze(result);
    }
    // Given a transaction, find the matching function fragment (if any) and
    // determine all its properties and call parameters
    parseTransaction(tx) {
      let fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase());
      if (!fragment) {
        return null;
      }
      return new TransactionDescription({
        args: this._abiCoder.decode(fragment.inputs, "0x" + tx.data.substring(10)),
        functionFragment: fragment,
        name: fragment.name,
        signature: fragment.format(),
        sighash: this.getSighash(fragment),
        value: BigNumber.from(tx.value || "0")
      });
    }
    // @TODO
    //parseCallResult(data: BytesLike): ??
    // Given an event log, find the matching event fragment (if any) and
    // determine all its properties and values
    parseLog(log) {
      let fragment = this.getEvent(log.topics[0]);
      if (!fragment || fragment.anonymous) {
        return null;
      }
      return new LogDescription({
        eventFragment: fragment,
        name: fragment.name,
        signature: fragment.format(),
        topic: this.getEventTopic(fragment),
        args: this.decodeEventLog(fragment, log.data, log.topics)
      });
    }
    parseError(data2) {
      const hexData = hexlify(data2);
      let fragment = this.getError(hexData.substring(0, 10).toLowerCase());
      if (!fragment) {
        return null;
      }
      return new ErrorDescription({
        args: this._abiCoder.decode(fragment.inputs, "0x" + hexData.substring(10)),
        errorFragment: fragment,
        name: fragment.name,
        signature: fragment.format(),
        sighash: this.getSighash(fragment)
      });
    }
    /*
    static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {
        if (Interface.isInterface(value)) {
            return value;
        }
        if (typeof(value) === "string") {
            return new Interface(JSON.parse(value));
        }
        return new Interface(value);
    }
    */
    static isInterface(value) {
      return !!(value && value._isInterface);
    }
  };

  // node_modules/@ethersproject/abstract-provider/lib.esm/_version.js
  var version13 = "abstract-provider/5.7.0";

  // node_modules/@ethersproject/abstract-provider/lib.esm/index.js
  var __awaiter4 = function(thisArg, _arguments, P7, generator) {
    function adopt(value) {
      return value instanceof P7 ? value : new P7(function(resolve) {
        resolve(value);
      });
    }
    return new (P7 || (P7 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e9) {
          reject(e9);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e9) {
          reject(e9);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var logger15 = new Logger(version13);
  var ForkEvent = class extends Description {
    static isForkEvent(value) {
      return !!(value && value._isForkEvent);
    }
  };
  var Provider = class {
    constructor() {
      logger15.checkAbstract(new.target, Provider);
      defineReadOnly(this, "_isProvider", true);
    }
    getFeeData() {
      return __awaiter4(this, void 0, void 0, function* () {
        const { block: block2, gasPrice } = yield resolveProperties({
          block: this.getBlock("latest"),
          gasPrice: this.getGasPrice().catch((error) => {
            return null;
          })
        });
        let lastBaseFeePerGas = null, maxFeePerGas = null, maxPriorityFeePerGas = null;
        if (block2 && block2.baseFeePerGas) {
          lastBaseFeePerGas = block2.baseFeePerGas;
          maxPriorityFeePerGas = BigNumber.from("1500000000");
          maxFeePerGas = block2.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);
        }
        return { lastBaseFeePerGas, maxFeePerGas, maxPriorityFeePerGas, gasPrice };
      });
    }
    // Alias for "on"
    addListener(eventName, listener) {
      return this.on(eventName, listener);
    }
    // Alias for "off"
    removeListener(eventName, listener) {
      return this.off(eventName, listener);
    }
    static isProvider(value) {
      return !!(value && value._isProvider);
    }
  };

  // node_modules/@ethersproject/abstract-signer/lib.esm/_version.js
  var version14 = "abstract-signer/5.7.0";

  // node_modules/@ethersproject/abstract-signer/lib.esm/index.js
  var __awaiter5 = function(thisArg, _arguments, P7, generator) {
    function adopt(value) {
      return value instanceof P7 ? value : new P7(function(resolve) {
        resolve(value);
      });
    }
    return new (P7 || (P7 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e9) {
          reject(e9);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e9) {
          reject(e9);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var logger16 = new Logger(version14);
  var allowedTransactionKeys = [
    "accessList",
    "ccipReadEnabled",
    "chainId",
    "customData",
    "data",
    "from",
    "gasLimit",
    "gasPrice",
    "maxFeePerGas",
    "maxPriorityFeePerGas",
    "nonce",
    "to",
    "type",
    "value"
  ];
  var forwardErrors = [
    Logger.errors.INSUFFICIENT_FUNDS,
    Logger.errors.NONCE_EXPIRED,
    Logger.errors.REPLACEMENT_UNDERPRICED
  ];
  var Signer = class {
    ///////////////////
    // Sub-classes MUST call super
    constructor() {
      logger16.checkAbstract(new.target, Signer);
      defineReadOnly(this, "_isSigner", true);
    }
    ///////////////////
    // Sub-classes MAY override these
    getBalance(blockTag) {
      return __awaiter5(this, void 0, void 0, function* () {
        this._checkProvider("getBalance");
        return yield this.provider.getBalance(this.getAddress(), blockTag);
      });
    }
    getTransactionCount(blockTag) {
      return __awaiter5(this, void 0, void 0, function* () {
        this._checkProvider("getTransactionCount");
        return yield this.provider.getTransactionCount(this.getAddress(), blockTag);
      });
    }
    // Populates "from" if unspecified, and estimates the gas for the transaction
    estimateGas(transaction) {
      return __awaiter5(this, void 0, void 0, function* () {
        this._checkProvider("estimateGas");
        const tx = yield resolveProperties(this.checkTransaction(transaction));
        return yield this.provider.estimateGas(tx);
      });
    }
    // Populates "from" if unspecified, and calls with the transaction
    call(transaction, blockTag) {
      return __awaiter5(this, void 0, void 0, function* () {
        this._checkProvider("call");
        const tx = yield resolveProperties(this.checkTransaction(transaction));
        return yield this.provider.call(tx, blockTag);
      });
    }
    // Populates all fields in a transaction, signs it and sends it to the network
    sendTransaction(transaction) {
      return __awaiter5(this, void 0, void 0, function* () {
        this._checkProvider("sendTransaction");
        const tx = yield this.populateTransaction(transaction);
        const signedTx = yield this.signTransaction(tx);
        return yield this.provider.sendTransaction(signedTx);
      });
    }
    getChainId() {
      return __awaiter5(this, void 0, void 0, function* () {
        this._checkProvider("getChainId");
        const network = yield this.provider.getNetwork();
        return network.chainId;
      });
    }
    getGasPrice() {
      return __awaiter5(this, void 0, void 0, function* () {
        this._checkProvider("getGasPrice");
        return yield this.provider.getGasPrice();
      });
    }
    getFeeData() {
      return __awaiter5(this, void 0, void 0, function* () {
        this._checkProvider("getFeeData");
        return yield this.provider.getFeeData();
      });
    }
    resolveName(name2) {
      return __awaiter5(this, void 0, void 0, function* () {
        this._checkProvider("resolveName");
        return yield this.provider.resolveName(name2);
      });
    }
    // Checks a transaction does not contain invalid keys and if
    // no "from" is provided, populates it.
    // - does NOT require a provider
    // - adds "from" is not present
    // - returns a COPY (safe to mutate the result)
    // By default called from: (overriding these prevents it)
    //   - call
    //   - estimateGas
    //   - populateTransaction (and therefor sendTransaction)
    checkTransaction(transaction) {
      for (const key2 in transaction) {
        if (allowedTransactionKeys.indexOf(key2) === -1) {
          logger16.throwArgumentError("invalid transaction key: " + key2, "transaction", transaction);
        }
      }
      const tx = shallowCopy(transaction);
      if (tx.from == null) {
        tx.from = this.getAddress();
      } else {
        tx.from = Promise.all([
          Promise.resolve(tx.from),
          this.getAddress()
        ]).then((result) => {
          if (result[0].toLowerCase() !== result[1].toLowerCase()) {
            logger16.throwArgumentError("from address mismatch", "transaction", transaction);
          }
          return result[0];
        });
      }
      return tx;
    }
    // Populates ALL keys for a transaction and checks that "from" matches
    // this Signer. Should be used by sendTransaction but NOT by signTransaction.
    // By default called from: (overriding these prevents it)
    //   - sendTransaction
    //
    // Notes:
    //  - We allow gasPrice for EIP-1559 as long as it matches maxFeePerGas
    populateTransaction(transaction) {
      return __awaiter5(this, void 0, void 0, function* () {
        const tx = yield resolveProperties(this.checkTransaction(transaction));
        if (tx.to != null) {
          tx.to = Promise.resolve(tx.to).then((to3) => __awaiter5(this, void 0, void 0, function* () {
            if (to3 == null) {
              return null;
            }
            const address = yield this.resolveName(to3);
            if (address == null) {
              logger16.throwArgumentError("provided ENS name resolves to null", "tx.to", to3);
            }
            return address;
          }));
          tx.to.catch((error) => {
          });
        }
        const hasEip1559 = tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null;
        if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {
          logger16.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", transaction);
        } else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {
          logger16.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", transaction);
        }
        if ((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null)) {
          tx.type = 2;
        } else if (tx.type === 0 || tx.type === 1) {
          if (tx.gasPrice == null) {
            tx.gasPrice = this.getGasPrice();
          }
        } else {
          const feeData = yield this.getFeeData();
          if (tx.type == null) {
            if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
              tx.type = 2;
              if (tx.gasPrice != null) {
                const gasPrice = tx.gasPrice;
                delete tx.gasPrice;
                tx.maxFeePerGas = gasPrice;
                tx.maxPriorityFeePerGas = gasPrice;
              } else {
                if (tx.maxFeePerGas == null) {
                  tx.maxFeePerGas = feeData.maxFeePerGas;
                }
                if (tx.maxPriorityFeePerGas == null) {
                  tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
                }
              }
            } else if (feeData.gasPrice != null) {
              if (hasEip1559) {
                logger16.throwError("network does not support EIP-1559", Logger.errors.UNSUPPORTED_OPERATION, {
                  operation: "populateTransaction"
                });
              }
              if (tx.gasPrice == null) {
                tx.gasPrice = feeData.gasPrice;
              }
              tx.type = 0;
            } else {
              logger16.throwError("failed to get consistent fee data", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "signer.getFeeData"
              });
            }
          } else if (tx.type === 2) {
            if (tx.maxFeePerGas == null) {
              tx.maxFeePerGas = feeData.maxFeePerGas;
            }
            if (tx.maxPriorityFeePerGas == null) {
              tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
            }
          }
        }
        if (tx.nonce == null) {
          tx.nonce = this.getTransactionCount("pending");
        }
        if (tx.gasLimit == null) {
          tx.gasLimit = this.estimateGas(tx).catch((error) => {
            if (forwardErrors.indexOf(error.code) >= 0) {
              throw error;
            }
            return logger16.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
              error,
              tx
            });
          });
        }
        if (tx.chainId == null) {
          tx.chainId = this.getChainId();
        } else {
          tx.chainId = Promise.all([
            Promise.resolve(tx.chainId),
            this.getChainId()
          ]).then((results2) => {
            if (results2[1] !== 0 && results2[0] !== results2[1]) {
              logger16.throwArgumentError("chainId address mismatch", "transaction", transaction);
            }
            return results2[0];
          });
        }
        return yield resolveProperties(tx);
      });
    }
    ///////////////////
    // Sub-classes SHOULD leave these alone
    _checkProvider(operation) {
      if (!this.provider) {
        logger16.throwError("missing provider", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: operation || "_checkProvider"
        });
      }
    }
    static isSigner(value) {
      return !!(value && value._isSigner);
    }
  };
  var VoidSigner = class extends Signer {
    constructor(address, provider) {
      super();
      defineReadOnly(this, "address", address);
      defineReadOnly(this, "provider", provider || null);
    }
    getAddress() {
      return Promise.resolve(this.address);
    }
    _fail(message, operation) {
      return Promise.resolve().then(() => {
        logger16.throwError(message, Logger.errors.UNSUPPORTED_OPERATION, { operation });
      });
    }
    signMessage(message) {
      return this._fail("VoidSigner cannot sign messages", "signMessage");
    }
    signTransaction(transaction) {
      return this._fail("VoidSigner cannot sign transactions", "signTransaction");
    }
    _signTypedData(domain2, types, value) {
      return this._fail("VoidSigner cannot sign typed data", "signTypedData");
    }
    connect(provider) {
      return new VoidSigner(this.address, provider);
    }
  };

  // node_modules/@ethersproject/signing-key/lib.esm/elliptic.js
  var import_bn2 = __toESM(require_bn());
  var import_hash2 = __toESM(require_hash2());
  function createCommonjsModule(fn2, basedir, module) {
    return module = {
      path: basedir,
      exports: {},
      require: function(path, base4) {
        return commonjsRequire(path, base4 === void 0 || base4 === null ? module.path : base4);
      }
    }, fn2(module, module.exports), module.exports;
  }
  function commonjsRequire() {
    throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
  }
  var minimalisticAssert = assert2;
  function assert2(val, msg) {
    if (!val)
      throw new Error(msg || "Assertion failed");
  }
  assert2.equal = function assertEqual(l9, r8, msg) {
    if (l9 != r8)
      throw new Error(msg || "Assertion failed: " + l9 + " != " + r8);
  };
  var utils_1 = createCommonjsModule(function(module, exports) {
    "use strict";
    var utils = exports;
    function toArray2(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg !== "string") {
        for (var i7 = 0; i7 < msg.length; i7++)
          res[i7] = msg[i7] | 0;
        return res;
      }
      if (enc === "hex") {
        msg = msg.replace(/[^a-z0-9]+/ig, "");
        if (msg.length % 2 !== 0)
          msg = "0" + msg;
        for (var i7 = 0; i7 < msg.length; i7 += 2)
          res.push(parseInt(msg[i7] + msg[i7 + 1], 16));
      } else {
        for (var i7 = 0; i7 < msg.length; i7++) {
          var c9 = msg.charCodeAt(i7);
          var hi2 = c9 >> 8;
          var lo3 = c9 & 255;
          if (hi2)
            res.push(hi2, lo3);
          else
            res.push(lo3);
        }
      }
      return res;
    }
    utils.toArray = toArray2;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    utils.zero2 = zero2;
    function toHex3(msg) {
      var res = "";
      for (var i7 = 0; i7 < msg.length; i7++)
        res += zero2(msg[i7].toString(16));
      return res;
    }
    utils.toHex = toHex3;
    utils.encode = function encode10(arr, enc) {
      if (enc === "hex")
        return toHex3(arr);
      else
        return arr;
    };
  });
  var utils_1$1 = createCommonjsModule(function(module, exports) {
    "use strict";
    var utils = exports;
    utils.assert = minimalisticAssert;
    utils.toArray = utils_1.toArray;
    utils.zero2 = utils_1.zero2;
    utils.toHex = utils_1.toHex;
    utils.encode = utils_1.encode;
    function getNAF2(num, w8, bits) {
      var naf = new Array(Math.max(num.bitLength(), bits) + 1);
      naf.fill(0);
      var ws3 = 1 << w8 + 1;
      var k6 = num.clone();
      for (var i7 = 0; i7 < naf.length; i7++) {
        var z7;
        var mod = k6.andln(ws3 - 1);
        if (k6.isOdd()) {
          if (mod > (ws3 >> 1) - 1)
            z7 = (ws3 >> 1) - mod;
          else
            z7 = mod;
          k6.isubn(z7);
        } else {
          z7 = 0;
        }
        naf[i7] = z7;
        k6.iushrn(1);
      }
      return naf;
    }
    utils.getNAF = getNAF2;
    function getJSF2(k1, k22) {
      var jsf = [
        [],
        []
      ];
      k1 = k1.clone();
      k22 = k22.clone();
      var d1 = 0;
      var d22 = 0;
      var m8;
      while (k1.cmpn(-d1) > 0 || k22.cmpn(-d22) > 0) {
        var m14 = k1.andln(3) + d1 & 3;
        var m24 = k22.andln(3) + d22 & 3;
        if (m14 === 3)
          m14 = -1;
        if (m24 === 3)
          m24 = -1;
        var u1;
        if ((m14 & 1) === 0) {
          u1 = 0;
        } else {
          m8 = k1.andln(7) + d1 & 7;
          if ((m8 === 3 || m8 === 5) && m24 === 2)
            u1 = -m14;
          else
            u1 = m14;
        }
        jsf[0].push(u1);
        var u22;
        if ((m24 & 1) === 0) {
          u22 = 0;
        } else {
          m8 = k22.andln(7) + d22 & 7;
          if ((m8 === 3 || m8 === 5) && m14 === 2)
            u22 = -m24;
          else
            u22 = m24;
        }
        jsf[1].push(u22);
        if (2 * d1 === u1 + 1)
          d1 = 1 - d1;
        if (2 * d22 === u22 + 1)
          d22 = 1 - d22;
        k1.iushrn(1);
        k22.iushrn(1);
      }
      return jsf;
    }
    utils.getJSF = getJSF2;
    function cachedProperty(obj, name2, computer) {
      var key2 = "_" + name2;
      obj.prototype[name2] = function cachedProperty2() {
        return this[key2] !== void 0 ? this[key2] : this[key2] = computer.call(this);
      };
    }
    utils.cachedProperty = cachedProperty;
    function parseBytes(bytes3) {
      return typeof bytes3 === "string" ? utils.toArray(bytes3, "hex") : bytes3;
    }
    utils.parseBytes = parseBytes;
    function intFromLE(bytes3) {
      return new import_bn2.default(bytes3, "hex", "le");
    }
    utils.intFromLE = intFromLE;
  });
  var getNAF = utils_1$1.getNAF;
  var getJSF = utils_1$1.getJSF;
  var assert$1 = utils_1$1.assert;
  function BaseCurve(type, conf) {
    this.type = type;
    this.p = new import_bn2.default(conf.p, 16);
    this.red = conf.prime ? import_bn2.default.red(conf.prime) : import_bn2.default.mont(this.p);
    this.zero = new import_bn2.default(0).toRed(this.red);
    this.one = new import_bn2.default(1).toRed(this.red);
    this.two = new import_bn2.default(2).toRed(this.red);
    this.n = conf.n && new import_bn2.default(conf.n, 16);
    this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
    this._wnafT1 = new Array(4);
    this._wnafT2 = new Array(4);
    this._wnafT3 = new Array(4);
    this._wnafT4 = new Array(4);
    this._bitLength = this.n ? this.n.bitLength() : 0;
    var adjustCount = this.n && this.p.div(this.n);
    if (!adjustCount || adjustCount.cmpn(100) > 0) {
      this.redN = null;
    } else {
      this._maxwellTrick = true;
      this.redN = this.n.toRed(this.red);
    }
  }
  var base3 = BaseCurve;
  BaseCurve.prototype.point = function point() {
    throw new Error("Not implemented");
  };
  BaseCurve.prototype.validate = function validate() {
    throw new Error("Not implemented");
  };
  BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p8, k6) {
    assert$1(p8.precomputed);
    var doubles = p8._getDoubles();
    var naf = getNAF(k6, 1, this._bitLength);
    var I5 = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
    I5 /= 3;
    var repr = [];
    var j7;
    var nafW;
    for (j7 = 0; j7 < naf.length; j7 += doubles.step) {
      nafW = 0;
      for (var l9 = j7 + doubles.step - 1; l9 >= j7; l9--)
        nafW = (nafW << 1) + naf[l9];
      repr.push(nafW);
    }
    var a6 = this.jpoint(null, null, null);
    var b7 = this.jpoint(null, null, null);
    for (var i7 = I5; i7 > 0; i7--) {
      for (j7 = 0; j7 < repr.length; j7++) {
        nafW = repr[j7];
        if (nafW === i7)
          b7 = b7.mixedAdd(doubles.points[j7]);
        else if (nafW === -i7)
          b7 = b7.mixedAdd(doubles.points[j7].neg());
      }
      a6 = a6.add(b7);
    }
    return a6.toP();
  };
  BaseCurve.prototype._wnafMul = function _wnafMul(p8, k6) {
    var w8 = 4;
    var nafPoints = p8._getNAFPoints(w8);
    w8 = nafPoints.wnd;
    var wnd = nafPoints.points;
    var naf = getNAF(k6, w8, this._bitLength);
    var acc = this.jpoint(null, null, null);
    for (var i7 = naf.length - 1; i7 >= 0; i7--) {
      for (var l9 = 0; i7 >= 0 && naf[i7] === 0; i7--)
        l9++;
      if (i7 >= 0)
        l9++;
      acc = acc.dblp(l9);
      if (i7 < 0)
        break;
      var z7 = naf[i7];
      assert$1(z7 !== 0);
      if (p8.type === "affine") {
        if (z7 > 0)
          acc = acc.mixedAdd(wnd[z7 - 1 >> 1]);
        else
          acc = acc.mixedAdd(wnd[-z7 - 1 >> 1].neg());
      } else {
        if (z7 > 0)
          acc = acc.add(wnd[z7 - 1 >> 1]);
        else
          acc = acc.add(wnd[-z7 - 1 >> 1].neg());
      }
    }
    return p8.type === "affine" ? acc.toP() : acc;
  };
  BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
    var wndWidth = this._wnafT1;
    var wnd = this._wnafT2;
    var naf = this._wnafT3;
    var max = 0;
    var i7;
    var j7;
    var p8;
    for (i7 = 0; i7 < len; i7++) {
      p8 = points[i7];
      var nafPoints = p8._getNAFPoints(defW);
      wndWidth[i7] = nafPoints.wnd;
      wnd[i7] = nafPoints.points;
    }
    for (i7 = len - 1; i7 >= 1; i7 -= 2) {
      var a6 = i7 - 1;
      var b7 = i7;
      if (wndWidth[a6] !== 1 || wndWidth[b7] !== 1) {
        naf[a6] = getNAF(coeffs[a6], wndWidth[a6], this._bitLength);
        naf[b7] = getNAF(coeffs[b7], wndWidth[b7], this._bitLength);
        max = Math.max(naf[a6].length, max);
        max = Math.max(naf[b7].length, max);
        continue;
      }
      var comb = [
        points[a6],
        /* 1 */
        null,
        /* 3 */
        null,
        /* 5 */
        points[b7]
        /* 7 */
      ];
      if (points[a6].y.cmp(points[b7].y) === 0) {
        comb[1] = points[a6].add(points[b7]);
        comb[2] = points[a6].toJ().mixedAdd(points[b7].neg());
      } else if (points[a6].y.cmp(points[b7].y.redNeg()) === 0) {
        comb[1] = points[a6].toJ().mixedAdd(points[b7]);
        comb[2] = points[a6].add(points[b7].neg());
      } else {
        comb[1] = points[a6].toJ().mixedAdd(points[b7]);
        comb[2] = points[a6].toJ().mixedAdd(points[b7].neg());
      }
      var index2 = [
        -3,
        /* -1 -1 */
        -1,
        /* -1 0 */
        -5,
        /* -1 1 */
        -7,
        /* 0 -1 */
        0,
        /* 0 0 */
        7,
        /* 0 1 */
        5,
        /* 1 -1 */
        1,
        /* 1 0 */
        3
        /* 1 1 */
      ];
      var jsf = getJSF(coeffs[a6], coeffs[b7]);
      max = Math.max(jsf[0].length, max);
      naf[a6] = new Array(max);
      naf[b7] = new Array(max);
      for (j7 = 0; j7 < max; j7++) {
        var ja2 = jsf[0][j7] | 0;
        var jb = jsf[1][j7] | 0;
        naf[a6][j7] = index2[(ja2 + 1) * 3 + (jb + 1)];
        naf[b7][j7] = 0;
        wnd[a6] = comb;
      }
    }
    var acc = this.jpoint(null, null, null);
    var tmp = this._wnafT4;
    for (i7 = max; i7 >= 0; i7--) {
      var k6 = 0;
      while (i7 >= 0) {
        var zero = true;
        for (j7 = 0; j7 < len; j7++) {
          tmp[j7] = naf[j7][i7] | 0;
          if (tmp[j7] !== 0)
            zero = false;
        }
        if (!zero)
          break;
        k6++;
        i7--;
      }
      if (i7 >= 0)
        k6++;
      acc = acc.dblp(k6);
      if (i7 < 0)
        break;
      for (j7 = 0; j7 < len; j7++) {
        var z7 = tmp[j7];
        p8;
        if (z7 === 0)
          continue;
        else if (z7 > 0)
          p8 = wnd[j7][z7 - 1 >> 1];
        else if (z7 < 0)
          p8 = wnd[j7][-z7 - 1 >> 1].neg();
        if (p8.type === "affine")
          acc = acc.mixedAdd(p8);
        else
          acc = acc.add(p8);
      }
    }
    for (i7 = 0; i7 < len; i7++)
      wnd[i7] = null;
    if (jacobianResult)
      return acc;
    else
      return acc.toP();
  };
  function BasePoint(curve, type) {
    this.curve = curve;
    this.type = type;
    this.precomputed = null;
  }
  BaseCurve.BasePoint = BasePoint;
  BasePoint.prototype.eq = function eq() {
    throw new Error("Not implemented");
  };
  BasePoint.prototype.validate = function validate2() {
    return this.curve.validate(this);
  };
  BaseCurve.prototype.decodePoint = function decodePoint(bytes3, enc) {
    bytes3 = utils_1$1.toArray(bytes3, enc);
    var len = this.p.byteLength();
    if ((bytes3[0] === 4 || bytes3[0] === 6 || bytes3[0] === 7) && bytes3.length - 1 === 2 * len) {
      if (bytes3[0] === 6)
        assert$1(bytes3[bytes3.length - 1] % 2 === 0);
      else if (bytes3[0] === 7)
        assert$1(bytes3[bytes3.length - 1] % 2 === 1);
      var res = this.point(
        bytes3.slice(1, 1 + len),
        bytes3.slice(1 + len, 1 + 2 * len)
      );
      return res;
    } else if ((bytes3[0] === 2 || bytes3[0] === 3) && bytes3.length - 1 === len) {
      return this.pointFromX(bytes3.slice(1, 1 + len), bytes3[0] === 3);
    }
    throw new Error("Unknown point format");
  };
  BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
    return this.encode(enc, true);
  };
  BasePoint.prototype._encode = function _encode2(compact) {
    var len = this.curve.p.byteLength();
    var x4 = this.getX().toArray("be", len);
    if (compact)
      return [this.getY().isEven() ? 2 : 3].concat(x4);
    return [4].concat(x4, this.getY().toArray("be", len));
  };
  BasePoint.prototype.encode = function encode9(enc, compact) {
    return utils_1$1.encode(this._encode(compact), enc);
  };
  BasePoint.prototype.precompute = function precompute(power) {
    if (this.precomputed)
      return this;
    var precomputed = {
      doubles: null,
      naf: null,
      beta: null
    };
    precomputed.naf = this._getNAFPoints(8);
    precomputed.doubles = this._getDoubles(4, power);
    precomputed.beta = this._getBeta();
    this.precomputed = precomputed;
    return this;
  };
  BasePoint.prototype._hasDoubles = function _hasDoubles(k6) {
    if (!this.precomputed)
      return false;
    var doubles = this.precomputed.doubles;
    if (!doubles)
      return false;
    return doubles.points.length >= Math.ceil((k6.bitLength() + 1) / doubles.step);
  };
  BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
    if (this.precomputed && this.precomputed.doubles)
      return this.precomputed.doubles;
    var doubles = [this];
    var acc = this;
    for (var i7 = 0; i7 < power; i7 += step) {
      for (var j7 = 0; j7 < step; j7++)
        acc = acc.dbl();
      doubles.push(acc);
    }
    return {
      step,
      points: doubles
    };
  };
  BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
    if (this.precomputed && this.precomputed.naf)
      return this.precomputed.naf;
    var res = [this];
    var max = (1 << wnd) - 1;
    var dbl3 = max === 1 ? null : this.dbl();
    for (var i7 = 1; i7 < max; i7++)
      res[i7] = res[i7 - 1].add(dbl3);
    return {
      wnd,
      points: res
    };
  };
  BasePoint.prototype._getBeta = function _getBeta() {
    return null;
  };
  BasePoint.prototype.dblp = function dblp(k6) {
    var r8 = this;
    for (var i7 = 0; i7 < k6; i7++)
      r8 = r8.dbl();
    return r8;
  };
  var inherits_browser = createCommonjsModule(function(module) {
    if (typeof Object.create === "function") {
      module.exports = function inherits2(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module.exports = function inherits2(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  });
  var assert$2 = utils_1$1.assert;
  function ShortCurve(conf) {
    base3.call(this, "short", conf);
    this.a = new import_bn2.default(conf.a, 16).toRed(this.red);
    this.b = new import_bn2.default(conf.b, 16).toRed(this.red);
    this.tinv = this.two.redInvm();
    this.zeroA = this.a.fromRed().cmpn(0) === 0;
    this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
    this.endo = this._getEndomorphism(conf);
    this._endoWnafT1 = new Array(4);
    this._endoWnafT2 = new Array(4);
  }
  inherits_browser(ShortCurve, base3);
  var short_1 = ShortCurve;
  ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
    if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
      return;
    var beta;
    var lambda;
    if (conf.beta) {
      beta = new import_bn2.default(conf.beta, 16).toRed(this.red);
    } else {
      var betas = this._getEndoRoots(this.p);
      beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
      beta = beta.toRed(this.red);
    }
    if (conf.lambda) {
      lambda = new import_bn2.default(conf.lambda, 16);
    } else {
      var lambdas = this._getEndoRoots(this.n);
      if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
        lambda = lambdas[0];
      } else {
        lambda = lambdas[1];
        assert$2(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
      }
    }
    var basis;
    if (conf.basis) {
      basis = conf.basis.map(function(vec) {
        return {
          a: new import_bn2.default(vec.a, 16),
          b: new import_bn2.default(vec.b, 16)
        };
      });
    } else {
      basis = this._getEndoBasis(lambda);
    }
    return {
      beta,
      lambda,
      basis
    };
  };
  ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
    var red = num === this.p ? this.red : import_bn2.default.mont(num);
    var tinv = new import_bn2.default(2).toRed(red).redInvm();
    var ntinv = tinv.redNeg();
    var s7 = new import_bn2.default(3).toRed(red).redNeg().redSqrt().redMul(tinv);
    var l1 = ntinv.redAdd(s7).fromRed();
    var l22 = ntinv.redSub(s7).fromRed();
    return [l1, l22];
  };
  ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
    var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
    var u7 = lambda;
    var v6 = this.n.clone();
    var x1 = new import_bn2.default(1);
    var y1 = new import_bn2.default(0);
    var x22 = new import_bn2.default(0);
    var y22 = new import_bn2.default(1);
    var a0;
    var b0;
    var a1;
    var b1;
    var a22;
    var b22;
    var prevR;
    var i7 = 0;
    var r8;
    var x4;
    while (u7.cmpn(0) !== 0) {
      var q8 = v6.div(u7);
      r8 = v6.sub(q8.mul(u7));
      x4 = x22.sub(q8.mul(x1));
      var y11 = y22.sub(q8.mul(y1));
      if (!a1 && r8.cmp(aprxSqrt) < 0) {
        a0 = prevR.neg();
        b0 = x1;
        a1 = r8.neg();
        b1 = x4;
      } else if (a1 && ++i7 === 2) {
        break;
      }
      prevR = r8;
      v6 = u7;
      u7 = r8;
      x22 = x1;
      x1 = x4;
      y22 = y1;
      y1 = y11;
    }
    a22 = r8.neg();
    b22 = x4;
    var len1 = a1.sqr().add(b1.sqr());
    var len2 = a22.sqr().add(b22.sqr());
    if (len2.cmp(len1) >= 0) {
      a22 = a0;
      b22 = b0;
    }
    if (a1.negative) {
      a1 = a1.neg();
      b1 = b1.neg();
    }
    if (a22.negative) {
      a22 = a22.neg();
      b22 = b22.neg();
    }
    return [
      { a: a1, b: b1 },
      { a: a22, b: b22 }
    ];
  };
  ShortCurve.prototype._endoSplit = function _endoSplit(k6) {
    var basis = this.endo.basis;
    var v1 = basis[0];
    var v22 = basis[1];
    var c1 = v22.b.mul(k6).divRound(this.n);
    var c22 = v1.b.neg().mul(k6).divRound(this.n);
    var p1 = c1.mul(v1.a);
    var p22 = c22.mul(v22.a);
    var q1 = c1.mul(v1.b);
    var q22 = c22.mul(v22.b);
    var k1 = k6.sub(p1).sub(p22);
    var k22 = q1.add(q22).neg();
    return { k1, k2: k22 };
  };
  ShortCurve.prototype.pointFromX = function pointFromX(x4, odd) {
    x4 = new import_bn2.default(x4, 16);
    if (!x4.red)
      x4 = x4.toRed(this.red);
    var y22 = x4.redSqr().redMul(x4).redIAdd(x4.redMul(this.a)).redIAdd(this.b);
    var y11 = y22.redSqrt();
    if (y11.redSqr().redSub(y22).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var isOdd = y11.fromRed().isOdd();
    if (odd && !isOdd || !odd && isOdd)
      y11 = y11.redNeg();
    return this.point(x4, y11);
  };
  ShortCurve.prototype.validate = function validate3(point3) {
    if (point3.inf)
      return true;
    var x4 = point3.x;
    var y11 = point3.y;
    var ax = this.a.redMul(x4);
    var rhs = x4.redSqr().redMul(x4).redIAdd(ax).redIAdd(this.b);
    return y11.redSqr().redISub(rhs).cmpn(0) === 0;
  };
  ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
    var npoints = this._endoWnafT1;
    var ncoeffs = this._endoWnafT2;
    for (var i7 = 0; i7 < points.length; i7++) {
      var split2 = this._endoSplit(coeffs[i7]);
      var p8 = points[i7];
      var beta = p8._getBeta();
      if (split2.k1.negative) {
        split2.k1.ineg();
        p8 = p8.neg(true);
      }
      if (split2.k2.negative) {
        split2.k2.ineg();
        beta = beta.neg(true);
      }
      npoints[i7 * 2] = p8;
      npoints[i7 * 2 + 1] = beta;
      ncoeffs[i7 * 2] = split2.k1;
      ncoeffs[i7 * 2 + 1] = split2.k2;
    }
    var res = this._wnafMulAdd(1, npoints, ncoeffs, i7 * 2, jacobianResult);
    for (var j7 = 0; j7 < i7 * 2; j7++) {
      npoints[j7] = null;
      ncoeffs[j7] = null;
    }
    return res;
  };
  function Point(curve, x4, y11, isRed) {
    base3.BasePoint.call(this, curve, "affine");
    if (x4 === null && y11 === null) {
      this.x = null;
      this.y = null;
      this.inf = true;
    } else {
      this.x = new import_bn2.default(x4, 16);
      this.y = new import_bn2.default(y11, 16);
      if (isRed) {
        this.x.forceRed(this.curve.red);
        this.y.forceRed(this.curve.red);
      }
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      this.inf = false;
    }
  }
  inherits_browser(Point, base3.BasePoint);
  ShortCurve.prototype.point = function point2(x4, y11, isRed) {
    return new Point(this, x4, y11, isRed);
  };
  ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
    return Point.fromJSON(this, obj, red);
  };
  Point.prototype._getBeta = function _getBeta2() {
    if (!this.curve.endo)
      return;
    var pre = this.precomputed;
    if (pre && pre.beta)
      return pre.beta;
    var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (pre) {
      var curve = this.curve;
      var endoMul = function(p8) {
        return curve.point(p8.x.redMul(curve.endo.beta), p8.y);
      };
      pre.beta = beta;
      beta.precomputed = {
        beta: null,
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: pre.naf.points.map(endoMul)
        },
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: pre.doubles.points.map(endoMul)
        }
      };
    }
    return beta;
  };
  Point.prototype.toJSON = function toJSON2() {
    if (!this.precomputed)
      return [this.x, this.y];
    return [this.x, this.y, this.precomputed && {
      doubles: this.precomputed.doubles && {
        step: this.precomputed.doubles.step,
        points: this.precomputed.doubles.points.slice(1)
      },
      naf: this.precomputed.naf && {
        wnd: this.precomputed.naf.wnd,
        points: this.precomputed.naf.points.slice(1)
      }
    }];
  };
  Point.fromJSON = function fromJSON(curve, obj, red) {
    if (typeof obj === "string")
      obj = JSON.parse(obj);
    var res = curve.point(obj[0], obj[1], red);
    if (!obj[2])
      return res;
    function obj2point(obj2) {
      return curve.point(obj2[0], obj2[1], red);
    }
    var pre = obj[2];
    res.precomputed = {
      beta: null,
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: [res].concat(pre.doubles.points.map(obj2point))
      },
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: [res].concat(pre.naf.points.map(obj2point))
      }
    };
    return res;
  };
  Point.prototype.inspect = function inspect() {
    if (this.isInfinity())
      return "<EC Point Infinity>";
    return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
  };
  Point.prototype.isInfinity = function isInfinity() {
    return this.inf;
  };
  Point.prototype.add = function add2(p8) {
    if (this.inf)
      return p8;
    if (p8.inf)
      return this;
    if (this.eq(p8))
      return this.dbl();
    if (this.neg().eq(p8))
      return this.curve.point(null, null);
    if (this.x.cmp(p8.x) === 0)
      return this.curve.point(null, null);
    var c9 = this.y.redSub(p8.y);
    if (c9.cmpn(0) !== 0)
      c9 = c9.redMul(this.x.redSub(p8.x).redInvm());
    var nx = c9.redSqr().redISub(this.x).redISub(p8.x);
    var ny = c9.redMul(this.x.redSub(nx)).redISub(this.y);
    return this.curve.point(nx, ny);
  };
  Point.prototype.dbl = function dbl() {
    if (this.inf)
      return this;
    var ys1 = this.y.redAdd(this.y);
    if (ys1.cmpn(0) === 0)
      return this.curve.point(null, null);
    var a6 = this.curve.a;
    var x22 = this.x.redSqr();
    var dyinv = ys1.redInvm();
    var c9 = x22.redAdd(x22).redIAdd(x22).redIAdd(a6).redMul(dyinv);
    var nx = c9.redSqr().redISub(this.x.redAdd(this.x));
    var ny = c9.redMul(this.x.redSub(nx)).redISub(this.y);
    return this.curve.point(nx, ny);
  };
  Point.prototype.getX = function getX() {
    return this.x.fromRed();
  };
  Point.prototype.getY = function getY() {
    return this.y.fromRed();
  };
  Point.prototype.mul = function mul(k6) {
    k6 = new import_bn2.default(k6, 16);
    if (this.isInfinity())
      return this;
    else if (this._hasDoubles(k6))
      return this.curve._fixedNafMul(this, k6);
    else if (this.curve.endo)
      return this.curve._endoWnafMulAdd([this], [k6]);
    else
      return this.curve._wnafMul(this, k6);
  };
  Point.prototype.mulAdd = function mulAdd(k1, p22, k22) {
    var points = [this, p22];
    var coeffs = [k1, k22];
    if (this.curve.endo)
      return this.curve._endoWnafMulAdd(points, coeffs);
    else
      return this.curve._wnafMulAdd(1, points, coeffs, 2);
  };
  Point.prototype.jmulAdd = function jmulAdd(k1, p22, k22) {
    var points = [this, p22];
    var coeffs = [k1, k22];
    if (this.curve.endo)
      return this.curve._endoWnafMulAdd(points, coeffs, true);
    else
      return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
  };
  Point.prototype.eq = function eq2(p8) {
    return this === p8 || this.inf === p8.inf && (this.inf || this.x.cmp(p8.x) === 0 && this.y.cmp(p8.y) === 0);
  };
  Point.prototype.neg = function neg(_precompute) {
    if (this.inf)
      return this;
    var res = this.curve.point(this.x, this.y.redNeg());
    if (_precompute && this.precomputed) {
      var pre = this.precomputed;
      var negate = function(p8) {
        return p8.neg();
      };
      res.precomputed = {
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: pre.naf.points.map(negate)
        },
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: pre.doubles.points.map(negate)
        }
      };
    }
    return res;
  };
  Point.prototype.toJ = function toJ() {
    if (this.inf)
      return this.curve.jpoint(null, null, null);
    var res = this.curve.jpoint(this.x, this.y, this.curve.one);
    return res;
  };
  function JPoint(curve, x4, y11, z7) {
    base3.BasePoint.call(this, curve, "jacobian");
    if (x4 === null && y11 === null && z7 === null) {
      this.x = this.curve.one;
      this.y = this.curve.one;
      this.z = new import_bn2.default(0);
    } else {
      this.x = new import_bn2.default(x4, 16);
      this.y = new import_bn2.default(y11, 16);
      this.z = new import_bn2.default(z7, 16);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;
  }
  inherits_browser(JPoint, base3.BasePoint);
  ShortCurve.prototype.jpoint = function jpoint(x4, y11, z7) {
    return new JPoint(this, x4, y11, z7);
  };
  JPoint.prototype.toP = function toP() {
    if (this.isInfinity())
      return this.curve.point(null, null);
    var zinv = this.z.redInvm();
    var zinv2 = zinv.redSqr();
    var ax = this.x.redMul(zinv2);
    var ay = this.y.redMul(zinv2).redMul(zinv);
    return this.curve.point(ax, ay);
  };
  JPoint.prototype.neg = function neg2() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
  };
  JPoint.prototype.add = function add3(p8) {
    if (this.isInfinity())
      return p8;
    if (p8.isInfinity())
      return this;
    var pz2 = p8.z.redSqr();
    var z22 = this.z.redSqr();
    var u1 = this.x.redMul(pz2);
    var u22 = p8.x.redMul(z22);
    var s1 = this.y.redMul(pz2.redMul(p8.z));
    var s22 = p8.y.redMul(z22.redMul(this.z));
    var h10 = u1.redSub(u22);
    var r8 = s1.redSub(s22);
    if (h10.cmpn(0) === 0) {
      if (r8.cmpn(0) !== 0)
        return this.curve.jpoint(null, null, null);
      else
        return this.dbl();
    }
    var h22 = h10.redSqr();
    var h32 = h22.redMul(h10);
    var v6 = u1.redMul(h22);
    var nx = r8.redSqr().redIAdd(h32).redISub(v6).redISub(v6);
    var ny = r8.redMul(v6.redISub(nx)).redISub(s1.redMul(h32));
    var nz = this.z.redMul(p8.z).redMul(h10);
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype.mixedAdd = function mixedAdd(p8) {
    if (this.isInfinity())
      return p8.toJ();
    if (p8.isInfinity())
      return this;
    var z22 = this.z.redSqr();
    var u1 = this.x;
    var u22 = p8.x.redMul(z22);
    var s1 = this.y;
    var s22 = p8.y.redMul(z22).redMul(this.z);
    var h10 = u1.redSub(u22);
    var r8 = s1.redSub(s22);
    if (h10.cmpn(0) === 0) {
      if (r8.cmpn(0) !== 0)
        return this.curve.jpoint(null, null, null);
      else
        return this.dbl();
    }
    var h22 = h10.redSqr();
    var h32 = h22.redMul(h10);
    var v6 = u1.redMul(h22);
    var nx = r8.redSqr().redIAdd(h32).redISub(v6).redISub(v6);
    var ny = r8.redMul(v6.redISub(nx)).redISub(s1.redMul(h32));
    var nz = this.z.redMul(h10);
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype.dblp = function dblp2(pow) {
    if (pow === 0)
      return this;
    if (this.isInfinity())
      return this;
    if (!pow)
      return this.dbl();
    var i7;
    if (this.curve.zeroA || this.curve.threeA) {
      var r8 = this;
      for (i7 = 0; i7 < pow; i7++)
        r8 = r8.dbl();
      return r8;
    }
    var a6 = this.curve.a;
    var tinv = this.curve.tinv;
    var jx = this.x;
    var jy = this.y;
    var jz = this.z;
    var jz4 = jz.redSqr().redSqr();
    var jyd = jy.redAdd(jy);
    for (i7 = 0; i7 < pow; i7++) {
      var jx2 = jx.redSqr();
      var jyd2 = jyd.redSqr();
      var jyd4 = jyd2.redSqr();
      var c9 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a6.redMul(jz4));
      var t1 = jx.redMul(jyd2);
      var nx = c9.redSqr().redISub(t1.redAdd(t1));
      var t22 = t1.redISub(nx);
      var dny = c9.redMul(t22);
      dny = dny.redIAdd(dny).redISub(jyd4);
      var nz = jyd.redMul(jz);
      if (i7 + 1 < pow)
        jz4 = jz4.redMul(jyd4);
      jx = nx;
      jz = nz;
      jyd = dny;
    }
    return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
  };
  JPoint.prototype.dbl = function dbl2() {
    if (this.isInfinity())
      return this;
    if (this.curve.zeroA)
      return this._zeroDbl();
    else if (this.curve.threeA)
      return this._threeDbl();
    else
      return this._dbl();
  };
  JPoint.prototype._zeroDbl = function _zeroDbl() {
    var nx;
    var ny;
    var nz;
    if (this.zOne) {
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var yyyy = yy.redSqr();
      var s7 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      s7 = s7.redIAdd(s7);
      var m6 = xx.redAdd(xx).redIAdd(xx);
      var t6 = m6.redSqr().redISub(s7).redISub(s7);
      var yyyy8 = yyyy.redIAdd(yyyy);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      nx = t6;
      ny = m6.redMul(s7.redISub(t6)).redISub(yyyy8);
      nz = this.y.redAdd(this.y);
    } else {
      var a6 = this.x.redSqr();
      var b7 = this.y.redSqr();
      var c9 = b7.redSqr();
      var d7 = this.x.redAdd(b7).redSqr().redISub(a6).redISub(c9);
      d7 = d7.redIAdd(d7);
      var e9 = a6.redAdd(a6).redIAdd(a6);
      var f7 = e9.redSqr();
      var c82 = c9.redIAdd(c9);
      c82 = c82.redIAdd(c82);
      c82 = c82.redIAdd(c82);
      nx = f7.redISub(d7).redISub(d7);
      ny = e9.redMul(d7.redISub(nx)).redISub(c82);
      nz = this.y.redMul(this.z);
      nz = nz.redIAdd(nz);
    }
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype._threeDbl = function _threeDbl() {
    var nx;
    var ny;
    var nz;
    if (this.zOne) {
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var yyyy = yy.redSqr();
      var s7 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      s7 = s7.redIAdd(s7);
      var m6 = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
      var t6 = m6.redSqr().redISub(s7).redISub(s7);
      nx = t6;
      var yyyy8 = yyyy.redIAdd(yyyy);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      ny = m6.redMul(s7.redISub(t6)).redISub(yyyy8);
      nz = this.y.redAdd(this.y);
    } else {
      var delta = this.z.redSqr();
      var gamma = this.y.redSqr();
      var beta = this.x.redMul(gamma);
      var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
      alpha = alpha.redAdd(alpha).redIAdd(alpha);
      var beta4 = beta.redIAdd(beta);
      beta4 = beta4.redIAdd(beta4);
      var beta8 = beta4.redAdd(beta4);
      nx = alpha.redSqr().redISub(beta8);
      nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
      var ggamma8 = gamma.redSqr();
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
    }
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype._dbl = function _dbl() {
    var a6 = this.curve.a;
    var jx = this.x;
    var jy = this.y;
    var jz = this.z;
    var jz4 = jz.redSqr().redSqr();
    var jx2 = jx.redSqr();
    var jy2 = jy.redSqr();
    var c9 = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a6.redMul(jz4));
    var jxd4 = jx.redAdd(jx);
    jxd4 = jxd4.redIAdd(jxd4);
    var t1 = jxd4.redMul(jy2);
    var nx = c9.redSqr().redISub(t1.redAdd(t1));
    var t22 = t1.redISub(nx);
    var jyd8 = jy2.redSqr();
    jyd8 = jyd8.redIAdd(jyd8);
    jyd8 = jyd8.redIAdd(jyd8);
    jyd8 = jyd8.redIAdd(jyd8);
    var ny = c9.redMul(t22).redISub(jyd8);
    var nz = jy.redAdd(jy).redMul(jz);
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype.trpl = function trpl() {
    if (!this.curve.zeroA)
      return this.dbl().add(this);
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var zz = this.z.redSqr();
    var yyyy = yy.redSqr();
    var m6 = xx.redAdd(xx).redIAdd(xx);
    var mm = m6.redSqr();
    var e9 = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    e9 = e9.redIAdd(e9);
    e9 = e9.redAdd(e9).redIAdd(e9);
    e9 = e9.redISub(mm);
    var ee6 = e9.redSqr();
    var t6 = yyyy.redIAdd(yyyy);
    t6 = t6.redIAdd(t6);
    t6 = t6.redIAdd(t6);
    t6 = t6.redIAdd(t6);
    var u7 = m6.redIAdd(e9).redSqr().redISub(mm).redISub(ee6).redISub(t6);
    var yyu4 = yy.redMul(u7);
    yyu4 = yyu4.redIAdd(yyu4);
    yyu4 = yyu4.redIAdd(yyu4);
    var nx = this.x.redMul(ee6).redISub(yyu4);
    nx = nx.redIAdd(nx);
    nx = nx.redIAdd(nx);
    var ny = this.y.redMul(u7.redMul(t6.redISub(u7)).redISub(e9.redMul(ee6)));
    ny = ny.redIAdd(ny);
    ny = ny.redIAdd(ny);
    ny = ny.redIAdd(ny);
    var nz = this.z.redAdd(e9).redSqr().redISub(zz).redISub(ee6);
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype.mul = function mul2(k6, kbase) {
    k6 = new import_bn2.default(k6, kbase);
    return this.curve._wnafMul(this, k6);
  };
  JPoint.prototype.eq = function eq3(p8) {
    if (p8.type === "affine")
      return this.eq(p8.toJ());
    if (this === p8)
      return true;
    var z22 = this.z.redSqr();
    var pz2 = p8.z.redSqr();
    if (this.x.redMul(pz2).redISub(p8.x.redMul(z22)).cmpn(0) !== 0)
      return false;
    var z32 = z22.redMul(this.z);
    var pz3 = pz2.redMul(p8.z);
    return this.y.redMul(pz3).redISub(p8.y.redMul(z32)).cmpn(0) === 0;
  };
  JPoint.prototype.eqXToP = function eqXToP(x4) {
    var zs2 = this.z.redSqr();
    var rx = x4.toRed(this.curve.red).redMul(zs2);
    if (this.x.cmp(rx) === 0)
      return true;
    var xc = x4.clone();
    var t6 = this.curve.redN.redMul(zs2);
    for (; ; ) {
      xc.iadd(this.curve.n);
      if (xc.cmp(this.curve.p) >= 0)
        return false;
      rx.redIAdd(t6);
      if (this.x.cmp(rx) === 0)
        return true;
    }
  };
  JPoint.prototype.inspect = function inspect2() {
    if (this.isInfinity())
      return "<EC JPoint Infinity>";
    return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
  };
  JPoint.prototype.isInfinity = function isInfinity2() {
    return this.z.cmpn(0) === 0;
  };
  var curve_1 = createCommonjsModule(function(module, exports) {
    "use strict";
    var curve = exports;
    curve.base = base3;
    curve.short = short_1;
    curve.mont = /*RicMoo:ethers:require(./mont)*/
    null;
    curve.edwards = /*RicMoo:ethers:require(./edwards)*/
    null;
  });
  var curves_1 = createCommonjsModule(function(module, exports) {
    "use strict";
    var curves = exports;
    var assert3 = utils_1$1.assert;
    function PresetCurve(options2) {
      if (options2.type === "short")
        this.curve = new curve_1.short(options2);
      else if (options2.type === "edwards")
        this.curve = new curve_1.edwards(options2);
      else
        this.curve = new curve_1.mont(options2);
      this.g = this.curve.g;
      this.n = this.curve.n;
      this.hash = options2.hash;
      assert3(this.g.validate(), "Invalid curve");
      assert3(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    curves.PresetCurve = PresetCurve;
    function defineCurve(name2, options2) {
      Object.defineProperty(curves, name2, {
        configurable: true,
        enumerable: true,
        get: function() {
          var curve = new PresetCurve(options2);
          Object.defineProperty(curves, name2, {
            configurable: true,
            enumerable: true,
            value: curve
          });
          return curve;
        }
      });
    }
    defineCurve("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: import_hash2.default.sha256,
      gRed: false,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    });
    defineCurve("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: import_hash2.default.sha256,
      gRed: false,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    });
    defineCurve("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: import_hash2.default.sha256,
      gRed: false,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    });
    defineCurve("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: import_hash2.default.sha384,
      gRed: false,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    });
    defineCurve("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: import_hash2.default.sha512,
      gRed: false,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    });
    defineCurve("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: import_hash2.default.sha256,
      gRed: false,
      g: [
        "9"
      ]
    });
    defineCurve("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      // -121665 * (121666^(-1)) (mod P)
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: import_hash2.default.sha256,
      gRed: false,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        // 4/5
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var pre;
    try {
      pre = /*RicMoo:ethers:require(./precomputed/secp256k1)*/
      null.crash();
    } catch (e9) {
      pre = void 0;
    }
    defineCurve("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: import_hash2.default.sha256,
      // Precomputed endomorphism
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: false,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        pre
      ]
    });
  });
  function HmacDRBG(options2) {
    if (!(this instanceof HmacDRBG))
      return new HmacDRBG(options2);
    this.hash = options2.hash;
    this.predResist = !!options2.predResist;
    this.outLen = this.hash.outSize;
    this.minEntropy = options2.minEntropy || this.hash.hmacStrength;
    this._reseed = null;
    this.reseedInterval = null;
    this.K = null;
    this.V = null;
    var entropy = utils_1.toArray(options2.entropy, options2.entropyEnc || "hex");
    var nonce = utils_1.toArray(options2.nonce, options2.nonceEnc || "hex");
    var pers = utils_1.toArray(options2.pers, options2.persEnc || "hex");
    minimalisticAssert(
      entropy.length >= this.minEntropy / 8,
      "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
    );
    this._init(entropy, nonce, pers);
  }
  var hmacDrbg = HmacDRBG;
  HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
    var seed = entropy.concat(nonce).concat(pers);
    this.K = new Array(this.outLen / 8);
    this.V = new Array(this.outLen / 8);
    for (var i7 = 0; i7 < this.V.length; i7++) {
      this.K[i7] = 0;
      this.V[i7] = 1;
    }
    this._update(seed);
    this._reseed = 1;
    this.reseedInterval = 281474976710656;
  };
  HmacDRBG.prototype._hmac = function hmac() {
    return new import_hash2.default.hmac(this.hash, this.K);
  };
  HmacDRBG.prototype._update = function update(seed) {
    var kmac = this._hmac().update(this.V).update([0]);
    if (seed)
      kmac = kmac.update(seed);
    this.K = kmac.digest();
    this.V = this._hmac().update(this.V).digest();
    if (!seed)
      return;
    this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
    this.V = this._hmac().update(this.V).digest();
  };
  HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add4, addEnc) {
    if (typeof entropyEnc !== "string") {
      addEnc = add4;
      add4 = entropyEnc;
      entropyEnc = null;
    }
    entropy = utils_1.toArray(entropy, entropyEnc);
    add4 = utils_1.toArray(add4, addEnc);
    minimalisticAssert(
      entropy.length >= this.minEntropy / 8,
      "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
    );
    this._update(entropy.concat(add4 || []));
    this._reseed = 1;
  };
  HmacDRBG.prototype.generate = function generate(len, enc, add4, addEnc) {
    if (this._reseed > this.reseedInterval)
      throw new Error("Reseed is required");
    if (typeof enc !== "string") {
      addEnc = add4;
      add4 = enc;
      enc = null;
    }
    if (add4) {
      add4 = utils_1.toArray(add4, addEnc || "hex");
      this._update(add4);
    }
    var temp = [];
    while (temp.length < len) {
      this.V = this._hmac().update(this.V).digest();
      temp = temp.concat(this.V);
    }
    var res = temp.slice(0, len);
    this._update(add4);
    this._reseed++;
    return utils_1.encode(res, enc);
  };
  var assert$3 = utils_1$1.assert;
  function KeyPair(ec2, options2) {
    this.ec = ec2;
    this.priv = null;
    this.pub = null;
    if (options2.priv)
      this._importPrivate(options2.priv, options2.privEnc);
    if (options2.pub)
      this._importPublic(options2.pub, options2.pubEnc);
  }
  var key = KeyPair;
  KeyPair.fromPublic = function fromPublic(ec2, pub, enc) {
    if (pub instanceof KeyPair)
      return pub;
    return new KeyPair(ec2, {
      pub,
      pubEnc: enc
    });
  };
  KeyPair.fromPrivate = function fromPrivate(ec2, priv, enc) {
    if (priv instanceof KeyPair)
      return priv;
    return new KeyPair(ec2, {
      priv,
      privEnc: enc
    });
  };
  KeyPair.prototype.validate = function validate4() {
    var pub = this.getPublic();
    if (pub.isInfinity())
      return { result: false, reason: "Invalid public key" };
    if (!pub.validate())
      return { result: false, reason: "Public key is not a point" };
    if (!pub.mul(this.ec.curve.n).isInfinity())
      return { result: false, reason: "Public key * N != O" };
    return { result: true, reason: null };
  };
  KeyPair.prototype.getPublic = function getPublic(compact, enc) {
    if (typeof compact === "string") {
      enc = compact;
      compact = null;
    }
    if (!this.pub)
      this.pub = this.ec.g.mul(this.priv);
    if (!enc)
      return this.pub;
    return this.pub.encode(enc, compact);
  };
  KeyPair.prototype.getPrivate = function getPrivate(enc) {
    if (enc === "hex")
      return this.priv.toString(16, 2);
    else
      return this.priv;
  };
  KeyPair.prototype._importPrivate = function _importPrivate(key2, enc) {
    this.priv = new import_bn2.default(key2, enc || 16);
    this.priv = this.priv.umod(this.ec.curve.n);
  };
  KeyPair.prototype._importPublic = function _importPublic(key2, enc) {
    if (key2.x || key2.y) {
      if (this.ec.curve.type === "mont") {
        assert$3(key2.x, "Need x coordinate");
      } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
        assert$3(key2.x && key2.y, "Need both x and y coordinate");
      }
      this.pub = this.ec.curve.point(key2.x, key2.y);
      return;
    }
    this.pub = this.ec.curve.decodePoint(key2, enc);
  };
  KeyPair.prototype.derive = function derive(pub) {
    if (!pub.validate()) {
      assert$3(pub.validate(), "public point not validated");
    }
    return pub.mul(this.priv).getX();
  };
  KeyPair.prototype.sign = function sign2(msg, enc, options2) {
    return this.ec.sign(msg, this, enc, options2);
  };
  KeyPair.prototype.verify = function verify2(msg, signature2) {
    return this.ec.verify(msg, signature2, this);
  };
  KeyPair.prototype.inspect = function inspect3() {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
  };
  var assert$4 = utils_1$1.assert;
  function Signature(options2, enc) {
    if (options2 instanceof Signature)
      return options2;
    if (this._importDER(options2, enc))
      return;
    assert$4(options2.r && options2.s, "Signature without r or s");
    this.r = new import_bn2.default(options2.r, 16);
    this.s = new import_bn2.default(options2.s, 16);
    if (options2.recoveryParam === void 0)
      this.recoveryParam = null;
    else
      this.recoveryParam = options2.recoveryParam;
  }
  var signature = Signature;
  function Position() {
    this.place = 0;
  }
  function getLength(buf, p8) {
    var initial = buf[p8.place++];
    if (!(initial & 128)) {
      return initial;
    }
    var octetLen = initial & 15;
    if (octetLen === 0 || octetLen > 4) {
      return false;
    }
    var val = 0;
    for (var i7 = 0, off = p8.place; i7 < octetLen; i7++, off++) {
      val <<= 8;
      val |= buf[off];
      val >>>= 0;
    }
    if (val <= 127) {
      return false;
    }
    p8.place = off;
    return val;
  }
  function rmPadding(buf) {
    var i7 = 0;
    var len = buf.length - 1;
    while (!buf[i7] && !(buf[i7 + 1] & 128) && i7 < len) {
      i7++;
    }
    if (i7 === 0) {
      return buf;
    }
    return buf.slice(i7);
  }
  Signature.prototype._importDER = function _importDER(data2, enc) {
    data2 = utils_1$1.toArray(data2, enc);
    var p8 = new Position();
    if (data2[p8.place++] !== 48) {
      return false;
    }
    var len = getLength(data2, p8);
    if (len === false) {
      return false;
    }
    if (len + p8.place !== data2.length) {
      return false;
    }
    if (data2[p8.place++] !== 2) {
      return false;
    }
    var rlen = getLength(data2, p8);
    if (rlen === false) {
      return false;
    }
    var r8 = data2.slice(p8.place, rlen + p8.place);
    p8.place += rlen;
    if (data2[p8.place++] !== 2) {
      return false;
    }
    var slen = getLength(data2, p8);
    if (slen === false) {
      return false;
    }
    if (data2.length !== slen + p8.place) {
      return false;
    }
    var s7 = data2.slice(p8.place, slen + p8.place);
    if (r8[0] === 0) {
      if (r8[1] & 128) {
        r8 = r8.slice(1);
      } else {
        return false;
      }
    }
    if (s7[0] === 0) {
      if (s7[1] & 128) {
        s7 = s7.slice(1);
      } else {
        return false;
      }
    }
    this.r = new import_bn2.default(r8);
    this.s = new import_bn2.default(s7);
    this.recoveryParam = null;
    return true;
  };
  function constructLength(arr, len) {
    if (len < 128) {
      arr.push(len);
      return;
    }
    var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
    arr.push(octets | 128);
    while (--octets) {
      arr.push(len >>> (octets << 3) & 255);
    }
    arr.push(len);
  }
  Signature.prototype.toDER = function toDER(enc) {
    var r8 = this.r.toArray();
    var s7 = this.s.toArray();
    if (r8[0] & 128)
      r8 = [0].concat(r8);
    if (s7[0] & 128)
      s7 = [0].concat(s7);
    r8 = rmPadding(r8);
    s7 = rmPadding(s7);
    while (!s7[0] && !(s7[1] & 128)) {
      s7 = s7.slice(1);
    }
    var arr = [2];
    constructLength(arr, r8.length);
    arr = arr.concat(r8);
    arr.push(2);
    constructLength(arr, s7.length);
    var backHalf = arr.concat(s7);
    var res = [48];
    constructLength(res, backHalf.length);
    res = res.concat(backHalf);
    return utils_1$1.encode(res, enc);
  };
  var rand = (
    /*RicMoo:ethers:require(brorand)*/
    function() {
      throw new Error("unsupported");
    }
  );
  var assert$5 = utils_1$1.assert;
  function EC(options2) {
    if (!(this instanceof EC))
      return new EC(options2);
    if (typeof options2 === "string") {
      assert$5(
        Object.prototype.hasOwnProperty.call(curves_1, options2),
        "Unknown curve " + options2
      );
      options2 = curves_1[options2];
    }
    if (options2 instanceof curves_1.PresetCurve)
      options2 = { curve: options2 };
    this.curve = options2.curve.curve;
    this.n = this.curve.n;
    this.nh = this.n.ushrn(1);
    this.g = this.curve.g;
    this.g = options2.curve.g;
    this.g.precompute(options2.curve.n.bitLength() + 1);
    this.hash = options2.hash || options2.curve.hash;
  }
  var ec = EC;
  EC.prototype.keyPair = function keyPair(options2) {
    return new key(this, options2);
  };
  EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
    return key.fromPrivate(this, priv, enc);
  };
  EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
    return key.fromPublic(this, pub, enc);
  };
  EC.prototype.genKeyPair = function genKeyPair(options2) {
    if (!options2)
      options2 = {};
    var drbg = new hmacDrbg({
      hash: this.hash,
      pers: options2.pers,
      persEnc: options2.persEnc || "utf8",
      entropy: options2.entropy || rand(this.hash.hmacStrength),
      entropyEnc: options2.entropy && options2.entropyEnc || "utf8",
      nonce: this.n.toArray()
    });
    var bytes3 = this.n.byteLength();
    var ns2 = this.n.sub(new import_bn2.default(2));
    for (; ; ) {
      var priv = new import_bn2.default(drbg.generate(bytes3));
      if (priv.cmp(ns2) > 0)
        continue;
      priv.iaddn(1);
      return this.keyFromPrivate(priv);
    }
  };
  EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
    var delta = msg.byteLength() * 8 - this.n.bitLength();
    if (delta > 0)
      msg = msg.ushrn(delta);
    if (!truncOnly && msg.cmp(this.n) >= 0)
      return msg.sub(this.n);
    else
      return msg;
  };
  EC.prototype.sign = function sign3(msg, key2, enc, options2) {
    if (typeof enc === "object") {
      options2 = enc;
      enc = null;
    }
    if (!options2)
      options2 = {};
    key2 = this.keyFromPrivate(key2, enc);
    msg = this._truncateToN(new import_bn2.default(msg, 16));
    var bytes3 = this.n.byteLength();
    var bkey = key2.getPrivate().toArray("be", bytes3);
    var nonce = msg.toArray("be", bytes3);
    var drbg = new hmacDrbg({
      hash: this.hash,
      entropy: bkey,
      nonce,
      pers: options2.pers,
      persEnc: options2.persEnc || "utf8"
    });
    var ns1 = this.n.sub(new import_bn2.default(1));
    for (var iter = 0; ; iter++) {
      var k6 = options2.k ? options2.k(iter) : new import_bn2.default(drbg.generate(this.n.byteLength()));
      k6 = this._truncateToN(k6, true);
      if (k6.cmpn(1) <= 0 || k6.cmp(ns1) >= 0)
        continue;
      var kp = this.g.mul(k6);
      if (kp.isInfinity())
        continue;
      var kpX = kp.getX();
      var r8 = kpX.umod(this.n);
      if (r8.cmpn(0) === 0)
        continue;
      var s7 = k6.invm(this.n).mul(r8.mul(key2.getPrivate()).iadd(msg));
      s7 = s7.umod(this.n);
      if (s7.cmpn(0) === 0)
        continue;
      var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r8) !== 0 ? 2 : 0);
      if (options2.canonical && s7.cmp(this.nh) > 0) {
        s7 = this.n.sub(s7);
        recoveryParam ^= 1;
      }
      return new signature({ r: r8, s: s7, recoveryParam });
    }
  };
  EC.prototype.verify = function verify3(msg, signature$1, key2, enc) {
    msg = this._truncateToN(new import_bn2.default(msg, 16));
    key2 = this.keyFromPublic(key2, enc);
    signature$1 = new signature(signature$1, "hex");
    var r8 = signature$1.r;
    var s7 = signature$1.s;
    if (r8.cmpn(1) < 0 || r8.cmp(this.n) >= 0)
      return false;
    if (s7.cmpn(1) < 0 || s7.cmp(this.n) >= 0)
      return false;
    var sinv = s7.invm(this.n);
    var u1 = sinv.mul(msg).umod(this.n);
    var u22 = sinv.mul(r8).umod(this.n);
    var p8;
    if (!this.curve._maxwellTrick) {
      p8 = this.g.mulAdd(u1, key2.getPublic(), u22);
      if (p8.isInfinity())
        return false;
      return p8.getX().umod(this.n).cmp(r8) === 0;
    }
    p8 = this.g.jmulAdd(u1, key2.getPublic(), u22);
    if (p8.isInfinity())
      return false;
    return p8.eqXToP(r8);
  };
  EC.prototype.recoverPubKey = function(msg, signature$1, j7, enc) {
    assert$5((3 & j7) === j7, "The recovery param is more than two bits");
    signature$1 = new signature(signature$1, enc);
    var n9 = this.n;
    var e9 = new import_bn2.default(msg);
    var r8 = signature$1.r;
    var s7 = signature$1.s;
    var isYOdd = j7 & 1;
    var isSecondKey = j7 >> 1;
    if (r8.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
      throw new Error("Unable to find sencond key candinate");
    if (isSecondKey)
      r8 = this.curve.pointFromX(r8.add(this.curve.n), isYOdd);
    else
      r8 = this.curve.pointFromX(r8, isYOdd);
    var rInv = signature$1.r.invm(n9);
    var s1 = n9.sub(e9).mul(rInv).umod(n9);
    var s22 = s7.mul(rInv).umod(n9);
    return this.g.mulAdd(s1, r8, s22);
  };
  EC.prototype.getKeyRecoveryParam = function(e9, signature$1, Q10, enc) {
    signature$1 = new signature(signature$1, enc);
    if (signature$1.recoveryParam !== null)
      return signature$1.recoveryParam;
    for (var i7 = 0; i7 < 4; i7++) {
      var Qprime;
      try {
        Qprime = this.recoverPubKey(e9, signature$1, i7);
      } catch (e10) {
        continue;
      }
      if (Qprime.eq(Q10))
        return i7;
    }
    throw new Error("Unable to find valid recovery factor");
  };
  var elliptic_1 = createCommonjsModule(function(module, exports) {
    "use strict";
    var elliptic = exports;
    elliptic.version = /*RicMoo:ethers*/
    { version: "6.5.4" }.version;
    elliptic.utils = utils_1$1;
    elliptic.rand = /*RicMoo:ethers:require(brorand)*/
    function() {
      throw new Error("unsupported");
    };
    elliptic.curve = curve_1;
    elliptic.curves = curves_1;
    elliptic.ec = ec;
    elliptic.eddsa = /*RicMoo:ethers:require(./elliptic/eddsa)*/
    null;
  });
  var EC$1 = elliptic_1.ec;

  // node_modules/@ethersproject/signing-key/lib.esm/_version.js
  var version15 = "signing-key/5.7.0";

  // node_modules/@ethersproject/signing-key/lib.esm/index.js
  var logger17 = new Logger(version15);
  var _curve = null;
  function getCurve() {
    if (!_curve) {
      _curve = new EC$1("secp256k1");
    }
    return _curve;
  }
  var SigningKey = class {
    constructor(privateKey) {
      defineReadOnly(this, "curve", "secp256k1");
      defineReadOnly(this, "privateKey", hexlify(privateKey));
      if (hexDataLength(this.privateKey) !== 32) {
        logger17.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
      }
      const keyPair2 = getCurve().keyFromPrivate(arrayify(this.privateKey));
      defineReadOnly(this, "publicKey", "0x" + keyPair2.getPublic(false, "hex"));
      defineReadOnly(this, "compressedPublicKey", "0x" + keyPair2.getPublic(true, "hex"));
      defineReadOnly(this, "_isSigningKey", true);
    }
    _addPoint(other) {
      const p0 = getCurve().keyFromPublic(arrayify(this.publicKey));
      const p1 = getCurve().keyFromPublic(arrayify(other));
      return "0x" + p0.pub.add(p1.pub).encodeCompressed("hex");
    }
    signDigest(digest2) {
      const keyPair2 = getCurve().keyFromPrivate(arrayify(this.privateKey));
      const digestBytes = arrayify(digest2);
      if (digestBytes.length !== 32) {
        logger17.throwArgumentError("bad digest length", "digest", digest2);
      }
      const signature2 = keyPair2.sign(digestBytes, { canonical: true });
      return splitSignature({
        recoveryParam: signature2.recoveryParam,
        r: hexZeroPad("0x" + signature2.r.toString(16), 32),
        s: hexZeroPad("0x" + signature2.s.toString(16), 32)
      });
    }
    computeSharedSecret(otherKey) {
      const keyPair2 = getCurve().keyFromPrivate(arrayify(this.privateKey));
      const otherKeyPair = getCurve().keyFromPublic(arrayify(computePublicKey(otherKey)));
      return hexZeroPad("0x" + keyPair2.derive(otherKeyPair.getPublic()).toString(16), 32);
    }
    static isSigningKey(value) {
      return !!(value && value._isSigningKey);
    }
  };
  function recoverPublicKey2(digest2, signature2) {
    const sig = splitSignature(signature2);
    const rs2 = { r: arrayify(sig.r), s: arrayify(sig.s) };
    return "0x" + getCurve().recoverPubKey(arrayify(digest2), rs2, sig.recoveryParam).encode("hex", false);
  }
  function computePublicKey(key2, compressed) {
    const bytes3 = arrayify(key2);
    if (bytes3.length === 32) {
      const signingKey = new SigningKey(bytes3);
      if (compressed) {
        return "0x" + getCurve().keyFromPrivate(bytes3).getPublic(true, "hex");
      }
      return signingKey.publicKey;
    } else if (bytes3.length === 33) {
      if (compressed) {
        return hexlify(bytes3);
      }
      return "0x" + getCurve().keyFromPublic(bytes3).getPublic(false, "hex");
    } else if (bytes3.length === 65) {
      if (!compressed) {
        return hexlify(bytes3);
      }
      return "0x" + getCurve().keyFromPublic(bytes3).getPublic(true, "hex");
    }
    return logger17.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
  }

  // node_modules/@ethersproject/transactions/lib.esm/_version.js
  var version16 = "transactions/5.7.0";

  // node_modules/@ethersproject/transactions/lib.esm/index.js
  var logger18 = new Logger(version16);
  var TransactionTypes;
  (function(TransactionTypes2) {
    TransactionTypes2[TransactionTypes2["legacy"] = 0] = "legacy";
    TransactionTypes2[TransactionTypes2["eip2930"] = 1] = "eip2930";
    TransactionTypes2[TransactionTypes2["eip1559"] = 2] = "eip1559";
  })(TransactionTypes || (TransactionTypes = {}));
  function handleAddress(value) {
    if (value === "0x") {
      return null;
    }
    return getAddress2(value);
  }
  function handleNumber(value) {
    if (value === "0x") {
      return Zero2;
    }
    return BigNumber.from(value);
  }
  var transactionFields = [
    { name: "nonce", maxLength: 32, numeric: true },
    { name: "gasPrice", maxLength: 32, numeric: true },
    { name: "gasLimit", maxLength: 32, numeric: true },
    { name: "to", length: 20 },
    { name: "value", maxLength: 32, numeric: true },
    { name: "data" }
  ];
  var allowedTransactionKeys2 = {
    chainId: true,
    data: true,
    gasLimit: true,
    gasPrice: true,
    nonce: true,
    to: true,
    type: true,
    value: true
  };
  function computeAddress(key2) {
    const publicKey = computePublicKey(key2);
    return getAddress2(hexDataSlice(keccak2562(hexDataSlice(publicKey, 1)), 12));
  }
  function recoverAddress2(digest2, signature2) {
    return computeAddress(recoverPublicKey2(arrayify(digest2), signature2));
  }
  function formatNumber(value, name2) {
    const result = stripZeros(BigNumber.from(value).toHexString());
    if (result.length > 32) {
      logger18.throwArgumentError("invalid length for " + name2, "transaction:" + name2, value);
    }
    return result;
  }
  function accessSetify(addr, storageKeys) {
    return {
      address: getAddress2(addr),
      storageKeys: (storageKeys || []).map((storageKey, index2) => {
        if (hexDataLength(storageKey) !== 32) {
          logger18.throwArgumentError("invalid access list storageKey", `accessList[${addr}:${index2}]`, storageKey);
        }
        return storageKey.toLowerCase();
      })
    };
  }
  function accessListify(value) {
    if (Array.isArray(value)) {
      return value.map((set2, index2) => {
        if (Array.isArray(set2)) {
          if (set2.length > 2) {
            logger18.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${index2}]`, set2);
          }
          return accessSetify(set2[0], set2[1]);
        }
        return accessSetify(set2.address, set2.storageKeys);
      });
    }
    const result = Object.keys(value).map((addr) => {
      const storageKeys = value[addr].reduce((accum, storageKey) => {
        accum[storageKey] = true;
        return accum;
      }, {});
      return accessSetify(addr, Object.keys(storageKeys).sort());
    });
    result.sort((a6, b7) => a6.address.localeCompare(b7.address));
    return result;
  }
  function formatAccessList(value) {
    return accessListify(value).map((set2) => [set2.address, set2.storageKeys]);
  }
  function _serializeEip1559(transaction, signature2) {
    if (transaction.gasPrice != null) {
      const gasPrice = BigNumber.from(transaction.gasPrice);
      const maxFeePerGas = BigNumber.from(transaction.maxFeePerGas || 0);
      if (!gasPrice.eq(maxFeePerGas)) {
        logger18.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
          gasPrice,
          maxFeePerGas
        });
      }
    }
    const fields = [
      formatNumber(transaction.chainId || 0, "chainId"),
      formatNumber(transaction.nonce || 0, "nonce"),
      formatNumber(transaction.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
      formatNumber(transaction.maxFeePerGas || 0, "maxFeePerGas"),
      formatNumber(transaction.gasLimit || 0, "gasLimit"),
      transaction.to != null ? getAddress2(transaction.to) : "0x",
      formatNumber(transaction.value || 0, "value"),
      transaction.data || "0x",
      formatAccessList(transaction.accessList || [])
    ];
    if (signature2) {
      const sig = splitSignature(signature2);
      fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
      fields.push(stripZeros(sig.r));
      fields.push(stripZeros(sig.s));
    }
    return hexConcat(["0x02", encode7(fields)]);
  }
  function _serializeEip2930(transaction, signature2) {
    const fields = [
      formatNumber(transaction.chainId || 0, "chainId"),
      formatNumber(transaction.nonce || 0, "nonce"),
      formatNumber(transaction.gasPrice || 0, "gasPrice"),
      formatNumber(transaction.gasLimit || 0, "gasLimit"),
      transaction.to != null ? getAddress2(transaction.to) : "0x",
      formatNumber(transaction.value || 0, "value"),
      transaction.data || "0x",
      formatAccessList(transaction.accessList || [])
    ];
    if (signature2) {
      const sig = splitSignature(signature2);
      fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
      fields.push(stripZeros(sig.r));
      fields.push(stripZeros(sig.s));
    }
    return hexConcat(["0x01", encode7(fields)]);
  }
  function _serialize(transaction, signature2) {
    checkProperties(transaction, allowedTransactionKeys2);
    const raw = [];
    transactionFields.forEach(function(fieldInfo) {
      let value = transaction[fieldInfo.name] || [];
      const options2 = {};
      if (fieldInfo.numeric) {
        options2.hexPad = "left";
      }
      value = arrayify(hexlify(value, options2));
      if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {
        logger18.throwArgumentError("invalid length for " + fieldInfo.name, "transaction:" + fieldInfo.name, value);
      }
      if (fieldInfo.maxLength) {
        value = stripZeros(value);
        if (value.length > fieldInfo.maxLength) {
          logger18.throwArgumentError("invalid length for " + fieldInfo.name, "transaction:" + fieldInfo.name, value);
        }
      }
      raw.push(hexlify(value));
    });
    let chainId = 0;
    if (transaction.chainId != null) {
      chainId = transaction.chainId;
      if (typeof chainId !== "number") {
        logger18.throwArgumentError("invalid transaction.chainId", "transaction", transaction);
      }
    } else if (signature2 && !isBytesLike(signature2) && signature2.v > 28) {
      chainId = Math.floor((signature2.v - 35) / 2);
    }
    if (chainId !== 0) {
      raw.push(hexlify(chainId));
      raw.push("0x");
      raw.push("0x");
    }
    if (!signature2) {
      return encode7(raw);
    }
    const sig = splitSignature(signature2);
    let v6 = 27 + sig.recoveryParam;
    if (chainId !== 0) {
      raw.pop();
      raw.pop();
      raw.pop();
      v6 += chainId * 2 + 8;
      if (sig.v > 28 && sig.v !== v6) {
        logger18.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature2);
      }
    } else if (sig.v !== v6) {
      logger18.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature2);
    }
    raw.push(hexlify(v6));
    raw.push(stripZeros(arrayify(sig.r)));
    raw.push(stripZeros(arrayify(sig.s)));
    return encode7(raw);
  }
  function serialize2(transaction, signature2) {
    if (transaction.type == null || transaction.type === 0) {
      if (transaction.accessList != null) {
        logger18.throwArgumentError("untyped transactions do not support accessList; include type: 1", "transaction", transaction);
      }
      return _serialize(transaction, signature2);
    }
    switch (transaction.type) {
      case 1:
        return _serializeEip2930(transaction, signature2);
      case 2:
        return _serializeEip1559(transaction, signature2);
      default:
        break;
    }
    return logger18.throwError(`unsupported transaction type: ${transaction.type}`, Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "serializeTransaction",
      transactionType: transaction.type
    });
  }
  function _parseEipSignature(tx, fields, serialize4) {
    try {
      const recid = handleNumber(fields[0]).toNumber();
      if (recid !== 0 && recid !== 1) {
        throw new Error("bad recid");
      }
      tx.v = recid;
    } catch (error) {
      logger18.throwArgumentError("invalid v for transaction type: 1", "v", fields[0]);
    }
    tx.r = hexZeroPad(fields[1], 32);
    tx.s = hexZeroPad(fields[2], 32);
    try {
      const digest2 = keccak2562(serialize4(tx));
      tx.from = recoverAddress2(digest2, { r: tx.r, s: tx.s, recoveryParam: tx.v });
    } catch (error) {
    }
  }
  function _parseEip1559(payload) {
    const transaction = decode6(payload.slice(1));
    if (transaction.length !== 9 && transaction.length !== 12) {
      logger18.throwArgumentError("invalid component count for transaction type: 2", "payload", hexlify(payload));
    }
    const maxPriorityFeePerGas = handleNumber(transaction[2]);
    const maxFeePerGas = handleNumber(transaction[3]);
    const tx = {
      type: 2,
      chainId: handleNumber(transaction[0]).toNumber(),
      nonce: handleNumber(transaction[1]).toNumber(),
      maxPriorityFeePerGas,
      maxFeePerGas,
      gasPrice: null,
      gasLimit: handleNumber(transaction[4]),
      to: handleAddress(transaction[5]),
      value: handleNumber(transaction[6]),
      data: transaction[7],
      accessList: accessListify(transaction[8])
    };
    if (transaction.length === 9) {
      return tx;
    }
    tx.hash = keccak2562(payload);
    _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);
    return tx;
  }
  function _parseEip2930(payload) {
    const transaction = decode6(payload.slice(1));
    if (transaction.length !== 8 && transaction.length !== 11) {
      logger18.throwArgumentError("invalid component count for transaction type: 1", "payload", hexlify(payload));
    }
    const tx = {
      type: 1,
      chainId: handleNumber(transaction[0]).toNumber(),
      nonce: handleNumber(transaction[1]).toNumber(),
      gasPrice: handleNumber(transaction[2]),
      gasLimit: handleNumber(transaction[3]),
      to: handleAddress(transaction[4]),
      value: handleNumber(transaction[5]),
      data: transaction[6],
      accessList: accessListify(transaction[7])
    };
    if (transaction.length === 8) {
      return tx;
    }
    tx.hash = keccak2562(payload);
    _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);
    return tx;
  }
  function _parse(rawTransaction) {
    const transaction = decode6(rawTransaction);
    if (transaction.length !== 9 && transaction.length !== 6) {
      logger18.throwArgumentError("invalid raw transaction", "rawTransaction", rawTransaction);
    }
    const tx = {
      nonce: handleNumber(transaction[0]).toNumber(),
      gasPrice: handleNumber(transaction[1]),
      gasLimit: handleNumber(transaction[2]),
      to: handleAddress(transaction[3]),
      value: handleNumber(transaction[4]),
      data: transaction[5],
      chainId: 0
    };
    if (transaction.length === 6) {
      return tx;
    }
    try {
      tx.v = BigNumber.from(transaction[6]).toNumber();
    } catch (error) {
      return tx;
    }
    tx.r = hexZeroPad(transaction[7], 32);
    tx.s = hexZeroPad(transaction[8], 32);
    if (BigNumber.from(tx.r).isZero() && BigNumber.from(tx.s).isZero()) {
      tx.chainId = tx.v;
      tx.v = 0;
    } else {
      tx.chainId = Math.floor((tx.v - 35) / 2);
      if (tx.chainId < 0) {
        tx.chainId = 0;
      }
      let recoveryParam = tx.v - 27;
      const raw = transaction.slice(0, 6);
      if (tx.chainId !== 0) {
        raw.push(hexlify(tx.chainId));
        raw.push("0x");
        raw.push("0x");
        recoveryParam -= tx.chainId * 2 + 8;
      }
      const digest2 = keccak2562(encode7(raw));
      try {
        tx.from = recoverAddress2(digest2, { r: hexlify(tx.r), s: hexlify(tx.s), recoveryParam });
      } catch (error) {
      }
      tx.hash = keccak2562(rawTransaction);
    }
    tx.type = null;
    return tx;
  }
  function parse3(rawTransaction) {
    const payload = arrayify(rawTransaction);
    if (payload[0] > 127) {
      return _parse(payload);
    }
    switch (payload[0]) {
      case 1:
        return _parseEip2930(payload);
      case 2:
        return _parseEip1559(payload);
      default:
        break;
    }
    return logger18.throwError(`unsupported transaction type: ${payload[0]}`, Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "parseTransaction",
      transactionType: payload[0]
    });
  }

  // node_modules/@ethersproject/contracts/lib.esm/_version.js
  var version17 = "contracts/5.7.0";

  // node_modules/@ethersproject/contracts/lib.esm/index.js
  var __awaiter6 = function(thisArg, _arguments, P7, generator) {
    function adopt(value) {
      return value instanceof P7 ? value : new P7(function(resolve) {
        resolve(value);
      });
    }
    return new (P7 || (P7 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e9) {
          reject(e9);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e9) {
          reject(e9);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var logger19 = new Logger(version17);
  var allowedTransactionKeys3 = {
    chainId: true,
    data: true,
    from: true,
    gasLimit: true,
    gasPrice: true,
    nonce: true,
    to: true,
    value: true,
    type: true,
    accessList: true,
    maxFeePerGas: true,
    maxPriorityFeePerGas: true,
    customData: true,
    ccipReadEnabled: true
  };
  function resolveName(resolver, nameOrPromise) {
    return __awaiter6(this, void 0, void 0, function* () {
      const name2 = yield nameOrPromise;
      if (typeof name2 !== "string") {
        logger19.throwArgumentError("invalid address or ENS name", "name", name2);
      }
      try {
        return getAddress2(name2);
      } catch (error) {
      }
      if (!resolver) {
        logger19.throwError("a provider or signer is needed to resolve ENS names", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "resolveName"
        });
      }
      const address = yield resolver.resolveName(name2);
      if (address == null) {
        logger19.throwArgumentError("resolver or addr is not configured for ENS name", "name", name2);
      }
      return address;
    });
  }
  function resolveAddresses(resolver, value, paramType) {
    return __awaiter6(this, void 0, void 0, function* () {
      if (Array.isArray(paramType)) {
        return yield Promise.all(paramType.map((paramType2, index2) => {
          return resolveAddresses(resolver, Array.isArray(value) ? value[index2] : value[paramType2.name], paramType2);
        }));
      }
      if (paramType.type === "address") {
        return yield resolveName(resolver, value);
      }
      if (paramType.type === "tuple") {
        return yield resolveAddresses(resolver, value, paramType.components);
      }
      if (paramType.baseType === "array") {
        if (!Array.isArray(value)) {
          return Promise.reject(logger19.makeError("invalid value for array", Logger.errors.INVALID_ARGUMENT, {
            argument: "value",
            value
          }));
        }
        return yield Promise.all(value.map((v6) => resolveAddresses(resolver, v6, paramType.arrayChildren)));
      }
      return value;
    });
  }
  function populateTransaction(contract, fragment, args) {
    return __awaiter6(this, void 0, void 0, function* () {
      let overrides = {};
      if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") {
        overrides = shallowCopy(args.pop());
      }
      logger19.checkArgumentCount(args.length, fragment.inputs.length, "passed to contract");
      if (contract.signer) {
        if (overrides.from) {
          overrides.from = resolveProperties({
            override: resolveName(contract.signer, overrides.from),
            signer: contract.signer.getAddress()
          }).then((check) => __awaiter6(this, void 0, void 0, function* () {
            if (getAddress2(check.signer) !== check.override) {
              logger19.throwError("Contract with a Signer cannot override from", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "overrides.from"
              });
            }
            return check.override;
          }));
        } else {
          overrides.from = contract.signer.getAddress();
        }
      } else if (overrides.from) {
        overrides.from = resolveName(contract.provider, overrides.from);
      }
      const resolved = yield resolveProperties({
        args: resolveAddresses(contract.signer || contract.provider, args, fragment.inputs),
        address: contract.resolvedAddress,
        overrides: resolveProperties(overrides) || {}
      });
      const data2 = contract.interface.encodeFunctionData(fragment, resolved.args);
      const tx = {
        data: data2,
        to: resolved.address
      };
      const ro3 = resolved.overrides;
      if (ro3.nonce != null) {
        tx.nonce = BigNumber.from(ro3.nonce).toNumber();
      }
      if (ro3.gasLimit != null) {
        tx.gasLimit = BigNumber.from(ro3.gasLimit);
      }
      if (ro3.gasPrice != null) {
        tx.gasPrice = BigNumber.from(ro3.gasPrice);
      }
      if (ro3.maxFeePerGas != null) {
        tx.maxFeePerGas = BigNumber.from(ro3.maxFeePerGas);
      }
      if (ro3.maxPriorityFeePerGas != null) {
        tx.maxPriorityFeePerGas = BigNumber.from(ro3.maxPriorityFeePerGas);
      }
      if (ro3.from != null) {
        tx.from = ro3.from;
      }
      if (ro3.type != null) {
        tx.type = ro3.type;
      }
      if (ro3.accessList != null) {
        tx.accessList = accessListify(ro3.accessList);
      }
      if (tx.gasLimit == null && fragment.gas != null) {
        let intrinsic = 21e3;
        const bytes3 = arrayify(data2);
        for (let i7 = 0; i7 < bytes3.length; i7++) {
          intrinsic += 4;
          if (bytes3[i7]) {
            intrinsic += 64;
          }
        }
        tx.gasLimit = BigNumber.from(fragment.gas).add(intrinsic);
      }
      if (ro3.value) {
        const roValue = BigNumber.from(ro3.value);
        if (!roValue.isZero() && !fragment.payable) {
          logger19.throwError("non-payable method cannot override value", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "overrides.value",
            value: overrides.value
          });
        }
        tx.value = roValue;
      }
      if (ro3.customData) {
        tx.customData = shallowCopy(ro3.customData);
      }
      if (ro3.ccipReadEnabled) {
        tx.ccipReadEnabled = !!ro3.ccipReadEnabled;
      }
      delete overrides.nonce;
      delete overrides.gasLimit;
      delete overrides.gasPrice;
      delete overrides.from;
      delete overrides.value;
      delete overrides.type;
      delete overrides.accessList;
      delete overrides.maxFeePerGas;
      delete overrides.maxPriorityFeePerGas;
      delete overrides.customData;
      delete overrides.ccipReadEnabled;
      const leftovers = Object.keys(overrides).filter((key2) => overrides[key2] != null);
      if (leftovers.length) {
        logger19.throwError(`cannot override ${leftovers.map((l9) => JSON.stringify(l9)).join(",")}`, Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "overrides",
          overrides: leftovers
        });
      }
      return tx;
    });
  }
  function buildPopulate(contract, fragment) {
    return function(...args) {
      return populateTransaction(contract, fragment, args);
    };
  }
  function buildEstimate(contract, fragment) {
    const signerOrProvider = contract.signer || contract.provider;
    return function(...args) {
      return __awaiter6(this, void 0, void 0, function* () {
        if (!signerOrProvider) {
          logger19.throwError("estimate require a provider or signer", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "estimateGas"
          });
        }
        const tx = yield populateTransaction(contract, fragment, args);
        return yield signerOrProvider.estimateGas(tx);
      });
    };
  }
  function addContractWait(contract, tx) {
    const wait2 = tx.wait.bind(tx);
    tx.wait = (confirmations) => {
      return wait2(confirmations).then((receipt) => {
        receipt.events = receipt.logs.map((log) => {
          let event = deepCopy(log);
          let parsed = null;
          try {
            parsed = contract.interface.parseLog(log);
          } catch (e9) {
          }
          if (parsed) {
            event.args = parsed.args;
            event.decode = (data2, topics) => {
              return contract.interface.decodeEventLog(parsed.eventFragment, data2, topics);
            };
            event.event = parsed.name;
            event.eventSignature = parsed.signature;
          }
          event.removeListener = () => {
            return contract.provider;
          };
          event.getBlock = () => {
            return contract.provider.getBlock(receipt.blockHash);
          };
          event.getTransaction = () => {
            return contract.provider.getTransaction(receipt.transactionHash);
          };
          event.getTransactionReceipt = () => {
            return Promise.resolve(receipt);
          };
          return event;
        });
        return receipt;
      });
    };
  }
  function buildCall(contract, fragment, collapseSimple) {
    const signerOrProvider = contract.signer || contract.provider;
    return function(...args) {
      return __awaiter6(this, void 0, void 0, function* () {
        let blockTag = void 0;
        if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") {
          const overrides = shallowCopy(args.pop());
          if (overrides.blockTag != null) {
            blockTag = yield overrides.blockTag;
          }
          delete overrides.blockTag;
          args.push(overrides);
        }
        if (contract.deployTransaction != null) {
          yield contract._deployed(blockTag);
        }
        const tx = yield populateTransaction(contract, fragment, args);
        const result = yield signerOrProvider.call(tx, blockTag);
        try {
          let value = contract.interface.decodeFunctionResult(fragment, result);
          if (collapseSimple && fragment.outputs.length === 1) {
            value = value[0];
          }
          return value;
        } catch (error) {
          if (error.code === Logger.errors.CALL_EXCEPTION) {
            error.address = contract.address;
            error.args = args;
            error.transaction = tx;
          }
          throw error;
        }
      });
    };
  }
  function buildSend(contract, fragment) {
    return function(...args) {
      return __awaiter6(this, void 0, void 0, function* () {
        if (!contract.signer) {
          logger19.throwError("sending a transaction requires a signer", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "sendTransaction"
          });
        }
        if (contract.deployTransaction != null) {
          yield contract._deployed();
        }
        const txRequest = yield populateTransaction(contract, fragment, args);
        const tx = yield contract.signer.sendTransaction(txRequest);
        addContractWait(contract, tx);
        return tx;
      });
    };
  }
  function buildDefault(contract, fragment, collapseSimple) {
    if (fragment.constant) {
      return buildCall(contract, fragment, collapseSimple);
    }
    return buildSend(contract, fragment);
  }
  function getEventTag(filter2) {
    if (filter2.address && (filter2.topics == null || filter2.topics.length === 0)) {
      return "*";
    }
    return (filter2.address || "*") + "@" + (filter2.topics ? filter2.topics.map((topic) => {
      if (Array.isArray(topic)) {
        return topic.join("|");
      }
      return topic;
    }).join(":") : "");
  }
  var RunningEvent = class {
    constructor(tag, filter2) {
      defineReadOnly(this, "tag", tag);
      defineReadOnly(this, "filter", filter2);
      this._listeners = [];
    }
    addListener(listener, once) {
      this._listeners.push({ listener, once });
    }
    removeListener(listener) {
      let done = false;
      this._listeners = this._listeners.filter((item) => {
        if (done || item.listener !== listener) {
          return true;
        }
        done = true;
        return false;
      });
    }
    removeAllListeners() {
      this._listeners = [];
    }
    listeners() {
      return this._listeners.map((i7) => i7.listener);
    }
    listenerCount() {
      return this._listeners.length;
    }
    run(args) {
      const listenerCount = this.listenerCount();
      this._listeners = this._listeners.filter((item) => {
        const argsCopy = args.slice();
        setTimeout(() => {
          item.listener.apply(this, argsCopy);
        }, 0);
        return !item.once;
      });
      return listenerCount;
    }
    prepareEvent(event) {
    }
    // Returns the array that will be applied to an emit
    getEmit(event) {
      return [event];
    }
  };
  var ErrorRunningEvent = class extends RunningEvent {
    constructor() {
      super("error", null);
    }
  };
  var FragmentRunningEvent = class extends RunningEvent {
    constructor(address, contractInterface, fragment, topics) {
      const filter2 = {
        address
      };
      let topic = contractInterface.getEventTopic(fragment);
      if (topics) {
        if (topic !== topics[0]) {
          logger19.throwArgumentError("topic mismatch", "topics", topics);
        }
        filter2.topics = topics.slice();
      } else {
        filter2.topics = [topic];
      }
      super(getEventTag(filter2), filter2);
      defineReadOnly(this, "address", address);
      defineReadOnly(this, "interface", contractInterface);
      defineReadOnly(this, "fragment", fragment);
    }
    prepareEvent(event) {
      super.prepareEvent(event);
      event.event = this.fragment.name;
      event.eventSignature = this.fragment.format();
      event.decode = (data2, topics) => {
        return this.interface.decodeEventLog(this.fragment, data2, topics);
      };
      try {
        event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);
      } catch (error) {
        event.args = null;
        event.decodeError = error;
      }
    }
    getEmit(event) {
      const errors = checkResultErrors(event.args);
      if (errors.length) {
        throw errors[0].error;
      }
      const args = (event.args || []).slice();
      args.push(event);
      return args;
    }
  };
  var WildcardRunningEvent = class extends RunningEvent {
    constructor(address, contractInterface) {
      super("*", { address });
      defineReadOnly(this, "address", address);
      defineReadOnly(this, "interface", contractInterface);
    }
    prepareEvent(event) {
      super.prepareEvent(event);
      try {
        const parsed = this.interface.parseLog(event);
        event.event = parsed.name;
        event.eventSignature = parsed.signature;
        event.decode = (data2, topics) => {
          return this.interface.decodeEventLog(parsed.eventFragment, data2, topics);
        };
        event.args = parsed.args;
      } catch (error) {
      }
    }
  };
  var BaseContract = class {
    constructor(addressOrName, contractInterface, signerOrProvider) {
      defineReadOnly(this, "interface", getStatic(new.target, "getInterface")(contractInterface));
      if (signerOrProvider == null) {
        defineReadOnly(this, "provider", null);
        defineReadOnly(this, "signer", null);
      } else if (Signer.isSigner(signerOrProvider)) {
        defineReadOnly(this, "provider", signerOrProvider.provider || null);
        defineReadOnly(this, "signer", signerOrProvider);
      } else if (Provider.isProvider(signerOrProvider)) {
        defineReadOnly(this, "provider", signerOrProvider);
        defineReadOnly(this, "signer", null);
      } else {
        logger19.throwArgumentError("invalid signer or provider", "signerOrProvider", signerOrProvider);
      }
      defineReadOnly(this, "callStatic", {});
      defineReadOnly(this, "estimateGas", {});
      defineReadOnly(this, "functions", {});
      defineReadOnly(this, "populateTransaction", {});
      defineReadOnly(this, "filters", {});
      {
        const uniqueFilters = {};
        Object.keys(this.interface.events).forEach((eventSignature) => {
          const event = this.interface.events[eventSignature];
          defineReadOnly(this.filters, eventSignature, (...args) => {
            return {
              address: this.address,
              topics: this.interface.encodeFilterTopics(event, args)
            };
          });
          if (!uniqueFilters[event.name]) {
            uniqueFilters[event.name] = [];
          }
          uniqueFilters[event.name].push(eventSignature);
        });
        Object.keys(uniqueFilters).forEach((name2) => {
          const filters = uniqueFilters[name2];
          if (filters.length === 1) {
            defineReadOnly(this.filters, name2, this.filters[filters[0]]);
          } else {
            logger19.warn(`Duplicate definition of ${name2} (${filters.join(", ")})`);
          }
        });
      }
      defineReadOnly(this, "_runningEvents", {});
      defineReadOnly(this, "_wrappedEmits", {});
      if (addressOrName == null) {
        logger19.throwArgumentError("invalid contract address or ENS name", "addressOrName", addressOrName);
      }
      defineReadOnly(this, "address", addressOrName);
      if (this.provider) {
        defineReadOnly(this, "resolvedAddress", resolveName(this.provider, addressOrName));
      } else {
        try {
          defineReadOnly(this, "resolvedAddress", Promise.resolve(getAddress2(addressOrName)));
        } catch (error) {
          logger19.throwError("provider is required to use ENS name as contract address", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "new Contract"
          });
        }
      }
      this.resolvedAddress.catch((e9) => {
      });
      const uniqueNames = {};
      const uniqueSignatures = {};
      Object.keys(this.interface.functions).forEach((signature2) => {
        const fragment = this.interface.functions[signature2];
        if (uniqueSignatures[signature2]) {
          logger19.warn(`Duplicate ABI entry for ${JSON.stringify(signature2)}`);
          return;
        }
        uniqueSignatures[signature2] = true;
        {
          const name2 = fragment.name;
          if (!uniqueNames[`%${name2}`]) {
            uniqueNames[`%${name2}`] = [];
          }
          uniqueNames[`%${name2}`].push(signature2);
        }
        if (this[signature2] == null) {
          defineReadOnly(this, signature2, buildDefault(this, fragment, true));
        }
        if (this.functions[signature2] == null) {
          defineReadOnly(this.functions, signature2, buildDefault(this, fragment, false));
        }
        if (this.callStatic[signature2] == null) {
          defineReadOnly(this.callStatic, signature2, buildCall(this, fragment, true));
        }
        if (this.populateTransaction[signature2] == null) {
          defineReadOnly(this.populateTransaction, signature2, buildPopulate(this, fragment));
        }
        if (this.estimateGas[signature2] == null) {
          defineReadOnly(this.estimateGas, signature2, buildEstimate(this, fragment));
        }
      });
      Object.keys(uniqueNames).forEach((name2) => {
        const signatures = uniqueNames[name2];
        if (signatures.length > 1) {
          return;
        }
        name2 = name2.substring(1);
        const signature2 = signatures[0];
        try {
          if (this[name2] == null) {
            defineReadOnly(this, name2, this[signature2]);
          }
        } catch (e9) {
        }
        if (this.functions[name2] == null) {
          defineReadOnly(this.functions, name2, this.functions[signature2]);
        }
        if (this.callStatic[name2] == null) {
          defineReadOnly(this.callStatic, name2, this.callStatic[signature2]);
        }
        if (this.populateTransaction[name2] == null) {
          defineReadOnly(this.populateTransaction, name2, this.populateTransaction[signature2]);
        }
        if (this.estimateGas[name2] == null) {
          defineReadOnly(this.estimateGas, name2, this.estimateGas[signature2]);
        }
      });
    }
    static getContractAddress(transaction) {
      return getContractAddress3(transaction);
    }
    static getInterface(contractInterface) {
      if (Interface.isInterface(contractInterface)) {
        return contractInterface;
      }
      return new Interface(contractInterface);
    }
    // @TODO: Allow timeout?
    deployed() {
      return this._deployed();
    }
    _deployed(blockTag) {
      if (!this._deployedPromise) {
        if (this.deployTransaction) {
          this._deployedPromise = this.deployTransaction.wait().then(() => {
            return this;
          });
        } else {
          this._deployedPromise = this.provider.getCode(this.address, blockTag).then((code2) => {
            if (code2 === "0x") {
              logger19.throwError("contract not deployed", Logger.errors.UNSUPPORTED_OPERATION, {
                contractAddress: this.address,
                operation: "getDeployed"
              });
            }
            return this;
          });
        }
      }
      return this._deployedPromise;
    }
    // @TODO:
    // estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>
    // @TODO:
    // estimateDeploy(bytecode: string, ...args): Promise<BigNumber>
    fallback(overrides) {
      if (!this.signer) {
        logger19.throwError("sending a transactions require a signer", Logger.errors.UNSUPPORTED_OPERATION, { operation: "sendTransaction(fallback)" });
      }
      const tx = shallowCopy(overrides || {});
      ["from", "to"].forEach(function(key2) {
        if (tx[key2] == null) {
          return;
        }
        logger19.throwError("cannot override " + key2, Logger.errors.UNSUPPORTED_OPERATION, { operation: key2 });
      });
      tx.to = this.resolvedAddress;
      return this.deployed().then(() => {
        return this.signer.sendTransaction(tx);
      });
    }
    // Reconnect to a different signer or provider
    connect(signerOrProvider) {
      if (typeof signerOrProvider === "string") {
        signerOrProvider = new VoidSigner(signerOrProvider, this.provider);
      }
      const contract = new this.constructor(this.address, this.interface, signerOrProvider);
      if (this.deployTransaction) {
        defineReadOnly(contract, "deployTransaction", this.deployTransaction);
      }
      return contract;
    }
    // Re-attach to a different on-chain instance of this contract
    attach(addressOrName) {
      return new this.constructor(addressOrName, this.interface, this.signer || this.provider);
    }
    static isIndexed(value) {
      return Indexed.isIndexed(value);
    }
    _normalizeRunningEvent(runningEvent) {
      if (this._runningEvents[runningEvent.tag]) {
        return this._runningEvents[runningEvent.tag];
      }
      return runningEvent;
    }
    _getRunningEvent(eventName) {
      if (typeof eventName === "string") {
        if (eventName === "error") {
          return this._normalizeRunningEvent(new ErrorRunningEvent());
        }
        if (eventName === "event") {
          return this._normalizeRunningEvent(new RunningEvent("event", null));
        }
        if (eventName === "*") {
          return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
        }
        const fragment = this.interface.getEvent(eventName);
        return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));
      }
      if (eventName.topics && eventName.topics.length > 0) {
        try {
          const topic = eventName.topics[0];
          if (typeof topic !== "string") {
            throw new Error("invalid topic");
          }
          const fragment = this.interface.getEvent(topic);
          return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));
        } catch (error) {
        }
        const filter2 = {
          address: this.address,
          topics: eventName.topics
        };
        return this._normalizeRunningEvent(new RunningEvent(getEventTag(filter2), filter2));
      }
      return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
    }
    _checkRunningEvents(runningEvent) {
      if (runningEvent.listenerCount() === 0) {
        delete this._runningEvents[runningEvent.tag];
        const emit = this._wrappedEmits[runningEvent.tag];
        if (emit && runningEvent.filter) {
          this.provider.off(runningEvent.filter, emit);
          delete this._wrappedEmits[runningEvent.tag];
        }
      }
    }
    // Subclasses can override this to gracefully recover
    // from parse errors if they wish
    _wrapEvent(runningEvent, log, listener) {
      const event = deepCopy(log);
      event.removeListener = () => {
        if (!listener) {
          return;
        }
        runningEvent.removeListener(listener);
        this._checkRunningEvents(runningEvent);
      };
      event.getBlock = () => {
        return this.provider.getBlock(log.blockHash);
      };
      event.getTransaction = () => {
        return this.provider.getTransaction(log.transactionHash);
      };
      event.getTransactionReceipt = () => {
        return this.provider.getTransactionReceipt(log.transactionHash);
      };
      runningEvent.prepareEvent(event);
      return event;
    }
    _addEventListener(runningEvent, listener, once) {
      if (!this.provider) {
        logger19.throwError("events require a provider or a signer with a provider", Logger.errors.UNSUPPORTED_OPERATION, { operation: "once" });
      }
      runningEvent.addListener(listener, once);
      this._runningEvents[runningEvent.tag] = runningEvent;
      if (!this._wrappedEmits[runningEvent.tag]) {
        const wrappedEmit = (log) => {
          let event = this._wrapEvent(runningEvent, log, listener);
          if (event.decodeError == null) {
            try {
              const args = runningEvent.getEmit(event);
              this.emit(runningEvent.filter, ...args);
            } catch (error) {
              event.decodeError = error.error;
            }
          }
          if (runningEvent.filter != null) {
            this.emit("event", event);
          }
          if (event.decodeError != null) {
            this.emit("error", event.decodeError, event);
          }
        };
        this._wrappedEmits[runningEvent.tag] = wrappedEmit;
        if (runningEvent.filter != null) {
          this.provider.on(runningEvent.filter, wrappedEmit);
        }
      }
    }
    queryFilter(event, fromBlockOrBlockhash, toBlock) {
      const runningEvent = this._getRunningEvent(event);
      const filter2 = shallowCopy(runningEvent.filter);
      if (typeof fromBlockOrBlockhash === "string" && isHexString(fromBlockOrBlockhash, 32)) {
        if (toBlock != null) {
          logger19.throwArgumentError("cannot specify toBlock with blockhash", "toBlock", toBlock);
        }
        filter2.blockHash = fromBlockOrBlockhash;
      } else {
        filter2.fromBlock = fromBlockOrBlockhash != null ? fromBlockOrBlockhash : 0;
        filter2.toBlock = toBlock != null ? toBlock : "latest";
      }
      return this.provider.getLogs(filter2).then((logs) => {
        return logs.map((log) => this._wrapEvent(runningEvent, log, null));
      });
    }
    on(event, listener) {
      this._addEventListener(this._getRunningEvent(event), listener, false);
      return this;
    }
    once(event, listener) {
      this._addEventListener(this._getRunningEvent(event), listener, true);
      return this;
    }
    emit(eventName, ...args) {
      if (!this.provider) {
        return false;
      }
      const runningEvent = this._getRunningEvent(eventName);
      const result = runningEvent.run(args) > 0;
      this._checkRunningEvents(runningEvent);
      return result;
    }
    listenerCount(eventName) {
      if (!this.provider) {
        return 0;
      }
      if (eventName == null) {
        return Object.keys(this._runningEvents).reduce((accum, key2) => {
          return accum + this._runningEvents[key2].listenerCount();
        }, 0);
      }
      return this._getRunningEvent(eventName).listenerCount();
    }
    listeners(eventName) {
      if (!this.provider) {
        return [];
      }
      if (eventName == null) {
        const result = [];
        for (let tag in this._runningEvents) {
          this._runningEvents[tag].listeners().forEach((listener) => {
            result.push(listener);
          });
        }
        return result;
      }
      return this._getRunningEvent(eventName).listeners();
    }
    removeAllListeners(eventName) {
      if (!this.provider) {
        return this;
      }
      if (eventName == null) {
        for (const tag in this._runningEvents) {
          const runningEvent2 = this._runningEvents[tag];
          runningEvent2.removeAllListeners();
          this._checkRunningEvents(runningEvent2);
        }
        return this;
      }
      const runningEvent = this._getRunningEvent(eventName);
      runningEvent.removeAllListeners();
      this._checkRunningEvents(runningEvent);
      return this;
    }
    off(eventName, listener) {
      if (!this.provider) {
        return this;
      }
      const runningEvent = this._getRunningEvent(eventName);
      runningEvent.removeListener(listener);
      this._checkRunningEvents(runningEvent);
      return this;
    }
    removeListener(eventName, listener) {
      return this.off(eventName, listener);
    }
  };
  var Contract = class extends BaseContract {
  };
  var ContractFactory = class {
    constructor(contractInterface, bytecode, signer) {
      let bytecodeHex = null;
      if (typeof bytecode === "string") {
        bytecodeHex = bytecode;
      } else if (isBytes2(bytecode)) {
        bytecodeHex = hexlify(bytecode);
      } else if (bytecode && typeof bytecode.object === "string") {
        bytecodeHex = bytecode.object;
      } else {
        bytecodeHex = "!";
      }
      if (bytecodeHex.substring(0, 2) !== "0x") {
        bytecodeHex = "0x" + bytecodeHex;
      }
      if (!isHexString(bytecodeHex) || bytecodeHex.length % 2) {
        logger19.throwArgumentError("invalid bytecode", "bytecode", bytecode);
      }
      if (signer && !Signer.isSigner(signer)) {
        logger19.throwArgumentError("invalid signer", "signer", signer);
      }
      defineReadOnly(this, "bytecode", bytecodeHex);
      defineReadOnly(this, "interface", getStatic(new.target, "getInterface")(contractInterface));
      defineReadOnly(this, "signer", signer || null);
    }
    // @TODO: Future; rename to populateTransaction?
    getDeployTransaction(...args) {
      let tx = {};
      if (args.length === this.interface.deploy.inputs.length + 1 && typeof args[args.length - 1] === "object") {
        tx = shallowCopy(args.pop());
        for (const key2 in tx) {
          if (!allowedTransactionKeys3[key2]) {
            throw new Error("unknown transaction override " + key2);
          }
        }
      }
      ["data", "from", "to"].forEach((key2) => {
        if (tx[key2] == null) {
          return;
        }
        logger19.throwError("cannot override " + key2, Logger.errors.UNSUPPORTED_OPERATION, { operation: key2 });
      });
      if (tx.value) {
        const value = BigNumber.from(tx.value);
        if (!value.isZero() && !this.interface.deploy.payable) {
          logger19.throwError("non-payable constructor cannot override value", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "overrides.value",
            value: tx.value
          });
        }
      }
      logger19.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor");
      tx.data = hexlify(concat3([
        this.bytecode,
        this.interface.encodeDeploy(args)
      ]));
      return tx;
    }
    deploy(...args) {
      return __awaiter6(this, void 0, void 0, function* () {
        let overrides = {};
        if (args.length === this.interface.deploy.inputs.length + 1) {
          overrides = args.pop();
        }
        logger19.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor");
        const params = yield resolveAddresses(this.signer, args, this.interface.deploy.inputs);
        params.push(overrides);
        const unsignedTx = this.getDeployTransaction(...params);
        const tx = yield this.signer.sendTransaction(unsignedTx);
        const address = getStatic(this.constructor, "getContractAddress")(tx);
        const contract = getStatic(this.constructor, "getContract")(address, this.interface, this.signer);
        addContractWait(contract, tx);
        defineReadOnly(contract, "deployTransaction", tx);
        return contract;
      });
    }
    attach(address) {
      return this.constructor.getContract(address, this.interface, this.signer);
    }
    connect(signer) {
      return new this.constructor(this.interface, this.bytecode, signer);
    }
    static fromSolidity(compilerOutput, signer) {
      if (compilerOutput == null) {
        logger19.throwError("missing compiler output", Logger.errors.MISSING_ARGUMENT, { argument: "compilerOutput" });
      }
      if (typeof compilerOutput === "string") {
        compilerOutput = JSON.parse(compilerOutput);
      }
      const abi = compilerOutput.abi;
      let bytecode = null;
      if (compilerOutput.bytecode) {
        bytecode = compilerOutput.bytecode;
      } else if (compilerOutput.evm && compilerOutput.evm.bytecode) {
        bytecode = compilerOutput.evm.bytecode;
      }
      return new this(abi, bytecode, signer);
    }
    static getInterface(contractInterface) {
      return Contract.getInterface(contractInterface);
    }
    static getContractAddress(tx) {
      return getContractAddress3(tx);
    }
    static getContract(address, contractInterface, signer) {
      return new Contract(address, contractInterface, signer);
    }
  };

  // node_modules/@ethersproject/basex/lib.esm/index.js
  var BaseX = class {
    constructor(alphabet2) {
      defineReadOnly(this, "alphabet", alphabet2);
      defineReadOnly(this, "base", alphabet2.length);
      defineReadOnly(this, "_alphabetMap", {});
      defineReadOnly(this, "_leader", alphabet2.charAt(0));
      for (let i7 = 0; i7 < alphabet2.length; i7++) {
        this._alphabetMap[alphabet2.charAt(i7)] = i7;
      }
    }
    encode(value) {
      let source = arrayify(value);
      if (source.length === 0) {
        return "";
      }
      let digits = [0];
      for (let i7 = 0; i7 < source.length; ++i7) {
        let carry = source[i7];
        for (let j7 = 0; j7 < digits.length; ++j7) {
          carry += digits[j7] << 8;
          digits[j7] = carry % this.base;
          carry = carry / this.base | 0;
        }
        while (carry > 0) {
          digits.push(carry % this.base);
          carry = carry / this.base | 0;
        }
      }
      let string2 = "";
      for (let k6 = 0; source[k6] === 0 && k6 < source.length - 1; ++k6) {
        string2 += this._leader;
      }
      for (let q8 = digits.length - 1; q8 >= 0; --q8) {
        string2 += this.alphabet[digits[q8]];
      }
      return string2;
    }
    decode(value) {
      if (typeof value !== "string") {
        throw new TypeError("Expected String");
      }
      let bytes3 = [];
      if (value.length === 0) {
        return new Uint8Array(bytes3);
      }
      bytes3.push(0);
      for (let i7 = 0; i7 < value.length; i7++) {
        let byte = this._alphabetMap[value[i7]];
        if (byte === void 0) {
          throw new Error("Non-base" + this.base + " character");
        }
        let carry = byte;
        for (let j7 = 0; j7 < bytes3.length; ++j7) {
          carry += bytes3[j7] * this.base;
          bytes3[j7] = carry & 255;
          carry >>= 8;
        }
        while (carry > 0) {
          bytes3.push(carry & 255);
          carry >>= 8;
        }
      }
      for (let k6 = 0; value[k6] === this._leader && k6 < value.length - 1; ++k6) {
        bytes3.push(0);
      }
      return arrayify(new Uint8Array(bytes3.reverse()));
    }
  };
  var Base32 = new BaseX("abcdefghijklmnopqrstuvwxyz234567");
  var Base58 = new BaseX("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");

  // node_modules/@ethersproject/sha2/lib.esm/sha2.js
  var import_hash3 = __toESM(require_hash2());

  // node_modules/@ethersproject/sha2/lib.esm/types.js
  var SupportedAlgorithm;
  (function(SupportedAlgorithm2) {
    SupportedAlgorithm2["sha256"] = "sha256";
    SupportedAlgorithm2["sha512"] = "sha512";
  })(SupportedAlgorithm || (SupportedAlgorithm = {}));

  // node_modules/@ethersproject/sha2/lib.esm/_version.js
  var version18 = "sha2/5.7.0";

  // node_modules/@ethersproject/sha2/lib.esm/sha2.js
  var logger20 = new Logger(version18);
  function ripemd160(data2) {
    return "0x" + import_hash3.default.ripemd160().update(arrayify(data2)).digest("hex");
  }
  function sha2562(data2) {
    return "0x" + import_hash3.default.sha256().update(arrayify(data2)).digest("hex");
  }
  function sha5122(data2) {
    return "0x" + import_hash3.default.sha512().update(arrayify(data2)).digest("hex");
  }
  function computeHmac(algorithm, key2, data2) {
    if (!SupportedAlgorithm[algorithm]) {
      logger20.throwError("unsupported algorithm " + algorithm, Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "hmac",
        algorithm
      });
    }
    return "0x" + import_hash3.default.hmac(import_hash3.default[algorithm], arrayify(key2)).update(arrayify(data2)).digest("hex");
  }

  // node_modules/@ethersproject/pbkdf2/lib.esm/pbkdf2.js
  function pbkdf2(password, salt, iterations, keylen, hashAlgorithm) {
    password = arrayify(password);
    salt = arrayify(salt);
    let hLen;
    let l9 = 1;
    const DK = new Uint8Array(keylen);
    const block1 = new Uint8Array(salt.length + 4);
    block1.set(salt);
    let r8;
    let T6;
    for (let i7 = 1; i7 <= l9; i7++) {
      block1[salt.length] = i7 >> 24 & 255;
      block1[salt.length + 1] = i7 >> 16 & 255;
      block1[salt.length + 2] = i7 >> 8 & 255;
      block1[salt.length + 3] = i7 & 255;
      let U9 = arrayify(computeHmac(hashAlgorithm, password, block1));
      if (!hLen) {
        hLen = U9.length;
        T6 = new Uint8Array(hLen);
        l9 = Math.ceil(keylen / hLen);
        r8 = keylen - (l9 - 1) * hLen;
      }
      T6.set(U9);
      for (let j7 = 1; j7 < iterations; j7++) {
        U9 = arrayify(computeHmac(hashAlgorithm, password, U9));
        for (let k6 = 0; k6 < hLen; k6++)
          T6[k6] ^= U9[k6];
      }
      const destPos = (i7 - 1) * hLen;
      const len = i7 === l9 ? r8 : hLen;
      DK.set(arrayify(T6).slice(0, len), destPos);
    }
    return hexlify(DK);
  }

  // node_modules/@ethersproject/wordlists/lib.esm/_version.js
  var version19 = "wordlists/5.7.0";

  // node_modules/@ethersproject/wordlists/lib.esm/wordlist.js
  var exportWordlist = false;
  var logger21 = new Logger(version19);
  var Wordlist = class {
    constructor(locale) {
      logger21.checkAbstract(new.target, Wordlist);
      defineReadOnly(this, "locale", locale);
    }
    // Subclasses may override this
    split(mnemonic) {
      return mnemonic.toLowerCase().split(/ +/g);
    }
    // Subclasses may override this
    join(words2) {
      return words2.join(" ");
    }
    static check(wordlist2) {
      const words2 = [];
      for (let i7 = 0; i7 < 2048; i7++) {
        const word = wordlist2.getWord(i7);
        if (i7 !== wordlist2.getWordIndex(word)) {
          return "0x";
        }
        words2.push(word);
      }
      return id2(words2.join("\n") + "\n");
    }
    static register(lang, name2) {
      if (!name2) {
        name2 = lang.locale;
      }
      if (exportWordlist) {
        try {
          const anyGlobal2 = window;
          if (anyGlobal2._ethers && anyGlobal2._ethers.wordlists) {
            if (!anyGlobal2._ethers.wordlists[name2]) {
              defineReadOnly(anyGlobal2._ethers.wordlists, name2, lang);
            }
          }
        } catch (error) {
        }
      }
    }
  };

  // node_modules/@ethersproject/wordlists/lib.esm/lang-en.js
  var words = "AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo";
  var wordlist = null;
  function loadWords(lang) {
    if (wordlist != null) {
      return;
    }
    wordlist = words.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ");
    if (Wordlist.check(lang) !== "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60") {
      wordlist = null;
      throw new Error("BIP39 Wordlist for en (English) FAILED");
    }
  }
  var LangEn = class extends Wordlist {
    constructor() {
      super("en");
    }
    getWord(index2) {
      loadWords(this);
      return wordlist[index2];
    }
    getWordIndex(word) {
      loadWords(this);
      return wordlist.indexOf(word);
    }
  };
  var langEn = new LangEn();
  Wordlist.register(langEn);

  // node_modules/@ethersproject/wordlists/lib.esm/wordlists.js
  var wordlists = {
    en: langEn
  };

  // node_modules/@ethersproject/hdnode/lib.esm/_version.js
  var version20 = "hdnode/5.7.0";

  // node_modules/@ethersproject/hdnode/lib.esm/index.js
  var logger22 = new Logger(version20);
  var N16 = BigNumber.from("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
  var MasterSecret = toUtf8Bytes("Bitcoin seed");
  var HardenedBit = 2147483648;
  function getUpperMask(bits) {
    return (1 << bits) - 1 << 8 - bits;
  }
  function getLowerMask(bits) {
    return (1 << bits) - 1;
  }
  function bytes32(value) {
    return hexZeroPad(hexlify(value), 32);
  }
  function base58check(data2) {
    return Base58.encode(concat3([data2, hexDataSlice(sha2562(sha2562(data2)), 0, 4)]));
  }
  function getWordlist(wordlist2) {
    if (wordlist2 == null) {
      return wordlists["en"];
    }
    if (typeof wordlist2 === "string") {
      const words2 = wordlists[wordlist2];
      if (words2 == null) {
        logger22.throwArgumentError("unknown locale", "wordlist", wordlist2);
      }
      return words2;
    }
    return wordlist2;
  }
  var _constructorGuard4 = {};
  var defaultPath = "m/44'/60'/0'/0/0";
  var HDNode = class {
    /**
     *  This constructor should not be called directly.
     *
     *  Please use:
     *   - fromMnemonic
     *   - fromSeed
     */
    constructor(constructorGuard, privateKey, publicKey, parentFingerprint, chainCode, index2, depth, mnemonicOrPath) {
      if (constructorGuard !== _constructorGuard4) {
        throw new Error("HDNode constructor cannot be called directly");
      }
      if (privateKey) {
        const signingKey = new SigningKey(privateKey);
        defineReadOnly(this, "privateKey", signingKey.privateKey);
        defineReadOnly(this, "publicKey", signingKey.compressedPublicKey);
      } else {
        defineReadOnly(this, "privateKey", null);
        defineReadOnly(this, "publicKey", hexlify(publicKey));
      }
      defineReadOnly(this, "parentFingerprint", parentFingerprint);
      defineReadOnly(this, "fingerprint", hexDataSlice(ripemd160(sha2562(this.publicKey)), 0, 4));
      defineReadOnly(this, "address", computeAddress(this.publicKey));
      defineReadOnly(this, "chainCode", chainCode);
      defineReadOnly(this, "index", index2);
      defineReadOnly(this, "depth", depth);
      if (mnemonicOrPath == null) {
        defineReadOnly(this, "mnemonic", null);
        defineReadOnly(this, "path", null);
      } else if (typeof mnemonicOrPath === "string") {
        defineReadOnly(this, "mnemonic", null);
        defineReadOnly(this, "path", mnemonicOrPath);
      } else {
        defineReadOnly(this, "mnemonic", mnemonicOrPath);
        defineReadOnly(this, "path", mnemonicOrPath.path);
      }
    }
    get extendedKey() {
      if (this.depth >= 256) {
        throw new Error("Depth too large!");
      }
      return base58check(concat3([
        this.privateKey != null ? "0x0488ADE4" : "0x0488B21E",
        hexlify(this.depth),
        this.parentFingerprint,
        hexZeroPad(hexlify(this.index), 4),
        this.chainCode,
        this.privateKey != null ? concat3(["0x00", this.privateKey]) : this.publicKey
      ]));
    }
    neuter() {
      return new HDNode(_constructorGuard4, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);
    }
    _derive(index2) {
      if (index2 > 4294967295) {
        throw new Error("invalid index - " + String(index2));
      }
      let path = this.path;
      if (path) {
        path += "/" + (index2 & ~HardenedBit);
      }
      const data2 = new Uint8Array(37);
      if (index2 & HardenedBit) {
        if (!this.privateKey) {
          throw new Error("cannot derive child of neutered node");
        }
        data2.set(arrayify(this.privateKey), 1);
        if (path) {
          path += "'";
        }
      } else {
        data2.set(arrayify(this.publicKey));
      }
      for (let i7 = 24; i7 >= 0; i7 -= 8) {
        data2[33 + (i7 >> 3)] = index2 >> 24 - i7 & 255;
      }
      const I5 = arrayify(computeHmac(SupportedAlgorithm.sha512, this.chainCode, data2));
      const IL = I5.slice(0, 32);
      const IR = I5.slice(32);
      let ki2 = null;
      let Ki = null;
      if (this.privateKey) {
        ki2 = bytes32(BigNumber.from(IL).add(this.privateKey).mod(N16));
      } else {
        const ek = new SigningKey(hexlify(IL));
        Ki = ek._addPoint(this.publicKey);
      }
      let mnemonicOrPath = path;
      const srcMnemonic = this.mnemonic;
      if (srcMnemonic) {
        mnemonicOrPath = Object.freeze({
          phrase: srcMnemonic.phrase,
          path,
          locale: srcMnemonic.locale || "en"
        });
      }
      return new HDNode(_constructorGuard4, ki2, Ki, this.fingerprint, bytes32(IR), index2, this.depth + 1, mnemonicOrPath);
    }
    derivePath(path) {
      const components = path.split("/");
      if (components.length === 0 || components[0] === "m" && this.depth !== 0) {
        throw new Error("invalid path - " + path);
      }
      if (components[0] === "m") {
        components.shift();
      }
      let result = this;
      for (let i7 = 0; i7 < components.length; i7++) {
        const component = components[i7];
        if (component.match(/^[0-9]+'$/)) {
          const index2 = parseInt(component.substring(0, component.length - 1));
          if (index2 >= HardenedBit) {
            throw new Error("invalid path index - " + component);
          }
          result = result._derive(HardenedBit + index2);
        } else if (component.match(/^[0-9]+$/)) {
          const index2 = parseInt(component);
          if (index2 >= HardenedBit) {
            throw new Error("invalid path index - " + component);
          }
          result = result._derive(index2);
        } else {
          throw new Error("invalid path component - " + component);
        }
      }
      return result;
    }
    static _fromSeed(seed, mnemonic) {
      const seedArray = arrayify(seed);
      if (seedArray.length < 16 || seedArray.length > 64) {
        throw new Error("invalid seed");
      }
      const I5 = arrayify(computeHmac(SupportedAlgorithm.sha512, MasterSecret, seedArray));
      return new HDNode(_constructorGuard4, bytes32(I5.slice(0, 32)), null, "0x00000000", bytes32(I5.slice(32)), 0, 0, mnemonic);
    }
    static fromMnemonic(mnemonic, password, wordlist2) {
      wordlist2 = getWordlist(wordlist2);
      mnemonic = entropyToMnemonic(mnemonicToEntropy(mnemonic, wordlist2), wordlist2);
      return HDNode._fromSeed(mnemonicToSeed(mnemonic, password), {
        phrase: mnemonic,
        path: "m",
        locale: wordlist2.locale
      });
    }
    static fromSeed(seed) {
      return HDNode._fromSeed(seed, null);
    }
    static fromExtendedKey(extendedKey) {
      const bytes3 = Base58.decode(extendedKey);
      if (bytes3.length !== 82 || base58check(bytes3.slice(0, 78)) !== extendedKey) {
        logger22.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
      }
      const depth = bytes3[4];
      const parentFingerprint = hexlify(bytes3.slice(5, 9));
      const index2 = parseInt(hexlify(bytes3.slice(9, 13)).substring(2), 16);
      const chainCode = hexlify(bytes3.slice(13, 45));
      const key2 = bytes3.slice(45, 78);
      switch (hexlify(bytes3.slice(0, 4))) {
        case "0x0488b21e":
        case "0x043587cf":
          return new HDNode(_constructorGuard4, null, hexlify(key2), parentFingerprint, chainCode, index2, depth, null);
        case "0x0488ade4":
        case "0x04358394 ":
          if (key2[0] !== 0) {
            break;
          }
          return new HDNode(_constructorGuard4, hexlify(key2.slice(1)), null, parentFingerprint, chainCode, index2, depth, null);
      }
      return logger22.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
    }
  };
  function mnemonicToSeed(mnemonic, password) {
    if (!password) {
      password = "";
    }
    const salt = toUtf8Bytes("mnemonic" + password, UnicodeNormalizationForm.NFKD);
    return pbkdf2(toUtf8Bytes(mnemonic, UnicodeNormalizationForm.NFKD), salt, 2048, 64, "sha512");
  }
  function mnemonicToEntropy(mnemonic, wordlist2) {
    wordlist2 = getWordlist(wordlist2);
    logger22.checkNormalize();
    const words2 = wordlist2.split(mnemonic);
    if (words2.length % 3 !== 0) {
      throw new Error("invalid mnemonic");
    }
    const entropy = arrayify(new Uint8Array(Math.ceil(11 * words2.length / 8)));
    let offset = 0;
    for (let i7 = 0; i7 < words2.length; i7++) {
      let index2 = wordlist2.getWordIndex(words2[i7].normalize("NFKD"));
      if (index2 === -1) {
        throw new Error("invalid mnemonic");
      }
      for (let bit = 0; bit < 11; bit++) {
        if (index2 & 1 << 10 - bit) {
          entropy[offset >> 3] |= 1 << 7 - offset % 8;
        }
        offset++;
      }
    }
    const entropyBits = 32 * words2.length / 3;
    const checksumBits = words2.length / 3;
    const checksumMask = getUpperMask(checksumBits);
    const checksum = arrayify(sha2562(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
    if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {
      throw new Error("invalid checksum");
    }
    return hexlify(entropy.slice(0, entropyBits / 8));
  }
  function entropyToMnemonic(entropy, wordlist2) {
    wordlist2 = getWordlist(wordlist2);
    entropy = arrayify(entropy);
    if (entropy.length % 4 !== 0 || entropy.length < 16 || entropy.length > 32) {
      throw new Error("invalid entropy");
    }
    const indices = [0];
    let remainingBits = 11;
    for (let i7 = 0; i7 < entropy.length; i7++) {
      if (remainingBits > 8) {
        indices[indices.length - 1] <<= 8;
        indices[indices.length - 1] |= entropy[i7];
        remainingBits -= 8;
      } else {
        indices[indices.length - 1] <<= remainingBits;
        indices[indices.length - 1] |= entropy[i7] >> 8 - remainingBits;
        indices.push(entropy[i7] & getLowerMask(8 - remainingBits));
        remainingBits += 3;
      }
    }
    const checksumBits = entropy.length / 4;
    const checksum = arrayify(sha2562(entropy))[0] & getUpperMask(checksumBits);
    indices[indices.length - 1] <<= checksumBits;
    indices[indices.length - 1] |= checksum >> 8 - checksumBits;
    return wordlist2.join(indices.map((index2) => wordlist2.getWord(index2)));
  }
  function isValidMnemonic(mnemonic, wordlist2) {
    try {
      mnemonicToEntropy(mnemonic, wordlist2);
      return true;
    } catch (error) {
    }
    return false;
  }
  function getAccountPath(index2) {
    if (typeof index2 !== "number" || index2 < 0 || index2 >= HardenedBit || index2 % 1) {
      logger22.throwArgumentError("invalid account index", "index", index2);
    }
    return `m/44'/60'/${index2}'/0/0`;
  }

  // node_modules/@ethersproject/random/lib.esm/_version.js
  var version21 = "random/5.7.0";

  // node_modules/@ethersproject/random/lib.esm/random.js
  var logger23 = new Logger(version21);
  function getGlobal() {
    if (typeof self !== "undefined") {
      return self;
    }
    if (typeof window !== "undefined") {
      return window;
    }
    if (typeof global !== "undefined") {
      return global;
    }
    throw new Error("unable to locate global object");
  }
  var anyGlobal = getGlobal();
  var crypto3 = anyGlobal.crypto || anyGlobal.msCrypto;
  if (!crypto3 || !crypto3.getRandomValues) {
    logger23.warn("WARNING: Missing strong random number source");
    crypto3 = {
      getRandomValues: function(buffer2) {
        return logger23.throwError("no secure random source avaialble", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "crypto.getRandomValues"
        });
      }
    };
  }
  function randomBytes2(length2) {
    if (length2 <= 0 || length2 > 1024 || length2 % 1 || length2 != length2) {
      logger23.throwArgumentError("invalid length", "length", length2);
    }
    const result = new Uint8Array(length2);
    crypto3.getRandomValues(result);
    return arrayify(result);
  }

  // node_modules/@ethersproject/random/lib.esm/shuffle.js
  function shuffled(array) {
    array = array.slice();
    for (let i7 = array.length - 1; i7 > 0; i7--) {
      const j7 = Math.floor(Math.random() * (i7 + 1));
      const tmp = array[i7];
      array[i7] = array[j7];
      array[j7] = tmp;
    }
    return array;
  }

  // node_modules/@ethersproject/json-wallets/lib.esm/crowdsale.js
  var import_aes_js = __toESM(require_aes_js());

  // node_modules/@ethersproject/json-wallets/lib.esm/_version.js
  var version22 = "json-wallets/5.7.0";

  // node_modules/@ethersproject/json-wallets/lib.esm/utils.js
  function looseArrayify(hexString) {
    if (typeof hexString === "string" && hexString.substring(0, 2) !== "0x") {
      hexString = "0x" + hexString;
    }
    return arrayify(hexString);
  }
  function zpad(value, length2) {
    value = String(value);
    while (value.length < length2) {
      value = "0" + value;
    }
    return value;
  }
  function getPassword(password) {
    if (typeof password === "string") {
      return toUtf8Bytes(password, UnicodeNormalizationForm.NFKC);
    }
    return arrayify(password);
  }
  function searchPath(object, path) {
    let currentChild = object;
    const comps = path.toLowerCase().split("/");
    for (let i7 = 0; i7 < comps.length; i7++) {
      let matchingChild = null;
      for (const key2 in currentChild) {
        if (key2.toLowerCase() === comps[i7]) {
          matchingChild = currentChild[key2];
          break;
        }
      }
      if (matchingChild === null) {
        return null;
      }
      currentChild = matchingChild;
    }
    return currentChild;
  }
  function uuidV4(randomBytes3) {
    const bytes3 = arrayify(randomBytes3);
    bytes3[6] = bytes3[6] & 15 | 64;
    bytes3[8] = bytes3[8] & 63 | 128;
    const value = hexlify(bytes3);
    return [
      value.substring(2, 10),
      value.substring(10, 14),
      value.substring(14, 18),
      value.substring(18, 22),
      value.substring(22, 34)
    ].join("-");
  }

  // node_modules/@ethersproject/json-wallets/lib.esm/crowdsale.js
  var logger24 = new Logger(version22);
  var CrowdsaleAccount = class extends Description {
    isCrowdsaleAccount(value) {
      return !!(value && value._isCrowdsaleAccount);
    }
  };
  function decrypt(json, password) {
    const data2 = JSON.parse(json);
    password = getPassword(password);
    const ethaddr = getAddress2(searchPath(data2, "ethaddr"));
    const encseed = looseArrayify(searchPath(data2, "encseed"));
    if (!encseed || encseed.length % 16 !== 0) {
      logger24.throwArgumentError("invalid encseed", "json", json);
    }
    const key2 = arrayify(pbkdf2(password, password, 2e3, 32, "sha256")).slice(0, 16);
    const iv2 = encseed.slice(0, 16);
    const encryptedSeed = encseed.slice(16);
    const aesCbc = new import_aes_js.default.ModeOfOperation.cbc(key2, iv2);
    const seed = import_aes_js.default.padding.pkcs7.strip(arrayify(aesCbc.decrypt(encryptedSeed)));
    let seedHex = "";
    for (let i7 = 0; i7 < seed.length; i7++) {
      seedHex += String.fromCharCode(seed[i7]);
    }
    const seedHexBytes = toUtf8Bytes(seedHex);
    const privateKey = keccak2562(seedHexBytes);
    return new CrowdsaleAccount({
      _isCrowdsaleAccount: true,
      address: ethaddr,
      privateKey
    });
  }

  // node_modules/@ethersproject/json-wallets/lib.esm/inspect.js
  function isCrowdsaleWallet(json) {
    let data2 = null;
    try {
      data2 = JSON.parse(json);
    } catch (error) {
      return false;
    }
    return data2.encseed && data2.ethaddr;
  }
  function isKeystoreWallet(json) {
    let data2 = null;
    try {
      data2 = JSON.parse(json);
    } catch (error) {
      return false;
    }
    if (!data2.version || parseInt(data2.version) !== data2.version || parseInt(data2.version) !== 3) {
      return false;
    }
    return true;
  }
  function getJsonWalletAddress(json) {
    if (isCrowdsaleWallet(json)) {
      try {
        return getAddress2(JSON.parse(json).ethaddr);
      } catch (error) {
        return null;
      }
    }
    if (isKeystoreWallet(json)) {
      try {
        return getAddress2(JSON.parse(json).address);
      } catch (error) {
        return null;
      }
    }
    return null;
  }

  // node_modules/@ethersproject/json-wallets/lib.esm/keystore.js
  var import_aes_js2 = __toESM(require_aes_js());
  var import_scrypt_js = __toESM(require_scrypt());
  var __awaiter7 = function(thisArg, _arguments, P7, generator) {
    function adopt(value) {
      return value instanceof P7 ? value : new P7(function(resolve) {
        resolve(value);
      });
    }
    return new (P7 || (P7 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e9) {
          reject(e9);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e9) {
          reject(e9);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var logger25 = new Logger(version22);
  function hasMnemonic(value) {
    return value != null && value.mnemonic && value.mnemonic.phrase;
  }
  var KeystoreAccount = class extends Description {
    isKeystoreAccount(value) {
      return !!(value && value._isKeystoreAccount);
    }
  };
  function _decrypt(data2, key2, ciphertext) {
    const cipher = searchPath(data2, "crypto/cipher");
    if (cipher === "aes-128-ctr") {
      const iv2 = looseArrayify(searchPath(data2, "crypto/cipherparams/iv"));
      const counter = new import_aes_js2.default.Counter(iv2);
      const aesCtr = new import_aes_js2.default.ModeOfOperation.ctr(key2, counter);
      return arrayify(aesCtr.decrypt(ciphertext));
    }
    return null;
  }
  function _getAccount(data2, key2) {
    const ciphertext = looseArrayify(searchPath(data2, "crypto/ciphertext"));
    const computedMAC = hexlify(keccak2562(concat3([key2.slice(16, 32), ciphertext]))).substring(2);
    if (computedMAC !== searchPath(data2, "crypto/mac").toLowerCase()) {
      throw new Error("invalid password");
    }
    const privateKey = _decrypt(data2, key2.slice(0, 16), ciphertext);
    if (!privateKey) {
      logger25.throwError("unsupported cipher", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "decrypt"
      });
    }
    const mnemonicKey = key2.slice(32, 64);
    const address = computeAddress(privateKey);
    if (data2.address) {
      let check = data2.address.toLowerCase();
      if (check.substring(0, 2) !== "0x") {
        check = "0x" + check;
      }
      if (getAddress2(check) !== address) {
        throw new Error("address mismatch");
      }
    }
    const account = {
      _isKeystoreAccount: true,
      address,
      privateKey: hexlify(privateKey)
    };
    if (searchPath(data2, "x-ethers/version") === "0.1") {
      const mnemonicCiphertext = looseArrayify(searchPath(data2, "x-ethers/mnemonicCiphertext"));
      const mnemonicIv = looseArrayify(searchPath(data2, "x-ethers/mnemonicCounter"));
      const mnemonicCounter = new import_aes_js2.default.Counter(mnemonicIv);
      const mnemonicAesCtr = new import_aes_js2.default.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
      const path = searchPath(data2, "x-ethers/path") || defaultPath;
      const locale = searchPath(data2, "x-ethers/locale") || "en";
      const entropy = arrayify(mnemonicAesCtr.decrypt(mnemonicCiphertext));
      try {
        const mnemonic = entropyToMnemonic(entropy, locale);
        const node = HDNode.fromMnemonic(mnemonic, null, locale).derivePath(path);
        if (node.privateKey != account.privateKey) {
          throw new Error("mnemonic mismatch");
        }
        account.mnemonic = node.mnemonic;
      } catch (error) {
        if (error.code !== Logger.errors.INVALID_ARGUMENT || error.argument !== "wordlist") {
          throw error;
        }
      }
    }
    return new KeystoreAccount(account);
  }
  function pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc) {
    return arrayify(pbkdf2(passwordBytes, salt, count, dkLen, prfFunc));
  }
  function pbkdf22(passwordBytes, salt, count, dkLen, prfFunc) {
    return Promise.resolve(pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc));
  }
  function _computeKdfKey(data2, password, pbkdf2Func, scryptFunc, progressCallback) {
    const passwordBytes = getPassword(password);
    const kdf = searchPath(data2, "crypto/kdf");
    if (kdf && typeof kdf === "string") {
      const throwError = function(name2, value) {
        return logger25.throwArgumentError("invalid key-derivation function parameters", name2, value);
      };
      if (kdf.toLowerCase() === "scrypt") {
        const salt = looseArrayify(searchPath(data2, "crypto/kdfparams/salt"));
        const N17 = parseInt(searchPath(data2, "crypto/kdfparams/n"));
        const r8 = parseInt(searchPath(data2, "crypto/kdfparams/r"));
        const p8 = parseInt(searchPath(data2, "crypto/kdfparams/p"));
        if (!N17 || !r8 || !p8) {
          throwError("kdf", kdf);
        }
        if ((N17 & N17 - 1) !== 0) {
          throwError("N", N17);
        }
        const dkLen = parseInt(searchPath(data2, "crypto/kdfparams/dklen"));
        if (dkLen !== 32) {
          throwError("dklen", dkLen);
        }
        return scryptFunc(passwordBytes, salt, N17, r8, p8, 64, progressCallback);
      } else if (kdf.toLowerCase() === "pbkdf2") {
        const salt = looseArrayify(searchPath(data2, "crypto/kdfparams/salt"));
        let prfFunc = null;
        const prf = searchPath(data2, "crypto/kdfparams/prf");
        if (prf === "hmac-sha256") {
          prfFunc = "sha256";
        } else if (prf === "hmac-sha512") {
          prfFunc = "sha512";
        } else {
          throwError("prf", prf);
        }
        const count = parseInt(searchPath(data2, "crypto/kdfparams/c"));
        const dkLen = parseInt(searchPath(data2, "crypto/kdfparams/dklen"));
        if (dkLen !== 32) {
          throwError("dklen", dkLen);
        }
        return pbkdf2Func(passwordBytes, salt, count, dkLen, prfFunc);
      }
    }
    return logger25.throwArgumentError("unsupported key-derivation function", "kdf", kdf);
  }
  function decryptSync(json, password) {
    const data2 = JSON.parse(json);
    const key2 = _computeKdfKey(data2, password, pbkdf2Sync, import_scrypt_js.default.syncScrypt);
    return _getAccount(data2, key2);
  }
  function decrypt2(json, password, progressCallback) {
    return __awaiter7(this, void 0, void 0, function* () {
      const data2 = JSON.parse(json);
      const key2 = yield _computeKdfKey(data2, password, pbkdf22, import_scrypt_js.default.scrypt, progressCallback);
      return _getAccount(data2, key2);
    });
  }
  function encrypt(account, password, options2, progressCallback) {
    try {
      if (getAddress2(account.address) !== computeAddress(account.privateKey)) {
        throw new Error("address/privateKey mismatch");
      }
      if (hasMnemonic(account)) {
        const mnemonic = account.mnemonic;
        const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path || defaultPath);
        if (node.privateKey != account.privateKey) {
          throw new Error("mnemonic mismatch");
        }
      }
    } catch (e9) {
      return Promise.reject(e9);
    }
    if (typeof options2 === "function" && !progressCallback) {
      progressCallback = options2;
      options2 = {};
    }
    if (!options2) {
      options2 = {};
    }
    const privateKey = arrayify(account.privateKey);
    const passwordBytes = getPassword(password);
    let entropy = null;
    let path = null;
    let locale = null;
    if (hasMnemonic(account)) {
      const srcMnemonic = account.mnemonic;
      entropy = arrayify(mnemonicToEntropy(srcMnemonic.phrase, srcMnemonic.locale || "en"));
      path = srcMnemonic.path || defaultPath;
      locale = srcMnemonic.locale || "en";
    }
    let client = options2.client;
    if (!client) {
      client = "ethers.js";
    }
    let salt = null;
    if (options2.salt) {
      salt = arrayify(options2.salt);
    } else {
      salt = randomBytes2(32);
      ;
    }
    let iv2 = null;
    if (options2.iv) {
      iv2 = arrayify(options2.iv);
      if (iv2.length !== 16) {
        throw new Error("invalid iv");
      }
    } else {
      iv2 = randomBytes2(16);
    }
    let uuidRandom = null;
    if (options2.uuid) {
      uuidRandom = arrayify(options2.uuid);
      if (uuidRandom.length !== 16) {
        throw new Error("invalid uuid");
      }
    } else {
      uuidRandom = randomBytes2(16);
    }
    let N17 = 1 << 17, r8 = 8, p8 = 1;
    if (options2.scrypt) {
      if (options2.scrypt.N) {
        N17 = options2.scrypt.N;
      }
      if (options2.scrypt.r) {
        r8 = options2.scrypt.r;
      }
      if (options2.scrypt.p) {
        p8 = options2.scrypt.p;
      }
    }
    return import_scrypt_js.default.scrypt(passwordBytes, salt, N17, r8, p8, 64, progressCallback).then((key2) => {
      key2 = arrayify(key2);
      const derivedKey = key2.slice(0, 16);
      const macPrefix = key2.slice(16, 32);
      const mnemonicKey = key2.slice(32, 64);
      const counter = new import_aes_js2.default.Counter(iv2);
      const aesCtr = new import_aes_js2.default.ModeOfOperation.ctr(derivedKey, counter);
      const ciphertext = arrayify(aesCtr.encrypt(privateKey));
      const mac = keccak2562(concat3([macPrefix, ciphertext]));
      const data2 = {
        address: account.address.substring(2).toLowerCase(),
        id: uuidV4(uuidRandom),
        version: 3,
        crypto: {
          cipher: "aes-128-ctr",
          cipherparams: {
            iv: hexlify(iv2).substring(2)
          },
          ciphertext: hexlify(ciphertext).substring(2),
          kdf: "scrypt",
          kdfparams: {
            salt: hexlify(salt).substring(2),
            n: N17,
            dklen: 32,
            p: p8,
            r: r8
          },
          mac: mac.substring(2)
        }
      };
      if (entropy) {
        const mnemonicIv = randomBytes2(16);
        const mnemonicCounter = new import_aes_js2.default.Counter(mnemonicIv);
        const mnemonicAesCtr = new import_aes_js2.default.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
        const mnemonicCiphertext = arrayify(mnemonicAesCtr.encrypt(entropy));
        const now2 = /* @__PURE__ */ new Date();
        const timestamp = now2.getUTCFullYear() + "-" + zpad(now2.getUTCMonth() + 1, 2) + "-" + zpad(now2.getUTCDate(), 2) + "T" + zpad(now2.getUTCHours(), 2) + "-" + zpad(now2.getUTCMinutes(), 2) + "-" + zpad(now2.getUTCSeconds(), 2) + ".0Z";
        data2["x-ethers"] = {
          client,
          gethFilename: "UTC--" + timestamp + "--" + data2.address,
          mnemonicCounter: hexlify(mnemonicIv).substring(2),
          mnemonicCiphertext: hexlify(mnemonicCiphertext).substring(2),
          path,
          locale,
          version: "0.1"
        };
      }
      return JSON.stringify(data2);
    });
  }

  // node_modules/@ethersproject/json-wallets/lib.esm/index.js
  function decryptJsonWallet(json, password, progressCallback) {
    if (isCrowdsaleWallet(json)) {
      if (progressCallback) {
        progressCallback(0);
      }
      const account = decrypt(json, password);
      if (progressCallback) {
        progressCallback(1);
      }
      return Promise.resolve(account);
    }
    if (isKeystoreWallet(json)) {
      return decrypt2(json, password, progressCallback);
    }
    return Promise.reject(new Error("invalid JSON wallet"));
  }
  function decryptJsonWalletSync(json, password) {
    if (isCrowdsaleWallet(json)) {
      return decrypt(json, password);
    }
    if (isKeystoreWallet(json)) {
      return decryptSync(json, password);
    }
    throw new Error("invalid JSON wallet");
  }

  // node_modules/@ethersproject/wallet/lib.esm/_version.js
  var version23 = "wallet/5.7.0";

  // node_modules/@ethersproject/wallet/lib.esm/index.js
  var __awaiter8 = function(thisArg, _arguments, P7, generator) {
    function adopt(value) {
      return value instanceof P7 ? value : new P7(function(resolve) {
        resolve(value);
      });
    }
    return new (P7 || (P7 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e9) {
          reject(e9);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e9) {
          reject(e9);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var logger26 = new Logger(version23);
  function isAccount(value) {
    return value != null && isHexString(value.privateKey, 32) && value.address != null;
  }
  function hasMnemonic2(value) {
    const mnemonic = value.mnemonic;
    return mnemonic && mnemonic.phrase;
  }
  var Wallet = class extends Signer {
    constructor(privateKey, provider) {
      super();
      if (isAccount(privateKey)) {
        const signingKey = new SigningKey(privateKey.privateKey);
        defineReadOnly(this, "_signingKey", () => signingKey);
        defineReadOnly(this, "address", computeAddress(this.publicKey));
        if (this.address !== getAddress2(privateKey.address)) {
          logger26.throwArgumentError("privateKey/address mismatch", "privateKey", "[REDACTED]");
        }
        if (hasMnemonic2(privateKey)) {
          const srcMnemonic = privateKey.mnemonic;
          defineReadOnly(this, "_mnemonic", () => ({
            phrase: srcMnemonic.phrase,
            path: srcMnemonic.path || defaultPath,
            locale: srcMnemonic.locale || "en"
          }));
          const mnemonic = this.mnemonic;
          const node = HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path);
          if (computeAddress(node.privateKey) !== this.address) {
            logger26.throwArgumentError("mnemonic/address mismatch", "privateKey", "[REDACTED]");
          }
        } else {
          defineReadOnly(this, "_mnemonic", () => null);
        }
      } else {
        if (SigningKey.isSigningKey(privateKey)) {
          if (privateKey.curve !== "secp256k1") {
            logger26.throwArgumentError("unsupported curve; must be secp256k1", "privateKey", "[REDACTED]");
          }
          defineReadOnly(this, "_signingKey", () => privateKey);
        } else {
          if (typeof privateKey === "string") {
            if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {
              privateKey = "0x" + privateKey;
            }
          }
          const signingKey = new SigningKey(privateKey);
          defineReadOnly(this, "_signingKey", () => signingKey);
        }
        defineReadOnly(this, "_mnemonic", () => null);
        defineReadOnly(this, "address", computeAddress(this.publicKey));
      }
      if (provider && !Provider.isProvider(provider)) {
        logger26.throwArgumentError("invalid provider", "provider", provider);
      }
      defineReadOnly(this, "provider", provider || null);
    }
    get mnemonic() {
      return this._mnemonic();
    }
    get privateKey() {
      return this._signingKey().privateKey;
    }
    get publicKey() {
      return this._signingKey().publicKey;
    }
    getAddress() {
      return Promise.resolve(this.address);
    }
    connect(provider) {
      return new Wallet(this, provider);
    }
    signTransaction(transaction) {
      return resolveProperties(transaction).then((tx) => {
        if (tx.from != null) {
          if (getAddress2(tx.from) !== this.address) {
            logger26.throwArgumentError("transaction from address mismatch", "transaction.from", transaction.from);
          }
          delete tx.from;
        }
        const signature2 = this._signingKey().signDigest(keccak2562(serialize2(tx)));
        return serialize2(tx, signature2);
      });
    }
    signMessage(message) {
      return __awaiter8(this, void 0, void 0, function* () {
        return joinSignature(this._signingKey().signDigest(hashMessage2(message)));
      });
    }
    _signTypedData(domain2, types, value) {
      return __awaiter8(this, void 0, void 0, function* () {
        const populated = yield TypedDataEncoder.resolveNames(domain2, types, value, (name2) => {
          if (this.provider == null) {
            logger26.throwError("cannot resolve ENS names without a provider", Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "resolveName",
              value: name2
            });
          }
          return this.provider.resolveName(name2);
        });
        return joinSignature(this._signingKey().signDigest(TypedDataEncoder.hash(populated.domain, types, populated.value)));
      });
    }
    encrypt(password, options2, progressCallback) {
      if (typeof options2 === "function" && !progressCallback) {
        progressCallback = options2;
        options2 = {};
      }
      if (progressCallback && typeof progressCallback !== "function") {
        throw new Error("invalid callback");
      }
      if (!options2) {
        options2 = {};
      }
      return encrypt(this, password, options2, progressCallback);
    }
    /**
     *  Static methods to create Wallet instances.
     */
    static createRandom(options2) {
      let entropy = randomBytes2(16);
      if (!options2) {
        options2 = {};
      }
      if (options2.extraEntropy) {
        entropy = arrayify(hexDataSlice(keccak2562(concat3([entropy, options2.extraEntropy])), 0, 16));
      }
      const mnemonic = entropyToMnemonic(entropy, options2.locale);
      return Wallet.fromMnemonic(mnemonic, options2.path, options2.locale);
    }
    static fromEncryptedJson(json, password, progressCallback) {
      return decryptJsonWallet(json, password, progressCallback).then((account) => {
        return new Wallet(account);
      });
    }
    static fromEncryptedJsonSync(json, password) {
      return new Wallet(decryptJsonWalletSync(json, password));
    }
    static fromMnemonic(mnemonic, path, wordlist2) {
      if (!path) {
        path = defaultPath;
      }
      return new Wallet(HDNode.fromMnemonic(mnemonic, null, wordlist2).derivePath(path));
    }
  };
  function verifyMessage3(message, signature2) {
    return recoverAddress2(hashMessage2(message), signature2);
  }
  function verifyTypedData3(domain2, types, value, signature2) {
    return recoverAddress2(TypedDataEncoder.hash(domain2, types, value), signature2);
  }

  // node_modules/@ethersproject/providers/lib.esm/index.js
  var lib_exports4 = {};
  __export(lib_exports4, {
    AlchemyProvider: () => AlchemyProvider,
    AlchemyWebSocketProvider: () => AlchemyWebSocketProvider,
    AnkrProvider: () => AnkrProvider,
    BaseProvider: () => BaseProvider,
    CloudflareProvider: () => CloudflareProvider,
    EtherscanProvider: () => EtherscanProvider,
    FallbackProvider: () => FallbackProvider,
    Formatter: () => Formatter,
    InfuraProvider: () => InfuraProvider,
    InfuraWebSocketProvider: () => InfuraWebSocketProvider,
    IpcProvider: () => IpcProvider,
    JsonRpcBatchProvider: () => JsonRpcBatchProvider,
    JsonRpcProvider: () => JsonRpcProvider2,
    JsonRpcSigner: () => JsonRpcSigner,
    NodesmithProvider: () => NodesmithProvider,
    PocketProvider: () => PocketProvider,
    Provider: () => Provider,
    Resolver: () => Resolver,
    StaticJsonRpcProvider: () => StaticJsonRpcProvider,
    UrlJsonRpcProvider: () => UrlJsonRpcProvider,
    Web3Provider: () => Web3Provider,
    WebSocketProvider: () => WebSocketProvider,
    getDefaultProvider: () => getDefaultProvider,
    getNetwork: () => getNetwork2,
    isCommunityResourcable: () => isCommunityResourcable,
    isCommunityResource: () => isCommunityResource,
    showThrottleMessage: () => showThrottleMessage
  });

  // node_modules/@ethersproject/networks/lib.esm/_version.js
  var version24 = "networks/5.7.1";

  // node_modules/@ethersproject/networks/lib.esm/index.js
  var logger27 = new Logger(version24);
  function isRenetworkable(value) {
    return value && typeof value.renetwork === "function";
  }
  function ethDefaultProvider(network) {
    const func = function(providers, options2) {
      if (options2 == null) {
        options2 = {};
      }
      const providerList = [];
      if (providers.InfuraProvider && options2.infura !== "-") {
        try {
          providerList.push(new providers.InfuraProvider(network, options2.infura));
        } catch (error) {
        }
      }
      if (providers.EtherscanProvider && options2.etherscan !== "-") {
        try {
          providerList.push(new providers.EtherscanProvider(network, options2.etherscan));
        } catch (error) {
        }
      }
      if (providers.AlchemyProvider && options2.alchemy !== "-") {
        try {
          providerList.push(new providers.AlchemyProvider(network, options2.alchemy));
        } catch (error) {
        }
      }
      if (providers.PocketProvider && options2.pocket !== "-") {
        const skip = ["goerli", "ropsten", "rinkeby", "sepolia"];
        try {
          const provider = new providers.PocketProvider(network, options2.pocket);
          if (provider.network && skip.indexOf(provider.network.name) === -1) {
            providerList.push(provider);
          }
        } catch (error) {
        }
      }
      if (providers.CloudflareProvider && options2.cloudflare !== "-") {
        try {
          providerList.push(new providers.CloudflareProvider(network));
        } catch (error) {
        }
      }
      if (providers.AnkrProvider && options2.ankr !== "-") {
        try {
          const skip = ["ropsten"];
          const provider = new providers.AnkrProvider(network, options2.ankr);
          if (provider.network && skip.indexOf(provider.network.name) === -1) {
            providerList.push(provider);
          }
        } catch (error) {
        }
      }
      if (providerList.length === 0) {
        return null;
      }
      if (providers.FallbackProvider) {
        let quorum = 1;
        if (options2.quorum != null) {
          quorum = options2.quorum;
        } else if (network === "homestead") {
          quorum = 2;
        }
        return new providers.FallbackProvider(providerList, quorum);
      }
      return providerList[0];
    };
    func.renetwork = function(network2) {
      return ethDefaultProvider(network2);
    };
    return func;
  }
  function etcDefaultProvider(url, network) {
    const func = function(providers, options2) {
      if (providers.JsonRpcProvider) {
        return new providers.JsonRpcProvider(url, network);
      }
      return null;
    };
    func.renetwork = function(network2) {
      return etcDefaultProvider(url, network2);
    };
    return func;
  }
  var homestead = {
    chainId: 1,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "homestead",
    _defaultProvider: ethDefaultProvider("homestead")
  };
  var ropsten = {
    chainId: 3,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "ropsten",
    _defaultProvider: ethDefaultProvider("ropsten")
  };
  var classicMordor = {
    chainId: 63,
    name: "classicMordor",
    _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/mordor", "classicMordor")
  };
  var networks = {
    unspecified: { chainId: 0, name: "unspecified" },
    homestead,
    mainnet: homestead,
    morden: { chainId: 2, name: "morden" },
    ropsten,
    testnet: ropsten,
    rinkeby: {
      chainId: 4,
      ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
      name: "rinkeby",
      _defaultProvider: ethDefaultProvider("rinkeby")
    },
    kovan: {
      chainId: 42,
      name: "kovan",
      _defaultProvider: ethDefaultProvider("kovan")
    },
    goerli: {
      chainId: 5,
      ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
      name: "goerli",
      _defaultProvider: ethDefaultProvider("goerli")
    },
    kintsugi: { chainId: 1337702, name: "kintsugi" },
    sepolia: {
      chainId: 11155111,
      name: "sepolia",
      _defaultProvider: ethDefaultProvider("sepolia")
    },
    // ETC (See: #351)
    classic: {
      chainId: 61,
      name: "classic",
      _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/etc", "classic")
    },
    classicMorden: { chainId: 62, name: "classicMorden" },
    classicMordor,
    classicTestnet: classicMordor,
    classicKotti: {
      chainId: 6,
      name: "classicKotti",
      _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/kotti", "classicKotti")
    },
    xdai: { chainId: 100, name: "xdai" },
    matic: {
      chainId: 137,
      name: "matic",
      _defaultProvider: ethDefaultProvider("matic")
    },
    maticmum: { chainId: 80001, name: "maticmum" },
    optimism: {
      chainId: 10,
      name: "optimism",
      _defaultProvider: ethDefaultProvider("optimism")
    },
    "optimism-kovan": { chainId: 69, name: "optimism-kovan" },
    "optimism-goerli": { chainId: 420, name: "optimism-goerli" },
    arbitrum: { chainId: 42161, name: "arbitrum" },
    "arbitrum-rinkeby": { chainId: 421611, name: "arbitrum-rinkeby" },
    "arbitrum-goerli": { chainId: 421613, name: "arbitrum-goerli" },
    bnb: { chainId: 56, name: "bnb" },
    bnbt: { chainId: 97, name: "bnbt" }
  };
  function getNetwork2(network) {
    if (network == null) {
      return null;
    }
    if (typeof network === "number") {
      for (const name2 in networks) {
        const standard2 = networks[name2];
        if (standard2.chainId === network) {
          return {
            name: standard2.name,
            chainId: standard2.chainId,
            ensAddress: standard2.ensAddress || null,
            _defaultProvider: standard2._defaultProvider || null
          };
        }
      }
      return {
        chainId: network,
        name: "unknown"
      };
    }
    if (typeof network === "string") {
      const standard2 = networks[network];
      if (standard2 == null) {
        return null;
      }
      return {
        name: standard2.name,
        chainId: standard2.chainId,
        ensAddress: standard2.ensAddress,
        _defaultProvider: standard2._defaultProvider || null
      };
    }
    const standard = networks[network.name];
    if (!standard) {
      if (typeof network.chainId !== "number") {
        logger27.throwArgumentError("invalid network chainId", "network", network);
      }
      return network;
    }
    if (network.chainId !== 0 && network.chainId !== standard.chainId) {
      logger27.throwArgumentError("network chainId mismatch", "network", network);
    }
    let defaultProvider = network._defaultProvider || null;
    if (defaultProvider == null && standard._defaultProvider) {
      if (isRenetworkable(standard._defaultProvider)) {
        defaultProvider = standard._defaultProvider.renetwork(network);
      } else {
        defaultProvider = standard._defaultProvider;
      }
    }
    return {
      name: network.name,
      chainId: standard.chainId,
      ensAddress: network.ensAddress || standard.ensAddress || null,
      _defaultProvider: defaultProvider
    };
  }

  // node_modules/@ethersproject/web/lib.esm/_version.js
  var version25 = "web/5.7.1";

  // node_modules/@ethersproject/web/lib.esm/geturl.js
  var __awaiter9 = function(thisArg, _arguments, P7, generator) {
    function adopt(value) {
      return value instanceof P7 ? value : new P7(function(resolve) {
        resolve(value);
      });
    }
    return new (P7 || (P7 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e9) {
          reject(e9);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e9) {
          reject(e9);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function getUrl2(href, options2) {
    return __awaiter9(this, void 0, void 0, function* () {
      if (options2 == null) {
        options2 = {};
      }
      const request = {
        method: options2.method || "GET",
        headers: options2.headers || {},
        body: options2.body || void 0
      };
      if (options2.skipFetchSetup !== true) {
        request.mode = "cors";
        request.cache = "no-cache";
        request.credentials = "same-origin";
        request.redirect = "follow";
        request.referrer = "client";
      }
      ;
      if (options2.fetchOptions != null) {
        const opts = options2.fetchOptions;
        if (opts.mode) {
          request.mode = opts.mode;
        }
        if (opts.cache) {
          request.cache = opts.cache;
        }
        if (opts.credentials) {
          request.credentials = opts.credentials;
        }
        if (opts.redirect) {
          request.redirect = opts.redirect;
        }
        if (opts.referrer) {
          request.referrer = opts.referrer;
        }
      }
      const response = yield fetch(href, request);
      const body = yield response.arrayBuffer();
      const headers = {};
      if (response.headers.forEach) {
        response.headers.forEach((value, key2) => {
          headers[key2.toLowerCase()] = value;
        });
      } else {
        response.headers.keys().forEach((key2) => {
          headers[key2.toLowerCase()] = response.headers.get(key2);
        });
      }
      return {
        headers,
        statusCode: response.status,
        statusMessage: response.statusText,
        body: arrayify(new Uint8Array(body))
      };
    });
  }

  // node_modules/@ethersproject/web/lib.esm/index.js
  var __awaiter10 = function(thisArg, _arguments, P7, generator) {
    function adopt(value) {
      return value instanceof P7 ? value : new P7(function(resolve) {
        resolve(value);
      });
    }
    return new (P7 || (P7 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e9) {
          reject(e9);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e9) {
          reject(e9);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var logger28 = new Logger(version25);
  function staller(duration) {
    return new Promise((resolve) => {
      setTimeout(resolve, duration);
    });
  }
  function bodyify(value, type) {
    if (value == null) {
      return null;
    }
    if (typeof value === "string") {
      return value;
    }
    if (isBytesLike(value)) {
      if (type && (type.split("/")[0] === "text" || type.split(";")[0].trim() === "application/json")) {
        try {
          return toUtf8String(value);
        } catch (error) {
        }
        ;
      }
      return hexlify(value);
    }
    return value;
  }
  function unpercent(value) {
    return toUtf8Bytes(value.replace(/%([0-9a-f][0-9a-f])/gi, (all3, code2) => {
      return String.fromCharCode(parseInt(code2, 16));
    }));
  }
  function _fetchData(connection, body, processFunc) {
    const attemptLimit = typeof connection === "object" && connection.throttleLimit != null ? connection.throttleLimit : 12;
    logger28.assertArgument(attemptLimit > 0 && attemptLimit % 1 === 0, "invalid connection throttle limit", "connection.throttleLimit", attemptLimit);
    const throttleCallback = typeof connection === "object" ? connection.throttleCallback : null;
    const throttleSlotInterval = typeof connection === "object" && typeof connection.throttleSlotInterval === "number" ? connection.throttleSlotInterval : 100;
    logger28.assertArgument(throttleSlotInterval > 0 && throttleSlotInterval % 1 === 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", throttleSlotInterval);
    const errorPassThrough = typeof connection === "object" ? !!connection.errorPassThrough : false;
    const headers = {};
    let url = null;
    const options2 = {
      method: "GET"
    };
    let allow304 = false;
    let timeout = 2 * 60 * 1e3;
    if (typeof connection === "string") {
      url = connection;
    } else if (typeof connection === "object") {
      if (connection == null || connection.url == null) {
        logger28.throwArgumentError("missing URL", "connection.url", connection);
      }
      url = connection.url;
      if (typeof connection.timeout === "number" && connection.timeout > 0) {
        timeout = connection.timeout;
      }
      if (connection.headers) {
        for (const key2 in connection.headers) {
          headers[key2.toLowerCase()] = { key: key2, value: String(connection.headers[key2]) };
          if (["if-none-match", "if-modified-since"].indexOf(key2.toLowerCase()) >= 0) {
            allow304 = true;
          }
        }
      }
      options2.allowGzip = !!connection.allowGzip;
      if (connection.user != null && connection.password != null) {
        if (url.substring(0, 6) !== "https:" && connection.allowInsecureAuthentication !== true) {
          logger28.throwError("basic authentication requires a secure https url", Logger.errors.INVALID_ARGUMENT, { argument: "url", url, user: connection.user, password: "[REDACTED]" });
        }
        const authorization = connection.user + ":" + connection.password;
        headers["authorization"] = {
          key: "Authorization",
          value: "Basic " + encode8(toUtf8Bytes(authorization))
        };
      }
      if (connection.skipFetchSetup != null) {
        options2.skipFetchSetup = !!connection.skipFetchSetup;
      }
      if (connection.fetchOptions != null) {
        options2.fetchOptions = shallowCopy(connection.fetchOptions);
      }
    }
    const reData = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i");
    const dataMatch = url ? url.match(reData) : null;
    if (dataMatch) {
      try {
        const response = {
          statusCode: 200,
          statusMessage: "OK",
          headers: { "content-type": dataMatch[1] || "text/plain" },
          body: dataMatch[2] ? decode7(dataMatch[3]) : unpercent(dataMatch[3])
        };
        let result = response.body;
        if (processFunc) {
          result = processFunc(response.body, response);
        }
        return Promise.resolve(result);
      } catch (error) {
        logger28.throwError("processing response error", Logger.errors.SERVER_ERROR, {
          body: bodyify(dataMatch[1], dataMatch[2]),
          error,
          requestBody: null,
          requestMethod: "GET",
          url
        });
      }
    }
    if (body) {
      options2.method = "POST";
      options2.body = body;
      if (headers["content-type"] == null) {
        headers["content-type"] = { key: "Content-Type", value: "application/octet-stream" };
      }
      if (headers["content-length"] == null) {
        headers["content-length"] = { key: "Content-Length", value: String(body.length) };
      }
    }
    const flatHeaders = {};
    Object.keys(headers).forEach((key2) => {
      const header = headers[key2];
      flatHeaders[header.key] = header.value;
    });
    options2.headers = flatHeaders;
    const runningTimeout = function() {
      let timer2 = null;
      const promise = new Promise(function(resolve, reject) {
        if (timeout) {
          timer2 = setTimeout(() => {
            if (timer2 == null) {
              return;
            }
            timer2 = null;
            reject(logger28.makeError("timeout", Logger.errors.TIMEOUT, {
              requestBody: bodyify(options2.body, flatHeaders["content-type"]),
              requestMethod: options2.method,
              timeout,
              url
            }));
          }, timeout);
        }
      });
      const cancel = function() {
        if (timer2 == null) {
          return;
        }
        clearTimeout(timer2);
        timer2 = null;
      };
      return { promise, cancel };
    }();
    const runningFetch = function() {
      return __awaiter10(this, void 0, void 0, function* () {
        for (let attempt = 0; attempt < attemptLimit; attempt++) {
          let response = null;
          try {
            response = yield getUrl2(url, options2);
            if (attempt < attemptLimit) {
              if (response.statusCode === 301 || response.statusCode === 302) {
                const location2 = response.headers.location || "";
                if (options2.method === "GET" && location2.match(/^https:/)) {
                  url = response.headers.location;
                  continue;
                }
              } else if (response.statusCode === 429) {
                let tryAgain = true;
                if (throttleCallback) {
                  tryAgain = yield throttleCallback(attempt, url);
                }
                if (tryAgain) {
                  let stall3 = 0;
                  const retryAfter = response.headers["retry-after"];
                  if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
                    stall3 = parseInt(retryAfter) * 1e3;
                  } else {
                    stall3 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                  }
                  yield staller(stall3);
                  continue;
                }
              }
            }
          } catch (error) {
            response = error.response;
            if (response == null) {
              runningTimeout.cancel();
              logger28.throwError("missing response", Logger.errors.SERVER_ERROR, {
                requestBody: bodyify(options2.body, flatHeaders["content-type"]),
                requestMethod: options2.method,
                serverError: error,
                url
              });
            }
          }
          let body2 = response.body;
          if (allow304 && response.statusCode === 304) {
            body2 = null;
          } else if (!errorPassThrough && (response.statusCode < 200 || response.statusCode >= 300)) {
            runningTimeout.cancel();
            logger28.throwError("bad response", Logger.errors.SERVER_ERROR, {
              status: response.statusCode,
              headers: response.headers,
              body: bodyify(body2, response.headers ? response.headers["content-type"] : null),
              requestBody: bodyify(options2.body, flatHeaders["content-type"]),
              requestMethod: options2.method,
              url
            });
          }
          if (processFunc) {
            try {
              const result = yield processFunc(body2, response);
              runningTimeout.cancel();
              return result;
            } catch (error) {
              if (error.throttleRetry && attempt < attemptLimit) {
                let tryAgain = true;
                if (throttleCallback) {
                  tryAgain = yield throttleCallback(attempt, url);
                }
                if (tryAgain) {
                  const timeout2 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                  yield staller(timeout2);
                  continue;
                }
              }
              runningTimeout.cancel();
              logger28.throwError("processing response error", Logger.errors.SERVER_ERROR, {
                body: bodyify(body2, response.headers ? response.headers["content-type"] : null),
                error,
                requestBody: bodyify(options2.body, flatHeaders["content-type"]),
                requestMethod: options2.method,
                url
              });
            }
          }
          runningTimeout.cancel();
          return body2;
        }
        return logger28.throwError("failed response", Logger.errors.SERVER_ERROR, {
          requestBody: bodyify(options2.body, flatHeaders["content-type"]),
          requestMethod: options2.method,
          url
        });
      });
    }();
    return Promise.race([runningTimeout.promise, runningFetch]);
  }
  function fetchJson(connection, json, processFunc) {
    let processJsonFunc = (value, response) => {
      let result = null;
      if (value != null) {
        try {
          result = JSON.parse(toUtf8String(value));
        } catch (error) {
          logger28.throwError("invalid JSON", Logger.errors.SERVER_ERROR, {
            body: value,
            error
          });
        }
      }
      if (processFunc) {
        result = processFunc(result, response);
      }
      return result;
    };
    let body = null;
    if (json != null) {
      body = toUtf8Bytes(json);
      const updated = typeof connection === "string" ? { url: connection } : shallowCopy(connection);
      if (updated.headers) {
        const hasContentType = Object.keys(updated.headers).filter((k6) => k6.toLowerCase() === "content-type").length !== 0;
        if (!hasContentType) {
          updated.headers = shallowCopy(updated.headers);
          updated.headers["content-type"] = "application/json";
        }
      } else {
        updated.headers = { "content-type": "application/json" };
      }
      connection = updated;
    }
    return _fetchData(connection, body, processJsonFunc);
  }
  function poll2(func, options2) {
    if (!options2) {
      options2 = {};
    }
    options2 = shallowCopy(options2);
    if (options2.floor == null) {
      options2.floor = 0;
    }
    if (options2.ceiling == null) {
      options2.ceiling = 1e4;
    }
    if (options2.interval == null) {
      options2.interval = 250;
    }
    return new Promise(function(resolve, reject) {
      let timer2 = null;
      let done = false;
      const cancel = () => {
        if (done) {
          return false;
        }
        done = true;
        if (timer2) {
          clearTimeout(timer2);
        }
        return true;
      };
      if (options2.timeout) {
        timer2 = setTimeout(() => {
          if (cancel()) {
            reject(new Error("timeout"));
          }
        }, options2.timeout);
      }
      const retryLimit = options2.retryLimit;
      let attempt = 0;
      function check() {
        return func().then(function(result) {
          if (result !== void 0) {
            if (cancel()) {
              resolve(result);
            }
          } else if (options2.oncePoll) {
            options2.oncePoll.once("poll", check);
          } else if (options2.onceBlock) {
            options2.onceBlock.once("block", check);
          } else if (!done) {
            attempt++;
            if (attempt > retryLimit) {
              if (cancel()) {
                reject(new Error("retry limit reached"));
              }
              return;
            }
            let timeout = options2.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));
            if (timeout < options2.floor) {
              timeout = options2.floor;
            }
            if (timeout > options2.ceiling) {
              timeout = options2.ceiling;
            }
            setTimeout(check, timeout);
          }
          return null;
        }, function(error) {
          if (cancel()) {
            reject(error);
          }
        });
      }
      check();
    });
  }

  // node_modules/@ethersproject/providers/lib.esm/base-provider.js
  var import_bech32 = __toESM(require_bech32());

  // node_modules/@ethersproject/providers/lib.esm/_version.js
  var version26 = "providers/5.7.2";

  // node_modules/@ethersproject/providers/lib.esm/formatter.js
  var logger29 = new Logger(version26);
  var Formatter = class {
    constructor() {
      this.formats = this.getDefaultFormats();
    }
    getDefaultFormats() {
      const formats = {};
      const address = this.address.bind(this);
      const bigNumber = this.bigNumber.bind(this);
      const blockTag = this.blockTag.bind(this);
      const data2 = this.data.bind(this);
      const hash5 = this.hash.bind(this);
      const hex = this.hex.bind(this);
      const number2 = this.number.bind(this);
      const type = this.type.bind(this);
      const strictData = (v6) => {
        return this.data(v6, true);
      };
      formats.transaction = {
        hash: hash5,
        type,
        accessList: Formatter.allowNull(this.accessList.bind(this), null),
        blockHash: Formatter.allowNull(hash5, null),
        blockNumber: Formatter.allowNull(number2, null),
        transactionIndex: Formatter.allowNull(number2, null),
        confirmations: Formatter.allowNull(number2, null),
        from: address,
        // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)
        // must be set
        gasPrice: Formatter.allowNull(bigNumber),
        maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
        maxFeePerGas: Formatter.allowNull(bigNumber),
        gasLimit: bigNumber,
        to: Formatter.allowNull(address, null),
        value: bigNumber,
        nonce: number2,
        data: data2,
        r: Formatter.allowNull(this.uint256),
        s: Formatter.allowNull(this.uint256),
        v: Formatter.allowNull(number2),
        creates: Formatter.allowNull(address, null),
        raw: Formatter.allowNull(data2)
      };
      formats.transactionRequest = {
        from: Formatter.allowNull(address),
        nonce: Formatter.allowNull(number2),
        gasLimit: Formatter.allowNull(bigNumber),
        gasPrice: Formatter.allowNull(bigNumber),
        maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
        maxFeePerGas: Formatter.allowNull(bigNumber),
        to: Formatter.allowNull(address),
        value: Formatter.allowNull(bigNumber),
        data: Formatter.allowNull(strictData),
        type: Formatter.allowNull(number2),
        accessList: Formatter.allowNull(this.accessList.bind(this), null)
      };
      formats.receiptLog = {
        transactionIndex: number2,
        blockNumber: number2,
        transactionHash: hash5,
        address,
        topics: Formatter.arrayOf(hash5),
        data: data2,
        logIndex: number2,
        blockHash: hash5
      };
      formats.receipt = {
        to: Formatter.allowNull(this.address, null),
        from: Formatter.allowNull(this.address, null),
        contractAddress: Formatter.allowNull(address, null),
        transactionIndex: number2,
        // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
        root: Formatter.allowNull(hex),
        gasUsed: bigNumber,
        logsBloom: Formatter.allowNull(data2),
        blockHash: hash5,
        transactionHash: hash5,
        logs: Formatter.arrayOf(this.receiptLog.bind(this)),
        blockNumber: number2,
        confirmations: Formatter.allowNull(number2, null),
        cumulativeGasUsed: bigNumber,
        effectiveGasPrice: Formatter.allowNull(bigNumber),
        status: Formatter.allowNull(number2),
        type
      };
      formats.block = {
        hash: Formatter.allowNull(hash5),
        parentHash: hash5,
        number: number2,
        timestamp: number2,
        nonce: Formatter.allowNull(hex),
        difficulty: this.difficulty.bind(this),
        gasLimit: bigNumber,
        gasUsed: bigNumber,
        miner: Formatter.allowNull(address),
        extraData: data2,
        transactions: Formatter.allowNull(Formatter.arrayOf(hash5)),
        baseFeePerGas: Formatter.allowNull(bigNumber)
      };
      formats.blockWithTransactions = shallowCopy(formats.block);
      formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));
      formats.filter = {
        fromBlock: Formatter.allowNull(blockTag, void 0),
        toBlock: Formatter.allowNull(blockTag, void 0),
        blockHash: Formatter.allowNull(hash5, void 0),
        address: Formatter.allowNull(address, void 0),
        topics: Formatter.allowNull(this.topics.bind(this), void 0)
      };
      formats.filterLog = {
        blockNumber: Formatter.allowNull(number2),
        blockHash: Formatter.allowNull(hash5),
        transactionIndex: number2,
        removed: Formatter.allowNull(this.boolean.bind(this)),
        address,
        data: Formatter.allowFalsish(data2, "0x"),
        topics: Formatter.arrayOf(hash5),
        transactionHash: hash5,
        logIndex: number2
      };
      return formats;
    }
    accessList(accessList) {
      return accessListify(accessList || []);
    }
    // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number
    // Strict! Used on input.
    number(number2) {
      if (number2 === "0x") {
        return 0;
      }
      return BigNumber.from(number2).toNumber();
    }
    type(number2) {
      if (number2 === "0x" || number2 == null) {
        return 0;
      }
      return BigNumber.from(number2).toNumber();
    }
    // Strict! Used on input.
    bigNumber(value) {
      return BigNumber.from(value);
    }
    // Requires a boolean, "true" or  "false"; returns a boolean
    boolean(value) {
      if (typeof value === "boolean") {
        return value;
      }
      if (typeof value === "string") {
        value = value.toLowerCase();
        if (value === "true") {
          return true;
        }
        if (value === "false") {
          return false;
        }
      }
      throw new Error("invalid boolean - " + value);
    }
    hex(value, strict) {
      if (typeof value === "string") {
        if (!strict && value.substring(0, 2) !== "0x") {
          value = "0x" + value;
        }
        if (isHexString(value)) {
          return value.toLowerCase();
        }
      }
      return logger29.throwArgumentError("invalid hash", "value", value);
    }
    data(value, strict) {
      const result = this.hex(value, strict);
      if (result.length % 2 !== 0) {
        throw new Error("invalid data; odd-length - " + value);
      }
      return result;
    }
    // Requires an address
    // Strict! Used on input.
    address(value) {
      return getAddress2(value);
    }
    callAddress(value) {
      if (!isHexString(value, 32)) {
        return null;
      }
      const address = getAddress2(hexDataSlice(value, 12));
      return address === AddressZero ? null : address;
    }
    contractAddress(value) {
      return getContractAddress3(value);
    }
    // Strict! Used on input.
    blockTag(blockTag) {
      if (blockTag == null) {
        return "latest";
      }
      if (blockTag === "earliest") {
        return "0x0";
      }
      switch (blockTag) {
        case "earliest":
          return "0x0";
        case "latest":
        case "pending":
        case "safe":
        case "finalized":
          return blockTag;
      }
      if (typeof blockTag === "number" || isHexString(blockTag)) {
        return hexValue(blockTag);
      }
      throw new Error("invalid blockTag");
    }
    // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.
    hash(value, strict) {
      const result = this.hex(value, strict);
      if (hexDataLength(result) !== 32) {
        return logger29.throwArgumentError("invalid hash", "value", value);
      }
      return result;
    }
    // Returns the difficulty as a number, or if too large (i.e. PoA network) null
    difficulty(value) {
      if (value == null) {
        return null;
      }
      const v6 = BigNumber.from(value);
      try {
        return v6.toNumber();
      } catch (error) {
      }
      return null;
    }
    uint256(value) {
      if (!isHexString(value)) {
        throw new Error("invalid uint256");
      }
      return hexZeroPad(value, 32);
    }
    _block(value, format2) {
      if (value.author != null && value.miner == null) {
        value.miner = value.author;
      }
      const difficulty = value._difficulty != null ? value._difficulty : value.difficulty;
      const result = Formatter.check(format2, value);
      result._difficulty = difficulty == null ? null : BigNumber.from(difficulty);
      return result;
    }
    block(value) {
      return this._block(value, this.formats.block);
    }
    blockWithTransactions(value) {
      return this._block(value, this.formats.blockWithTransactions);
    }
    // Strict! Used on input.
    transactionRequest(value) {
      return Formatter.check(this.formats.transactionRequest, value);
    }
    transactionResponse(transaction) {
      if (transaction.gas != null && transaction.gasLimit == null) {
        transaction.gasLimit = transaction.gas;
      }
      if (transaction.to && BigNumber.from(transaction.to).isZero()) {
        transaction.to = "0x0000000000000000000000000000000000000000";
      }
      if (transaction.input != null && transaction.data == null) {
        transaction.data = transaction.input;
      }
      if (transaction.to == null && transaction.creates == null) {
        transaction.creates = this.contractAddress(transaction);
      }
      if ((transaction.type === 1 || transaction.type === 2) && transaction.accessList == null) {
        transaction.accessList = [];
      }
      const result = Formatter.check(this.formats.transaction, transaction);
      if (transaction.chainId != null) {
        let chainId = transaction.chainId;
        if (isHexString(chainId)) {
          chainId = BigNumber.from(chainId).toNumber();
        }
        result.chainId = chainId;
      } else {
        let chainId = transaction.networkId;
        if (chainId == null && result.v == null) {
          chainId = transaction.chainId;
        }
        if (isHexString(chainId)) {
          chainId = BigNumber.from(chainId).toNumber();
        }
        if (typeof chainId !== "number" && result.v != null) {
          chainId = (result.v - 35) / 2;
          if (chainId < 0) {
            chainId = 0;
          }
          chainId = parseInt(chainId);
        }
        if (typeof chainId !== "number") {
          chainId = 0;
        }
        result.chainId = chainId;
      }
      if (result.blockHash && result.blockHash.replace(/0/g, "") === "x") {
        result.blockHash = null;
      }
      return result;
    }
    transaction(value) {
      return parse3(value);
    }
    receiptLog(value) {
      return Formatter.check(this.formats.receiptLog, value);
    }
    receipt(value) {
      const result = Formatter.check(this.formats.receipt, value);
      if (result.root != null) {
        if (result.root.length <= 4) {
          const value2 = BigNumber.from(result.root).toNumber();
          if (value2 === 0 || value2 === 1) {
            if (result.status != null && result.status !== value2) {
              logger29.throwArgumentError("alt-root-status/status mismatch", "value", { root: result.root, status: result.status });
            }
            result.status = value2;
            delete result.root;
          } else {
            logger29.throwArgumentError("invalid alt-root-status", "value.root", result.root);
          }
        } else if (result.root.length !== 66) {
          logger29.throwArgumentError("invalid root hash", "value.root", result.root);
        }
      }
      if (result.status != null) {
        result.byzantium = true;
      }
      return result;
    }
    topics(value) {
      if (Array.isArray(value)) {
        return value.map((v6) => this.topics(v6));
      } else if (value != null) {
        return this.hash(value, true);
      }
      return null;
    }
    filter(value) {
      return Formatter.check(this.formats.filter, value);
    }
    filterLog(value) {
      return Formatter.check(this.formats.filterLog, value);
    }
    static check(format2, object) {
      const result = {};
      for (const key2 in format2) {
        try {
          const value = format2[key2](object[key2]);
          if (value !== void 0) {
            result[key2] = value;
          }
        } catch (error) {
          error.checkKey = key2;
          error.checkValue = object[key2];
          throw error;
        }
      }
      return result;
    }
    // if value is null-ish, nullValue is returned
    static allowNull(format2, nullValue) {
      return function(value) {
        if (value == null) {
          return nullValue;
        }
        return format2(value);
      };
    }
    // If value is false-ish, replaceValue is returned
    static allowFalsish(format2, replaceValue) {
      return function(value) {
        if (!value) {
          return replaceValue;
        }
        return format2(value);
      };
    }
    // Requires an Array satisfying check
    static arrayOf(format2) {
      return function(array) {
        if (!Array.isArray(array)) {
          throw new Error("not an array");
        }
        const result = [];
        array.forEach(function(value) {
          result.push(format2(value));
        });
        return result;
      };
    }
  };
  function isCommunityResourcable(value) {
    return value && typeof value.isCommunityResource === "function";
  }
  function isCommunityResource(value) {
    return isCommunityResourcable(value) && value.isCommunityResource();
  }
  var throttleMessage = false;
  function showThrottleMessage() {
    if (throttleMessage) {
      return;
    }
    throttleMessage = true;
    console.log("========= NOTICE =========");
    console.log("Request-Rate Exceeded  (this message will not be repeated)");
    console.log("");
    console.log("The default API keys for each service are provided as a highly-throttled,");
    console.log("community resource for low-traffic projects and early prototyping.");
    console.log("");
    console.log("While your application will continue to function, we highly recommended");
    console.log("signing up for your own API keys to improve performance, increase your");
    console.log("request rate/limit and enable other perks, such as metrics and advanced APIs.");
    console.log("");
    console.log("For more details: https://docs.ethers.io/api-keys/");
    console.log("==========================");
  }

  // node_modules/@ethersproject/providers/lib.esm/base-provider.js
  var __awaiter11 = function(thisArg, _arguments, P7, generator) {
    function adopt(value) {
      return value instanceof P7 ? value : new P7(function(resolve) {
        resolve(value);
      });
    }
    return new (P7 || (P7 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e9) {
          reject(e9);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e9) {
          reject(e9);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var logger30 = new Logger(version26);
  var MAX_CCIP_REDIRECTS = 10;
  function checkTopic(topic) {
    if (topic == null) {
      return "null";
    }
    if (hexDataLength(topic) !== 32) {
      logger30.throwArgumentError("invalid topic", "topic", topic);
    }
    return topic.toLowerCase();
  }
  function serializeTopics(topics) {
    topics = topics.slice();
    while (topics.length > 0 && topics[topics.length - 1] == null) {
      topics.pop();
    }
    return topics.map((topic) => {
      if (Array.isArray(topic)) {
        const unique = {};
        topic.forEach((topic2) => {
          unique[checkTopic(topic2)] = true;
        });
        const sorted = Object.keys(unique);
        sorted.sort();
        return sorted.join("|");
      } else {
        return checkTopic(topic);
      }
    }).join("&");
  }
  function deserializeTopics(data2) {
    if (data2 === "") {
      return [];
    }
    return data2.split(/&/g).map((topic) => {
      if (topic === "") {
        return [];
      }
      const comps = topic.split("|").map((topic2) => {
        return topic2 === "null" ? null : topic2;
      });
      return comps.length === 1 ? comps[0] : comps;
    });
  }
  function getEventTag2(eventName) {
    if (typeof eventName === "string") {
      eventName = eventName.toLowerCase();
      if (hexDataLength(eventName) === 32) {
        return "tx:" + eventName;
      }
      if (eventName.indexOf(":") === -1) {
        return eventName;
      }
    } else if (Array.isArray(eventName)) {
      return "filter:*:" + serializeTopics(eventName);
    } else if (ForkEvent.isForkEvent(eventName)) {
      logger30.warn("not implemented");
      throw new Error("not implemented");
    } else if (eventName && typeof eventName === "object") {
      return "filter:" + (eventName.address || "*") + ":" + serializeTopics(eventName.topics || []);
    }
    throw new Error("invalid event - " + eventName);
  }
  function getTime() {
    return (/* @__PURE__ */ new Date()).getTime();
  }
  function stall(duration) {
    return new Promise((resolve) => {
      setTimeout(resolve, duration);
    });
  }
  var PollableEvents = ["block", "network", "pending", "poll"];
  var Event = class {
    constructor(tag, listener, once) {
      defineReadOnly(this, "tag", tag);
      defineReadOnly(this, "listener", listener);
      defineReadOnly(this, "once", once);
      this._lastBlockNumber = -2;
      this._inflight = false;
    }
    get event() {
      switch (this.type) {
        case "tx":
          return this.hash;
        case "filter":
          return this.filter;
      }
      return this.tag;
    }
    get type() {
      return this.tag.split(":")[0];
    }
    get hash() {
      const comps = this.tag.split(":");
      if (comps[0] !== "tx") {
        return null;
      }
      return comps[1];
    }
    get filter() {
      const comps = this.tag.split(":");
      if (comps[0] !== "filter") {
        return null;
      }
      const address = comps[1];
      const topics = deserializeTopics(comps[2]);
      const filter2 = {};
      if (topics.length > 0) {
        filter2.topics = topics;
      }
      if (address && address !== "*") {
        filter2.address = address;
      }
      return filter2;
    }
    pollable() {
      return this.tag.indexOf(":") >= 0 || PollableEvents.indexOf(this.tag) >= 0;
    }
  };
  var coinInfos = {
    "0": { symbol: "btc", p2pkh: 0, p2sh: 5, prefix: "bc" },
    "2": { symbol: "ltc", p2pkh: 48, p2sh: 50, prefix: "ltc" },
    "3": { symbol: "doge", p2pkh: 30, p2sh: 22 },
    "60": { symbol: "eth", ilk: "eth" },
    "61": { symbol: "etc", ilk: "eth" },
    "700": { symbol: "xdai", ilk: "eth" }
  };
  function bytes32ify(value) {
    return hexZeroPad(BigNumber.from(value).toHexString(), 32);
  }
  function base58Encode(data2) {
    return Base58.encode(concat3([data2, hexDataSlice(sha2562(sha2562(data2)), 0, 4)]));
  }
  var matcherIpfs = new RegExp("^(ipfs)://(.*)$", "i");
  var matchers = [
    new RegExp("^(https)://(.*)$", "i"),
    new RegExp("^(data):(.*)$", "i"),
    matcherIpfs,
    new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
  ];
  function _parseString(result, start) {
    try {
      return toUtf8String(_parseBytes(result, start));
    } catch (error) {
    }
    return null;
  }
  function _parseBytes(result, start) {
    if (result === "0x") {
      return null;
    }
    const offset = BigNumber.from(hexDataSlice(result, start, start + 32)).toNumber();
    const length2 = BigNumber.from(hexDataSlice(result, offset, offset + 32)).toNumber();
    return hexDataSlice(result, offset + 32, offset + 32 + length2);
  }
  function getIpfsLink(link) {
    if (link.match(/^ipfs:\/\/ipfs\//i)) {
      link = link.substring(12);
    } else if (link.match(/^ipfs:\/\//i)) {
      link = link.substring(7);
    } else {
      logger30.throwArgumentError("unsupported IPFS format", "link", link);
    }
    return `https://gateway.ipfs.io/ipfs/${link}`;
  }
  function numPad(value) {
    const result = arrayify(value);
    if (result.length > 32) {
      throw new Error("internal; should not happen");
    }
    const padded = new Uint8Array(32);
    padded.set(result, 32 - result.length);
    return padded;
  }
  function bytesPad(value) {
    if (value.length % 32 === 0) {
      return value;
    }
    const result = new Uint8Array(Math.ceil(value.length / 32) * 32);
    result.set(value);
    return result;
  }
  function encodeBytes2(datas) {
    const result = [];
    let byteCount = 0;
    for (let i7 = 0; i7 < datas.length; i7++) {
      result.push(null);
      byteCount += 32;
    }
    for (let i7 = 0; i7 < datas.length; i7++) {
      const data2 = arrayify(datas[i7]);
      result[i7] = numPad(byteCount);
      result.push(numPad(data2.length));
      result.push(bytesPad(data2));
      byteCount += 32 + Math.ceil(data2.length / 32) * 32;
    }
    return hexConcat(result);
  }
  var Resolver = class {
    // The resolvedAddress is only for creating a ReverseLookup resolver
    constructor(provider, address, name2, resolvedAddress) {
      defineReadOnly(this, "provider", provider);
      defineReadOnly(this, "name", name2);
      defineReadOnly(this, "address", provider.formatter.address(address));
      defineReadOnly(this, "_resolvedAddress", resolvedAddress);
    }
    supportsWildcard() {
      if (!this._supportsEip2544) {
        this._supportsEip2544 = this.provider.call({
          to: this.address,
          data: "0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000"
        }).then((result) => {
          return BigNumber.from(result).eq(1);
        }).catch((error) => {
          if (error.code === Logger.errors.CALL_EXCEPTION) {
            return false;
          }
          this._supportsEip2544 = null;
          throw error;
        });
      }
      return this._supportsEip2544;
    }
    _fetch(selector, parameters) {
      return __awaiter11(this, void 0, void 0, function* () {
        const tx = {
          to: this.address,
          ccipReadEnabled: true,
          data: hexConcat([selector, namehash2(this.name), parameters || "0x"])
        };
        let parseBytes = false;
        if (yield this.supportsWildcard()) {
          parseBytes = true;
          tx.data = hexConcat(["0x9061b923", encodeBytes2([dnsEncode(this.name), tx.data])]);
        }
        try {
          let result = yield this.provider.call(tx);
          if (arrayify(result).length % 32 === 4) {
            logger30.throwError("resolver threw error", Logger.errors.CALL_EXCEPTION, {
              transaction: tx,
              data: result
            });
          }
          if (parseBytes) {
            result = _parseBytes(result, 0);
          }
          return result;
        } catch (error) {
          if (error.code === Logger.errors.CALL_EXCEPTION) {
            return null;
          }
          throw error;
        }
      });
    }
    _fetchBytes(selector, parameters) {
      return __awaiter11(this, void 0, void 0, function* () {
        const result = yield this._fetch(selector, parameters);
        if (result != null) {
          return _parseBytes(result, 0);
        }
        return null;
      });
    }
    _getAddress(coinType, hexBytes) {
      const coinInfo = coinInfos[String(coinType)];
      if (coinInfo == null) {
        logger30.throwError(`unsupported coin type: ${coinType}`, Logger.errors.UNSUPPORTED_OPERATION, {
          operation: `getAddress(${coinType})`
        });
      }
      if (coinInfo.ilk === "eth") {
        return this.provider.formatter.address(hexBytes);
      }
      const bytes3 = arrayify(hexBytes);
      if (coinInfo.p2pkh != null) {
        const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);
        if (p2pkh) {
          const length2 = parseInt(p2pkh[1], 16);
          if (p2pkh[2].length === length2 * 2 && length2 >= 1 && length2 <= 75) {
            return base58Encode(concat3([[coinInfo.p2pkh], "0x" + p2pkh[2]]));
          }
        }
      }
      if (coinInfo.p2sh != null) {
        const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);
        if (p2sh) {
          const length2 = parseInt(p2sh[1], 16);
          if (p2sh[2].length === length2 * 2 && length2 >= 1 && length2 <= 75) {
            return base58Encode(concat3([[coinInfo.p2sh], "0x" + p2sh[2]]));
          }
        }
      }
      if (coinInfo.prefix != null) {
        const length2 = bytes3[1];
        let version30 = bytes3[0];
        if (version30 === 0) {
          if (length2 !== 20 && length2 !== 32) {
            version30 = -1;
          }
        } else {
          version30 = -1;
        }
        if (version30 >= 0 && bytes3.length === 2 + length2 && length2 >= 1 && length2 <= 75) {
          const words2 = import_bech32.default.toWords(bytes3.slice(2));
          words2.unshift(version30);
          return import_bech32.default.encode(coinInfo.prefix, words2);
        }
      }
      return null;
    }
    getAddress(coinType) {
      return __awaiter11(this, void 0, void 0, function* () {
        if (coinType == null) {
          coinType = 60;
        }
        if (coinType === 60) {
          try {
            const result = yield this._fetch("0x3b3b57de");
            if (result === "0x" || result === HashZero) {
              return null;
            }
            return this.provider.formatter.callAddress(result);
          } catch (error) {
            if (error.code === Logger.errors.CALL_EXCEPTION) {
              return null;
            }
            throw error;
          }
        }
        const hexBytes = yield this._fetchBytes("0xf1cb7e06", bytes32ify(coinType));
        if (hexBytes == null || hexBytes === "0x") {
          return null;
        }
        const address = this._getAddress(coinType, hexBytes);
        if (address == null) {
          logger30.throwError(`invalid or unsupported coin data`, Logger.errors.UNSUPPORTED_OPERATION, {
            operation: `getAddress(${coinType})`,
            coinType,
            data: hexBytes
          });
        }
        return address;
      });
    }
    getAvatar() {
      return __awaiter11(this, void 0, void 0, function* () {
        const linkage = [{ type: "name", content: this.name }];
        try {
          const avatar = yield this.getText("avatar");
          if (avatar == null) {
            return null;
          }
          for (let i7 = 0; i7 < matchers.length; i7++) {
            const match = avatar.match(matchers[i7]);
            if (match == null) {
              continue;
            }
            const scheme = match[1].toLowerCase();
            switch (scheme) {
              case "https":
                linkage.push({ type: "url", content: avatar });
                return { linkage, url: avatar };
              case "data":
                linkage.push({ type: "data", content: avatar });
                return { linkage, url: avatar };
              case "ipfs":
                linkage.push({ type: "ipfs", content: avatar });
                return { linkage, url: getIpfsLink(avatar) };
              case "erc721":
              case "erc1155": {
                const selector = scheme === "erc721" ? "0xc87b56dd" : "0x0e89341c";
                linkage.push({ type: scheme, content: avatar });
                const owner = this._resolvedAddress || (yield this.getAddress());
                const comps = (match[2] || "").split("/");
                if (comps.length !== 2) {
                  return null;
                }
                const addr = yield this.provider.formatter.address(comps[0]);
                const tokenId = hexZeroPad(BigNumber.from(comps[1]).toHexString(), 32);
                if (scheme === "erc721") {
                  const tokenOwner = this.provider.formatter.callAddress(yield this.provider.call({
                    to: addr,
                    data: hexConcat(["0x6352211e", tokenId])
                  }));
                  if (owner !== tokenOwner) {
                    return null;
                  }
                  linkage.push({ type: "owner", content: tokenOwner });
                } else if (scheme === "erc1155") {
                  const balance = BigNumber.from(yield this.provider.call({
                    to: addr,
                    data: hexConcat(["0x00fdd58e", hexZeroPad(owner, 32), tokenId])
                  }));
                  if (balance.isZero()) {
                    return null;
                  }
                  linkage.push({ type: "balance", content: balance.toString() });
                }
                const tx = {
                  to: this.provider.formatter.address(comps[0]),
                  data: hexConcat([selector, tokenId])
                };
                let metadataUrl = _parseString(yield this.provider.call(tx), 0);
                if (metadataUrl == null) {
                  return null;
                }
                linkage.push({ type: "metadata-url-base", content: metadataUrl });
                if (scheme === "erc1155") {
                  metadataUrl = metadataUrl.replace("{id}", tokenId.substring(2));
                  linkage.push({ type: "metadata-url-expanded", content: metadataUrl });
                }
                if (metadataUrl.match(/^ipfs:/i)) {
                  metadataUrl = getIpfsLink(metadataUrl);
                }
                linkage.push({ type: "metadata-url", content: metadataUrl });
                const metadata = yield fetchJson(metadataUrl);
                if (!metadata) {
                  return null;
                }
                linkage.push({ type: "metadata", content: JSON.stringify(metadata) });
                let imageUrl = metadata.image;
                if (typeof imageUrl !== "string") {
                  return null;
                }
                if (imageUrl.match(/^(https:\/\/|data:)/i)) {
                } else {
                  const ipfs = imageUrl.match(matcherIpfs);
                  if (ipfs == null) {
                    return null;
                  }
                  linkage.push({ type: "url-ipfs", content: imageUrl });
                  imageUrl = getIpfsLink(imageUrl);
                }
                linkage.push({ type: "url", content: imageUrl });
                return { linkage, url: imageUrl };
              }
            }
          }
        } catch (error) {
        }
        return null;
      });
    }
    getContentHash() {
      return __awaiter11(this, void 0, void 0, function* () {
        const hexBytes = yield this._fetchBytes("0xbc1c58d1");
        if (hexBytes == null || hexBytes === "0x") {
          return null;
        }
        const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
        if (ipfs) {
          const length2 = parseInt(ipfs[3], 16);
          if (ipfs[4].length === length2 * 2) {
            return "ipfs://" + Base58.encode("0x" + ipfs[1]);
          }
        }
        const ipns = hexBytes.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
        if (ipns) {
          const length2 = parseInt(ipns[3], 16);
          if (ipns[4].length === length2 * 2) {
            return "ipns://" + Base58.encode("0x" + ipns[1]);
          }
        }
        const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);
        if (swarm) {
          if (swarm[1].length === 32 * 2) {
            return "bzz://" + swarm[1];
          }
        }
        const skynet = hexBytes.match(/^0x90b2c605([0-9a-f]*)$/);
        if (skynet) {
          if (skynet[1].length === 34 * 2) {
            const urlSafe = { "=": "", "+": "-", "/": "_" };
            const hash5 = encode8("0x" + skynet[1]).replace(/[=+\/]/g, (a6) => urlSafe[a6]);
            return "sia://" + hash5;
          }
        }
        return logger30.throwError(`invalid or unsupported content hash data`, Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "getContentHash()",
          data: hexBytes
        });
      });
    }
    getText(key2) {
      return __awaiter11(this, void 0, void 0, function* () {
        let keyBytes = toUtf8Bytes(key2);
        keyBytes = concat3([bytes32ify(64), bytes32ify(keyBytes.length), keyBytes]);
        if (keyBytes.length % 32 !== 0) {
          keyBytes = concat3([keyBytes, hexZeroPad("0x", 32 - key2.length % 32)]);
        }
        const hexBytes = yield this._fetchBytes("0x59d1d43c", hexlify(keyBytes));
        if (hexBytes == null || hexBytes === "0x") {
          return null;
        }
        return toUtf8String(hexBytes);
      });
    }
  };
  var defaultFormatter = null;
  var nextPollId = 1;
  var BaseProvider = class extends Provider {
    /**
     *  ready
     *
     *  A Promise<Network> that resolves only once the provider is ready.
     *
     *  Sub-classes that call the super with a network without a chainId
     *  MUST set this. Standard named networks have a known chainId.
     *
     */
    constructor(network) {
      super();
      this._events = [];
      this._emitted = { block: -2 };
      this.disableCcipRead = false;
      this.formatter = new.target.getFormatter();
      defineReadOnly(this, "anyNetwork", network === "any");
      if (this.anyNetwork) {
        network = this.detectNetwork();
      }
      if (network instanceof Promise) {
        this._networkPromise = network;
        network.catch((error) => {
        });
        this._ready().catch((error) => {
        });
      } else {
        const knownNetwork = getStatic(new.target, "getNetwork")(network);
        if (knownNetwork) {
          defineReadOnly(this, "_network", knownNetwork);
          this.emit("network", knownNetwork, null);
        } else {
          logger30.throwArgumentError("invalid network", "network", network);
        }
      }
      this._maxInternalBlockNumber = -1024;
      this._lastBlockNumber = -2;
      this._maxFilterBlockRange = 10;
      this._pollingInterval = 4e3;
      this._fastQueryDate = 0;
    }
    _ready() {
      return __awaiter11(this, void 0, void 0, function* () {
        if (this._network == null) {
          let network = null;
          if (this._networkPromise) {
            try {
              network = yield this._networkPromise;
            } catch (error) {
            }
          }
          if (network == null) {
            network = yield this.detectNetwork();
          }
          if (!network) {
            logger30.throwError("no network detected", Logger.errors.UNKNOWN_ERROR, {});
          }
          if (this._network == null) {
            if (this.anyNetwork) {
              this._network = network;
            } else {
              defineReadOnly(this, "_network", network);
            }
            this.emit("network", network, null);
          }
        }
        return this._network;
      });
    }
    // This will always return the most recently established network.
    // For "any", this can change (a "network" event is emitted before
    // any change is reflected); otherwise this cannot change
    get ready() {
      return poll2(() => {
        return this._ready().then((network) => {
          return network;
        }, (error) => {
          if (error.code === Logger.errors.NETWORK_ERROR && error.event === "noNetwork") {
            return void 0;
          }
          throw error;
        });
      });
    }
    // @TODO: Remove this and just create a singleton formatter
    static getFormatter() {
      if (defaultFormatter == null) {
        defaultFormatter = new Formatter();
      }
      return defaultFormatter;
    }
    // @TODO: Remove this and just use getNetwork
    static getNetwork(network) {
      return getNetwork2(network == null ? "homestead" : network);
    }
    ccipReadFetch(tx, calldata, urls) {
      return __awaiter11(this, void 0, void 0, function* () {
        if (this.disableCcipRead || urls.length === 0) {
          return null;
        }
        const sender = tx.to.toLowerCase();
        const data2 = calldata.toLowerCase();
        const errorMessages = [];
        for (let i7 = 0; i7 < urls.length; i7++) {
          const url = urls[i7];
          const href = url.replace("{sender}", sender).replace("{data}", data2);
          const json = url.indexOf("{data}") >= 0 ? null : JSON.stringify({ data: data2, sender });
          const result = yield fetchJson({ url: href, errorPassThrough: true }, json, (value, response) => {
            value.status = response.statusCode;
            return value;
          });
          if (result.data) {
            return result.data;
          }
          const errorMessage = result.message || "unknown error";
          if (result.status >= 400 && result.status < 500) {
            return logger30.throwError(`response not found during CCIP fetch: ${errorMessage}`, Logger.errors.SERVER_ERROR, { url, errorMessage });
          }
          errorMessages.push(errorMessage);
        }
        return logger30.throwError(`error encountered during CCIP fetch: ${errorMessages.map((m6) => JSON.stringify(m6)).join(", ")}`, Logger.errors.SERVER_ERROR, {
          urls,
          errorMessages
        });
      });
    }
    // Fetches the blockNumber, but will reuse any result that is less
    // than maxAge old or has been requested since the last request
    _getInternalBlockNumber(maxAge) {
      return __awaiter11(this, void 0, void 0, function* () {
        yield this._ready();
        if (maxAge > 0) {
          while (this._internalBlockNumber) {
            const internalBlockNumber = this._internalBlockNumber;
            try {
              const result = yield internalBlockNumber;
              if (getTime() - result.respTime <= maxAge) {
                return result.blockNumber;
              }
              break;
            } catch (error) {
              if (this._internalBlockNumber === internalBlockNumber) {
                break;
              }
            }
          }
        }
        const reqTime = getTime();
        const checkInternalBlockNumber = resolveProperties({
          blockNumber: this.perform("getBlockNumber", {}),
          networkError: this.getNetwork().then((network) => null, (error) => error)
        }).then(({ blockNumber, networkError }) => {
          if (networkError) {
            if (this._internalBlockNumber === checkInternalBlockNumber) {
              this._internalBlockNumber = null;
            }
            throw networkError;
          }
          const respTime = getTime();
          blockNumber = BigNumber.from(blockNumber).toNumber();
          if (blockNumber < this._maxInternalBlockNumber) {
            blockNumber = this._maxInternalBlockNumber;
          }
          this._maxInternalBlockNumber = blockNumber;
          this._setFastBlockNumber(blockNumber);
          return { blockNumber, reqTime, respTime };
        });
        this._internalBlockNumber = checkInternalBlockNumber;
        checkInternalBlockNumber.catch((error) => {
          if (this._internalBlockNumber === checkInternalBlockNumber) {
            this._internalBlockNumber = null;
          }
        });
        return (yield checkInternalBlockNumber).blockNumber;
      });
    }
    poll() {
      return __awaiter11(this, void 0, void 0, function* () {
        const pollId = nextPollId++;
        const runners = [];
        let blockNumber = null;
        try {
          blockNumber = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);
        } catch (error) {
          this.emit("error", error);
          return;
        }
        this._setFastBlockNumber(blockNumber);
        this.emit("poll", pollId, blockNumber);
        if (blockNumber === this._lastBlockNumber) {
          this.emit("didPoll", pollId);
          return;
        }
        if (this._emitted.block === -2) {
          this._emitted.block = blockNumber - 1;
        }
        if (Math.abs(this._emitted.block - blockNumber) > 1e3) {
          logger30.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${blockNumber})`);
          this.emit("error", logger30.makeError("network block skew detected", Logger.errors.NETWORK_ERROR, {
            blockNumber,
            event: "blockSkew",
            previousBlockNumber: this._emitted.block
          }));
          this.emit("block", blockNumber);
        } else {
          for (let i7 = this._emitted.block + 1; i7 <= blockNumber; i7++) {
            this.emit("block", i7);
          }
        }
        if (this._emitted.block !== blockNumber) {
          this._emitted.block = blockNumber;
          Object.keys(this._emitted).forEach((key2) => {
            if (key2 === "block") {
              return;
            }
            const eventBlockNumber = this._emitted[key2];
            if (eventBlockNumber === "pending") {
              return;
            }
            if (blockNumber - eventBlockNumber > 12) {
              delete this._emitted[key2];
            }
          });
        }
        if (this._lastBlockNumber === -2) {
          this._lastBlockNumber = blockNumber - 1;
        }
        this._events.forEach((event) => {
          switch (event.type) {
            case "tx": {
              const hash5 = event.hash;
              let runner = this.getTransactionReceipt(hash5).then((receipt) => {
                if (!receipt || receipt.blockNumber == null) {
                  return null;
                }
                this._emitted["t:" + hash5] = receipt.blockNumber;
                this.emit(hash5, receipt);
                return null;
              }).catch((error) => {
                this.emit("error", error);
              });
              runners.push(runner);
              break;
            }
            case "filter": {
              if (!event._inflight) {
                event._inflight = true;
                if (event._lastBlockNumber === -2) {
                  event._lastBlockNumber = blockNumber - 1;
                }
                const filter2 = event.filter;
                filter2.fromBlock = event._lastBlockNumber + 1;
                filter2.toBlock = blockNumber;
                const minFromBlock = filter2.toBlock - this._maxFilterBlockRange;
                if (minFromBlock > filter2.fromBlock) {
                  filter2.fromBlock = minFromBlock;
                }
                if (filter2.fromBlock < 0) {
                  filter2.fromBlock = 0;
                }
                const runner = this.getLogs(filter2).then((logs) => {
                  event._inflight = false;
                  if (logs.length === 0) {
                    return;
                  }
                  logs.forEach((log) => {
                    if (log.blockNumber > event._lastBlockNumber) {
                      event._lastBlockNumber = log.blockNumber;
                    }
                    this._emitted["b:" + log.blockHash] = log.blockNumber;
                    this._emitted["t:" + log.transactionHash] = log.blockNumber;
                    this.emit(filter2, log);
                  });
                }).catch((error) => {
                  this.emit("error", error);
                  event._inflight = false;
                });
                runners.push(runner);
              }
              break;
            }
          }
        });
        this._lastBlockNumber = blockNumber;
        Promise.all(runners).then(() => {
          this.emit("didPoll", pollId);
        }).catch((error) => {
          this.emit("error", error);
        });
        return;
      });
    }
    // Deprecated; do not use this
    resetEventsBlock(blockNumber) {
      this._lastBlockNumber = blockNumber - 1;
      if (this.polling) {
        this.poll();
      }
    }
    get network() {
      return this._network;
    }
    // This method should query the network if the underlying network
    // can change, such as when connected to a JSON-RPC backend
    detectNetwork() {
      return __awaiter11(this, void 0, void 0, function* () {
        return logger30.throwError("provider does not support network detection", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "provider.detectNetwork"
        });
      });
    }
    getNetwork() {
      return __awaiter11(this, void 0, void 0, function* () {
        const network = yield this._ready();
        const currentNetwork = yield this.detectNetwork();
        if (network.chainId !== currentNetwork.chainId) {
          if (this.anyNetwork) {
            this._network = currentNetwork;
            this._lastBlockNumber = -2;
            this._fastBlockNumber = null;
            this._fastBlockNumberPromise = null;
            this._fastQueryDate = 0;
            this._emitted.block = -2;
            this._maxInternalBlockNumber = -1024;
            this._internalBlockNumber = null;
            this.emit("network", currentNetwork, network);
            yield stall(0);
            return this._network;
          }
          const error = logger30.makeError("underlying network changed", Logger.errors.NETWORK_ERROR, {
            event: "changed",
            network,
            detectedNetwork: currentNetwork
          });
          this.emit("error", error);
          throw error;
        }
        return network;
      });
    }
    get blockNumber() {
      this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber) => {
        this._setFastBlockNumber(blockNumber);
      }, (error) => {
      });
      return this._fastBlockNumber != null ? this._fastBlockNumber : -1;
    }
    get polling() {
      return this._poller != null;
    }
    set polling(value) {
      if (value && !this._poller) {
        this._poller = setInterval(() => {
          this.poll();
        }, this.pollingInterval);
        if (!this._bootstrapPoll) {
          this._bootstrapPoll = setTimeout(() => {
            this.poll();
            this._bootstrapPoll = setTimeout(() => {
              if (!this._poller) {
                this.poll();
              }
              this._bootstrapPoll = null;
            }, this.pollingInterval);
          }, 0);
        }
      } else if (!value && this._poller) {
        clearInterval(this._poller);
        this._poller = null;
      }
    }
    get pollingInterval() {
      return this._pollingInterval;
    }
    set pollingInterval(value) {
      if (typeof value !== "number" || value <= 0 || parseInt(String(value)) != value) {
        throw new Error("invalid polling interval");
      }
      this._pollingInterval = value;
      if (this._poller) {
        clearInterval(this._poller);
        this._poller = setInterval(() => {
          this.poll();
        }, this._pollingInterval);
      }
    }
    _getFastBlockNumber() {
      const now2 = getTime();
      if (now2 - this._fastQueryDate > 2 * this._pollingInterval) {
        this._fastQueryDate = now2;
        this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber) => {
          if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
            this._fastBlockNumber = blockNumber;
          }
          return this._fastBlockNumber;
        });
      }
      return this._fastBlockNumberPromise;
    }
    _setFastBlockNumber(blockNumber) {
      if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {
        return;
      }
      this._fastQueryDate = getTime();
      if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
        this._fastBlockNumber = blockNumber;
        this._fastBlockNumberPromise = Promise.resolve(blockNumber);
      }
    }
    waitForTransaction(transactionHash, confirmations, timeout) {
      return __awaiter11(this, void 0, void 0, function* () {
        return this._waitForTransaction(transactionHash, confirmations == null ? 1 : confirmations, timeout || 0, null);
      });
    }
    _waitForTransaction(transactionHash, confirmations, timeout, replaceable) {
      return __awaiter11(this, void 0, void 0, function* () {
        const receipt = yield this.getTransactionReceipt(transactionHash);
        if ((receipt ? receipt.confirmations : 0) >= confirmations) {
          return receipt;
        }
        return new Promise((resolve, reject) => {
          const cancelFuncs = [];
          let done = false;
          const alreadyDone = function() {
            if (done) {
              return true;
            }
            done = true;
            cancelFuncs.forEach((func) => {
              func();
            });
            return false;
          };
          const minedHandler = (receipt2) => {
            if (receipt2.confirmations < confirmations) {
              return;
            }
            if (alreadyDone()) {
              return;
            }
            resolve(receipt2);
          };
          this.on(transactionHash, minedHandler);
          cancelFuncs.push(() => {
            this.removeListener(transactionHash, minedHandler);
          });
          if (replaceable) {
            let lastBlockNumber = replaceable.startBlock;
            let scannedBlock = null;
            const replaceHandler = (blockNumber) => __awaiter11(this, void 0, void 0, function* () {
              if (done) {
                return;
              }
              yield stall(1e3);
              this.getTransactionCount(replaceable.from).then((nonce) => __awaiter11(this, void 0, void 0, function* () {
                if (done) {
                  return;
                }
                if (nonce <= replaceable.nonce) {
                  lastBlockNumber = blockNumber;
                } else {
                  {
                    const mined = yield this.getTransaction(transactionHash);
                    if (mined && mined.blockNumber != null) {
                      return;
                    }
                  }
                  if (scannedBlock == null) {
                    scannedBlock = lastBlockNumber - 3;
                    if (scannedBlock < replaceable.startBlock) {
                      scannedBlock = replaceable.startBlock;
                    }
                  }
                  while (scannedBlock <= blockNumber) {
                    if (done) {
                      return;
                    }
                    const block2 = yield this.getBlockWithTransactions(scannedBlock);
                    for (let ti2 = 0; ti2 < block2.transactions.length; ti2++) {
                      const tx = block2.transactions[ti2];
                      if (tx.hash === transactionHash) {
                        return;
                      }
                      if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {
                        if (done) {
                          return;
                        }
                        const receipt2 = yield this.waitForTransaction(tx.hash, confirmations);
                        if (alreadyDone()) {
                          return;
                        }
                        let reason = "replaced";
                        if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {
                          reason = "repriced";
                        } else if (tx.data === "0x" && tx.from === tx.to && tx.value.isZero()) {
                          reason = "cancelled";
                        }
                        reject(logger30.makeError("transaction was replaced", Logger.errors.TRANSACTION_REPLACED, {
                          cancelled: reason === "replaced" || reason === "cancelled",
                          reason,
                          replacement: this._wrapTransaction(tx),
                          hash: transactionHash,
                          receipt: receipt2
                        }));
                        return;
                      }
                    }
                    scannedBlock++;
                  }
                }
                if (done) {
                  return;
                }
                this.once("block", replaceHandler);
              }), (error) => {
                if (done) {
                  return;
                }
                this.once("block", replaceHandler);
              });
            });
            if (done) {
              return;
            }
            this.once("block", replaceHandler);
            cancelFuncs.push(() => {
              this.removeListener("block", replaceHandler);
            });
          }
          if (typeof timeout === "number" && timeout > 0) {
            const timer2 = setTimeout(() => {
              if (alreadyDone()) {
                return;
              }
              reject(logger30.makeError("timeout exceeded", Logger.errors.TIMEOUT, { timeout }));
            }, timeout);
            if (timer2.unref) {
              timer2.unref();
            }
            cancelFuncs.push(() => {
              clearTimeout(timer2);
            });
          }
        });
      });
    }
    getBlockNumber() {
      return __awaiter11(this, void 0, void 0, function* () {
        return this._getInternalBlockNumber(0);
      });
    }
    getGasPrice() {
      return __awaiter11(this, void 0, void 0, function* () {
        yield this.getNetwork();
        const result = yield this.perform("getGasPrice", {});
        try {
          return BigNumber.from(result);
        } catch (error) {
          return logger30.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
            method: "getGasPrice",
            result,
            error
          });
        }
      });
    }
    getBalance(addressOrName, blockTag) {
      return __awaiter11(this, void 0, void 0, function* () {
        yield this.getNetwork();
        const params = yield resolveProperties({
          address: this._getAddress(addressOrName),
          blockTag: this._getBlockTag(blockTag)
        });
        const result = yield this.perform("getBalance", params);
        try {
          return BigNumber.from(result);
        } catch (error) {
          return logger30.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
            method: "getBalance",
            params,
            result,
            error
          });
        }
      });
    }
    getTransactionCount(addressOrName, blockTag) {
      return __awaiter11(this, void 0, void 0, function* () {
        yield this.getNetwork();
        const params = yield resolveProperties({
          address: this._getAddress(addressOrName),
          blockTag: this._getBlockTag(blockTag)
        });
        const result = yield this.perform("getTransactionCount", params);
        try {
          return BigNumber.from(result).toNumber();
        } catch (error) {
          return logger30.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
            method: "getTransactionCount",
            params,
            result,
            error
          });
        }
      });
    }
    getCode(addressOrName, blockTag) {
      return __awaiter11(this, void 0, void 0, function* () {
        yield this.getNetwork();
        const params = yield resolveProperties({
          address: this._getAddress(addressOrName),
          blockTag: this._getBlockTag(blockTag)
        });
        const result = yield this.perform("getCode", params);
        try {
          return hexlify(result);
        } catch (error) {
          return logger30.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
            method: "getCode",
            params,
            result,
            error
          });
        }
      });
    }
    getStorageAt(addressOrName, position, blockTag) {
      return __awaiter11(this, void 0, void 0, function* () {
        yield this.getNetwork();
        const params = yield resolveProperties({
          address: this._getAddress(addressOrName),
          blockTag: this._getBlockTag(blockTag),
          position: Promise.resolve(position).then((p8) => hexValue(p8))
        });
        const result = yield this.perform("getStorageAt", params);
        try {
          return hexlify(result);
        } catch (error) {
          return logger30.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
            method: "getStorageAt",
            params,
            result,
            error
          });
        }
      });
    }
    // This should be called by any subclass wrapping a TransactionResponse
    _wrapTransaction(tx, hash5, startBlock) {
      if (hash5 != null && hexDataLength(hash5) !== 32) {
        throw new Error("invalid response - sendTransaction");
      }
      const result = tx;
      if (hash5 != null && tx.hash !== hash5) {
        logger30.throwError("Transaction hash mismatch from Provider.sendTransaction.", Logger.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash5 });
      }
      result.wait = (confirms, timeout) => __awaiter11(this, void 0, void 0, function* () {
        if (confirms == null) {
          confirms = 1;
        }
        if (timeout == null) {
          timeout = 0;
        }
        let replacement = void 0;
        if (confirms !== 0 && startBlock != null) {
          replacement = {
            data: tx.data,
            from: tx.from,
            nonce: tx.nonce,
            to: tx.to,
            value: tx.value,
            startBlock
          };
        }
        const receipt = yield this._waitForTransaction(tx.hash, confirms, timeout, replacement);
        if (receipt == null && confirms === 0) {
          return null;
        }
        this._emitted["t:" + tx.hash] = receipt.blockNumber;
        if (receipt.status === 0) {
          logger30.throwError("transaction failed", Logger.errors.CALL_EXCEPTION, {
            transactionHash: tx.hash,
            transaction: tx,
            receipt
          });
        }
        return receipt;
      });
      return result;
    }
    sendTransaction(signedTransaction) {
      return __awaiter11(this, void 0, void 0, function* () {
        yield this.getNetwork();
        const hexTx = yield Promise.resolve(signedTransaction).then((t6) => hexlify(t6));
        const tx = this.formatter.transaction(signedTransaction);
        if (tx.confirmations == null) {
          tx.confirmations = 0;
        }
        const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
        try {
          const hash5 = yield this.perform("sendTransaction", { signedTransaction: hexTx });
          return this._wrapTransaction(tx, hash5, blockNumber);
        } catch (error) {
          error.transaction = tx;
          error.transactionHash = tx.hash;
          throw error;
        }
      });
    }
    _getTransactionRequest(transaction) {
      return __awaiter11(this, void 0, void 0, function* () {
        const values = yield transaction;
        const tx = {};
        ["from", "to"].forEach((key2) => {
          if (values[key2] == null) {
            return;
          }
          tx[key2] = Promise.resolve(values[key2]).then((v6) => v6 ? this._getAddress(v6) : null);
        });
        ["gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "value"].forEach((key2) => {
          if (values[key2] == null) {
            return;
          }
          tx[key2] = Promise.resolve(values[key2]).then((v6) => v6 ? BigNumber.from(v6) : null);
        });
        ["type"].forEach((key2) => {
          if (values[key2] == null) {
            return;
          }
          tx[key2] = Promise.resolve(values[key2]).then((v6) => v6 != null ? v6 : null);
        });
        if (values.accessList) {
          tx.accessList = this.formatter.accessList(values.accessList);
        }
        ["data"].forEach((key2) => {
          if (values[key2] == null) {
            return;
          }
          tx[key2] = Promise.resolve(values[key2]).then((v6) => v6 ? hexlify(v6) : null);
        });
        return this.formatter.transactionRequest(yield resolveProperties(tx));
      });
    }
    _getFilter(filter2) {
      return __awaiter11(this, void 0, void 0, function* () {
        filter2 = yield filter2;
        const result = {};
        if (filter2.address != null) {
          result.address = this._getAddress(filter2.address);
        }
        ["blockHash", "topics"].forEach((key2) => {
          if (filter2[key2] == null) {
            return;
          }
          result[key2] = filter2[key2];
        });
        ["fromBlock", "toBlock"].forEach((key2) => {
          if (filter2[key2] == null) {
            return;
          }
          result[key2] = this._getBlockTag(filter2[key2]);
        });
        return this.formatter.filter(yield resolveProperties(result));
      });
    }
    _call(transaction, blockTag, attempt) {
      return __awaiter11(this, void 0, void 0, function* () {
        if (attempt >= MAX_CCIP_REDIRECTS) {
          logger30.throwError("CCIP read exceeded maximum redirections", Logger.errors.SERVER_ERROR, {
            redirects: attempt,
            transaction
          });
        }
        const txSender = transaction.to;
        const result = yield this.perform("call", { transaction, blockTag });
        if (attempt >= 0 && blockTag === "latest" && txSender != null && result.substring(0, 10) === "0x556f1830" && hexDataLength(result) % 32 === 4) {
          try {
            const data2 = hexDataSlice(result, 4);
            const sender = hexDataSlice(data2, 0, 32);
            if (!BigNumber.from(sender).eq(txSender)) {
              logger30.throwError("CCIP Read sender did not match", Logger.errors.CALL_EXCEPTION, {
                name: "OffchainLookup",
                signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                transaction,
                data: result
              });
            }
            const urls = [];
            const urlsOffset = BigNumber.from(hexDataSlice(data2, 32, 64)).toNumber();
            const urlsLength = BigNumber.from(hexDataSlice(data2, urlsOffset, urlsOffset + 32)).toNumber();
            const urlsData = hexDataSlice(data2, urlsOffset + 32);
            for (let u7 = 0; u7 < urlsLength; u7++) {
              const url = _parseString(urlsData, u7 * 32);
              if (url == null) {
                logger30.throwError("CCIP Read contained corrupt URL string", Logger.errors.CALL_EXCEPTION, {
                  name: "OffchainLookup",
                  signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                  transaction,
                  data: result
                });
              }
              urls.push(url);
            }
            const calldata = _parseBytes(data2, 64);
            if (!BigNumber.from(hexDataSlice(data2, 100, 128)).isZero()) {
              logger30.throwError("CCIP Read callback selector included junk", Logger.errors.CALL_EXCEPTION, {
                name: "OffchainLookup",
                signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                transaction,
                data: result
              });
            }
            const callbackSelector = hexDataSlice(data2, 96, 100);
            const extraData = _parseBytes(data2, 128);
            const ccipResult = yield this.ccipReadFetch(transaction, calldata, urls);
            if (ccipResult == null) {
              logger30.throwError("CCIP Read disabled or provided no URLs", Logger.errors.CALL_EXCEPTION, {
                name: "OffchainLookup",
                signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                transaction,
                data: result
              });
            }
            const tx = {
              to: txSender,
              data: hexConcat([callbackSelector, encodeBytes2([ccipResult, extraData])])
            };
            return this._call(tx, blockTag, attempt + 1);
          } catch (error) {
            if (error.code === Logger.errors.SERVER_ERROR) {
              throw error;
            }
          }
        }
        try {
          return hexlify(result);
        } catch (error) {
          return logger30.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
            method: "call",
            params: { transaction, blockTag },
            result,
            error
          });
        }
      });
    }
    call(transaction, blockTag) {
      return __awaiter11(this, void 0, void 0, function* () {
        yield this.getNetwork();
        const resolved = yield resolveProperties({
          transaction: this._getTransactionRequest(transaction),
          blockTag: this._getBlockTag(blockTag),
          ccipReadEnabled: Promise.resolve(transaction.ccipReadEnabled)
        });
        return this._call(resolved.transaction, resolved.blockTag, resolved.ccipReadEnabled ? 0 : -1);
      });
    }
    estimateGas(transaction) {
      return __awaiter11(this, void 0, void 0, function* () {
        yield this.getNetwork();
        const params = yield resolveProperties({
          transaction: this._getTransactionRequest(transaction)
        });
        const result = yield this.perform("estimateGas", params);
        try {
          return BigNumber.from(result);
        } catch (error) {
          return logger30.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
            method: "estimateGas",
            params,
            result,
            error
          });
        }
      });
    }
    _getAddress(addressOrName) {
      return __awaiter11(this, void 0, void 0, function* () {
        addressOrName = yield addressOrName;
        if (typeof addressOrName !== "string") {
          logger30.throwArgumentError("invalid address or ENS name", "name", addressOrName);
        }
        const address = yield this.resolveName(addressOrName);
        if (address == null) {
          logger30.throwError("ENS name not configured", Logger.errors.UNSUPPORTED_OPERATION, {
            operation: `resolveName(${JSON.stringify(addressOrName)})`
          });
        }
        return address;
      });
    }
    _getBlock(blockHashOrBlockTag, includeTransactions) {
      return __awaiter11(this, void 0, void 0, function* () {
        yield this.getNetwork();
        blockHashOrBlockTag = yield blockHashOrBlockTag;
        let blockNumber = -128;
        const params = {
          includeTransactions: !!includeTransactions
        };
        if (isHexString(blockHashOrBlockTag, 32)) {
          params.blockHash = blockHashOrBlockTag;
        } else {
          try {
            params.blockTag = yield this._getBlockTag(blockHashOrBlockTag);
            if (isHexString(params.blockTag)) {
              blockNumber = parseInt(params.blockTag.substring(2), 16);
            }
          } catch (error) {
            logger30.throwArgumentError("invalid block hash or block tag", "blockHashOrBlockTag", blockHashOrBlockTag);
          }
        }
        return poll2(() => __awaiter11(this, void 0, void 0, function* () {
          const block2 = yield this.perform("getBlock", params);
          if (block2 == null) {
            if (params.blockHash != null) {
              if (this._emitted["b:" + params.blockHash] == null) {
                return null;
              }
            }
            if (params.blockTag != null) {
              if (blockNumber > this._emitted.block) {
                return null;
              }
            }
            return void 0;
          }
          if (includeTransactions) {
            let blockNumber2 = null;
            for (let i7 = 0; i7 < block2.transactions.length; i7++) {
              const tx = block2.transactions[i7];
              if (tx.blockNumber == null) {
                tx.confirmations = 0;
              } else if (tx.confirmations == null) {
                if (blockNumber2 == null) {
                  blockNumber2 = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
                }
                let confirmations = blockNumber2 - tx.blockNumber + 1;
                if (confirmations <= 0) {
                  confirmations = 1;
                }
                tx.confirmations = confirmations;
              }
            }
            const blockWithTxs = this.formatter.blockWithTransactions(block2);
            blockWithTxs.transactions = blockWithTxs.transactions.map((tx) => this._wrapTransaction(tx));
            return blockWithTxs;
          }
          return this.formatter.block(block2);
        }), { oncePoll: this });
      });
    }
    getBlock(blockHashOrBlockTag) {
      return this._getBlock(blockHashOrBlockTag, false);
    }
    getBlockWithTransactions(blockHashOrBlockTag) {
      return this._getBlock(blockHashOrBlockTag, true);
    }
    getTransaction(transactionHash) {
      return __awaiter11(this, void 0, void 0, function* () {
        yield this.getNetwork();
        transactionHash = yield transactionHash;
        const params = { transactionHash: this.formatter.hash(transactionHash, true) };
        return poll2(() => __awaiter11(this, void 0, void 0, function* () {
          const result = yield this.perform("getTransaction", params);
          if (result == null) {
            if (this._emitted["t:" + transactionHash] == null) {
              return null;
            }
            return void 0;
          }
          const tx = this.formatter.transactionResponse(result);
          if (tx.blockNumber == null) {
            tx.confirmations = 0;
          } else if (tx.confirmations == null) {
            const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
            let confirmations = blockNumber - tx.blockNumber + 1;
            if (confirmations <= 0) {
              confirmations = 1;
            }
            tx.confirmations = confirmations;
          }
          return this._wrapTransaction(tx);
        }), { oncePoll: this });
      });
    }
    getTransactionReceipt(transactionHash) {
      return __awaiter11(this, void 0, void 0, function* () {
        yield this.getNetwork();
        transactionHash = yield transactionHash;
        const params = { transactionHash: this.formatter.hash(transactionHash, true) };
        return poll2(() => __awaiter11(this, void 0, void 0, function* () {
          const result = yield this.perform("getTransactionReceipt", params);
          if (result == null) {
            if (this._emitted["t:" + transactionHash] == null) {
              return null;
            }
            return void 0;
          }
          if (result.blockHash == null) {
            return void 0;
          }
          const receipt = this.formatter.receipt(result);
          if (receipt.blockNumber == null) {
            receipt.confirmations = 0;
          } else if (receipt.confirmations == null) {
            const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
            let confirmations = blockNumber - receipt.blockNumber + 1;
            if (confirmations <= 0) {
              confirmations = 1;
            }
            receipt.confirmations = confirmations;
          }
          return receipt;
        }), { oncePoll: this });
      });
    }
    getLogs(filter2) {
      return __awaiter11(this, void 0, void 0, function* () {
        yield this.getNetwork();
        const params = yield resolveProperties({ filter: this._getFilter(filter2) });
        const logs = yield this.perform("getLogs", params);
        logs.forEach((log) => {
          if (log.removed == null) {
            log.removed = false;
          }
        });
        return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);
      });
    }
    getEtherPrice() {
      return __awaiter11(this, void 0, void 0, function* () {
        yield this.getNetwork();
        return this.perform("getEtherPrice", {});
      });
    }
    _getBlockTag(blockTag) {
      return __awaiter11(this, void 0, void 0, function* () {
        blockTag = yield blockTag;
        if (typeof blockTag === "number" && blockTag < 0) {
          if (blockTag % 1) {
            logger30.throwArgumentError("invalid BlockTag", "blockTag", blockTag);
          }
          let blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
          blockNumber += blockTag;
          if (blockNumber < 0) {
            blockNumber = 0;
          }
          return this.formatter.blockTag(blockNumber);
        }
        return this.formatter.blockTag(blockTag);
      });
    }
    getResolver(name2) {
      return __awaiter11(this, void 0, void 0, function* () {
        let currentName = name2;
        while (true) {
          if (currentName === "" || currentName === ".") {
            return null;
          }
          if (name2 !== "eth" && currentName === "eth") {
            return null;
          }
          const addr = yield this._getResolver(currentName, "getResolver");
          if (addr != null) {
            const resolver = new Resolver(this, addr, name2);
            if (currentName !== name2 && !(yield resolver.supportsWildcard())) {
              return null;
            }
            return resolver;
          }
          currentName = currentName.split(".").slice(1).join(".");
        }
      });
    }
    _getResolver(name2, operation) {
      return __awaiter11(this, void 0, void 0, function* () {
        if (operation == null) {
          operation = "ENS";
        }
        const network = yield this.getNetwork();
        if (!network.ensAddress) {
          logger30.throwError("network does not support ENS", Logger.errors.UNSUPPORTED_OPERATION, { operation, network: network.name });
        }
        try {
          const addrData = yield this.call({
            to: network.ensAddress,
            data: "0x0178b8bf" + namehash2(name2).substring(2)
          });
          return this.formatter.callAddress(addrData);
        } catch (error) {
        }
        return null;
      });
    }
    resolveName(name2) {
      return __awaiter11(this, void 0, void 0, function* () {
        name2 = yield name2;
        try {
          return Promise.resolve(this.formatter.address(name2));
        } catch (error) {
          if (isHexString(name2)) {
            throw error;
          }
        }
        if (typeof name2 !== "string") {
          logger30.throwArgumentError("invalid ENS name", "name", name2);
        }
        const resolver = yield this.getResolver(name2);
        if (!resolver) {
          return null;
        }
        return yield resolver.getAddress();
      });
    }
    lookupAddress(address) {
      return __awaiter11(this, void 0, void 0, function* () {
        address = yield address;
        address = this.formatter.address(address);
        const node = address.substring(2).toLowerCase() + ".addr.reverse";
        const resolverAddr = yield this._getResolver(node, "lookupAddress");
        if (resolverAddr == null) {
          return null;
        }
        const name2 = _parseString(yield this.call({
          to: resolverAddr,
          data: "0x691f3431" + namehash2(node).substring(2)
        }), 0);
        const addr = yield this.resolveName(name2);
        if (addr != address) {
          return null;
        }
        return name2;
      });
    }
    getAvatar(nameOrAddress) {
      return __awaiter11(this, void 0, void 0, function* () {
        let resolver = null;
        if (isHexString(nameOrAddress)) {
          const address = this.formatter.address(nameOrAddress);
          const node = address.substring(2).toLowerCase() + ".addr.reverse";
          const resolverAddress = yield this._getResolver(node, "getAvatar");
          if (!resolverAddress) {
            return null;
          }
          resolver = new Resolver(this, resolverAddress, node);
          try {
            const avatar2 = yield resolver.getAvatar();
            if (avatar2) {
              return avatar2.url;
            }
          } catch (error) {
            if (error.code !== Logger.errors.CALL_EXCEPTION) {
              throw error;
            }
          }
          try {
            const name2 = _parseString(yield this.call({
              to: resolverAddress,
              data: "0x691f3431" + namehash2(node).substring(2)
            }), 0);
            resolver = yield this.getResolver(name2);
          } catch (error) {
            if (error.code !== Logger.errors.CALL_EXCEPTION) {
              throw error;
            }
            return null;
          }
        } else {
          resolver = yield this.getResolver(nameOrAddress);
          if (!resolver) {
            return null;
          }
        }
        const avatar = yield resolver.getAvatar();
        if (avatar == null) {
          return null;
        }
        return avatar.url;
      });
    }
    perform(method, params) {
      return logger30.throwError(method + " not implemented", Logger.errors.NOT_IMPLEMENTED, { operation: method });
    }
    _startEvent(event) {
      this.polling = this._events.filter((e9) => e9.pollable()).length > 0;
    }
    _stopEvent(event) {
      this.polling = this._events.filter((e9) => e9.pollable()).length > 0;
    }
    _addEventListener(eventName, listener, once) {
      const event = new Event(getEventTag2(eventName), listener, once);
      this._events.push(event);
      this._startEvent(event);
      return this;
    }
    on(eventName, listener) {
      return this._addEventListener(eventName, listener, false);
    }
    once(eventName, listener) {
      return this._addEventListener(eventName, listener, true);
    }
    emit(eventName, ...args) {
      let result = false;
      let stopped = [];
      let eventTag = getEventTag2(eventName);
      this._events = this._events.filter((event) => {
        if (event.tag !== eventTag) {
          return true;
        }
        setTimeout(() => {
          event.listener.apply(this, args);
        }, 0);
        result = true;
        if (event.once) {
          stopped.push(event);
          return false;
        }
        return true;
      });
      stopped.forEach((event) => {
        this._stopEvent(event);
      });
      return result;
    }
    listenerCount(eventName) {
      if (!eventName) {
        return this._events.length;
      }
      let eventTag = getEventTag2(eventName);
      return this._events.filter((event) => {
        return event.tag === eventTag;
      }).length;
    }
    listeners(eventName) {
      if (eventName == null) {
        return this._events.map((event) => event.listener);
      }
      let eventTag = getEventTag2(eventName);
      return this._events.filter((event) => event.tag === eventTag).map((event) => event.listener);
    }
    off(eventName, listener) {
      if (listener == null) {
        return this.removeAllListeners(eventName);
      }
      const stopped = [];
      let found = false;
      let eventTag = getEventTag2(eventName);
      this._events = this._events.filter((event) => {
        if (event.tag !== eventTag || event.listener != listener) {
          return true;
        }
        if (found) {
          return true;
        }
        found = true;
        stopped.push(event);
        return false;
      });
      stopped.forEach((event) => {
        this._stopEvent(event);
      });
      return this;
    }
    removeAllListeners(eventName) {
      let stopped = [];
      if (eventName == null) {
        stopped = this._events;
        this._events = [];
      } else {
        const eventTag = getEventTag2(eventName);
        this._events = this._events.filter((event) => {
          if (event.tag !== eventTag) {
            return true;
          }
          stopped.push(event);
          return false;
        });
      }
      stopped.forEach((event) => {
        this._stopEvent(event);
      });
      return this;
    }
  };

  // node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js
  var __awaiter12 = function(thisArg, _arguments, P7, generator) {
    function adopt(value) {
      return value instanceof P7 ? value : new P7(function(resolve) {
        resolve(value);
      });
    }
    return new (P7 || (P7 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e9) {
          reject(e9);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e9) {
          reject(e9);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var logger31 = new Logger(version26);
  var errorGas = ["call", "estimateGas"];
  function spelunk(value, requireData) {
    if (value == null) {
      return null;
    }
    if (typeof value.message === "string" && value.message.match("reverted")) {
      const data2 = isHexString(value.data) ? value.data : null;
      if (!requireData || data2) {
        return { message: value.message, data: data2 };
      }
    }
    if (typeof value === "object") {
      for (const key2 in value) {
        const result = spelunk(value[key2], requireData);
        if (result) {
          return result;
        }
      }
      return null;
    }
    if (typeof value === "string") {
      try {
        return spelunk(JSON.parse(value), requireData);
      } catch (error) {
      }
    }
    return null;
  }
  function checkError(method, error, params) {
    const transaction = params.transaction || params.signedTransaction;
    if (method === "call") {
      const result = spelunk(error, true);
      if (result) {
        return result.data;
      }
      logger31.throwError("missing revert data in call exception; Transaction reverted without a reason string", Logger.errors.CALL_EXCEPTION, {
        data: "0x",
        transaction,
        error
      });
    }
    if (method === "estimateGas") {
      let result = spelunk(error.body, false);
      if (result == null) {
        result = spelunk(error, false);
      }
      if (result) {
        logger31.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
          reason: result.message,
          method,
          transaction,
          error
        });
      }
    }
    let message = error.message;
    if (error.code === Logger.errors.SERVER_ERROR && error.error && typeof error.error.message === "string") {
      message = error.error.message;
    } else if (typeof error.body === "string") {
      message = error.body;
    } else if (typeof error.responseText === "string") {
      message = error.responseText;
    }
    message = (message || "").toLowerCase();
    if (message.match(/insufficient funds|base fee exceeds gas limit|InsufficientFunds/i)) {
      logger31.throwError("insufficient funds for intrinsic transaction cost", Logger.errors.INSUFFICIENT_FUNDS, {
        error,
        method,
        transaction
      });
    }
    if (message.match(/nonce (is )?too low/i)) {
      logger31.throwError("nonce has already been used", Logger.errors.NONCE_EXPIRED, {
        error,
        method,
        transaction
      });
    }
    if (message.match(/replacement transaction underpriced|transaction gas price.*too low/i)) {
      logger31.throwError("replacement fee too low", Logger.errors.REPLACEMENT_UNDERPRICED, {
        error,
        method,
        transaction
      });
    }
    if (message.match(/only replay-protected/i)) {
      logger31.throwError("legacy pre-eip-155 transactions not supported", Logger.errors.UNSUPPORTED_OPERATION, {
        error,
        method,
        transaction
      });
    }
    if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted|revert/)) {
      logger31.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
        error,
        method,
        transaction
      });
    }
    throw error;
  }
  function timer(timeout) {
    return new Promise(function(resolve) {
      setTimeout(resolve, timeout);
    });
  }
  function getResult(payload) {
    if (payload.error) {
      const error = new Error(payload.error.message);
      error.code = payload.error.code;
      error.data = payload.error.data;
      throw error;
    }
    return payload.result;
  }
  function getLowerCase(value) {
    if (value) {
      return value.toLowerCase();
    }
    return value;
  }
  var _constructorGuard5 = {};
  var JsonRpcSigner = class extends Signer {
    constructor(constructorGuard, provider, addressOrIndex) {
      super();
      if (constructorGuard !== _constructorGuard5) {
        throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner");
      }
      defineReadOnly(this, "provider", provider);
      if (addressOrIndex == null) {
        addressOrIndex = 0;
      }
      if (typeof addressOrIndex === "string") {
        defineReadOnly(this, "_address", this.provider.formatter.address(addressOrIndex));
        defineReadOnly(this, "_index", null);
      } else if (typeof addressOrIndex === "number") {
        defineReadOnly(this, "_index", addressOrIndex);
        defineReadOnly(this, "_address", null);
      } else {
        logger31.throwArgumentError("invalid address or index", "addressOrIndex", addressOrIndex);
      }
    }
    connect(provider) {
      return logger31.throwError("cannot alter JSON-RPC Signer connection", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "connect"
      });
    }
    connectUnchecked() {
      return new UncheckedJsonRpcSigner(_constructorGuard5, this.provider, this._address || this._index);
    }
    getAddress() {
      if (this._address) {
        return Promise.resolve(this._address);
      }
      return this.provider.send("eth_accounts", []).then((accounts) => {
        if (accounts.length <= this._index) {
          logger31.throwError("unknown account #" + this._index, Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "getAddress"
          });
        }
        return this.provider.formatter.address(accounts[this._index]);
      });
    }
    sendUncheckedTransaction(transaction) {
      transaction = shallowCopy(transaction);
      const fromAddress = this.getAddress().then((address) => {
        if (address) {
          address = address.toLowerCase();
        }
        return address;
      });
      if (transaction.gasLimit == null) {
        const estimate = shallowCopy(transaction);
        estimate.from = fromAddress;
        transaction.gasLimit = this.provider.estimateGas(estimate);
      }
      if (transaction.to != null) {
        transaction.to = Promise.resolve(transaction.to).then((to3) => __awaiter12(this, void 0, void 0, function* () {
          if (to3 == null) {
            return null;
          }
          const address = yield this.provider.resolveName(to3);
          if (address == null) {
            logger31.throwArgumentError("provided ENS name resolves to null", "tx.to", to3);
          }
          return address;
        }));
      }
      return resolveProperties({
        tx: resolveProperties(transaction),
        sender: fromAddress
      }).then(({ tx, sender }) => {
        if (tx.from != null) {
          if (tx.from.toLowerCase() !== sender) {
            logger31.throwArgumentError("from address mismatch", "transaction", transaction);
          }
        } else {
          tx.from = sender;
        }
        const hexTx = this.provider.constructor.hexlifyTransaction(tx, { from: true });
        return this.provider.send("eth_sendTransaction", [hexTx]).then((hash5) => {
          return hash5;
        }, (error) => {
          if (typeof error.message === "string" && error.message.match(/user denied/i)) {
            logger31.throwError("user rejected transaction", Logger.errors.ACTION_REJECTED, {
              action: "sendTransaction",
              transaction: tx
            });
          }
          return checkError("sendTransaction", error, hexTx);
        });
      });
    }
    signTransaction(transaction) {
      return logger31.throwError("signing transactions is unsupported", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "signTransaction"
      });
    }
    sendTransaction(transaction) {
      return __awaiter12(this, void 0, void 0, function* () {
        const blockNumber = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);
        const hash5 = yield this.sendUncheckedTransaction(transaction);
        try {
          return yield poll2(() => __awaiter12(this, void 0, void 0, function* () {
            const tx = yield this.provider.getTransaction(hash5);
            if (tx === null) {
              return void 0;
            }
            return this.provider._wrapTransaction(tx, hash5, blockNumber);
          }), { oncePoll: this.provider });
        } catch (error) {
          error.transactionHash = hash5;
          throw error;
        }
      });
    }
    signMessage(message) {
      return __awaiter12(this, void 0, void 0, function* () {
        const data2 = typeof message === "string" ? toUtf8Bytes(message) : message;
        const address = yield this.getAddress();
        try {
          return yield this.provider.send("personal_sign", [hexlify(data2), address.toLowerCase()]);
        } catch (error) {
          if (typeof error.message === "string" && error.message.match(/user denied/i)) {
            logger31.throwError("user rejected signing", Logger.errors.ACTION_REJECTED, {
              action: "signMessage",
              from: address,
              messageData: message
            });
          }
          throw error;
        }
      });
    }
    _legacySignMessage(message) {
      return __awaiter12(this, void 0, void 0, function* () {
        const data2 = typeof message === "string" ? toUtf8Bytes(message) : message;
        const address = yield this.getAddress();
        try {
          return yield this.provider.send("eth_sign", [address.toLowerCase(), hexlify(data2)]);
        } catch (error) {
          if (typeof error.message === "string" && error.message.match(/user denied/i)) {
            logger31.throwError("user rejected signing", Logger.errors.ACTION_REJECTED, {
              action: "_legacySignMessage",
              from: address,
              messageData: message
            });
          }
          throw error;
        }
      });
    }
    _signTypedData(domain2, types, value) {
      return __awaiter12(this, void 0, void 0, function* () {
        const populated = yield TypedDataEncoder.resolveNames(domain2, types, value, (name2) => {
          return this.provider.resolveName(name2);
        });
        const address = yield this.getAddress();
        try {
          return yield this.provider.send("eth_signTypedData_v4", [
            address.toLowerCase(),
            JSON.stringify(TypedDataEncoder.getPayload(populated.domain, types, populated.value))
          ]);
        } catch (error) {
          if (typeof error.message === "string" && error.message.match(/user denied/i)) {
            logger31.throwError("user rejected signing", Logger.errors.ACTION_REJECTED, {
              action: "_signTypedData",
              from: address,
              messageData: { domain: populated.domain, types, value: populated.value }
            });
          }
          throw error;
        }
      });
    }
    unlock(password) {
      return __awaiter12(this, void 0, void 0, function* () {
        const provider = this.provider;
        const address = yield this.getAddress();
        return provider.send("personal_unlockAccount", [address.toLowerCase(), password, null]);
      });
    }
  };
  var UncheckedJsonRpcSigner = class extends JsonRpcSigner {
    sendTransaction(transaction) {
      return this.sendUncheckedTransaction(transaction).then((hash5) => {
        return {
          hash: hash5,
          nonce: null,
          gasLimit: null,
          gasPrice: null,
          data: null,
          value: null,
          chainId: null,
          confirmations: 0,
          from: null,
          wait: (confirmations) => {
            return this.provider.waitForTransaction(hash5, confirmations);
          }
        };
      });
    }
  };
  var allowedTransactionKeys4 = {
    chainId: true,
    data: true,
    gasLimit: true,
    gasPrice: true,
    nonce: true,
    to: true,
    value: true,
    type: true,
    accessList: true,
    maxFeePerGas: true,
    maxPriorityFeePerGas: true
  };
  var JsonRpcProvider2 = class extends BaseProvider {
    constructor(url, network) {
      let networkOrReady = network;
      if (networkOrReady == null) {
        networkOrReady = new Promise((resolve, reject) => {
          setTimeout(() => {
            this.detectNetwork().then((network2) => {
              resolve(network2);
            }, (error) => {
              reject(error);
            });
          }, 0);
        });
      }
      super(networkOrReady);
      if (!url) {
        url = getStatic(this.constructor, "defaultUrl")();
      }
      if (typeof url === "string") {
        defineReadOnly(this, "connection", Object.freeze({
          url
        }));
      } else {
        defineReadOnly(this, "connection", Object.freeze(shallowCopy(url)));
      }
      this._nextId = 42;
    }
    get _cache() {
      if (this._eventLoopCache == null) {
        this._eventLoopCache = {};
      }
      return this._eventLoopCache;
    }
    static defaultUrl() {
      return "http://localhost:8545";
    }
    detectNetwork() {
      if (!this._cache["detectNetwork"]) {
        this._cache["detectNetwork"] = this._uncachedDetectNetwork();
        setTimeout(() => {
          this._cache["detectNetwork"] = null;
        }, 0);
      }
      return this._cache["detectNetwork"];
    }
    _uncachedDetectNetwork() {
      return __awaiter12(this, void 0, void 0, function* () {
        yield timer(0);
        let chainId = null;
        try {
          chainId = yield this.send("eth_chainId", []);
        } catch (error) {
          try {
            chainId = yield this.send("net_version", []);
          } catch (error2) {
          }
        }
        if (chainId != null) {
          const getNetwork3 = getStatic(this.constructor, "getNetwork");
          try {
            return getNetwork3(BigNumber.from(chainId).toNumber());
          } catch (error) {
            return logger31.throwError("could not detect network", Logger.errors.NETWORK_ERROR, {
              chainId,
              event: "invalidNetwork",
              serverError: error
            });
          }
        }
        return logger31.throwError("could not detect network", Logger.errors.NETWORK_ERROR, {
          event: "noNetwork"
        });
      });
    }
    getSigner(addressOrIndex) {
      return new JsonRpcSigner(_constructorGuard5, this, addressOrIndex);
    }
    getUncheckedSigner(addressOrIndex) {
      return this.getSigner(addressOrIndex).connectUnchecked();
    }
    listAccounts() {
      return this.send("eth_accounts", []).then((accounts) => {
        return accounts.map((a6) => this.formatter.address(a6));
      });
    }
    send(method, params) {
      const request = {
        method,
        params,
        id: this._nextId++,
        jsonrpc: "2.0"
      };
      this.emit("debug", {
        action: "request",
        request: deepCopy(request),
        provider: this
      });
      const cache = ["eth_chainId", "eth_blockNumber"].indexOf(method) >= 0;
      if (cache && this._cache[method]) {
        return this._cache[method];
      }
      const result = fetchJson(this.connection, JSON.stringify(request), getResult).then((result2) => {
        this.emit("debug", {
          action: "response",
          request,
          response: result2,
          provider: this
        });
        return result2;
      }, (error) => {
        this.emit("debug", {
          action: "response",
          error,
          request,
          provider: this
        });
        throw error;
      });
      if (cache) {
        this._cache[method] = result;
        setTimeout(() => {
          this._cache[method] = null;
        }, 0);
      }
      return result;
    }
    prepareRequest(method, params) {
      switch (method) {
        case "getBlockNumber":
          return ["eth_blockNumber", []];
        case "getGasPrice":
          return ["eth_gasPrice", []];
        case "getBalance":
          return ["eth_getBalance", [getLowerCase(params.address), params.blockTag]];
        case "getTransactionCount":
          return ["eth_getTransactionCount", [getLowerCase(params.address), params.blockTag]];
        case "getCode":
          return ["eth_getCode", [getLowerCase(params.address), params.blockTag]];
        case "getStorageAt":
          return ["eth_getStorageAt", [getLowerCase(params.address), hexZeroPad(params.position, 32), params.blockTag]];
        case "sendTransaction":
          return ["eth_sendRawTransaction", [params.signedTransaction]];
        case "getBlock":
          if (params.blockTag) {
            return ["eth_getBlockByNumber", [params.blockTag, !!params.includeTransactions]];
          } else if (params.blockHash) {
            return ["eth_getBlockByHash", [params.blockHash, !!params.includeTransactions]];
          }
          return null;
        case "getTransaction":
          return ["eth_getTransactionByHash", [params.transactionHash]];
        case "getTransactionReceipt":
          return ["eth_getTransactionReceipt", [params.transactionHash]];
        case "call": {
          const hexlifyTransaction = getStatic(this.constructor, "hexlifyTransaction");
          return ["eth_call", [hexlifyTransaction(params.transaction, { from: true }), params.blockTag]];
        }
        case "estimateGas": {
          const hexlifyTransaction = getStatic(this.constructor, "hexlifyTransaction");
          return ["eth_estimateGas", [hexlifyTransaction(params.transaction, { from: true })]];
        }
        case "getLogs":
          if (params.filter && params.filter.address != null) {
            params.filter.address = getLowerCase(params.filter.address);
          }
          return ["eth_getLogs", [params.filter]];
        default:
          break;
      }
      return null;
    }
    perform(method, params) {
      return __awaiter12(this, void 0, void 0, function* () {
        if (method === "call" || method === "estimateGas") {
          const tx = params.transaction;
          if (tx && tx.type != null && BigNumber.from(tx.type).isZero()) {
            if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {
              const feeData = yield this.getFeeData();
              if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
                params = shallowCopy(params);
                params.transaction = shallowCopy(tx);
                delete params.transaction.type;
              }
            }
          }
        }
        const args = this.prepareRequest(method, params);
        if (args == null) {
          logger31.throwError(method + " not implemented", Logger.errors.NOT_IMPLEMENTED, { operation: method });
        }
        try {
          return yield this.send(args[0], args[1]);
        } catch (error) {
          return checkError(method, error, params);
        }
      });
    }
    _startEvent(event) {
      if (event.tag === "pending") {
        this._startPending();
      }
      super._startEvent(event);
    }
    _startPending() {
      if (this._pendingFilter != null) {
        return;
      }
      const self2 = this;
      const pendingFilter = this.send("eth_newPendingTransactionFilter", []);
      this._pendingFilter = pendingFilter;
      pendingFilter.then(function(filterId) {
        function poll3() {
          self2.send("eth_getFilterChanges", [filterId]).then(function(hashes2) {
            if (self2._pendingFilter != pendingFilter) {
              return null;
            }
            let seq = Promise.resolve();
            hashes2.forEach(function(hash5) {
              self2._emitted["t:" + hash5.toLowerCase()] = "pending";
              seq = seq.then(function() {
                return self2.getTransaction(hash5).then(function(tx) {
                  self2.emit("pending", tx);
                  return null;
                });
              });
            });
            return seq.then(function() {
              return timer(1e3);
            });
          }).then(function() {
            if (self2._pendingFilter != pendingFilter) {
              self2.send("eth_uninstallFilter", [filterId]);
              return;
            }
            setTimeout(function() {
              poll3();
            }, 0);
            return null;
          }).catch((error) => {
          });
        }
        poll3();
        return filterId;
      }).catch((error) => {
      });
    }
    _stopEvent(event) {
      if (event.tag === "pending" && this.listenerCount("pending") === 0) {
        this._pendingFilter = null;
      }
      super._stopEvent(event);
    }
    // Convert an ethers.js transaction into a JSON-RPC transaction
    //  - gasLimit => gas
    //  - All values hexlified
    //  - All numeric values zero-striped
    //  - All addresses are lowercased
    // NOTE: This allows a TransactionRequest, but all values should be resolved
    //       before this is called
    // @TODO: This will likely be removed in future versions and prepareRequest
    //        will be the preferred method for this.
    static hexlifyTransaction(transaction, allowExtra) {
      const allowed = shallowCopy(allowedTransactionKeys4);
      if (allowExtra) {
        for (const key2 in allowExtra) {
          if (allowExtra[key2]) {
            allowed[key2] = true;
          }
        }
      }
      checkProperties(transaction, allowed);
      const result = {};
      ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(function(key2) {
        if (transaction[key2] == null) {
          return;
        }
        const value = hexValue(BigNumber.from(transaction[key2]));
        if (key2 === "gasLimit") {
          key2 = "gas";
        }
        result[key2] = value;
      });
      ["from", "to", "data"].forEach(function(key2) {
        if (transaction[key2] == null) {
          return;
        }
        result[key2] = hexlify(transaction[key2]);
      });
      if (transaction.accessList) {
        result["accessList"] = accessListify(transaction.accessList);
      }
      return result;
    }
  };

  // node_modules/@ethersproject/providers/lib.esm/ws.js
  var WS = null;
  try {
    WS = WebSocket;
    if (WS == null) {
      throw new Error("inject please");
    }
  } catch (error) {
    const logger47 = new Logger(version26);
    WS = function() {
      logger47.throwError("WebSockets not supported in this environment", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new WebSocket()"
      });
    };
  }

  // node_modules/@ethersproject/providers/lib.esm/websocket-provider.js
  var __awaiter13 = function(thisArg, _arguments, P7, generator) {
    function adopt(value) {
      return value instanceof P7 ? value : new P7(function(resolve) {
        resolve(value);
      });
    }
    return new (P7 || (P7 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e9) {
          reject(e9);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e9) {
          reject(e9);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var logger32 = new Logger(version26);
  var NextId = 1;
  var WebSocketProvider = class extends JsonRpcProvider2 {
    constructor(url, network) {
      if (network === "any") {
        logger32.throwError("WebSocketProvider does not support 'any' network yet", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "network:any"
        });
      }
      if (typeof url === "string") {
        super(url, network);
      } else {
        super("_websocket", network);
      }
      this._pollingInterval = -1;
      this._wsReady = false;
      if (typeof url === "string") {
        defineReadOnly(this, "_websocket", new WS(this.connection.url));
      } else {
        defineReadOnly(this, "_websocket", url);
      }
      defineReadOnly(this, "_requests", {});
      defineReadOnly(this, "_subs", {});
      defineReadOnly(this, "_subIds", {});
      defineReadOnly(this, "_detectNetwork", super.detectNetwork());
      this.websocket.onopen = () => {
        this._wsReady = true;
        Object.keys(this._requests).forEach((id3) => {
          this.websocket.send(this._requests[id3].payload);
        });
      };
      this.websocket.onmessage = (messageEvent) => {
        const data2 = messageEvent.data;
        const result = JSON.parse(data2);
        if (result.id != null) {
          const id3 = String(result.id);
          const request = this._requests[id3];
          delete this._requests[id3];
          if (result.result !== void 0) {
            request.callback(null, result.result);
            this.emit("debug", {
              action: "response",
              request: JSON.parse(request.payload),
              response: result.result,
              provider: this
            });
          } else {
            let error = null;
            if (result.error) {
              error = new Error(result.error.message || "unknown error");
              defineReadOnly(error, "code", result.error.code || null);
              defineReadOnly(error, "response", data2);
            } else {
              error = new Error("unknown error");
            }
            request.callback(error, void 0);
            this.emit("debug", {
              action: "response",
              error,
              request: JSON.parse(request.payload),
              provider: this
            });
          }
        } else if (result.method === "eth_subscription") {
          const sub = this._subs[result.params.subscription];
          if (sub) {
            sub.processFunc(result.params.result);
          }
        } else {
          console.warn("this should not happen");
        }
      };
      const fauxPoll = setInterval(() => {
        this.emit("poll");
      }, 1e3);
      if (fauxPoll.unref) {
        fauxPoll.unref();
      }
    }
    // Cannot narrow the type of _websocket, as that is not backwards compatible
    // so we add a getter and let the WebSocket be a public API.
    get websocket() {
      return this._websocket;
    }
    detectNetwork() {
      return this._detectNetwork;
    }
    get pollingInterval() {
      return 0;
    }
    resetEventsBlock(blockNumber) {
      logger32.throwError("cannot reset events block on WebSocketProvider", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "resetEventBlock"
      });
    }
    set pollingInterval(value) {
      logger32.throwError("cannot set polling interval on WebSocketProvider", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setPollingInterval"
      });
    }
    poll() {
      return __awaiter13(this, void 0, void 0, function* () {
        return null;
      });
    }
    set polling(value) {
      if (!value) {
        return;
      }
      logger32.throwError("cannot set polling on WebSocketProvider", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setPolling"
      });
    }
    send(method, params) {
      const rid = NextId++;
      return new Promise((resolve, reject) => {
        function callback(error, result) {
          if (error) {
            return reject(error);
          }
          return resolve(result);
        }
        const payload = JSON.stringify({
          method,
          params,
          id: rid,
          jsonrpc: "2.0"
        });
        this.emit("debug", {
          action: "request",
          request: JSON.parse(payload),
          provider: this
        });
        this._requests[String(rid)] = { callback, payload };
        if (this._wsReady) {
          this.websocket.send(payload);
        }
      });
    }
    static defaultUrl() {
      return "ws://localhost:8546";
    }
    _subscribe(tag, param, processFunc) {
      return __awaiter13(this, void 0, void 0, function* () {
        let subIdPromise = this._subIds[tag];
        if (subIdPromise == null) {
          subIdPromise = Promise.all(param).then((param2) => {
            return this.send("eth_subscribe", param2);
          });
          this._subIds[tag] = subIdPromise;
        }
        const subId = yield subIdPromise;
        this._subs[subId] = { tag, processFunc };
      });
    }
    _startEvent(event) {
      switch (event.type) {
        case "block":
          this._subscribe("block", ["newHeads"], (result) => {
            const blockNumber = BigNumber.from(result.number).toNumber();
            this._emitted.block = blockNumber;
            this.emit("block", blockNumber);
          });
          break;
        case "pending":
          this._subscribe("pending", ["newPendingTransactions"], (result) => {
            this.emit("pending", result);
          });
          break;
        case "filter":
          this._subscribe(event.tag, ["logs", this._getFilter(event.filter)], (result) => {
            if (result.removed == null) {
              result.removed = false;
            }
            this.emit(event.filter, this.formatter.filterLog(result));
          });
          break;
        case "tx": {
          const emitReceipt = (event2) => {
            const hash5 = event2.hash;
            this.getTransactionReceipt(hash5).then((receipt) => {
              if (!receipt) {
                return;
              }
              this.emit(hash5, receipt);
            });
          };
          emitReceipt(event);
          this._subscribe("tx", ["newHeads"], (result) => {
            this._events.filter((e9) => e9.type === "tx").forEach(emitReceipt);
          });
          break;
        }
        case "debug":
        case "poll":
        case "willPoll":
        case "didPoll":
        case "error":
          break;
        default:
          console.log("unhandled:", event);
          break;
      }
    }
    _stopEvent(event) {
      let tag = event.tag;
      if (event.type === "tx") {
        if (this._events.filter((e9) => e9.type === "tx").length) {
          return;
        }
        tag = "tx";
      } else if (this.listenerCount(event.event)) {
        return;
      }
      const subId = this._subIds[tag];
      if (!subId) {
        return;
      }
      delete this._subIds[tag];
      subId.then((subId2) => {
        if (!this._subs[subId2]) {
          return;
        }
        delete this._subs[subId2];
        this.send("eth_unsubscribe", [subId2]);
      });
    }
    destroy() {
      return __awaiter13(this, void 0, void 0, function* () {
        if (this.websocket.readyState === WS.CONNECTING) {
          yield new Promise((resolve) => {
            this.websocket.onopen = function() {
              resolve(true);
            };
            this.websocket.onerror = function() {
              resolve(false);
            };
          });
        }
        this.websocket.close(1e3);
      });
    }
  };

  // node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js
  var __awaiter14 = function(thisArg, _arguments, P7, generator) {
    function adopt(value) {
      return value instanceof P7 ? value : new P7(function(resolve) {
        resolve(value);
      });
    }
    return new (P7 || (P7 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e9) {
          reject(e9);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e9) {
          reject(e9);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var logger33 = new Logger(version26);
  var StaticJsonRpcProvider = class extends JsonRpcProvider2 {
    detectNetwork() {
      const _super = Object.create(null, {
        detectNetwork: { get: () => super.detectNetwork }
      });
      return __awaiter14(this, void 0, void 0, function* () {
        let network = this.network;
        if (network == null) {
          network = yield _super.detectNetwork.call(this);
          if (!network) {
            logger33.throwError("no network detected", Logger.errors.UNKNOWN_ERROR, {});
          }
          if (this._network == null) {
            defineReadOnly(this, "_network", network);
            this.emit("network", network, null);
          }
        }
        return network;
      });
    }
  };
  var UrlJsonRpcProvider = class extends StaticJsonRpcProvider {
    constructor(network, apiKey) {
      logger33.checkAbstract(new.target, UrlJsonRpcProvider);
      network = getStatic(new.target, "getNetwork")(network);
      apiKey = getStatic(new.target, "getApiKey")(apiKey);
      const connection = getStatic(new.target, "getUrl")(network, apiKey);
      super(connection, network);
      if (typeof apiKey === "string") {
        defineReadOnly(this, "apiKey", apiKey);
      } else if (apiKey != null) {
        Object.keys(apiKey).forEach((key2) => {
          defineReadOnly(this, key2, apiKey[key2]);
        });
      }
    }
    _startPending() {
      logger33.warn("WARNING: API provider does not support pending filters");
    }
    isCommunityResource() {
      return false;
    }
    getSigner(address) {
      return logger33.throwError("API provider does not support signing", Logger.errors.UNSUPPORTED_OPERATION, { operation: "getSigner" });
    }
    listAccounts() {
      return Promise.resolve([]);
    }
    // Return a defaultApiKey if null, otherwise validate the API key
    static getApiKey(apiKey) {
      return apiKey;
    }
    // Returns the url or connection for the given network and API key. The
    // API key will have been sanitized by the getApiKey first, so any validation
    // or transformations can be done there.
    static getUrl(network, apiKey) {
      return logger33.throwError("not implemented; sub-classes must override getUrl", Logger.errors.NOT_IMPLEMENTED, {
        operation: "getUrl"
      });
    }
  };

  // node_modules/@ethersproject/providers/lib.esm/alchemy-provider.js
  var logger34 = new Logger(version26);
  var defaultApiKey = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";
  var AlchemyWebSocketProvider = class extends WebSocketProvider {
    constructor(network, apiKey) {
      const provider = new AlchemyProvider(network, apiKey);
      const url = provider.connection.url.replace(/^http/i, "ws").replace(".alchemyapi.", ".ws.alchemyapi.");
      super(url, provider.network);
      defineReadOnly(this, "apiKey", provider.apiKey);
    }
    isCommunityResource() {
      return this.apiKey === defaultApiKey;
    }
  };
  var AlchemyProvider = class extends UrlJsonRpcProvider {
    static getWebSocketProvider(network, apiKey) {
      return new AlchemyWebSocketProvider(network, apiKey);
    }
    static getApiKey(apiKey) {
      if (apiKey == null) {
        return defaultApiKey;
      }
      if (apiKey && typeof apiKey !== "string") {
        logger34.throwArgumentError("invalid apiKey", "apiKey", apiKey);
      }
      return apiKey;
    }
    static getUrl(network, apiKey) {
      let host = null;
      switch (network.name) {
        case "homestead":
          host = "eth-mainnet.alchemyapi.io/v2/";
          break;
        case "goerli":
          host = "eth-goerli.g.alchemy.com/v2/";
          break;
        case "matic":
          host = "polygon-mainnet.g.alchemy.com/v2/";
          break;
        case "maticmum":
          host = "polygon-mumbai.g.alchemy.com/v2/";
          break;
        case "arbitrum":
          host = "arb-mainnet.g.alchemy.com/v2/";
          break;
        case "arbitrum-goerli":
          host = "arb-goerli.g.alchemy.com/v2/";
          break;
        case "optimism":
          host = "opt-mainnet.g.alchemy.com/v2/";
          break;
        case "optimism-goerli":
          host = "opt-goerli.g.alchemy.com/v2/";
          break;
        default:
          logger34.throwArgumentError("unsupported network", "network", arguments[0]);
      }
      return {
        allowGzip: true,
        url: "https://" + host + apiKey,
        throttleCallback: (attempt, url) => {
          if (apiKey === defaultApiKey) {
            showThrottleMessage();
          }
          return Promise.resolve(true);
        }
      };
    }
    isCommunityResource() {
      return this.apiKey === defaultApiKey;
    }
  };

  // node_modules/@ethersproject/providers/lib.esm/ankr-provider.js
  var logger35 = new Logger(version26);
  var defaultApiKey2 = "9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972";
  function getHost(name2) {
    switch (name2) {
      case "homestead":
        return "rpc.ankr.com/eth/";
      case "ropsten":
        return "rpc.ankr.com/eth_ropsten/";
      case "rinkeby":
        return "rpc.ankr.com/eth_rinkeby/";
      case "goerli":
        return "rpc.ankr.com/eth_goerli/";
      case "matic":
        return "rpc.ankr.com/polygon/";
      case "arbitrum":
        return "rpc.ankr.com/arbitrum/";
    }
    return logger35.throwArgumentError("unsupported network", "name", name2);
  }
  var AnkrProvider = class extends UrlJsonRpcProvider {
    isCommunityResource() {
      return this.apiKey === defaultApiKey2;
    }
    static getApiKey(apiKey) {
      if (apiKey == null) {
        return defaultApiKey2;
      }
      return apiKey;
    }
    static getUrl(network, apiKey) {
      if (apiKey == null) {
        apiKey = defaultApiKey2;
      }
      const connection = {
        allowGzip: true,
        url: "https://" + getHost(network.name) + apiKey,
        throttleCallback: (attempt, url) => {
          if (apiKey.apiKey === defaultApiKey2) {
            showThrottleMessage();
          }
          return Promise.resolve(true);
        }
      };
      if (apiKey.projectSecret != null) {
        connection.user = "";
        connection.password = apiKey.projectSecret;
      }
      return connection;
    }
  };

  // node_modules/@ethersproject/providers/lib.esm/cloudflare-provider.js
  var __awaiter15 = function(thisArg, _arguments, P7, generator) {
    function adopt(value) {
      return value instanceof P7 ? value : new P7(function(resolve) {
        resolve(value);
      });
    }
    return new (P7 || (P7 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e9) {
          reject(e9);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e9) {
          reject(e9);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var logger36 = new Logger(version26);
  var CloudflareProvider = class extends UrlJsonRpcProvider {
    static getApiKey(apiKey) {
      if (apiKey != null) {
        logger36.throwArgumentError("apiKey not supported for cloudflare", "apiKey", apiKey);
      }
      return null;
    }
    static getUrl(network, apiKey) {
      let host = null;
      switch (network.name) {
        case "homestead":
          host = "https://cloudflare-eth.com/";
          break;
        default:
          logger36.throwArgumentError("unsupported network", "network", arguments[0]);
      }
      return host;
    }
    perform(method, params) {
      const _super = Object.create(null, {
        perform: { get: () => super.perform }
      });
      return __awaiter15(this, void 0, void 0, function* () {
        if (method === "getBlockNumber") {
          const block2 = yield _super.perform.call(this, "getBlock", { blockTag: "latest" });
          return block2.number;
        }
        return _super.perform.call(this, method, params);
      });
    }
  };

  // node_modules/@ethersproject/providers/lib.esm/etherscan-provider.js
  var __awaiter16 = function(thisArg, _arguments, P7, generator) {
    function adopt(value) {
      return value instanceof P7 ? value : new P7(function(resolve) {
        resolve(value);
      });
    }
    return new (P7 || (P7 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e9) {
          reject(e9);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e9) {
          reject(e9);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var logger37 = new Logger(version26);
  function getTransactionPostData(transaction) {
    const result = {};
    for (let key2 in transaction) {
      if (transaction[key2] == null) {
        continue;
      }
      let value = transaction[key2];
      if (key2 === "type" && value === 0) {
        continue;
      }
      if ({ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true }[key2]) {
        value = hexValue(hexlify(value));
      } else if (key2 === "accessList") {
        value = "[" + accessListify(value).map((set2) => {
          return `{address:"${set2.address}",storageKeys:["${set2.storageKeys.join('","')}"]}`;
        }).join(",") + "]";
      } else {
        value = hexlify(value);
      }
      result[key2] = value;
    }
    return result;
  }
  function getResult2(result) {
    if (result.status == 0 && (result.message === "No records found" || result.message === "No transactions found")) {
      return result.result;
    }
    if (result.status != 1 || typeof result.message !== "string" || !result.message.match(/^OK/)) {
      const error = new Error("invalid response");
      error.result = JSON.stringify(result);
      if ((result.result || "").toLowerCase().indexOf("rate limit") >= 0) {
        error.throttleRetry = true;
      }
      throw error;
    }
    return result.result;
  }
  function getJsonResult(result) {
    if (result && result.status == 0 && result.message == "NOTOK" && (result.result || "").toLowerCase().indexOf("rate limit") >= 0) {
      const error = new Error("throttled response");
      error.result = JSON.stringify(result);
      error.throttleRetry = true;
      throw error;
    }
    if (result.jsonrpc != "2.0") {
      const error = new Error("invalid response");
      error.result = JSON.stringify(result);
      throw error;
    }
    if (result.error) {
      const error = new Error(result.error.message || "unknown error");
      if (result.error.code) {
        error.code = result.error.code;
      }
      if (result.error.data) {
        error.data = result.error.data;
      }
      throw error;
    }
    return result.result;
  }
  function checkLogTag(blockTag) {
    if (blockTag === "pending") {
      throw new Error("pending not supported");
    }
    if (blockTag === "latest") {
      return blockTag;
    }
    return parseInt(blockTag.substring(2), 16);
  }
  function checkError2(method, error, transaction) {
    if (method === "call" && error.code === Logger.errors.SERVER_ERROR) {
      const e9 = error.error;
      if (e9 && (e9.message.match(/reverted/i) || e9.message.match(/VM execution error/i))) {
        let data2 = e9.data;
        if (data2) {
          data2 = "0x" + data2.replace(/^.*0x/i, "");
        }
        if (isHexString(data2)) {
          return data2;
        }
        logger37.throwError("missing revert data in call exception", Logger.errors.CALL_EXCEPTION, {
          error,
          data: "0x"
        });
      }
    }
    let message = error.message;
    if (error.code === Logger.errors.SERVER_ERROR) {
      if (error.error && typeof error.error.message === "string") {
        message = error.error.message;
      } else if (typeof error.body === "string") {
        message = error.body;
      } else if (typeof error.responseText === "string") {
        message = error.responseText;
      }
    }
    message = (message || "").toLowerCase();
    if (message.match(/insufficient funds/)) {
      logger37.throwError("insufficient funds for intrinsic transaction cost", Logger.errors.INSUFFICIENT_FUNDS, {
        error,
        method,
        transaction
      });
    }
    if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {
      logger37.throwError("nonce has already been used", Logger.errors.NONCE_EXPIRED, {
        error,
        method,
        transaction
      });
    }
    if (message.match(/another transaction with same nonce/)) {
      logger37.throwError("replacement fee too low", Logger.errors.REPLACEMENT_UNDERPRICED, {
        error,
        method,
        transaction
      });
    }
    if (message.match(/execution failed due to an exception|execution reverted/)) {
      logger37.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
        error,
        method,
        transaction
      });
    }
    throw error;
  }
  var EtherscanProvider = class extends BaseProvider {
    constructor(network, apiKey) {
      super(network);
      defineReadOnly(this, "baseUrl", this.getBaseUrl());
      defineReadOnly(this, "apiKey", apiKey || null);
    }
    getBaseUrl() {
      switch (this.network ? this.network.name : "invalid") {
        case "homestead":
          return "https://api.etherscan.io";
        case "goerli":
          return "https://api-goerli.etherscan.io";
        case "sepolia":
          return "https://api-sepolia.etherscan.io";
        case "matic":
          return "https://api.polygonscan.com";
        case "maticmum":
          return "https://api-testnet.polygonscan.com";
        case "arbitrum":
          return "https://api.arbiscan.io";
        case "arbitrum-goerli":
          return "https://api-goerli.arbiscan.io";
        case "optimism":
          return "https://api-optimistic.etherscan.io";
        case "optimism-goerli":
          return "https://api-goerli-optimistic.etherscan.io";
        default:
      }
      return logger37.throwArgumentError("unsupported network", "network", this.network.name);
    }
    getUrl(module, params) {
      const query = Object.keys(params).reduce((accum, key2) => {
        const value = params[key2];
        if (value != null) {
          accum += `&${key2}=${value}`;
        }
        return accum;
      }, "");
      const apiKey = this.apiKey ? `&apikey=${this.apiKey}` : "";
      return `${this.baseUrl}/api?module=${module}${query}${apiKey}`;
    }
    getPostUrl() {
      return `${this.baseUrl}/api`;
    }
    getPostData(module, params) {
      params.module = module;
      params.apikey = this.apiKey;
      return params;
    }
    fetch(module, params, post) {
      return __awaiter16(this, void 0, void 0, function* () {
        const url = post ? this.getPostUrl() : this.getUrl(module, params);
        const payload = post ? this.getPostData(module, params) : null;
        const procFunc = module === "proxy" ? getJsonResult : getResult2;
        this.emit("debug", {
          action: "request",
          request: url,
          provider: this
        });
        const connection = {
          url,
          throttleSlotInterval: 1e3,
          throttleCallback: (attempt, url2) => {
            if (this.isCommunityResource()) {
              showThrottleMessage();
            }
            return Promise.resolve(true);
          }
        };
        let payloadStr = null;
        if (payload) {
          connection.headers = { "content-type": "application/x-www-form-urlencoded; charset=UTF-8" };
          payloadStr = Object.keys(payload).map((key2) => {
            return `${key2}=${payload[key2]}`;
          }).join("&");
        }
        const result = yield fetchJson(connection, payloadStr, procFunc || getJsonResult);
        this.emit("debug", {
          action: "response",
          request: url,
          response: deepCopy(result),
          provider: this
        });
        return result;
      });
    }
    detectNetwork() {
      return __awaiter16(this, void 0, void 0, function* () {
        return this.network;
      });
    }
    perform(method, params) {
      const _super = Object.create(null, {
        perform: { get: () => super.perform }
      });
      return __awaiter16(this, void 0, void 0, function* () {
        switch (method) {
          case "getBlockNumber":
            return this.fetch("proxy", { action: "eth_blockNumber" });
          case "getGasPrice":
            return this.fetch("proxy", { action: "eth_gasPrice" });
          case "getBalance":
            return this.fetch("account", {
              action: "balance",
              address: params.address,
              tag: params.blockTag
            });
          case "getTransactionCount":
            return this.fetch("proxy", {
              action: "eth_getTransactionCount",
              address: params.address,
              tag: params.blockTag
            });
          case "getCode":
            return this.fetch("proxy", {
              action: "eth_getCode",
              address: params.address,
              tag: params.blockTag
            });
          case "getStorageAt":
            return this.fetch("proxy", {
              action: "eth_getStorageAt",
              address: params.address,
              position: params.position,
              tag: params.blockTag
            });
          case "sendTransaction":
            return this.fetch("proxy", {
              action: "eth_sendRawTransaction",
              hex: params.signedTransaction
            }, true).catch((error) => {
              return checkError2("sendTransaction", error, params.signedTransaction);
            });
          case "getBlock":
            if (params.blockTag) {
              return this.fetch("proxy", {
                action: "eth_getBlockByNumber",
                tag: params.blockTag,
                boolean: params.includeTransactions ? "true" : "false"
              });
            }
            throw new Error("getBlock by blockHash not implemented");
          case "getTransaction":
            return this.fetch("proxy", {
              action: "eth_getTransactionByHash",
              txhash: params.transactionHash
            });
          case "getTransactionReceipt":
            return this.fetch("proxy", {
              action: "eth_getTransactionReceipt",
              txhash: params.transactionHash
            });
          case "call": {
            if (params.blockTag !== "latest") {
              throw new Error("EtherscanProvider does not support blockTag for call");
            }
            const postData = getTransactionPostData(params.transaction);
            postData.module = "proxy";
            postData.action = "eth_call";
            try {
              return yield this.fetch("proxy", postData, true);
            } catch (error) {
              return checkError2("call", error, params.transaction);
            }
          }
          case "estimateGas": {
            const postData = getTransactionPostData(params.transaction);
            postData.module = "proxy";
            postData.action = "eth_estimateGas";
            try {
              return yield this.fetch("proxy", postData, true);
            } catch (error) {
              return checkError2("estimateGas", error, params.transaction);
            }
          }
          case "getLogs": {
            const args = { action: "getLogs" };
            if (params.filter.fromBlock) {
              args.fromBlock = checkLogTag(params.filter.fromBlock);
            }
            if (params.filter.toBlock) {
              args.toBlock = checkLogTag(params.filter.toBlock);
            }
            if (params.filter.address) {
              args.address = params.filter.address;
            }
            if (params.filter.topics && params.filter.topics.length > 0) {
              if (params.filter.topics.length > 1) {
                logger37.throwError("unsupported topic count", Logger.errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });
              }
              if (params.filter.topics.length === 1) {
                const topic0 = params.filter.topics[0];
                if (typeof topic0 !== "string" || topic0.length !== 66) {
                  logger37.throwError("unsupported topic format", Logger.errors.UNSUPPORTED_OPERATION, { topic0 });
                }
                args.topic0 = topic0;
              }
            }
            const logs = yield this.fetch("logs", args);
            let blocks = {};
            for (let i7 = 0; i7 < logs.length; i7++) {
              const log = logs[i7];
              if (log.blockHash != null) {
                continue;
              }
              if (blocks[log.blockNumber] == null) {
                const block2 = yield this.getBlock(log.blockNumber);
                if (block2) {
                  blocks[log.blockNumber] = block2.hash;
                }
              }
              log.blockHash = blocks[log.blockNumber];
            }
            return logs;
          }
          case "getEtherPrice":
            if (this.network.name !== "homestead") {
              return 0;
            }
            return parseFloat((yield this.fetch("stats", { action: "ethprice" })).ethusd);
          default:
            break;
        }
        return _super.perform.call(this, method, params);
      });
    }
    // Note: The `page` page parameter only allows pagination within the
    //       10,000 window available without a page and offset parameter
    //       Error: Result window is too large, PageNo x Offset size must
    //              be less than or equal to 10000
    getHistory(addressOrName, startBlock, endBlock) {
      return __awaiter16(this, void 0, void 0, function* () {
        const params = {
          action: "txlist",
          address: yield this.resolveName(addressOrName),
          startblock: startBlock == null ? 0 : startBlock,
          endblock: endBlock == null ? 99999999 : endBlock,
          sort: "asc"
        };
        const result = yield this.fetch("account", params);
        return result.map((tx) => {
          ["contractAddress", "to"].forEach(function(key2) {
            if (tx[key2] == "") {
              delete tx[key2];
            }
          });
          if (tx.creates == null && tx.contractAddress != null) {
            tx.creates = tx.contractAddress;
          }
          const item = this.formatter.transactionResponse(tx);
          if (tx.timeStamp) {
            item.timestamp = parseInt(tx.timeStamp);
          }
          return item;
        });
      });
    }
    isCommunityResource() {
      return this.apiKey == null;
    }
  };

  // node_modules/@ethersproject/providers/lib.esm/fallback-provider.js
  var __awaiter17 = function(thisArg, _arguments, P7, generator) {
    function adopt(value) {
      return value instanceof P7 ? value : new P7(function(resolve) {
        resolve(value);
      });
    }
    return new (P7 || (P7 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e9) {
          reject(e9);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e9) {
          reject(e9);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var logger38 = new Logger(version26);
  function now() {
    return (/* @__PURE__ */ new Date()).getTime();
  }
  function checkNetworks(networks2) {
    let result = null;
    for (let i7 = 0; i7 < networks2.length; i7++) {
      const network = networks2[i7];
      if (network == null) {
        return null;
      }
      if (result) {
        if (!(result.name === network.name && result.chainId === network.chainId && (result.ensAddress === network.ensAddress || result.ensAddress == null && network.ensAddress == null))) {
          logger38.throwArgumentError("provider mismatch", "networks", networks2);
        }
      } else {
        result = network;
      }
    }
    return result;
  }
  function median(values, maxDelta) {
    values = values.slice().sort();
    const middle = Math.floor(values.length / 2);
    if (values.length % 2) {
      return values[middle];
    }
    const a6 = values[middle - 1], b7 = values[middle];
    if (maxDelta != null && Math.abs(a6 - b7) > maxDelta) {
      return null;
    }
    return (a6 + b7) / 2;
  }
  function serialize3(value) {
    if (value === null) {
      return "null";
    } else if (typeof value === "number" || typeof value === "boolean") {
      return JSON.stringify(value);
    } else if (typeof value === "string") {
      return value;
    } else if (BigNumber.isBigNumber(value)) {
      return value.toString();
    } else if (Array.isArray(value)) {
      return JSON.stringify(value.map((i7) => serialize3(i7)));
    } else if (typeof value === "object") {
      const keys2 = Object.keys(value);
      keys2.sort();
      return "{" + keys2.map((key2) => {
        let v6 = value[key2];
        if (typeof v6 === "function") {
          v6 = "[function]";
        } else {
          v6 = serialize3(v6);
        }
        return JSON.stringify(key2) + ":" + v6;
      }).join(",") + "}";
    }
    throw new Error("unknown value type: " + typeof value);
  }
  var nextRid = 1;
  function stall2(duration) {
    let cancel = null;
    let timer2 = null;
    let promise = new Promise((resolve) => {
      cancel = function() {
        if (timer2) {
          clearTimeout(timer2);
          timer2 = null;
        }
        resolve();
      };
      timer2 = setTimeout(cancel, duration);
    });
    const wait2 = (func) => {
      promise = promise.then(func);
      return promise;
    };
    function getPromise() {
      return promise;
    }
    return { cancel, getPromise, wait: wait2 };
  }
  var ForwardErrors = [
    Logger.errors.CALL_EXCEPTION,
    Logger.errors.INSUFFICIENT_FUNDS,
    Logger.errors.NONCE_EXPIRED,
    Logger.errors.REPLACEMENT_UNDERPRICED,
    Logger.errors.UNPREDICTABLE_GAS_LIMIT
  ];
  var ForwardProperties = [
    "address",
    "args",
    "errorArgs",
    "errorSignature",
    "method",
    "transaction"
  ];
  function exposeDebugConfig(config2, now2) {
    const result = {
      weight: config2.weight
    };
    Object.defineProperty(result, "provider", { get: () => config2.provider });
    if (config2.start) {
      result.start = config2.start;
    }
    if (now2) {
      result.duration = now2 - config2.start;
    }
    if (config2.done) {
      if (config2.error) {
        result.error = config2.error;
      } else {
        result.result = config2.result || null;
      }
    }
    return result;
  }
  function normalizedTally(normalize3, quorum) {
    return function(configs) {
      const tally = {};
      configs.forEach((c9) => {
        const value = normalize3(c9.result);
        if (!tally[value]) {
          tally[value] = { count: 0, result: c9.result };
        }
        tally[value].count++;
      });
      const keys2 = Object.keys(tally);
      for (let i7 = 0; i7 < keys2.length; i7++) {
        const check = tally[keys2[i7]];
        if (check.count >= quorum) {
          return check.result;
        }
      }
      return void 0;
    };
  }
  function getProcessFunc(provider, method, params) {
    let normalize3 = serialize3;
    switch (method) {
      case "getBlockNumber":
        return function(configs) {
          const values = configs.map((c9) => c9.result);
          let blockNumber = median(configs.map((c9) => c9.result), 2);
          if (blockNumber == null) {
            return void 0;
          }
          blockNumber = Math.ceil(blockNumber);
          if (values.indexOf(blockNumber + 1) >= 0) {
            blockNumber++;
          }
          if (blockNumber >= provider._highestBlockNumber) {
            provider._highestBlockNumber = blockNumber;
          }
          return provider._highestBlockNumber;
        };
      case "getGasPrice":
        return function(configs) {
          const values = configs.map((c9) => c9.result);
          values.sort();
          return values[Math.floor(values.length / 2)];
        };
      case "getEtherPrice":
        return function(configs) {
          return median(configs.map((c9) => c9.result));
        };
      case "getBalance":
      case "getTransactionCount":
      case "getCode":
      case "getStorageAt":
      case "call":
      case "estimateGas":
      case "getLogs":
        break;
      case "getTransaction":
      case "getTransactionReceipt":
        normalize3 = function(tx) {
          if (tx == null) {
            return null;
          }
          tx = shallowCopy(tx);
          tx.confirmations = -1;
          return serialize3(tx);
        };
        break;
      case "getBlock":
        if (params.includeTransactions) {
          normalize3 = function(block2) {
            if (block2 == null) {
              return null;
            }
            block2 = shallowCopy(block2);
            block2.transactions = block2.transactions.map((tx) => {
              tx = shallowCopy(tx);
              tx.confirmations = -1;
              return tx;
            });
            return serialize3(block2);
          };
        } else {
          normalize3 = function(block2) {
            if (block2 == null) {
              return null;
            }
            return serialize3(block2);
          };
        }
        break;
      default:
        throw new Error("unknown method: " + method);
    }
    return normalizedTally(normalize3, provider.quorum);
  }
  function waitForSync(config2, blockNumber) {
    return __awaiter17(this, void 0, void 0, function* () {
      const provider = config2.provider;
      if (provider.blockNumber != null && provider.blockNumber >= blockNumber || blockNumber === -1) {
        return provider;
      }
      return poll2(() => {
        return new Promise((resolve, reject) => {
          setTimeout(function() {
            if (provider.blockNumber >= blockNumber) {
              return resolve(provider);
            }
            if (config2.cancelled) {
              return resolve(null);
            }
            return resolve(void 0);
          }, 0);
        });
      }, { oncePoll: provider });
    });
  }
  function getRunner(config2, currentBlockNumber, method, params) {
    return __awaiter17(this, void 0, void 0, function* () {
      let provider = config2.provider;
      switch (method) {
        case "getBlockNumber":
        case "getGasPrice":
          return provider[method]();
        case "getEtherPrice":
          if (provider.getEtherPrice) {
            return provider.getEtherPrice();
          }
          break;
        case "getBalance":
        case "getTransactionCount":
        case "getCode":
          if (params.blockTag && isHexString(params.blockTag)) {
            provider = yield waitForSync(config2, currentBlockNumber);
          }
          return provider[method](params.address, params.blockTag || "latest");
        case "getStorageAt":
          if (params.blockTag && isHexString(params.blockTag)) {
            provider = yield waitForSync(config2, currentBlockNumber);
          }
          return provider.getStorageAt(params.address, params.position, params.blockTag || "latest");
        case "getBlock":
          if (params.blockTag && isHexString(params.blockTag)) {
            provider = yield waitForSync(config2, currentBlockNumber);
          }
          return provider[params.includeTransactions ? "getBlockWithTransactions" : "getBlock"](params.blockTag || params.blockHash);
        case "call":
        case "estimateGas":
          if (params.blockTag && isHexString(params.blockTag)) {
            provider = yield waitForSync(config2, currentBlockNumber);
          }
          if (method === "call" && params.blockTag) {
            return provider[method](params.transaction, params.blockTag);
          }
          return provider[method](params.transaction);
        case "getTransaction":
        case "getTransactionReceipt":
          return provider[method](params.transactionHash);
        case "getLogs": {
          let filter2 = params.filter;
          if (filter2.fromBlock && isHexString(filter2.fromBlock) || filter2.toBlock && isHexString(filter2.toBlock)) {
            provider = yield waitForSync(config2, currentBlockNumber);
          }
          return provider.getLogs(filter2);
        }
      }
      return logger38.throwError("unknown method error", Logger.errors.UNKNOWN_ERROR, {
        method,
        params
      });
    });
  }
  var FallbackProvider = class extends BaseProvider {
    constructor(providers, quorum) {
      if (providers.length === 0) {
        logger38.throwArgumentError("missing providers", "providers", providers);
      }
      const providerConfigs = providers.map((configOrProvider, index2) => {
        if (Provider.isProvider(configOrProvider)) {
          const stallTimeout = isCommunityResource(configOrProvider) ? 2e3 : 750;
          const priority = 1;
          return Object.freeze({ provider: configOrProvider, weight: 1, stallTimeout, priority });
        }
        const config2 = shallowCopy(configOrProvider);
        if (config2.priority == null) {
          config2.priority = 1;
        }
        if (config2.stallTimeout == null) {
          config2.stallTimeout = isCommunityResource(configOrProvider) ? 2e3 : 750;
        }
        if (config2.weight == null) {
          config2.weight = 1;
        }
        const weight = config2.weight;
        if (weight % 1 || weight > 512 || weight < 1) {
          logger38.throwArgumentError("invalid weight; must be integer in [1, 512]", `providers[${index2}].weight`, weight);
        }
        return Object.freeze(config2);
      });
      const total = providerConfigs.reduce((accum, c9) => accum + c9.weight, 0);
      if (quorum == null) {
        quorum = total / 2;
      } else if (quorum > total) {
        logger38.throwArgumentError("quorum will always fail; larger than total weight", "quorum", quorum);
      }
      let networkOrReady = checkNetworks(providerConfigs.map((c9) => c9.provider.network));
      if (networkOrReady == null) {
        networkOrReady = new Promise((resolve, reject) => {
          setTimeout(() => {
            this.detectNetwork().then(resolve, reject);
          }, 0);
        });
      }
      super(networkOrReady);
      defineReadOnly(this, "providerConfigs", Object.freeze(providerConfigs));
      defineReadOnly(this, "quorum", quorum);
      this._highestBlockNumber = -1;
    }
    detectNetwork() {
      return __awaiter17(this, void 0, void 0, function* () {
        const networks2 = yield Promise.all(this.providerConfigs.map((c9) => c9.provider.getNetwork()));
        return checkNetworks(networks2);
      });
    }
    perform(method, params) {
      return __awaiter17(this, void 0, void 0, function* () {
        if (method === "sendTransaction") {
          const results2 = yield Promise.all(this.providerConfigs.map((c9) => {
            return c9.provider.sendTransaction(params.signedTransaction).then((result) => {
              return result.hash;
            }, (error) => {
              return error;
            });
          }));
          for (let i8 = 0; i8 < results2.length; i8++) {
            const result = results2[i8];
            if (typeof result === "string") {
              return result;
            }
          }
          throw results2[0];
        }
        if (this._highestBlockNumber === -1 && method !== "getBlockNumber") {
          yield this.getBlockNumber();
        }
        const processFunc = getProcessFunc(this, method, params);
        const configs = shuffled(this.providerConfigs.map(shallowCopy));
        configs.sort((a6, b7) => a6.priority - b7.priority);
        const currentBlockNumber = this._highestBlockNumber;
        let i7 = 0;
        let first = true;
        while (true) {
          const t0 = now();
          let inflightWeight = configs.filter((c9) => c9.runner && t0 - c9.start < c9.stallTimeout).reduce((accum, c9) => accum + c9.weight, 0);
          while (inflightWeight < this.quorum && i7 < configs.length) {
            const config2 = configs[i7++];
            const rid = nextRid++;
            config2.start = now();
            config2.staller = stall2(config2.stallTimeout);
            config2.staller.wait(() => {
              config2.staller = null;
            });
            config2.runner = getRunner(config2, currentBlockNumber, method, params).then((result) => {
              config2.done = true;
              config2.result = result;
              if (this.listenerCount("debug")) {
                this.emit("debug", {
                  action: "request",
                  rid,
                  backend: exposeDebugConfig(config2, now()),
                  request: { method, params: deepCopy(params) },
                  provider: this
                });
              }
            }, (error) => {
              config2.done = true;
              config2.error = error;
              if (this.listenerCount("debug")) {
                this.emit("debug", {
                  action: "request",
                  rid,
                  backend: exposeDebugConfig(config2, now()),
                  request: { method, params: deepCopy(params) },
                  provider: this
                });
              }
            });
            if (this.listenerCount("debug")) {
              this.emit("debug", {
                action: "request",
                rid,
                backend: exposeDebugConfig(config2, null),
                request: { method, params: deepCopy(params) },
                provider: this
              });
            }
            inflightWeight += config2.weight;
          }
          const waiting = [];
          configs.forEach((c9) => {
            if (c9.done || !c9.runner) {
              return;
            }
            waiting.push(c9.runner);
            if (c9.staller) {
              waiting.push(c9.staller.getPromise());
            }
          });
          if (waiting.length) {
            yield Promise.race(waiting);
          }
          const results2 = configs.filter((c9) => c9.done && c9.error == null);
          if (results2.length >= this.quorum) {
            const result = processFunc(results2);
            if (result !== void 0) {
              configs.forEach((c9) => {
                if (c9.staller) {
                  c9.staller.cancel();
                }
                c9.cancelled = true;
              });
              return result;
            }
            if (!first) {
              yield stall2(100).getPromise();
            }
            first = false;
          }
          const errors = configs.reduce((accum, c9) => {
            if (!c9.done || c9.error == null) {
              return accum;
            }
            const code2 = c9.error.code;
            if (ForwardErrors.indexOf(code2) >= 0) {
              if (!accum[code2]) {
                accum[code2] = { error: c9.error, weight: 0 };
              }
              accum[code2].weight += c9.weight;
            }
            return accum;
          }, {});
          Object.keys(errors).forEach((errorCode) => {
            const tally = errors[errorCode];
            if (tally.weight < this.quorum) {
              return;
            }
            configs.forEach((c9) => {
              if (c9.staller) {
                c9.staller.cancel();
              }
              c9.cancelled = true;
            });
            const e9 = tally.error;
            const props = {};
            ForwardProperties.forEach((name2) => {
              if (e9[name2] == null) {
                return;
              }
              props[name2] = e9[name2];
            });
            logger38.throwError(e9.reason || e9.message, errorCode, props);
          });
          if (configs.filter((c9) => !c9.done).length === 0) {
            break;
          }
        }
        configs.forEach((c9) => {
          if (c9.staller) {
            c9.staller.cancel();
          }
          c9.cancelled = true;
        });
        return logger38.throwError("failed to meet quorum", Logger.errors.SERVER_ERROR, {
          method,
          params,
          //results: configs.map((c) => c.result),
          //errors: configs.map((c) => c.error),
          results: configs.map((c9) => exposeDebugConfig(c9)),
          provider: this
        });
      });
    }
  };

  // node_modules/@ethersproject/providers/lib.esm/ipc-provider.js
  var IpcProvider = null;

  // node_modules/@ethersproject/providers/lib.esm/infura-provider.js
  var logger39 = new Logger(version26);
  var defaultProjectId = "84842078b09946638c03157f83405213";
  var InfuraWebSocketProvider = class extends WebSocketProvider {
    constructor(network, apiKey) {
      const provider = new InfuraProvider(network, apiKey);
      const connection = provider.connection;
      if (connection.password) {
        logger39.throwError("INFURA WebSocket project secrets unsupported", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "InfuraProvider.getWebSocketProvider()"
        });
      }
      const url = connection.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/");
      super(url, network);
      defineReadOnly(this, "apiKey", provider.projectId);
      defineReadOnly(this, "projectId", provider.projectId);
      defineReadOnly(this, "projectSecret", provider.projectSecret);
    }
    isCommunityResource() {
      return this.projectId === defaultProjectId;
    }
  };
  var InfuraProvider = class extends UrlJsonRpcProvider {
    static getWebSocketProvider(network, apiKey) {
      return new InfuraWebSocketProvider(network, apiKey);
    }
    static getApiKey(apiKey) {
      const apiKeyObj = {
        apiKey: defaultProjectId,
        projectId: defaultProjectId,
        projectSecret: null
      };
      if (apiKey == null) {
        return apiKeyObj;
      }
      if (typeof apiKey === "string") {
        apiKeyObj.projectId = apiKey;
      } else if (apiKey.projectSecret != null) {
        logger39.assertArgument(typeof apiKey.projectId === "string", "projectSecret requires a projectId", "projectId", apiKey.projectId);
        logger39.assertArgument(typeof apiKey.projectSecret === "string", "invalid projectSecret", "projectSecret", "[REDACTED]");
        apiKeyObj.projectId = apiKey.projectId;
        apiKeyObj.projectSecret = apiKey.projectSecret;
      } else if (apiKey.projectId) {
        apiKeyObj.projectId = apiKey.projectId;
      }
      apiKeyObj.apiKey = apiKeyObj.projectId;
      return apiKeyObj;
    }
    static getUrl(network, apiKey) {
      let host = null;
      switch (network ? network.name : "unknown") {
        case "homestead":
          host = "mainnet.infura.io";
          break;
        case "goerli":
          host = "goerli.infura.io";
          break;
        case "sepolia":
          host = "sepolia.infura.io";
          break;
        case "matic":
          host = "polygon-mainnet.infura.io";
          break;
        case "maticmum":
          host = "polygon-mumbai.infura.io";
          break;
        case "optimism":
          host = "optimism-mainnet.infura.io";
          break;
        case "optimism-goerli":
          host = "optimism-goerli.infura.io";
          break;
        case "arbitrum":
          host = "arbitrum-mainnet.infura.io";
          break;
        case "arbitrum-goerli":
          host = "arbitrum-goerli.infura.io";
          break;
        default:
          logger39.throwError("unsupported network", Logger.errors.INVALID_ARGUMENT, {
            argument: "network",
            value: network
          });
      }
      const connection = {
        allowGzip: true,
        url: "https://" + host + "/v3/" + apiKey.projectId,
        throttleCallback: (attempt, url) => {
          if (apiKey.projectId === defaultProjectId) {
            showThrottleMessage();
          }
          return Promise.resolve(true);
        }
      };
      if (apiKey.projectSecret != null) {
        connection.user = "";
        connection.password = apiKey.projectSecret;
      }
      return connection;
    }
    isCommunityResource() {
      return this.projectId === defaultProjectId;
    }
  };

  // node_modules/@ethersproject/providers/lib.esm/json-rpc-batch-provider.js
  var JsonRpcBatchProvider = class extends JsonRpcProvider2 {
    send(method, params) {
      const request = {
        method,
        params,
        id: this._nextId++,
        jsonrpc: "2.0"
      };
      if (this._pendingBatch == null) {
        this._pendingBatch = [];
      }
      const inflightRequest = { request, resolve: null, reject: null };
      const promise = new Promise((resolve, reject) => {
        inflightRequest.resolve = resolve;
        inflightRequest.reject = reject;
      });
      this._pendingBatch.push(inflightRequest);
      if (!this._pendingBatchAggregator) {
        this._pendingBatchAggregator = setTimeout(() => {
          const batch = this._pendingBatch;
          this._pendingBatch = null;
          this._pendingBatchAggregator = null;
          const request2 = batch.map((inflight) => inflight.request);
          this.emit("debug", {
            action: "requestBatch",
            request: deepCopy(request2),
            provider: this
          });
          return fetchJson(this.connection, JSON.stringify(request2)).then((result) => {
            this.emit("debug", {
              action: "response",
              request: request2,
              response: result,
              provider: this
            });
            batch.forEach((inflightRequest2, index2) => {
              const payload = result[index2];
              if (payload.error) {
                const error = new Error(payload.error.message);
                error.code = payload.error.code;
                error.data = payload.error.data;
                inflightRequest2.reject(error);
              } else {
                inflightRequest2.resolve(payload.result);
              }
            });
          }, (error) => {
            this.emit("debug", {
              action: "response",
              error,
              request: request2,
              provider: this
            });
            batch.forEach((inflightRequest2) => {
              inflightRequest2.reject(error);
            });
          });
        }, 10);
      }
      return promise;
    }
  };

  // node_modules/@ethersproject/providers/lib.esm/nodesmith-provider.js
  var logger40 = new Logger(version26);
  var defaultApiKey3 = "ETHERS_JS_SHARED";
  var NodesmithProvider = class extends UrlJsonRpcProvider {
    static getApiKey(apiKey) {
      if (apiKey && typeof apiKey !== "string") {
        logger40.throwArgumentError("invalid apiKey", "apiKey", apiKey);
      }
      return apiKey || defaultApiKey3;
    }
    static getUrl(network, apiKey) {
      logger40.warn("NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.");
      let host = null;
      switch (network.name) {
        case "homestead":
          host = "https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc";
          break;
        case "ropsten":
          host = "https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc";
          break;
        case "rinkeby":
          host = "https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc";
          break;
        case "goerli":
          host = "https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc";
          break;
        case "kovan":
          host = "https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc";
          break;
        default:
          logger40.throwArgumentError("unsupported network", "network", arguments[0]);
      }
      return host + "?apiKey=" + apiKey;
    }
  };

  // node_modules/@ethersproject/providers/lib.esm/pocket-provider.js
  var logger41 = new Logger(version26);
  var defaultApplicationId = "62e1ad51b37b8e00394bda3b";
  var PocketProvider = class extends UrlJsonRpcProvider {
    static getApiKey(apiKey) {
      const apiKeyObj = {
        applicationId: null,
        loadBalancer: true,
        applicationSecretKey: null
      };
      if (apiKey == null) {
        apiKeyObj.applicationId = defaultApplicationId;
      } else if (typeof apiKey === "string") {
        apiKeyObj.applicationId = apiKey;
      } else if (apiKey.applicationSecretKey != null) {
        apiKeyObj.applicationId = apiKey.applicationId;
        apiKeyObj.applicationSecretKey = apiKey.applicationSecretKey;
      } else if (apiKey.applicationId) {
        apiKeyObj.applicationId = apiKey.applicationId;
      } else {
        logger41.throwArgumentError("unsupported PocketProvider apiKey", "apiKey", apiKey);
      }
      return apiKeyObj;
    }
    static getUrl(network, apiKey) {
      let host = null;
      switch (network ? network.name : "unknown") {
        case "goerli":
          host = "eth-goerli.gateway.pokt.network";
          break;
        case "homestead":
          host = "eth-mainnet.gateway.pokt.network";
          break;
        case "kovan":
          host = "poa-kovan.gateway.pokt.network";
          break;
        case "matic":
          host = "poly-mainnet.gateway.pokt.network";
          break;
        case "maticmum":
          host = "polygon-mumbai-rpc.gateway.pokt.network";
          break;
        case "rinkeby":
          host = "eth-rinkeby.gateway.pokt.network";
          break;
        case "ropsten":
          host = "eth-ropsten.gateway.pokt.network";
          break;
        default:
          logger41.throwError("unsupported network", Logger.errors.INVALID_ARGUMENT, {
            argument: "network",
            value: network
          });
      }
      const url = `https://${host}/v1/lb/${apiKey.applicationId}`;
      const connection = { headers: {}, url };
      if (apiKey.applicationSecretKey != null) {
        connection.user = "";
        connection.password = apiKey.applicationSecretKey;
      }
      return connection;
    }
    isCommunityResource() {
      return this.applicationId === defaultApplicationId;
    }
  };

  // node_modules/@ethersproject/providers/lib.esm/web3-provider.js
  var logger42 = new Logger(version26);
  var _nextId = 1;
  function buildWeb3LegacyFetcher(provider, sendFunc) {
    const fetcher = "Web3LegacyFetcher";
    return function(method, params) {
      const request = {
        method,
        params,
        id: _nextId++,
        jsonrpc: "2.0"
      };
      return new Promise((resolve, reject) => {
        this.emit("debug", {
          action: "request",
          fetcher,
          request: deepCopy(request),
          provider: this
        });
        sendFunc(request, (error, response) => {
          if (error) {
            this.emit("debug", {
              action: "response",
              fetcher,
              error,
              request,
              provider: this
            });
            return reject(error);
          }
          this.emit("debug", {
            action: "response",
            fetcher,
            request,
            response,
            provider: this
          });
          if (response.error) {
            const error2 = new Error(response.error.message);
            error2.code = response.error.code;
            error2.data = response.error.data;
            return reject(error2);
          }
          resolve(response.result);
        });
      });
    };
  }
  function buildEip1193Fetcher(provider) {
    return function(method, params) {
      if (params == null) {
        params = [];
      }
      const request = { method, params };
      this.emit("debug", {
        action: "request",
        fetcher: "Eip1193Fetcher",
        request: deepCopy(request),
        provider: this
      });
      return provider.request(request).then((response) => {
        this.emit("debug", {
          action: "response",
          fetcher: "Eip1193Fetcher",
          request,
          response,
          provider: this
        });
        return response;
      }, (error) => {
        this.emit("debug", {
          action: "response",
          fetcher: "Eip1193Fetcher",
          request,
          error,
          provider: this
        });
        throw error;
      });
    };
  }
  var Web3Provider = class extends JsonRpcProvider2 {
    constructor(provider, network) {
      if (provider == null) {
        logger42.throwArgumentError("missing provider", "provider", provider);
      }
      let path = null;
      let jsonRpcFetchFunc = null;
      let subprovider = null;
      if (typeof provider === "function") {
        path = "unknown:";
        jsonRpcFetchFunc = provider;
      } else {
        path = provider.host || provider.path || "";
        if (!path && provider.isMetaMask) {
          path = "metamask";
        }
        subprovider = provider;
        if (provider.request) {
          if (path === "") {
            path = "eip-1193:";
          }
          jsonRpcFetchFunc = buildEip1193Fetcher(provider);
        } else if (provider.sendAsync) {
          jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));
        } else if (provider.send) {
          jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));
        } else {
          logger42.throwArgumentError("unsupported provider", "provider", provider);
        }
        if (!path) {
          path = "unknown:";
        }
      }
      super(path, network);
      defineReadOnly(this, "jsonRpcFetchFunc", jsonRpcFetchFunc);
      defineReadOnly(this, "provider", subprovider);
    }
    send(method, params) {
      return this.jsonRpcFetchFunc(method, params);
    }
  };

  // node_modules/@ethersproject/providers/lib.esm/index.js
  var logger43 = new Logger(version26);
  function getDefaultProvider(network, options2) {
    if (network == null) {
      network = "homestead";
    }
    if (typeof network === "string") {
      const match = network.match(/^(ws|http)s?:/i);
      if (match) {
        switch (match[1].toLowerCase()) {
          case "http":
          case "https":
            return new JsonRpcProvider2(network);
          case "ws":
          case "wss":
            return new WebSocketProvider(network);
          default:
            logger43.throwArgumentError("unsupported URL scheme", "network", network);
        }
      }
    }
    const n9 = getNetwork2(network);
    if (!n9 || !n9._defaultProvider) {
      logger43.throwError("unsupported getDefaultProvider network", Logger.errors.NETWORK_ERROR, {
        operation: "getDefaultProvider",
        network
      });
    }
    return n9._defaultProvider({
      FallbackProvider,
      AlchemyProvider,
      AnkrProvider,
      CloudflareProvider,
      EtherscanProvider,
      InfuraProvider,
      JsonRpcProvider: JsonRpcProvider2,
      NodesmithProvider,
      PocketProvider,
      Web3Provider,
      IpcProvider
    }, options2);
  }

  // node_modules/ethers/lib.esm/utils.js
  var utils_exports2 = {};
  __export(utils_exports2, {
    AbiCoder: () => AbiCoder,
    ConstructorFragment: () => ConstructorFragment,
    ErrorFragment: () => ErrorFragment,
    EventFragment: () => EventFragment,
    FormatTypes: () => FormatTypes,
    Fragment: () => Fragment,
    FunctionFragment: () => FunctionFragment,
    HDNode: () => HDNode,
    Indexed: () => Indexed,
    Interface: () => Interface,
    LogDescription: () => LogDescription,
    Logger: () => Logger,
    ParamType: () => ParamType,
    RLP: () => lib_exports,
    SigningKey: () => SigningKey,
    SupportedAlgorithm: () => SupportedAlgorithm,
    TransactionDescription: () => TransactionDescription,
    TransactionTypes: () => TransactionTypes,
    UnicodeNormalizationForm: () => UnicodeNormalizationForm,
    Utf8ErrorFuncs: () => Utf8ErrorFuncs,
    Utf8ErrorReason: () => Utf8ErrorReason,
    _TypedDataEncoder: () => TypedDataEncoder,
    _fetchData: () => _fetchData,
    _toEscapedUtf8String: () => _toEscapedUtf8String,
    accessListify: () => accessListify,
    arrayify: () => arrayify,
    base58: () => Base58,
    base64: () => lib_exports3,
    checkProperties: () => checkProperties,
    checkResultErrors: () => checkResultErrors,
    commify: () => commify,
    computeAddress: () => computeAddress,
    computeHmac: () => computeHmac,
    computePublicKey: () => computePublicKey,
    concat: () => concat3,
    deepCopy: () => deepCopy,
    defaultAbiCoder: () => defaultAbiCoder,
    defaultPath: () => defaultPath,
    defineReadOnly: () => defineReadOnly,
    dnsEncode: () => dnsEncode,
    entropyToMnemonic: () => entropyToMnemonic,
    fetchJson: () => fetchJson,
    formatBytes32String: () => formatBytes32String,
    formatEther: () => formatEther2,
    formatUnits: () => formatUnits2,
    getAccountPath: () => getAccountPath,
    getAddress: () => getAddress2,
    getContractAddress: () => getContractAddress3,
    getCreate2Address: () => getCreate2Address2,
    getIcapAddress: () => getIcapAddress,
    getJsonWalletAddress: () => getJsonWalletAddress,
    getStatic: () => getStatic,
    hashMessage: () => hashMessage2,
    hexConcat: () => hexConcat,
    hexDataLength: () => hexDataLength,
    hexDataSlice: () => hexDataSlice,
    hexStripZeros: () => hexStripZeros,
    hexValue: () => hexValue,
    hexZeroPad: () => hexZeroPad,
    hexlify: () => hexlify,
    id: () => id2,
    isAddress: () => isAddress2,
    isBytes: () => isBytes2,
    isBytesLike: () => isBytesLike,
    isHexString: () => isHexString,
    isValidMnemonic: () => isValidMnemonic,
    isValidName: () => isValidName,
    joinSignature: () => joinSignature,
    keccak256: () => keccak2562,
    mnemonicToEntropy: () => mnemonicToEntropy,
    mnemonicToSeed: () => mnemonicToSeed,
    namehash: () => namehash2,
    nameprep: () => nameprep,
    parseBytes32String: () => parseBytes32String,
    parseEther: () => parseEther2,
    parseTransaction: () => parse3,
    parseUnits: () => parseUnits2,
    poll: () => poll2,
    randomBytes: () => randomBytes2,
    recoverAddress: () => recoverAddress2,
    recoverPublicKey: () => recoverPublicKey2,
    resolveProperties: () => resolveProperties,
    ripemd160: () => ripemd160,
    serializeTransaction: () => serialize2,
    sha256: () => sha2562,
    sha512: () => sha5122,
    shallowCopy: () => shallowCopy,
    shuffled: () => shuffled,
    solidityKeccak256: () => keccak2563,
    solidityPack: () => pack2,
    soliditySha256: () => sha2563,
    splitSignature: () => splitSignature,
    stripZeros: () => stripZeros,
    toUtf8Bytes: () => toUtf8Bytes,
    toUtf8CodePoints: () => toUtf8CodePoints,
    toUtf8String: () => toUtf8String,
    verifyMessage: () => verifyMessage3,
    verifyTypedData: () => verifyTypedData3,
    zeroPad: () => zeroPad
  });

  // node_modules/@ethersproject/solidity/lib.esm/_version.js
  var version27 = "solidity/5.7.0";

  // node_modules/@ethersproject/solidity/lib.esm/index.js
  var regexBytes = new RegExp("^bytes([0-9]+)$");
  var regexNumber = new RegExp("^(u?int)([0-9]*)$");
  var regexArray = new RegExp("^(.*)\\[([0-9]*)\\]$");
  var Zeros2 = "0000000000000000000000000000000000000000000000000000000000000000";
  var logger44 = new Logger(version27);
  function _pack(type, value, isArray2) {
    switch (type) {
      case "address":
        if (isArray2) {
          return zeroPad(value, 32);
        }
        return arrayify(value);
      case "string":
        return toUtf8Bytes(value);
      case "bytes":
        return arrayify(value);
      case "bool":
        value = value ? "0x01" : "0x00";
        if (isArray2) {
          return zeroPad(value, 32);
        }
        return arrayify(value);
    }
    let match = type.match(regexNumber);
    if (match) {
      let size3 = parseInt(match[2] || "256");
      if (match[2] && String(size3) !== match[2] || size3 % 8 !== 0 || size3 === 0 || size3 > 256) {
        logger44.throwArgumentError("invalid number type", "type", type);
      }
      if (isArray2) {
        size3 = 256;
      }
      value = BigNumber.from(value).toTwos(size3);
      return zeroPad(value, size3 / 8);
    }
    match = type.match(regexBytes);
    if (match) {
      const size3 = parseInt(match[1]);
      if (String(size3) !== match[1] || size3 === 0 || size3 > 32) {
        logger44.throwArgumentError("invalid bytes type", "type", type);
      }
      if (arrayify(value).byteLength !== size3) {
        logger44.throwArgumentError(`invalid value for ${type}`, "value", value);
      }
      if (isArray2) {
        return arrayify((value + Zeros2).substring(0, 66));
      }
      return value;
    }
    match = type.match(regexArray);
    if (match && Array.isArray(value)) {
      const baseType = match[1];
      const count = parseInt(match[2] || String(value.length));
      if (count != value.length) {
        logger44.throwArgumentError(`invalid array length for ${type}`, "value", value);
      }
      const result = [];
      value.forEach(function(value2) {
        result.push(_pack(baseType, value2, true));
      });
      return concat3(result);
    }
    return logger44.throwArgumentError("invalid type", "type", type);
  }
  function pack2(types, values) {
    if (types.length != values.length) {
      logger44.throwArgumentError("wrong number of values; expected ${ types.length }", "values", values);
    }
    const tight = [];
    types.forEach(function(type, index2) {
      tight.push(_pack(type, values[index2]));
    });
    return hexlify(concat3(tight));
  }
  function keccak2563(types, values) {
    return keccak2562(pack2(types, values));
  }
  function sha2563(types, values) {
    return sha2562(pack2(types, values));
  }

  // node_modules/@ethersproject/units/lib.esm/_version.js
  var version28 = "units/5.7.0";

  // node_modules/@ethersproject/units/lib.esm/index.js
  var logger45 = new Logger(version28);
  var names = [
    "wei",
    "kwei",
    "mwei",
    "gwei",
    "szabo",
    "finney",
    "ether"
  ];
  function commify(value) {
    const comps = String(value).split(".");
    if (comps.length > 2 || !comps[0].match(/^-?[0-9]*$/) || comps[1] && !comps[1].match(/^[0-9]*$/) || value === "." || value === "-.") {
      logger45.throwArgumentError("invalid value", "value", value);
    }
    let whole = comps[0];
    let negative = "";
    if (whole.substring(0, 1) === "-") {
      negative = "-";
      whole = whole.substring(1);
    }
    while (whole.substring(0, 1) === "0") {
      whole = whole.substring(1);
    }
    if (whole === "") {
      whole = "0";
    }
    let suffix = "";
    if (comps.length === 2) {
      suffix = "." + (comps[1] || "0");
    }
    while (suffix.length > 2 && suffix[suffix.length - 1] === "0") {
      suffix = suffix.substring(0, suffix.length - 1);
    }
    const formatted = [];
    while (whole.length) {
      if (whole.length <= 3) {
        formatted.unshift(whole);
        break;
      } else {
        const index2 = whole.length - 3;
        formatted.unshift(whole.substring(index2));
        whole = whole.substring(0, index2);
      }
    }
    return negative + formatted.join(",") + suffix;
  }
  function formatUnits2(value, unitName) {
    if (typeof unitName === "string") {
      const index2 = names.indexOf(unitName);
      if (index2 !== -1) {
        unitName = 3 * index2;
      }
    }
    return formatFixed(value, unitName != null ? unitName : 18);
  }
  function parseUnits2(value, unitName) {
    if (typeof value !== "string") {
      logger45.throwArgumentError("value must be a string", "value", value);
    }
    if (typeof unitName === "string") {
      const index2 = names.indexOf(unitName);
      if (index2 !== -1) {
        unitName = 3 * index2;
      }
    }
    return parseFixed(value, unitName != null ? unitName : 18);
  }
  function formatEther2(wei) {
    return formatUnits2(wei, 18);
  }
  function parseEther2(ether) {
    return parseUnits2(ether, 18);
  }

  // node_modules/ethers/lib.esm/_version.js
  var version29 = "ethers/5.7.2";

  // node_modules/ethers/lib.esm/ethers.js
  var logger46 = new Logger(version29);

  // node_modules/ethers/lib.esm/index.js
  try {
    const anyGlobal2 = window;
    if (anyGlobal2._ethers == null) {
      anyGlobal2._ethers = ethers_exports;
    }
  } catch (error) {
  }

  // src/helpers/parse-keys.ts
  function parseKeys(payload) {
    try {
      const primaryPublicKeyLength = parseInt("0x" + payload.slice(0, 2)) * 2;
      const primaryPublicKeyRaw = payload.slice(2, primaryPublicKeyLength + 2);
      const primaryPublicKeyHash = ethers_exports.utils.sha256("0x" + primaryPublicKeyRaw.slice(2));
      const secondaryPublicKeyLength = parseInt("0x" + payload.slice(primaryPublicKeyLength + 2, primaryPublicKeyLength + 4)) * 2;
      const secondaryPublicKeyRaw = payload.slice(
        primaryPublicKeyLength + 4,
        primaryPublicKeyLength + secondaryPublicKeyLength + 4
      );
      const secondaryPublicKeyHash = ethers_exports.utils.sha256("0x" + secondaryPublicKeyRaw.slice(2));
      const tertiaryPublicKeyLength = parseInt(
        "0x" + payload.slice(
          primaryPublicKeyLength + secondaryPublicKeyLength + 4,
          primaryPublicKeyLength + secondaryPublicKeyLength + 6
        )
      ) * 2;
      let tertiaryPublicKeyRaw = "";
      let tertiaryPublicKeyHash = "";
      if (tertiaryPublicKeyLength > 0) {
        tertiaryPublicKeyRaw = payload.slice(
          primaryPublicKeyLength + secondaryPublicKeyLength + 6,
          primaryPublicKeyLength + secondaryPublicKeyLength + tertiaryPublicKeyLength + 6
        );
        tertiaryPublicKeyHash = ethers_exports.utils.sha256("0x" + tertiaryPublicKeyRaw.slice(2));
      }
      const keys2 = {
        primaryPublicKeyHash,
        primaryPublicKeyRaw,
        secondaryPublicKeyHash,
        secondaryPublicKeyRaw,
        tertiaryPublicKeyHash,
        tertiaryPublicKeyRaw
      };
      return keys2;
    } catch (err) {
      return false;
    }
  }

  // src/helpers/generate-arweave-query.ts
  function generateArweaveQuery(keys2) {
    return `
  query {
      transactions(
          tags: [{
              name: "App-Name",
              values: ["ERS"]
          },{
              name: "Device-Id",
              values: ["${keys2.primaryPublicKeyHash}"]
          },{
              name: "Device-Record-Type",
              values: ["Device-Create", "Device-Media"]
          }
      ]
      ) {
          edges {
              cursor
              node {
              id
              tags {
                  name
                  value
              }
              block {
                  id
                  timestamp
                  height
              }
              }
          }
      }
  }
  `;
  }

  // src/constants.ts
  var ARWEAVE_GRAPHQL = "https://arweave.net/graphql";
  var TAG_DOMAIN = window.location.host;
  var ARWEAVE_NODE = "https://arweave.net";
  var REACT_APP_INFURA_PROJECT_ID = "273c16c48360429b910360f9a0591015";
  var WC_PROJECT = "b37b0256619f642e4ce39ed8df18668d";

  // src/helpers/safe-tag.ts
  function safeTag(node, tagName, defaultValue) {
    const tag = node.tags.find((tag2) => tag2.name === tagName);
    return tag ? tag.value : defaultValue;
  }

  // src/helpers/from-hex-string.ts
  function fromHexString(hexString) {
    return new Uint8Array(hexString.match(/.{1,2}/g).map((byte) => parseInt(byte, 16)));
  }

  // src/helpers/buff-to-hex.ts
  function buf2hex(buffer2) {
    return [...new Uint8Array(buffer2)].map((x4) => x4.toString(16).padStart(2, "0")).join("");
  }

  // src/stores/applicationStore.tsx
  var applicationStore = create2((set2) => ({
    /*
      Global
    */
    loading: true,
    /*
      Wallet
    */
    walletAddress: "",
    walletChainId: 1,
    walletReady: false,
    walletDropdownActive: false,
    walletConnected: false,
    walletConnect: (walletAddress, walletChainId) => {
      console.log(walletChainId);
      set2({ walletAddress, walletChainId, walletConnected: true });
    },
    walletDisconnect: async () => {
      set2({ walletAddress: "", walletChainId: 1, walletConnected: false });
    },
    walletSetReady: () => {
      set2({ walletReady: true });
    },
    walletSetDropdownActive: (walletDropdownActive) => {
      set2({ walletDropdownActive });
    },
    /*
      Devise
    */
    device: {
      node_id: "",
      app_name: "",
      app_version: "",
      content_type: "",
      device_record_type: "",
      device_id: "",
      device_token_metadata: "",
      device_address: "",
      device_manufacturer: "",
      device_model: "",
      device_merkel_root: "",
      device_minter: "",
      device_registry: "",
      ifps_add: "",
      chain_id: ""
    },
    deviceKeys: {
      primaryPublicKeyHash: "",
      primaryPublicKeyRaw: "",
      secondaryPublicKeyHash: "",
      secondaryPublicKeyRaw: "",
      tertiaryPublicKeyHash: "",
      tertiaryPublicKeyRaw: ""
    },
    deviceInit: () => {
      const url = new import_url_parse.default(window.location.href, true);
      if (url.query.static) {
        const deviceKeys = parseKeys(url.query.static);
        if (deviceKeys !== false) {
          set2({ deviceKeys });
          applicationStore.getState().deviceRetrieve();
        } else {
          set2({ loading: false });
        }
      } else {
        set2({ loading: false });
      }
    },
    deviceRetrieve: () => {
      const { deviceKeys } = applicationStore.getState();
      const query = generateArweaveQuery(deviceKeys);
      axios_default.post(ARWEAVE_GRAPHQL, { query }).then(async (res) => {
        const transactions = res.data.data.transactions.edges;
        const transactionIndex = transactions.findIndex((t6) => {
          const tag = t6.node.tags.find((tag2) => {
            return tag2.name === "Device-Record-Type";
          });
          if (tag && tag.value === "Device-Media") {
            return true;
          }
        });
        const tIndex = transactionIndex > -1 ? transactionIndex : 0;
        const mapped = [transactions[tIndex || 0]].flatMap((nodeItem) => {
          const node = nodeItem.node;
          return {
            node_id: node.id,
            app_name: safeTag(node, "App-Name", null),
            app_version: safeTag(node, "App-Version", null),
            content_type: safeTag(node, "Content-Type", null),
            device_record_type: safeTag(node, "Device-Record-Type", null),
            device_id: safeTag(node, "Device-Id", null),
            device_address: safeTag(node, "Device-Address", null),
            device_manufacturer: safeTag(node, "Device-Manufacturer", null),
            device_model: safeTag(node, "Device-Model", null),
            device_merkel_root: safeTag(node, "Device-Merkel-Root", null),
            device_registry: safeTag(node, "Device-Registry", null),
            ifps_add: safeTag(node, "IPFS-Add", null),
            device_token_metadata: safeTag(node, "Device-Token-Metadata", null),
            device_minter: safeTag(node, "Device-Minter", null),
            chain_id: safeTag(node, "Device-Minter-Chain-Id", null)
          };
        });
        set2({ device: mapped[0], loading: false });
      }).catch((err) => {
        set2({ loading: false });
      });
    },
    deviceTriggerScan: async () => {
      try {
        const req = {
          publicKey: {
            allowCredentials: [
              {
                id: fromHexString("02"),
                transports: ["nfc"],
                type: "public-key"
              }
            ],
            challenge: new Uint8Array([
              113,
              241,
              176,
              49,
              249,
              113,
              39,
              237,
              135,
              170,
              177,
              61,
              15,
              14,
              105,
              236,
              120,
              140,
              4,
              41,
              65,
              225,
              107,
              63,
              214,
              129,
              133,
              223,
              169,
              200,
              21,
              88
            ]),
            rpId: TAG_DOMAIN,
            timeout: 6e4,
            userVerification: "discouraged"
          }
        };
        const xdd = await navigator.credentials.get(req);
        const signature2 = xdd?.response.signature;
        const deviceKeys = parseKeys(buf2hex(signature2));
        if (deviceKeys) {
          set2({ deviceKeys });
          applicationStore.getState().deviceRetrieve();
        }
      } catch (err) {
        console.log("in heree");
      }
    }
  }));
  var applicationStore_default = applicationStore;

  // src/components/HeaderConnect.tsx
  var import_react5 = __toESM(require_react());
  function HeaderConnect() {
    const { open } = ne6();
    return /* @__PURE__ */ import_react5.default.createElement("button", { className: "header-connect", onClick: () => open() }, "Connect wallet");
  }

  // src/components/HeaderWallet.tsx
  var import_react7 = __toESM(require_react());
  var import_classnames = __toESM(require_classnames());

  // src/helpers/truncate-address.ts
  function truncateAddress(address) {
    const firstSix = address.slice(0, 5);
    const lastFour = address.substring(address.length - 4);
    const together = firstSix + ".." + lastFour;
    return together;
  }

  // src/svg/ChevronUp.tsx
  var import_react6 = __toESM(require_react());
  function ChevronUp() {
    return /* @__PURE__ */ import_react6.default.createElement("svg", { width: "6", viewBox: "0 0 6 4", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ import_react6.default.createElement("path", { d: "M5 3L3 1L1 3", stroke: "currentColor", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" }));
  }

  // src/components/HeaderWallet.tsx
  function HeaderWallet() {
    const { address } = useAccount();
    const setActive = applicationStore_default((s7) => s7.walletSetDropdownActive);
    const { disconnect: disconnect2 } = useDisconnect();
    const active = applicationStore_default((s7) => s7.walletDropdownActive);
    const truncatedAddress = truncateAddress(address);
    return /* @__PURE__ */ import_react7.default.createElement("div", { className: (0, import_classnames.default)("wallet-dropdown-wrap", { active }), onClick: () => setActive(false) }, /* @__PURE__ */ import_react7.default.createElement("div", { className: "header-wallet-dropdown-overlay" }), /* @__PURE__ */ import_react7.default.createElement("div", { className: "header-wallet-dropdown", onClick: (e9) => e9.stopPropagation() }, /* @__PURE__ */ import_react7.default.createElement(
      "button",
      {
        className: "header-wallet-button",
        onClick: (e9) => {
          e9.stopPropagation();
          setActive(!active);
        }
      },
      truncatedAddress,
      /* @__PURE__ */ import_react7.default.createElement(ChevronUp, null)
    ), /* @__PURE__ */ import_react7.default.createElement("div", { className: "header-wallet-dropdown-dropdown" }, /* @__PURE__ */ import_react7.default.createElement("span", { className: "header-wallet-dropdown-wallet-link" }, /* @__PURE__ */ import_react7.default.createElement("span", { className: "header-wallet-dropdown-wallet-link-indicator" }), /* @__PURE__ */ import_react7.default.createElement("span", { className: "header-wallet-dropdown-wallet-link-address" }, truncatedAddress)), /* @__PURE__ */ import_react7.default.createElement("button", { onClick: () => disconnect2(), className: "header-wallet-dropdown-wallet-disconnect" }, "Disconnect"))));
  }

  // src/components/Header.tsx
  function Header() {
    const settings = window.HALO_SETTINGS;
    const { address, isConnected, isDisconnected } = useAccount();
    const { chain } = useNetwork();
    const disconnect2 = applicationStore_default((s7) => s7.walletDisconnect);
    const connect2 = applicationStore_default((s7) => s7.walletConnect);
    import_react8.default.useEffect(() => {
      if (isConnected && address) {
        connect2(address, chain?.id || 1);
      }
      if (isDisconnected) {
        disconnect2();
      }
    }, [address, isConnected, isDisconnected]);
    return /* @__PURE__ */ import_react8.default.createElement("header", { className: "header" }, /* @__PURE__ */ import_react8.default.createElement("img", { src: settings.logo, alt: "logo" }), isConnected ? /* @__PURE__ */ import_react8.default.createElement(HeaderWallet, null) : /* @__PURE__ */ import_react8.default.createElement(HeaderConnect, null), " ");
  }

  // src/components/Footer.tsx
  var import_react10 = __toESM(require_react());

  // src/svg/Ers.tsx
  var import_react9 = __toESM(require_react());
  function Ers() {
    return /* @__PURE__ */ import_react9.default.createElement("svg", { width: "35", height: "32", viewBox: "0 0 35 32", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, /* @__PURE__ */ import_react9.default.createElement("mask", { id: "ers-mask", fill: "currentColor" }, /* @__PURE__ */ import_react9.default.createElement("path", { d: "M23.0863 1.06627e-07C25.3442 1.28166e-07 27.4306 1.20458 28.5595 3.15998L34.1483 12.84C35.2772 14.7954 35.2772 17.2046 34.1483 19.16L28.5595 28.84C27.4306 30.7954 25.3442 32 23.0863 32H11.9087C9.65083 32 7.56444 30.7954 6.43548 28.84L0.846715 19.16C-0.282238 17.2046 -0.282239 14.7954 0.846714 12.84L6.43548 3.15998C7.56444 1.20458 9.65083 -2.1539e-08 11.9087 0L23.0863 1.06627e-07Z" })), /* @__PURE__ */ import_react9.default.createElement(
      "path",
      {
        d: "M6.43548 3.15998L7.30151 3.65998V3.65998L6.43548 3.15998ZM11.9087 0V1V0ZM0.846715 19.16L1.71274 18.66L0.846715 19.16ZM0.846714 12.84L-0.0193111 12.34H-0.0193111L0.846714 12.84ZM11.9087 32V31V32ZM6.43548 28.84L5.56946 29.34L6.43548 28.84ZM28.5595 28.84L29.4256 29.34L28.5595 28.84ZM23.0863 32V33H23.0863L23.0863 32ZM34.1483 12.84L33.2823 13.34L34.1483 12.84ZM34.1483 19.16L33.2823 18.66L34.1483 19.16ZM28.5595 3.15998L29.4256 2.65998L28.5595 3.15998ZM23.0863 1.06627e-07L23.0863 -1L23.0863 1.06627e-07ZM27.6935 3.65998L33.2823 13.34L35.0143 12.34L29.4256 2.65998L27.6935 3.65998ZM33.2823 18.66L27.6935 28.34L29.4256 29.34L35.0143 19.66L33.2823 18.66ZM23.0863 31H11.9087V33H23.0863V31ZM7.30151 28.34L1.71274 18.66L-0.0193102 19.66L5.56946 29.34L7.30151 28.34ZM1.71274 13.34L7.30151 3.65998L5.56946 2.65998L-0.0193111 12.34L1.71274 13.34ZM11.9087 1L23.0863 1L23.0863 -1L11.9087 -1V1ZM7.30151 3.65998C8.25183 2.01398 10.0081 1 11.9087 1V-1C9.29356 -1 6.87704 0.395179 5.56946 2.65998L7.30151 3.65998ZM1.71274 18.66C0.76242 17.014 0.76242 14.986 1.71274 13.34L-0.0193111 12.34C-1.3269 14.6048 -1.3269 17.3952 -0.0193102 19.66L1.71274 18.66ZM11.9087 31C10.0081 31 8.25183 29.986 7.30151 28.34L5.56946 29.34C6.87704 31.6048 9.29357 33 11.9087 33V31ZM27.6935 28.34C26.7432 29.986 24.9869 31 23.0863 31L23.0863 33C25.7014 33 28.118 31.6048 29.4256 29.34L27.6935 28.34ZM33.2823 13.34C34.2326 14.986 34.2326 17.014 33.2823 18.66L35.0143 19.66C36.3219 17.3952 36.3219 14.6048 35.0143 12.34L33.2823 13.34ZM29.4256 2.65998C28.118 0.395177 25.7014 -1 23.0863 -1L23.0863 1C24.9869 1 26.7432 2.01398 27.6935 3.65998L29.4256 2.65998Z",
        fill: "currentColor",
        mask: "url(#ers-mask)"
      }
    ), /* @__PURE__ */ import_react9.default.createElement(
      "path",
      {
        d: "M13.6552 20V18.92H9.41924V16.22H12.9112V15.14H9.41924V12.68H13.5352V11.6H8.21924V20H13.6552Z",
        fill: "currentColor"
      }
    ), /* @__PURE__ */ import_react9.default.createElement(
      "path",
      {
        d: "M19.0146 15.932C19.8666 15.596 20.3586 14.876 20.3586 13.856C20.3586 12.548 19.2426 11.6 17.7786 11.6H14.8626V20H16.0626V16.628H18.3906C18.8586 16.628 19.0386 16.808 19.0386 17.276V20H20.2386V17.084C20.2386 16.328 19.9026 15.932 19.0746 15.932H19.0146ZM16.0626 15.548V12.68H17.5026C18.5586 12.68 19.1586 13.172 19.1586 14.072C19.1586 14.996 18.4626 15.548 17.5026 15.548H16.0626Z",
        fill: "currentColor"
      }
    ), /* @__PURE__ */ import_react9.default.createElement(
      "path",
      {
        d: "M24.1699 20.12C26.0539 20.12 27.1699 19.076 27.1699 17.648C27.1699 16.34 26.3779 15.62 24.9859 15.332L23.7739 15.08C22.9339 14.912 22.5619 14.576 22.5619 13.916C22.5619 13.16 23.2339 12.56 24.2539 12.56H24.3019C25.3339 12.56 26.0419 13.148 26.1019 14.144H27.3019C27.2659 12.572 26.1859 11.48 24.2899 11.48C22.4539 11.48 21.3619 12.632 21.3619 13.94C21.3619 15.176 22.0099 15.92 23.4259 16.22L24.7579 16.508C25.6219 16.688 25.9699 17.084 25.9699 17.72C25.9699 18.44 25.3939 19.04 24.2899 19.04H24.2299C22.9459 19.04 22.2019 18.488 22.1419 17.276H20.9419C20.9779 18.968 21.9859 20.12 24.1699 20.12Z",
        fill: "currentColor"
      }
    ));
  }

  // src/components/Footer.tsx
  function Footer() {
    return /* @__PURE__ */ import_react10.default.createElement("footer", { className: "footer" }, /* @__PURE__ */ import_react10.default.createElement(Ers, null), /* @__PURE__ */ import_react10.default.createElement("p", null, "Verified by ERS"));
  }

  // src/components/Wrapper.tsx
  var import_react11 = __toESM(require_react());
  function Wrapper({ children }) {
    return /* @__PURE__ */ import_react11.default.createElement("div", { className: "wrapper" }, children);
  }

  // src/components/Content.tsx
  var import_react16 = __toESM(require_react());

  // src/helpers/get-chain-data.ts
  var SUPPORTED_CHAINS = [
    {
      name: "Ethereum Mainnet",
      short_name: "eth",
      chain: "ETH",
      network: "mainnet",
      chain_id: 1,
      network_id: 1,
      explorer: "https://etherscan.io/address",
      rpc_url: "https://mainnet.infura.io/v3/%API_KEY%",
      native_currency: {
        symbol: "ETH",
        name: "Ether",
        decimals: "18",
        contractAddress: "",
        balance: ""
      }
    },
    {
      name: "Ethereum Ropsten",
      short_name: "rop",
      chain: "ETH",
      network: "ropsten",
      chain_id: 3,
      network_id: 3,
      explorer: "",
      rpc_url: "https://ropsten.infura.io/v3/%API_KEY%",
      native_currency: {
        symbol: "ETH",
        name: "Ether",
        decimals: "18",
        contractAddress: "",
        balance: ""
      }
    },
    {
      name: "Ethereum Rinkeby",
      short_name: "rin",
      chain: "ETH",
      network: "rinkeby",
      chain_id: 4,
      network_id: 4,
      explorer: "",
      rpc_url: "https://rinkeby.infura.io/v3/%API_KEY%",
      native_currency: {
        symbol: "ETH",
        name: "Ether",
        decimals: "18",
        contractAddress: "",
        balance: ""
      }
    },
    {
      name: "Ethereum G\xF6rli",
      short_name: "gor",
      chain: "ETH",
      network: "goerli",
      chain_id: 5,
      network_id: 5,
      explorer: "",
      rpc_url: "https://goerli.infura.io/v3/%API_KEY%",
      native_currency: {
        symbol: "ETH",
        name: "Ether",
        decimals: "18",
        contractAddress: "",
        balance: ""
      }
    },
    {
      name: "RSK Mainnet",
      short_name: "rsk",
      chain: "RSK",
      network: "mainnet",
      chain_id: 30,
      network_id: 30,
      explorer: "",
      rpc_url: "https://public-node.rsk.co",
      native_currency: {
        symbol: "RSK",
        name: "RSK",
        decimals: "18",
        contractAddress: "",
        balance: ""
      }
    },
    {
      name: "Ethereum Kovan",
      short_name: "kov",
      chain: "ETH",
      network: "kovan",
      chain_id: 42,
      network_id: 42,
      explorer: "",
      rpc_url: "https://kovan.infura.io/v3/%API_KEY%",
      native_currency: {
        symbol: "ETH",
        name: "Ether",
        decimals: "18",
        contractAddress: "",
        balance: ""
      }
    },
    {
      name: "Ethereum Classic Mainnet",
      short_name: "etc",
      chain: "ETC",
      network: "mainnet",
      chain_id: 61,
      network_id: 1,
      explorer: "",
      rpc_url: "https://ethereumclassic.network",
      native_currency: {
        symbol: "ETH",
        name: "Ether Classic",
        decimals: "18",
        contractAddress: "",
        balance: ""
      }
    },
    {
      name: "POA Network Sokol",
      short_name: "poa",
      chain: "POA",
      network: "sokol",
      chain_id: 77,
      network_id: 77,
      explorer: "",
      rpc_url: "https://sokol.poa.network",
      native_currency: {
        symbol: "POA",
        name: "POA",
        decimals: "18",
        contractAddress: "",
        balance: ""
      }
    },
    {
      name: "POA Network Core",
      short_name: "skl",
      chain: "POA",
      network: "core",
      chain_id: 99,
      network_id: 99,
      explorer: "",
      rpc_url: "https://core.poa.network",
      native_currency: {
        symbol: "POA",
        name: "POA",
        decimals: "18",
        contractAddress: "",
        balance: ""
      }
    },
    {
      name: "xDAI Chain",
      short_name: "xdai",
      chain: "POA",
      network: "dai",
      chain_id: 100,
      network_id: 100,
      explorer: "",
      rpc_url: "https://dai.poa.network",
      native_currency: {
        symbol: "xDAI",
        name: "xDAI",
        decimals: "18",
        contractAddress: "",
        balance: ""
      }
    },
    {
      name: "Callisto Mainnet",
      short_name: "clo",
      chain: "callisto",
      network: "mainnet",
      chain_id: 820,
      network_id: 1,
      explorer: "",
      rpc_url: "https://clo-geth.0xinfra.com/",
      native_currency: {
        symbol: "CLO",
        name: "CLO",
        decimals: "18",
        contractAddress: "",
        balance: ""
      }
    },
    {
      name: "Polygon Testnet Mumbai",
      chain: "Polygon",
      network: "mumbai",
      explorer: "",
      rpc_url: "https://rpc-mumbai.maticvigil.com",
      native_currency: {
        name: "MATIC",
        symbol: "MATIC",
        decimals: "18",
        contractAddress: "",
        balance: ""
      },
      short_name: "maticmum",
      chain_id: 80001,
      network_id: 80001
    },
    {
      name: "Polygon Mainnet",
      chain: "Polygon",
      network: "mainnet",
      explorer: "",
      rpc_url: "https://rpc-mainnet.maticvigil.com",
      native_currency: {
        name: "MATIC",
        symbol: "MATIC",
        decimals: "18",
        contractAddress: "",
        balance: ""
      },
      short_name: "MATIC",
      chain_id: 137,
      network_id: 137
    },
    {
      name: "Avalanche Fuji Testnet",
      chain: "AVAX",
      network: "fuji",
      explorer: "",
      rpc_url: "https://api.avax-test.network/ext/bc/C/rpc",
      native_currency: {
        name: "Avalanche",
        symbol: "AVAX",
        decimals: "18",
        contractAddress: "",
        balance: ""
      },
      short_name: "Fuji",
      chain_id: 43113,
      network_id: 1
    },
    {
      name: "Avalanche Mainnet",
      chain: "AVAX",
      network: "mainnet",
      explorer: "",
      rpc_url: "https://api.avax.network/ext/bc/C/rpc",
      native_currency: {
        name: "Avalanche",
        symbol: "AVAX",
        decimals: "18",
        contractAddress: "",
        balance: ""
      },
      short_name: "Avalanche",
      chain_id: 43114,
      network_id: 43114
    },
    {
      name: "Arbitrum One",
      chain_id: 42161,
      network_id: 42161,
      network: "mainnet",
      short_name: "arb1",
      chain: "ETH",
      native_currency: {
        name: "Ether",
        symbol: "AETH",
        decimals: "18",
        contractAddress: "",
        balance: ""
      },
      explorer: "",
      rpc_url: "https://arbitrum-mainnet.infura.io/v3/%API_KEY%"
    },
    {
      name: "Optimism",
      chain: "ETH",
      explorer: "",
      rpc_url: "https://mainnet.optimism.io/",
      network: "mainnet",
      native_currency: {
        name: "Ether",
        symbol: "OETH",
        decimals: "18",
        contractAddress: "",
        balance: ""
      },
      short_name: "oeth",
      chain_id: 10,
      network_id: 10
    }
  ];
  function getChainData(chainId) {
    const chainData = SUPPORTED_CHAINS.filter((chain) => chain.chain_id === chainId)[0];
    if (!chainData) {
      throw new Error("ChainId missing or not supported");
    }
    const API_KEY = REACT_APP_INFURA_PROJECT_ID;
    if (chainData.rpc_url.includes("infura.io") && chainData.rpc_url.includes("%API_KEY%") && API_KEY) {
      const rpcUrl = chainData.rpc_url.replace("%API_KEY%", API_KEY);
      return {
        ...chainData,
        rpc_url: rpcUrl
      };
    }
    return chainData;
  }

  // src/components/Card.tsx
  var import_react12 = __toESM(require_react());
  var import_classnames2 = __toESM(require_classnames());
  function Card({ children, className }) {
    return /* @__PURE__ */ import_react12.default.createElement("div", { className: (0, import_classnames2.default)("card", className) }, children);
  }

  // src/components/CardPadding.tsx
  var import_react13 = __toESM(require_react());
  var import_classnames3 = __toESM(require_classnames());
  function CardPadding({ children, className }) {
    return /* @__PURE__ */ import_react13.default.createElement("div", { className: (0, import_classnames3.default)("card-padding", className) }, children);
  }

  // src/components/ContentDetail.tsx
  var import_react14 = __toESM(require_react());
  var import_classnames4 = __toESM(require_classnames());
  function ContentDetail({ children, className, title }) {
    return /* @__PURE__ */ import_react14.default.createElement("div", { className: (0, import_classnames4.default)("content-detail", className) }, /* @__PURE__ */ import_react14.default.createElement("h2", null, title), /* @__PURE__ */ import_react14.default.createElement("p", null, children));
  }

  // src/components/Divider.tsx
  var import_react15 = __toESM(require_react());
  var import_classnames5 = __toESM(require_classnames());
  function Divider({ className }) {
    return /* @__PURE__ */ import_react15.default.createElement("div", { className: (0, import_classnames5.default)("divider", className) });
  }

  // node_modules/marked/lib/marked.esm.js
  function getDefaults() {
    return {
      async: false,
      baseUrl: null,
      breaks: false,
      extensions: null,
      gfm: true,
      headerIds: true,
      headerPrefix: "",
      highlight: null,
      hooks: null,
      langPrefix: "language-",
      mangle: true,
      pedantic: false,
      renderer: null,
      sanitize: false,
      sanitizer: null,
      silent: false,
      smartypants: false,
      tokenizer: null,
      walkTokens: null,
      xhtml: false
    };
  }
  var defaults3 = getDefaults();
  function changeDefaults(newDefaults) {
    defaults3 = newDefaults;
  }
  var escapeTest = /[&<>"']/;
  var escapeReplace = new RegExp(escapeTest.source, "g");
  var escapeTestNoEncode = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/;
  var escapeReplaceNoEncode = new RegExp(escapeTestNoEncode.source, "g");
  var escapeReplacements = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;"
  };
  var getEscapeReplacement = (ch) => escapeReplacements[ch];
  function escape(html, encode10) {
    if (encode10) {
      if (escapeTest.test(html)) {
        return html.replace(escapeReplace, getEscapeReplacement);
      }
    } else {
      if (escapeTestNoEncode.test(html)) {
        return html.replace(escapeReplaceNoEncode, getEscapeReplacement);
      }
    }
    return html;
  }
  var unescapeTest = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig;
  function unescape2(html) {
    return html.replace(unescapeTest, (_8, n9) => {
      n9 = n9.toLowerCase();
      if (n9 === "colon")
        return ":";
      if (n9.charAt(0) === "#") {
        return n9.charAt(1) === "x" ? String.fromCharCode(parseInt(n9.substring(2), 16)) : String.fromCharCode(+n9.substring(1));
      }
      return "";
    });
  }
  var caret = /(^|[^\[])\^/g;
  function edit(regex, opt) {
    regex = typeof regex === "string" ? regex : regex.source;
    opt = opt || "";
    const obj = {
      replace: (name2, val) => {
        val = val.source || val;
        val = val.replace(caret, "$1");
        regex = regex.replace(name2, val);
        return obj;
      },
      getRegex: () => {
        return new RegExp(regex, opt);
      }
    };
    return obj;
  }
  var nonWordAndColonTest = /[^\w:]/g;
  var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
  function cleanUrl(sanitize, base4, href) {
    if (sanitize) {
      let prot;
      try {
        prot = decodeURIComponent(unescape2(href)).replace(nonWordAndColonTest, "").toLowerCase();
      } catch (e9) {
        return null;
      }
      if (prot.indexOf("javascript:") === 0 || prot.indexOf("vbscript:") === 0 || prot.indexOf("data:") === 0) {
        return null;
      }
    }
    if (base4 && !originIndependentUrl.test(href)) {
      href = resolveUrl(base4, href);
    }
    try {
      href = encodeURI(href).replace(/%25/g, "%");
    } catch (e9) {
      return null;
    }
    return href;
  }
  var baseUrls = {};
  var justDomain = /^[^:]+:\/*[^/]*$/;
  var protocol = /^([^:]+:)[\s\S]*$/;
  var domain = /^([^:]+:\/*[^/]*)[\s\S]*$/;
  function resolveUrl(base4, href) {
    if (!baseUrls[" " + base4]) {
      if (justDomain.test(base4)) {
        baseUrls[" " + base4] = base4 + "/";
      } else {
        baseUrls[" " + base4] = rtrim(base4, "/", true);
      }
    }
    base4 = baseUrls[" " + base4];
    const relativeBase = base4.indexOf(":") === -1;
    if (href.substring(0, 2) === "//") {
      if (relativeBase) {
        return href;
      }
      return base4.replace(protocol, "$1") + href;
    } else if (href.charAt(0) === "/") {
      if (relativeBase) {
        return href;
      }
      return base4.replace(domain, "$1") + href;
    } else {
      return base4 + href;
    }
  }
  var noopTest = { exec: function noopTest2() {
  } };
  function splitCells(tableRow, count) {
    const row = tableRow.replace(/\|/g, (match, offset, str) => {
      let escaped = false, curr = offset;
      while (--curr >= 0 && str[curr] === "\\")
        escaped = !escaped;
      if (escaped) {
        return "|";
      } else {
        return " |";
      }
    }), cells = row.split(/ \|/);
    let i7 = 0;
    if (!cells[0].trim()) {
      cells.shift();
    }
    if (cells.length > 0 && !cells[cells.length - 1].trim()) {
      cells.pop();
    }
    if (cells.length > count) {
      cells.splice(count);
    } else {
      while (cells.length < count)
        cells.push("");
    }
    for (; i7 < cells.length; i7++) {
      cells[i7] = cells[i7].trim().replace(/\\\|/g, "|");
    }
    return cells;
  }
  function rtrim(str, c9, invert) {
    const l9 = str.length;
    if (l9 === 0) {
      return "";
    }
    let suffLen = 0;
    while (suffLen < l9) {
      const currChar = str.charAt(l9 - suffLen - 1);
      if (currChar === c9 && !invert) {
        suffLen++;
      } else if (currChar !== c9 && invert) {
        suffLen++;
      } else {
        break;
      }
    }
    return str.slice(0, l9 - suffLen);
  }
  function findClosingBracket(str, b7) {
    if (str.indexOf(b7[1]) === -1) {
      return -1;
    }
    const l9 = str.length;
    let level = 0, i7 = 0;
    for (; i7 < l9; i7++) {
      if (str[i7] === "\\") {
        i7++;
      } else if (str[i7] === b7[0]) {
        level++;
      } else if (str[i7] === b7[1]) {
        level--;
        if (level < 0) {
          return i7;
        }
      }
    }
    return -1;
  }
  function checkSanitizeDeprecation(opt) {
    if (opt && opt.sanitize && !opt.silent) {
      console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options");
    }
  }
  function repeatString(pattern, count) {
    if (count < 1) {
      return "";
    }
    let result = "";
    while (count > 1) {
      if (count & 1) {
        result += pattern;
      }
      count >>= 1;
      pattern += pattern;
    }
    return result + pattern;
  }
  function outputLink(cap, link, raw, lexer2) {
    const href = link.href;
    const title = link.title ? escape(link.title) : null;
    const text = cap[1].replace(/\\([\[\]])/g, "$1");
    if (cap[0].charAt(0) !== "!") {
      lexer2.state.inLink = true;
      const token = {
        type: "link",
        raw,
        href,
        title,
        text,
        tokens: lexer2.inlineTokens(text)
      };
      lexer2.state.inLink = false;
      return token;
    }
    return {
      type: "image",
      raw,
      href,
      title,
      text: escape(text)
    };
  }
  function indentCodeCompensation(raw, text) {
    const matchIndentToCode = raw.match(/^(\s+)(?:```)/);
    if (matchIndentToCode === null) {
      return text;
    }
    const indentToCode = matchIndentToCode[1];
    return text.split("\n").map((node) => {
      const matchIndentInNode = node.match(/^\s+/);
      if (matchIndentInNode === null) {
        return node;
      }
      const [indentInNode] = matchIndentInNode;
      if (indentInNode.length >= indentToCode.length) {
        return node.slice(indentToCode.length);
      }
      return node;
    }).join("\n");
  }
  var Tokenizer = class {
    constructor(options2) {
      this.options = options2 || defaults3;
    }
    space(src2) {
      const cap = this.rules.block.newline.exec(src2);
      if (cap && cap[0].length > 0) {
        return {
          type: "space",
          raw: cap[0]
        };
      }
    }
    code(src2) {
      const cap = this.rules.block.code.exec(src2);
      if (cap) {
        const text = cap[0].replace(/^ {1,4}/gm, "");
        return {
          type: "code",
          raw: cap[0],
          codeBlockStyle: "indented",
          text: !this.options.pedantic ? rtrim(text, "\n") : text
        };
      }
    }
    fences(src2) {
      const cap = this.rules.block.fences.exec(src2);
      if (cap) {
        const raw = cap[0];
        const text = indentCodeCompensation(raw, cap[3] || "");
        return {
          type: "code",
          raw,
          lang: cap[2] ? cap[2].trim().replace(this.rules.inline._escapes, "$1") : cap[2],
          text
        };
      }
    }
    heading(src2) {
      const cap = this.rules.block.heading.exec(src2);
      if (cap) {
        let text = cap[2].trim();
        if (/#$/.test(text)) {
          const trimmed = rtrim(text, "#");
          if (this.options.pedantic) {
            text = trimmed.trim();
          } else if (!trimmed || / $/.test(trimmed)) {
            text = trimmed.trim();
          }
        }
        return {
          type: "heading",
          raw: cap[0],
          depth: cap[1].length,
          text,
          tokens: this.lexer.inline(text)
        };
      }
    }
    hr(src2) {
      const cap = this.rules.block.hr.exec(src2);
      if (cap) {
        return {
          type: "hr",
          raw: cap[0]
        };
      }
    }
    blockquote(src2) {
      const cap = this.rules.block.blockquote.exec(src2);
      if (cap) {
        const text = cap[0].replace(/^ *>[ \t]?/gm, "");
        const top = this.lexer.state.top;
        this.lexer.state.top = true;
        const tokens = this.lexer.blockTokens(text);
        this.lexer.state.top = top;
        return {
          type: "blockquote",
          raw: cap[0],
          tokens,
          text
        };
      }
    }
    list(src2) {
      let cap = this.rules.block.list.exec(src2);
      if (cap) {
        let raw, istask, ischecked, indent, i7, blankLine, endsWithBlankLine, line, nextLine, rawLine, itemContents, endEarly;
        let bull = cap[1].trim();
        const isordered = bull.length > 1;
        const list = {
          type: "list",
          raw: "",
          ordered: isordered,
          start: isordered ? +bull.slice(0, -1) : "",
          loose: false,
          items: []
        };
        bull = isordered ? `\\d{1,9}\\${bull.slice(-1)}` : `\\${bull}`;
        if (this.options.pedantic) {
          bull = isordered ? bull : "[*+-]";
        }
        const itemRegex = new RegExp(`^( {0,3}${bull})((?:[	 ][^\\n]*)?(?:\\n|$))`);
        while (src2) {
          endEarly = false;
          if (!(cap = itemRegex.exec(src2))) {
            break;
          }
          if (this.rules.block.hr.test(src2)) {
            break;
          }
          raw = cap[0];
          src2 = src2.substring(raw.length);
          line = cap[2].split("\n", 1)[0].replace(/^\t+/, (t6) => " ".repeat(3 * t6.length));
          nextLine = src2.split("\n", 1)[0];
          if (this.options.pedantic) {
            indent = 2;
            itemContents = line.trimLeft();
          } else {
            indent = cap[2].search(/[^ ]/);
            indent = indent > 4 ? 1 : indent;
            itemContents = line.slice(indent);
            indent += cap[1].length;
          }
          blankLine = false;
          if (!line && /^ *$/.test(nextLine)) {
            raw += nextLine + "\n";
            src2 = src2.substring(nextLine.length + 1);
            endEarly = true;
          }
          if (!endEarly) {
            const nextBulletRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`);
            const hrRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`);
            const fencesBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\`\`\`|~~~)`);
            const headingBeginRegex = new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`);
            while (src2) {
              rawLine = src2.split("\n", 1)[0];
              nextLine = rawLine;
              if (this.options.pedantic) {
                nextLine = nextLine.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ");
              }
              if (fencesBeginRegex.test(nextLine)) {
                break;
              }
              if (headingBeginRegex.test(nextLine)) {
                break;
              }
              if (nextBulletRegex.test(nextLine)) {
                break;
              }
              if (hrRegex.test(src2)) {
                break;
              }
              if (nextLine.search(/[^ ]/) >= indent || !nextLine.trim()) {
                itemContents += "\n" + nextLine.slice(indent);
              } else {
                if (blankLine) {
                  break;
                }
                if (line.search(/[^ ]/) >= 4) {
                  break;
                }
                if (fencesBeginRegex.test(line)) {
                  break;
                }
                if (headingBeginRegex.test(line)) {
                  break;
                }
                if (hrRegex.test(line)) {
                  break;
                }
                itemContents += "\n" + nextLine;
              }
              if (!blankLine && !nextLine.trim()) {
                blankLine = true;
              }
              raw += rawLine + "\n";
              src2 = src2.substring(rawLine.length + 1);
              line = nextLine.slice(indent);
            }
          }
          if (!list.loose) {
            if (endsWithBlankLine) {
              list.loose = true;
            } else if (/\n *\n *$/.test(raw)) {
              endsWithBlankLine = true;
            }
          }
          if (this.options.gfm) {
            istask = /^\[[ xX]\] /.exec(itemContents);
            if (istask) {
              ischecked = istask[0] !== "[ ] ";
              itemContents = itemContents.replace(/^\[[ xX]\] +/, "");
            }
          }
          list.items.push({
            type: "list_item",
            raw,
            task: !!istask,
            checked: ischecked,
            loose: false,
            text: itemContents
          });
          list.raw += raw;
        }
        list.items[list.items.length - 1].raw = raw.trimRight();
        list.items[list.items.length - 1].text = itemContents.trimRight();
        list.raw = list.raw.trimRight();
        const l9 = list.items.length;
        for (i7 = 0; i7 < l9; i7++) {
          this.lexer.state.top = false;
          list.items[i7].tokens = this.lexer.blockTokens(list.items[i7].text, []);
          if (!list.loose) {
            const spacers = list.items[i7].tokens.filter((t6) => t6.type === "space");
            const hasMultipleLineBreaks = spacers.length > 0 && spacers.some((t6) => /\n.*\n/.test(t6.raw));
            list.loose = hasMultipleLineBreaks;
          }
        }
        if (list.loose) {
          for (i7 = 0; i7 < l9; i7++) {
            list.items[i7].loose = true;
          }
        }
        return list;
      }
    }
    html(src2) {
      const cap = this.rules.block.html.exec(src2);
      if (cap) {
        const token = {
          type: "html",
          raw: cap[0],
          pre: !this.options.sanitizer && (cap[1] === "pre" || cap[1] === "script" || cap[1] === "style"),
          text: cap[0]
        };
        if (this.options.sanitize) {
          const text = this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]);
          token.type = "paragraph";
          token.text = text;
          token.tokens = this.lexer.inline(text);
        }
        return token;
      }
    }
    def(src2) {
      const cap = this.rules.block.def.exec(src2);
      if (cap) {
        const tag = cap[1].toLowerCase().replace(/\s+/g, " ");
        const href = cap[2] ? cap[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline._escapes, "$1") : "";
        const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline._escapes, "$1") : cap[3];
        return {
          type: "def",
          tag,
          raw: cap[0],
          href,
          title
        };
      }
    }
    table(src2) {
      const cap = this.rules.block.table.exec(src2);
      if (cap) {
        const item = {
          type: "table",
          header: splitCells(cap[1]).map((c9) => {
            return { text: c9 };
          }),
          align: cap[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
          rows: cap[3] && cap[3].trim() ? cap[3].replace(/\n[ \t]*$/, "").split("\n") : []
        };
        if (item.header.length === item.align.length) {
          item.raw = cap[0];
          let l9 = item.align.length;
          let i7, j7, k6, row;
          for (i7 = 0; i7 < l9; i7++) {
            if (/^ *-+: *$/.test(item.align[i7])) {
              item.align[i7] = "right";
            } else if (/^ *:-+: *$/.test(item.align[i7])) {
              item.align[i7] = "center";
            } else if (/^ *:-+ *$/.test(item.align[i7])) {
              item.align[i7] = "left";
            } else {
              item.align[i7] = null;
            }
          }
          l9 = item.rows.length;
          for (i7 = 0; i7 < l9; i7++) {
            item.rows[i7] = splitCells(item.rows[i7], item.header.length).map((c9) => {
              return { text: c9 };
            });
          }
          l9 = item.header.length;
          for (j7 = 0; j7 < l9; j7++) {
            item.header[j7].tokens = this.lexer.inline(item.header[j7].text);
          }
          l9 = item.rows.length;
          for (j7 = 0; j7 < l9; j7++) {
            row = item.rows[j7];
            for (k6 = 0; k6 < row.length; k6++) {
              row[k6].tokens = this.lexer.inline(row[k6].text);
            }
          }
          return item;
        }
      }
    }
    lheading(src2) {
      const cap = this.rules.block.lheading.exec(src2);
      if (cap) {
        return {
          type: "heading",
          raw: cap[0],
          depth: cap[2].charAt(0) === "=" ? 1 : 2,
          text: cap[1],
          tokens: this.lexer.inline(cap[1])
        };
      }
    }
    paragraph(src2) {
      const cap = this.rules.block.paragraph.exec(src2);
      if (cap) {
        const text = cap[1].charAt(cap[1].length - 1) === "\n" ? cap[1].slice(0, -1) : cap[1];
        return {
          type: "paragraph",
          raw: cap[0],
          text,
          tokens: this.lexer.inline(text)
        };
      }
    }
    text(src2) {
      const cap = this.rules.block.text.exec(src2);
      if (cap) {
        return {
          type: "text",
          raw: cap[0],
          text: cap[0],
          tokens: this.lexer.inline(cap[0])
        };
      }
    }
    escape(src2) {
      const cap = this.rules.inline.escape.exec(src2);
      if (cap) {
        return {
          type: "escape",
          raw: cap[0],
          text: escape(cap[1])
        };
      }
    }
    tag(src2) {
      const cap = this.rules.inline.tag.exec(src2);
      if (cap) {
        if (!this.lexer.state.inLink && /^<a /i.test(cap[0])) {
          this.lexer.state.inLink = true;
        } else if (this.lexer.state.inLink && /^<\/a>/i.test(cap[0])) {
          this.lexer.state.inLink = false;
        }
        if (!this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
          this.lexer.state.inRawBlock = true;
        } else if (this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
          this.lexer.state.inRawBlock = false;
        }
        return {
          type: this.options.sanitize ? "text" : "html",
          raw: cap[0],
          inLink: this.lexer.state.inLink,
          inRawBlock: this.lexer.state.inRawBlock,
          text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0]
        };
      }
    }
    link(src2) {
      const cap = this.rules.inline.link.exec(src2);
      if (cap) {
        const trimmedUrl = cap[2].trim();
        if (!this.options.pedantic && /^</.test(trimmedUrl)) {
          if (!/>$/.test(trimmedUrl)) {
            return;
          }
          const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), "\\");
          if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {
            return;
          }
        } else {
          const lastParenIndex = findClosingBracket(cap[2], "()");
          if (lastParenIndex > -1) {
            const start = cap[0].indexOf("!") === 0 ? 5 : 4;
            const linkLen = start + cap[1].length + lastParenIndex;
            cap[2] = cap[2].substring(0, lastParenIndex);
            cap[0] = cap[0].substring(0, linkLen).trim();
            cap[3] = "";
          }
        }
        let href = cap[2];
        let title = "";
        if (this.options.pedantic) {
          const link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);
          if (link) {
            href = link[1];
            title = link[3];
          }
        } else {
          title = cap[3] ? cap[3].slice(1, -1) : "";
        }
        href = href.trim();
        if (/^</.test(href)) {
          if (this.options.pedantic && !/>$/.test(trimmedUrl)) {
            href = href.slice(1);
          } else {
            href = href.slice(1, -1);
          }
        }
        return outputLink(cap, {
          href: href ? href.replace(this.rules.inline._escapes, "$1") : href,
          title: title ? title.replace(this.rules.inline._escapes, "$1") : title
        }, cap[0], this.lexer);
      }
    }
    reflink(src2, links) {
      let cap;
      if ((cap = this.rules.inline.reflink.exec(src2)) || (cap = this.rules.inline.nolink.exec(src2))) {
        let link = (cap[2] || cap[1]).replace(/\s+/g, " ");
        link = links[link.toLowerCase()];
        if (!link) {
          const text = cap[0].charAt(0);
          return {
            type: "text",
            raw: text,
            text
          };
        }
        return outputLink(cap, link, cap[0], this.lexer);
      }
    }
    emStrong(src2, maskedSrc, prevChar = "") {
      let match = this.rules.inline.emStrong.lDelim.exec(src2);
      if (!match)
        return;
      if (match[3] && prevChar.match(/[\p{L}\p{N}]/u))
        return;
      const nextChar = match[1] || match[2] || "";
      if (!nextChar || nextChar && (prevChar === "" || this.rules.inline.punctuation.exec(prevChar))) {
        const lLength = match[0].length - 1;
        let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;
        const endReg = match[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
        endReg.lastIndex = 0;
        maskedSrc = maskedSrc.slice(-1 * src2.length + lLength);
        while ((match = endReg.exec(maskedSrc)) != null) {
          rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];
          if (!rDelim)
            continue;
          rLength = rDelim.length;
          if (match[3] || match[4]) {
            delimTotal += rLength;
            continue;
          } else if (match[5] || match[6]) {
            if (lLength % 3 && !((lLength + rLength) % 3)) {
              midDelimTotal += rLength;
              continue;
            }
          }
          delimTotal -= rLength;
          if (delimTotal > 0)
            continue;
          rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);
          const raw = src2.slice(0, lLength + match.index + (match[0].length - rDelim.length) + rLength);
          if (Math.min(lLength, rLength) % 2) {
            const text2 = raw.slice(1, -1);
            return {
              type: "em",
              raw,
              text: text2,
              tokens: this.lexer.inlineTokens(text2)
            };
          }
          const text = raw.slice(2, -2);
          return {
            type: "strong",
            raw,
            text,
            tokens: this.lexer.inlineTokens(text)
          };
        }
      }
    }
    codespan(src2) {
      const cap = this.rules.inline.code.exec(src2);
      if (cap) {
        let text = cap[2].replace(/\n/g, " ");
        const hasNonSpaceChars = /[^ ]/.test(text);
        const hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);
        if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {
          text = text.substring(1, text.length - 1);
        }
        text = escape(text, true);
        return {
          type: "codespan",
          raw: cap[0],
          text
        };
      }
    }
    br(src2) {
      const cap = this.rules.inline.br.exec(src2);
      if (cap) {
        return {
          type: "br",
          raw: cap[0]
        };
      }
    }
    del(src2) {
      const cap = this.rules.inline.del.exec(src2);
      if (cap) {
        return {
          type: "del",
          raw: cap[0],
          text: cap[2],
          tokens: this.lexer.inlineTokens(cap[2])
        };
      }
    }
    autolink(src2, mangle2) {
      const cap = this.rules.inline.autolink.exec(src2);
      if (cap) {
        let text, href;
        if (cap[2] === "@") {
          text = escape(this.options.mangle ? mangle2(cap[1]) : cap[1]);
          href = "mailto:" + text;
        } else {
          text = escape(cap[1]);
          href = text;
        }
        return {
          type: "link",
          raw: cap[0],
          text,
          href,
          tokens: [
            {
              type: "text",
              raw: text,
              text
            }
          ]
        };
      }
    }
    url(src2, mangle2) {
      let cap;
      if (cap = this.rules.inline.url.exec(src2)) {
        let text, href;
        if (cap[2] === "@") {
          text = escape(this.options.mangle ? mangle2(cap[0]) : cap[0]);
          href = "mailto:" + text;
        } else {
          let prevCapZero;
          do {
            prevCapZero = cap[0];
            cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];
          } while (prevCapZero !== cap[0]);
          text = escape(cap[0]);
          if (cap[1] === "www.") {
            href = "http://" + cap[0];
          } else {
            href = cap[0];
          }
        }
        return {
          type: "link",
          raw: cap[0],
          text,
          href,
          tokens: [
            {
              type: "text",
              raw: text,
              text
            }
          ]
        };
      }
    }
    inlineText(src2, smartypants2) {
      const cap = this.rules.inline.text.exec(src2);
      if (cap) {
        let text;
        if (this.lexer.state.inRawBlock) {
          text = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0];
        } else {
          text = escape(this.options.smartypants ? smartypants2(cap[0]) : cap[0]);
        }
        return {
          type: "text",
          raw: cap[0],
          text
        };
      }
    }
  };
  var block = {
    newline: /^(?: *(?:\n|$))+/,
    code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
    fences: /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
    hr: /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,
    heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
    blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
    list: /^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/,
    html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
    def: /^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
    table: noopTest,
    lheading: /^((?:.|\n(?!\n))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
    // regex template, placeholders will be replaced according to different paragraph
    // interruption rules of commonmark and the original markdown spec:
    _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
    text: /^[^\n]+/
  };
  block._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/;
  block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
  block.def = edit(block.def).replace("label", block._label).replace("title", block._title).getRegex();
  block.bullet = /(?:[*+-]|\d{1,9}[.)])/;
  block.listItemStart = edit(/^( *)(bull) */).replace("bull", block.bullet).getRegex();
  block.list = edit(block.list).replace(/bull/g, block.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + block.def.source + ")").getRegex();
  block._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
  block._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/;
  block.html = edit(block.html, "i").replace("comment", block._comment).replace("tag", block._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
  block.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
  block.blockquote = edit(block.blockquote).replace("paragraph", block.paragraph).getRegex();
  block.normal = { ...block };
  block.gfm = {
    ...block.normal,
    table: "^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
    // Cells
  };
  block.gfm.table = edit(block.gfm.table).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
  block.gfm.paragraph = edit(block._paragraph).replace("hr", block.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("table", block.gfm.table).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", block._tag).getRegex();
  block.pedantic = {
    ...block.normal,
    html: edit(
      `^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`
    ).replace("comment", block._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
    def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
    heading: /^(#{1,6})(.*)(?:\n+|$)/,
    fences: noopTest,
    // fences not supported
    lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
    paragraph: edit(block.normal._paragraph).replace("hr", block.hr).replace("heading", " *#{1,6} *[^\n]").replace("lheading", block.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex()
  };
  var inline = {
    escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
    autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
    url: noopTest,
    tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
    // CDATA section
    link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
    reflink: /^!?\[(label)\]\[(ref)\]/,
    nolink: /^!?\[(ref)\](?:\[\])?/,
    reflinkSearch: "reflink|nolink(?!\\()",
    emStrong: {
      lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
      //        (1) and (2) can only be a Right Delimiter. (3) and (4) can only be Left.  (5) and (6) can be either Left or Right.
      //          () Skip orphan inside strong                                      () Consume to delim     (1) #***                (2) a***#, a***                             (3) #***a, ***a                 (4) ***#              (5) #***#                 (6) a***a
      rDelimAst: /^(?:[^_*\\]|\\.)*?\_\_(?:[^_*\\]|\\.)*?\*(?:[^_*\\]|\\.)*?(?=\_\_)|(?:[^*\\]|\\.)+(?=[^*])|[punct_](\*+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|(?:[^punct*_\s\\]|\\.)(\*+)(?=[^punct*_\s])/,
      rDelimUnd: /^(?:[^_*\\]|\\.)*?\*\*(?:[^_*\\]|\\.)*?\_(?:[^_*\\]|\\.)*?(?=\*\*)|(?:[^_\\]|\\.)+(?=[^_])|[punct*](\_+)(?=[\s]|$)|(?:[^punct*_\s\\]|\\.)(\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/
      // ^- Not allowed for _
    },
    code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
    br: /^( {2,}|\\)\n(?!\s*$)/,
    del: noopTest,
    text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
    punctuation: /^([\spunctuation])/
  };
  inline._punctuation = "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~";
  inline.punctuation = edit(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex();
  inline.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g;
  inline.escapedEmSt = /(?:^|[^\\])(?:\\\\)*\\[*_]/g;
  inline._comment = edit(block._comment).replace("(?:-->|$)", "-->").getRegex();
  inline.emStrong.lDelim = edit(inline.emStrong.lDelim).replace(/punct/g, inline._punctuation).getRegex();
  inline.emStrong.rDelimAst = edit(inline.emStrong.rDelimAst, "g").replace(/punct/g, inline._punctuation).getRegex();
  inline.emStrong.rDelimUnd = edit(inline.emStrong.rDelimUnd, "g").replace(/punct/g, inline._punctuation).getRegex();
  inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;
  inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
  inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
  inline.autolink = edit(inline.autolink).replace("scheme", inline._scheme).replace("email", inline._email).getRegex();
  inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;
  inline.tag = edit(inline.tag).replace("comment", inline._comment).replace("attribute", inline._attribute).getRegex();
  inline._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
  inline._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/;
  inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;
  inline.link = edit(inline.link).replace("label", inline._label).replace("href", inline._href).replace("title", inline._title).getRegex();
  inline.reflink = edit(inline.reflink).replace("label", inline._label).replace("ref", block._label).getRegex();
  inline.nolink = edit(inline.nolink).replace("ref", block._label).getRegex();
  inline.reflinkSearch = edit(inline.reflinkSearch, "g").replace("reflink", inline.reflink).replace("nolink", inline.nolink).getRegex();
  inline.normal = { ...inline };
  inline.pedantic = {
    ...inline.normal,
    strong: {
      start: /^__|\*\*/,
      middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
      endAst: /\*\*(?!\*)/g,
      endUnd: /__(?!_)/g
    },
    em: {
      start: /^_|\*/,
      middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
      endAst: /\*(?!\*)/g,
      endUnd: /_(?!_)/g
    },
    link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", inline._label).getRegex(),
    reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", inline._label).getRegex()
  };
  inline.gfm = {
    ...inline.normal,
    escape: edit(inline.escape).replace("])", "~|])").getRegex(),
    _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
    url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
    _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
    del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
    text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
  };
  inline.gfm.url = edit(inline.gfm.url, "i").replace("email", inline.gfm._extended_email).getRegex();
  inline.breaks = {
    ...inline.gfm,
    br: edit(inline.br).replace("{2,}", "*").getRegex(),
    text: edit(inline.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
  };
  function smartypants(text) {
    return text.replace(/---/g, "\u2014").replace(/--/g, "\u2013").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1\u2018").replace(/'/g, "\u2019").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1\u201C").replace(/"/g, "\u201D").replace(/\.{3}/g, "\u2026");
  }
  function mangle(text) {
    let out = "", i7, ch;
    const l9 = text.length;
    for (i7 = 0; i7 < l9; i7++) {
      ch = text.charCodeAt(i7);
      if (Math.random() > 0.5) {
        ch = "x" + ch.toString(16);
      }
      out += "&#" + ch + ";";
    }
    return out;
  }
  var Lexer = class {
    constructor(options2) {
      this.tokens = [];
      this.tokens.links = /* @__PURE__ */ Object.create(null);
      this.options = options2 || defaults3;
      this.options.tokenizer = this.options.tokenizer || new Tokenizer();
      this.tokenizer = this.options.tokenizer;
      this.tokenizer.options = this.options;
      this.tokenizer.lexer = this;
      this.inlineQueue = [];
      this.state = {
        inLink: false,
        inRawBlock: false,
        top: true
      };
      const rules = {
        block: block.normal,
        inline: inline.normal
      };
      if (this.options.pedantic) {
        rules.block = block.pedantic;
        rules.inline = inline.pedantic;
      } else if (this.options.gfm) {
        rules.block = block.gfm;
        if (this.options.breaks) {
          rules.inline = inline.breaks;
        } else {
          rules.inline = inline.gfm;
        }
      }
      this.tokenizer.rules = rules;
    }
    /**
     * Expose Rules
     */
    static get rules() {
      return {
        block,
        inline
      };
    }
    /**
     * Static Lex Method
     */
    static lex(src2, options2) {
      const lexer2 = new Lexer(options2);
      return lexer2.lex(src2);
    }
    /**
     * Static Lex Inline Method
     */
    static lexInline(src2, options2) {
      const lexer2 = new Lexer(options2);
      return lexer2.inlineTokens(src2);
    }
    /**
     * Preprocessing
     */
    lex(src2) {
      src2 = src2.replace(/\r\n|\r/g, "\n");
      this.blockTokens(src2, this.tokens);
      let next;
      while (next = this.inlineQueue.shift()) {
        this.inlineTokens(next.src, next.tokens);
      }
      return this.tokens;
    }
    /**
     * Lexing
     */
    blockTokens(src2, tokens = []) {
      if (this.options.pedantic) {
        src2 = src2.replace(/\t/g, "    ").replace(/^ +$/gm, "");
      } else {
        src2 = src2.replace(/^( *)(\t+)/gm, (_8, leading, tabs) => {
          return leading + "    ".repeat(tabs.length);
        });
      }
      let token, lastToken, cutSrc, lastParagraphClipped;
      while (src2) {
        if (this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((extTokenizer) => {
          if (token = extTokenizer.call({ lexer: this }, src2, tokens)) {
            src2 = src2.substring(token.raw.length);
            tokens.push(token);
            return true;
          }
          return false;
        })) {
          continue;
        }
        if (token = this.tokenizer.space(src2)) {
          src2 = src2.substring(token.raw.length);
          if (token.raw.length === 1 && tokens.length > 0) {
            tokens[tokens.length - 1].raw += "\n";
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (token = this.tokenizer.code(src2)) {
          src2 = src2.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1];
          if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
            lastToken.raw += "\n" + token.raw;
            lastToken.text += "\n" + token.text;
            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (token = this.tokenizer.fences(src2)) {
          src2 = src2.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.heading(src2)) {
          src2 = src2.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.hr(src2)) {
          src2 = src2.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.blockquote(src2)) {
          src2 = src2.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.list(src2)) {
          src2 = src2.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.html(src2)) {
          src2 = src2.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.def(src2)) {
          src2 = src2.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1];
          if (lastToken && (lastToken.type === "paragraph" || lastToken.type === "text")) {
            lastToken.raw += "\n" + token.raw;
            lastToken.text += "\n" + token.raw;
            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
          } else if (!this.tokens.links[token.tag]) {
            this.tokens.links[token.tag] = {
              href: token.href,
              title: token.title
            };
          }
          continue;
        }
        if (token = this.tokenizer.table(src2)) {
          src2 = src2.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.lheading(src2)) {
          src2 = src2.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        cutSrc = src2;
        if (this.options.extensions && this.options.extensions.startBlock) {
          let startIndex = Infinity;
          const tempSrc = src2.slice(1);
          let tempStart;
          this.options.extensions.startBlock.forEach(function(getStartIndex) {
            tempStart = getStartIndex.call({ lexer: this }, tempSrc);
            if (typeof tempStart === "number" && tempStart >= 0) {
              startIndex = Math.min(startIndex, tempStart);
            }
          });
          if (startIndex < Infinity && startIndex >= 0) {
            cutSrc = src2.substring(0, startIndex + 1);
          }
        }
        if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {
          lastToken = tokens[tokens.length - 1];
          if (lastParagraphClipped && lastToken.type === "paragraph") {
            lastToken.raw += "\n" + token.raw;
            lastToken.text += "\n" + token.text;
            this.inlineQueue.pop();
            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
          } else {
            tokens.push(token);
          }
          lastParagraphClipped = cutSrc.length !== src2.length;
          src2 = src2.substring(token.raw.length);
          continue;
        }
        if (token = this.tokenizer.text(src2)) {
          src2 = src2.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1];
          if (lastToken && lastToken.type === "text") {
            lastToken.raw += "\n" + token.raw;
            lastToken.text += "\n" + token.text;
            this.inlineQueue.pop();
            this.inlineQueue[this.inlineQueue.length - 1].src = lastToken.text;
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (src2) {
          const errMsg = "Infinite loop on byte: " + src2.charCodeAt(0);
          if (this.options.silent) {
            console.error(errMsg);
            break;
          } else {
            throw new Error(errMsg);
          }
        }
      }
      this.state.top = true;
      return tokens;
    }
    inline(src2, tokens = []) {
      this.inlineQueue.push({ src: src2, tokens });
      return tokens;
    }
    /**
     * Lexing/Compiling
     */
    inlineTokens(src2, tokens = []) {
      let token, lastToken, cutSrc;
      let maskedSrc = src2;
      let match;
      let keepPrevChar, prevChar;
      if (this.tokens.links) {
        const links = Object.keys(this.tokens.links);
        if (links.length > 0) {
          while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {
            if (links.includes(match[0].slice(match[0].lastIndexOf("[") + 1, -1))) {
              maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);
            }
          }
        }
      }
      while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {
        maskedSrc = maskedSrc.slice(0, match.index) + "[" + repeatString("a", match[0].length - 2) + "]" + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
      }
      while ((match = this.tokenizer.rules.inline.escapedEmSt.exec(maskedSrc)) != null) {
        maskedSrc = maskedSrc.slice(0, match.index + match[0].length - 2) + "++" + maskedSrc.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);
        this.tokenizer.rules.inline.escapedEmSt.lastIndex--;
      }
      while (src2) {
        if (!keepPrevChar) {
          prevChar = "";
        }
        keepPrevChar = false;
        if (this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((extTokenizer) => {
          if (token = extTokenizer.call({ lexer: this }, src2, tokens)) {
            src2 = src2.substring(token.raw.length);
            tokens.push(token);
            return true;
          }
          return false;
        })) {
          continue;
        }
        if (token = this.tokenizer.escape(src2)) {
          src2 = src2.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.tag(src2)) {
          src2 = src2.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1];
          if (lastToken && token.type === "text" && lastToken.type === "text") {
            lastToken.raw += token.raw;
            lastToken.text += token.text;
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (token = this.tokenizer.link(src2)) {
          src2 = src2.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.reflink(src2, this.tokens.links)) {
          src2 = src2.substring(token.raw.length);
          lastToken = tokens[tokens.length - 1];
          if (lastToken && token.type === "text" && lastToken.type === "text") {
            lastToken.raw += token.raw;
            lastToken.text += token.text;
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (token = this.tokenizer.emStrong(src2, maskedSrc, prevChar)) {
          src2 = src2.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.codespan(src2)) {
          src2 = src2.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.br(src2)) {
          src2 = src2.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.del(src2)) {
          src2 = src2.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (token = this.tokenizer.autolink(src2, mangle)) {
          src2 = src2.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        if (!this.state.inLink && (token = this.tokenizer.url(src2, mangle))) {
          src2 = src2.substring(token.raw.length);
          tokens.push(token);
          continue;
        }
        cutSrc = src2;
        if (this.options.extensions && this.options.extensions.startInline) {
          let startIndex = Infinity;
          const tempSrc = src2.slice(1);
          let tempStart;
          this.options.extensions.startInline.forEach(function(getStartIndex) {
            tempStart = getStartIndex.call({ lexer: this }, tempSrc);
            if (typeof tempStart === "number" && tempStart >= 0) {
              startIndex = Math.min(startIndex, tempStart);
            }
          });
          if (startIndex < Infinity && startIndex >= 0) {
            cutSrc = src2.substring(0, startIndex + 1);
          }
        }
        if (token = this.tokenizer.inlineText(cutSrc, smartypants)) {
          src2 = src2.substring(token.raw.length);
          if (token.raw.slice(-1) !== "_") {
            prevChar = token.raw.slice(-1);
          }
          keepPrevChar = true;
          lastToken = tokens[tokens.length - 1];
          if (lastToken && lastToken.type === "text") {
            lastToken.raw += token.raw;
            lastToken.text += token.text;
          } else {
            tokens.push(token);
          }
          continue;
        }
        if (src2) {
          const errMsg = "Infinite loop on byte: " + src2.charCodeAt(0);
          if (this.options.silent) {
            console.error(errMsg);
            break;
          } else {
            throw new Error(errMsg);
          }
        }
      }
      return tokens;
    }
  };
  var Renderer = class {
    constructor(options2) {
      this.options = options2 || defaults3;
    }
    code(code2, infostring, escaped) {
      const lang = (infostring || "").match(/\S*/)[0];
      if (this.options.highlight) {
        const out = this.options.highlight(code2, lang);
        if (out != null && out !== code2) {
          escaped = true;
          code2 = out;
        }
      }
      code2 = code2.replace(/\n$/, "") + "\n";
      if (!lang) {
        return "<pre><code>" + (escaped ? code2 : escape(code2, true)) + "</code></pre>\n";
      }
      return '<pre><code class="' + this.options.langPrefix + escape(lang) + '">' + (escaped ? code2 : escape(code2, true)) + "</code></pre>\n";
    }
    /**
     * @param {string} quote
     */
    blockquote(quote) {
      return `<blockquote>
${quote}</blockquote>
`;
    }
    html(html) {
      return html;
    }
    /**
     * @param {string} text
     * @param {string} level
     * @param {string} raw
     * @param {any} slugger
     */
    heading(text, level, raw, slugger) {
      if (this.options.headerIds) {
        const id3 = this.options.headerPrefix + slugger.slug(raw);
        return `<h${level} id="${id3}">${text}</h${level}>
`;
      }
      return `<h${level}>${text}</h${level}>
`;
    }
    hr() {
      return this.options.xhtml ? "<hr/>\n" : "<hr>\n";
    }
    list(body, ordered, start) {
      const type = ordered ? "ol" : "ul", startatt = ordered && start !== 1 ? ' start="' + start + '"' : "";
      return "<" + type + startatt + ">\n" + body + "</" + type + ">\n";
    }
    /**
     * @param {string} text
     */
    listitem(text) {
      return `<li>${text}</li>
`;
    }
    checkbox(checked) {
      return "<input " + (checked ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> ";
    }
    /**
     * @param {string} text
     */
    paragraph(text) {
      return `<p>${text}</p>
`;
    }
    /**
     * @param {string} header
     * @param {string} body
     */
    table(header, body) {
      if (body)
        body = `<tbody>${body}</tbody>`;
      return "<table>\n<thead>\n" + header + "</thead>\n" + body + "</table>\n";
    }
    /**
     * @param {string} content
     */
    tablerow(content) {
      return `<tr>
${content}</tr>
`;
    }
    tablecell(content, flags) {
      const type = flags.header ? "th" : "td";
      const tag = flags.align ? `<${type} align="${flags.align}">` : `<${type}>`;
      return tag + content + `</${type}>
`;
    }
    /**
     * span level renderer
     * @param {string} text
     */
    strong(text) {
      return `<strong>${text}</strong>`;
    }
    /**
     * @param {string} text
     */
    em(text) {
      return `<em>${text}</em>`;
    }
    /**
     * @param {string} text
     */
    codespan(text) {
      return `<code>${text}</code>`;
    }
    br() {
      return this.options.xhtml ? "<br/>" : "<br>";
    }
    /**
     * @param {string} text
     */
    del(text) {
      return `<del>${text}</del>`;
    }
    /**
     * @param {string} href
     * @param {string} title
     * @param {string} text
     */
    link(href, title, text) {
      href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
      if (href === null) {
        return text;
      }
      let out = '<a href="' + href + '"';
      if (title) {
        out += ' title="' + title + '"';
      }
      out += ">" + text + "</a>";
      return out;
    }
    /**
     * @param {string} href
     * @param {string} title
     * @param {string} text
     */
    image(href, title, text) {
      href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
      if (href === null) {
        return text;
      }
      let out = `<img src="${href}" alt="${text}"`;
      if (title) {
        out += ` title="${title}"`;
      }
      out += this.options.xhtml ? "/>" : ">";
      return out;
    }
    text(text) {
      return text;
    }
  };
  var TextRenderer = class {
    // no need for block level renderers
    strong(text) {
      return text;
    }
    em(text) {
      return text;
    }
    codespan(text) {
      return text;
    }
    del(text) {
      return text;
    }
    html(text) {
      return text;
    }
    text(text) {
      return text;
    }
    link(href, title, text) {
      return "" + text;
    }
    image(href, title, text) {
      return "" + text;
    }
    br() {
      return "";
    }
  };
  var Slugger = class {
    constructor() {
      this.seen = {};
    }
    /**
     * @param {string} value
     */
    serialize(value) {
      return value.toLowerCase().trim().replace(/<[!\/a-z].*?>/ig, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-");
    }
    /**
     * Finds the next safe (unique) slug to use
     * @param {string} originalSlug
     * @param {boolean} isDryRun
     */
    getNextSafeSlug(originalSlug, isDryRun) {
      let slug = originalSlug;
      let occurenceAccumulator = 0;
      if (this.seen.hasOwnProperty(slug)) {
        occurenceAccumulator = this.seen[originalSlug];
        do {
          occurenceAccumulator++;
          slug = originalSlug + "-" + occurenceAccumulator;
        } while (this.seen.hasOwnProperty(slug));
      }
      if (!isDryRun) {
        this.seen[originalSlug] = occurenceAccumulator;
        this.seen[slug] = 0;
      }
      return slug;
    }
    /**
     * Convert string to unique id
     * @param {object} [options]
     * @param {boolean} [options.dryrun] Generates the next unique slug without
     * updating the internal accumulator.
     */
    slug(value, options2 = {}) {
      const slug = this.serialize(value);
      return this.getNextSafeSlug(slug, options2.dryrun);
    }
  };
  var Parser = class {
    constructor(options2) {
      this.options = options2 || defaults3;
      this.options.renderer = this.options.renderer || new Renderer();
      this.renderer = this.options.renderer;
      this.renderer.options = this.options;
      this.textRenderer = new TextRenderer();
      this.slugger = new Slugger();
    }
    /**
     * Static Parse Method
     */
    static parse(tokens, options2) {
      const parser2 = new Parser(options2);
      return parser2.parse(tokens);
    }
    /**
     * Static Parse Inline Method
     */
    static parseInline(tokens, options2) {
      const parser2 = new Parser(options2);
      return parser2.parseInline(tokens);
    }
    /**
     * Parse Loop
     */
    parse(tokens, top = true) {
      let out = "", i7, j7, k6, l22, l32, row, cell, header, body, token, ordered, start, loose, itemBody, item, checked, task, checkbox, ret;
      const l9 = tokens.length;
      for (i7 = 0; i7 < l9; i7++) {
        token = tokens[i7];
        if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
          ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
          if (ret !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(token.type)) {
            out += ret || "";
            continue;
          }
        }
        switch (token.type) {
          case "space": {
            continue;
          }
          case "hr": {
            out += this.renderer.hr();
            continue;
          }
          case "heading": {
            out += this.renderer.heading(
              this.parseInline(token.tokens),
              token.depth,
              unescape2(this.parseInline(token.tokens, this.textRenderer)),
              this.slugger
            );
            continue;
          }
          case "code": {
            out += this.renderer.code(
              token.text,
              token.lang,
              token.escaped
            );
            continue;
          }
          case "table": {
            header = "";
            cell = "";
            l22 = token.header.length;
            for (j7 = 0; j7 < l22; j7++) {
              cell += this.renderer.tablecell(
                this.parseInline(token.header[j7].tokens),
                { header: true, align: token.align[j7] }
              );
            }
            header += this.renderer.tablerow(cell);
            body = "";
            l22 = token.rows.length;
            for (j7 = 0; j7 < l22; j7++) {
              row = token.rows[j7];
              cell = "";
              l32 = row.length;
              for (k6 = 0; k6 < l32; k6++) {
                cell += this.renderer.tablecell(
                  this.parseInline(row[k6].tokens),
                  { header: false, align: token.align[k6] }
                );
              }
              body += this.renderer.tablerow(cell);
            }
            out += this.renderer.table(header, body);
            continue;
          }
          case "blockquote": {
            body = this.parse(token.tokens);
            out += this.renderer.blockquote(body);
            continue;
          }
          case "list": {
            ordered = token.ordered;
            start = token.start;
            loose = token.loose;
            l22 = token.items.length;
            body = "";
            for (j7 = 0; j7 < l22; j7++) {
              item = token.items[j7];
              checked = item.checked;
              task = item.task;
              itemBody = "";
              if (item.task) {
                checkbox = this.renderer.checkbox(checked);
                if (loose) {
                  if (item.tokens.length > 0 && item.tokens[0].type === "paragraph") {
                    item.tokens[0].text = checkbox + " " + item.tokens[0].text;
                    if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === "text") {
                      item.tokens[0].tokens[0].text = checkbox + " " + item.tokens[0].tokens[0].text;
                    }
                  } else {
                    item.tokens.unshift({
                      type: "text",
                      text: checkbox
                    });
                  }
                } else {
                  itemBody += checkbox;
                }
              }
              itemBody += this.parse(item.tokens, loose);
              body += this.renderer.listitem(itemBody, task, checked);
            }
            out += this.renderer.list(body, ordered, start);
            continue;
          }
          case "html": {
            out += this.renderer.html(token.text);
            continue;
          }
          case "paragraph": {
            out += this.renderer.paragraph(this.parseInline(token.tokens));
            continue;
          }
          case "text": {
            body = token.tokens ? this.parseInline(token.tokens) : token.text;
            while (i7 + 1 < l9 && tokens[i7 + 1].type === "text") {
              token = tokens[++i7];
              body += "\n" + (token.tokens ? this.parseInline(token.tokens) : token.text);
            }
            out += top ? this.renderer.paragraph(body) : body;
            continue;
          }
          default: {
            const errMsg = 'Token with "' + token.type + '" type was not found.';
            if (this.options.silent) {
              console.error(errMsg);
              return;
            } else {
              throw new Error(errMsg);
            }
          }
        }
      }
      return out;
    }
    /**
     * Parse Inline Tokens
     */
    parseInline(tokens, renderer) {
      renderer = renderer || this.renderer;
      let out = "", i7, token, ret;
      const l9 = tokens.length;
      for (i7 = 0; i7 < l9; i7++) {
        token = tokens[i7];
        if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[token.type]) {
          ret = this.options.extensions.renderers[token.type].call({ parser: this }, token);
          if (ret !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(token.type)) {
            out += ret || "";
            continue;
          }
        }
        switch (token.type) {
          case "escape": {
            out += renderer.text(token.text);
            break;
          }
          case "html": {
            out += renderer.html(token.text);
            break;
          }
          case "link": {
            out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));
            break;
          }
          case "image": {
            out += renderer.image(token.href, token.title, token.text);
            break;
          }
          case "strong": {
            out += renderer.strong(this.parseInline(token.tokens, renderer));
            break;
          }
          case "em": {
            out += renderer.em(this.parseInline(token.tokens, renderer));
            break;
          }
          case "codespan": {
            out += renderer.codespan(token.text);
            break;
          }
          case "br": {
            out += renderer.br();
            break;
          }
          case "del": {
            out += renderer.del(this.parseInline(token.tokens, renderer));
            break;
          }
          case "text": {
            out += renderer.text(token.text);
            break;
          }
          default: {
            const errMsg = 'Token with "' + token.type + '" type was not found.';
            if (this.options.silent) {
              console.error(errMsg);
              return;
            } else {
              throw new Error(errMsg);
            }
          }
        }
      }
      return out;
    }
  };
  var Hooks = class {
    constructor(options2) {
      this.options = options2 || defaults3;
    }
    /**
     * Process markdown before marked
     */
    preprocess(markdown) {
      return markdown;
    }
    /**
     * Process HTML after marked is finished
     */
    postprocess(html) {
      return html;
    }
  };
  __publicField(Hooks, "passThroughHooks", /* @__PURE__ */ new Set([
    "preprocess",
    "postprocess"
  ]));
  function onError(silent, async, callback) {
    return (e9) => {
      e9.message += "\nPlease report this to https://github.com/markedjs/marked.";
      if (silent) {
        const msg = "<p>An error occurred:</p><pre>" + escape(e9.message + "", true) + "</pre>";
        if (async) {
          return Promise.resolve(msg);
        }
        if (callback) {
          callback(null, msg);
          return;
        }
        return msg;
      }
      if (async) {
        return Promise.reject(e9);
      }
      if (callback) {
        callback(e9);
        return;
      }
      throw e9;
    };
  }
  function parseMarkdown(lexer2, parser2) {
    return (src2, opt, callback) => {
      if (typeof opt === "function") {
        callback = opt;
        opt = null;
      }
      const origOpt = { ...opt };
      opt = { ...marked.defaults, ...origOpt };
      const throwError = onError(opt.silent, opt.async, callback);
      if (typeof src2 === "undefined" || src2 === null) {
        return throwError(new Error("marked(): input parameter is undefined or null"));
      }
      if (typeof src2 !== "string") {
        return throwError(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(src2) + ", string expected"));
      }
      checkSanitizeDeprecation(opt);
      if (opt.hooks) {
        opt.hooks.options = opt;
      }
      if (callback) {
        const highlight = opt.highlight;
        let tokens;
        try {
          if (opt.hooks) {
            src2 = opt.hooks.preprocess(src2);
          }
          tokens = lexer2(src2, opt);
        } catch (e9) {
          return throwError(e9);
        }
        const done = function(err) {
          let out;
          if (!err) {
            try {
              if (opt.walkTokens) {
                marked.walkTokens(tokens, opt.walkTokens);
              }
              out = parser2(tokens, opt);
              if (opt.hooks) {
                out = opt.hooks.postprocess(out);
              }
            } catch (e9) {
              err = e9;
            }
          }
          opt.highlight = highlight;
          return err ? throwError(err) : callback(null, out);
        };
        if (!highlight || highlight.length < 3) {
          return done();
        }
        delete opt.highlight;
        if (!tokens.length)
          return done();
        let pending = 0;
        marked.walkTokens(tokens, function(token) {
          if (token.type === "code") {
            pending++;
            setTimeout(() => {
              highlight(token.text, token.lang, function(err, code2) {
                if (err) {
                  return done(err);
                }
                if (code2 != null && code2 !== token.text) {
                  token.text = code2;
                  token.escaped = true;
                }
                pending--;
                if (pending === 0) {
                  done();
                }
              });
            }, 0);
          }
        });
        if (pending === 0) {
          done();
        }
        return;
      }
      if (opt.async) {
        return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src2) : src2).then((src3) => lexer2(src3, opt)).then((tokens) => opt.walkTokens ? Promise.all(marked.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens).then((tokens) => parser2(tokens, opt)).then((html) => opt.hooks ? opt.hooks.postprocess(html) : html).catch(throwError);
      }
      try {
        if (opt.hooks) {
          src2 = opt.hooks.preprocess(src2);
        }
        const tokens = lexer2(src2, opt);
        if (opt.walkTokens) {
          marked.walkTokens(tokens, opt.walkTokens);
        }
        let html = parser2(tokens, opt);
        if (opt.hooks) {
          html = opt.hooks.postprocess(html);
        }
        return html;
      } catch (e9) {
        return throwError(e9);
      }
    };
  }
  function marked(src2, opt, callback) {
    return parseMarkdown(Lexer.lex, Parser.parse)(src2, opt, callback);
  }
  marked.options = marked.setOptions = function(opt) {
    marked.defaults = { ...marked.defaults, ...opt };
    changeDefaults(marked.defaults);
    return marked;
  };
  marked.getDefaults = getDefaults;
  marked.defaults = defaults3;
  marked.use = function(...args) {
    const extensions = marked.defaults.extensions || { renderers: {}, childTokens: {} };
    args.forEach((pack3) => {
      const opts = { ...pack3 };
      opts.async = marked.defaults.async || opts.async || false;
      if (pack3.extensions) {
        pack3.extensions.forEach((ext) => {
          if (!ext.name) {
            throw new Error("extension name required");
          }
          if (ext.renderer) {
            const prevRenderer = extensions.renderers[ext.name];
            if (prevRenderer) {
              extensions.renderers[ext.name] = function(...args2) {
                let ret = ext.renderer.apply(this, args2);
                if (ret === false) {
                  ret = prevRenderer.apply(this, args2);
                }
                return ret;
              };
            } else {
              extensions.renderers[ext.name] = ext.renderer;
            }
          }
          if (ext.tokenizer) {
            if (!ext.level || ext.level !== "block" && ext.level !== "inline") {
              throw new Error("extension level must be 'block' or 'inline'");
            }
            if (extensions[ext.level]) {
              extensions[ext.level].unshift(ext.tokenizer);
            } else {
              extensions[ext.level] = [ext.tokenizer];
            }
            if (ext.start) {
              if (ext.level === "block") {
                if (extensions.startBlock) {
                  extensions.startBlock.push(ext.start);
                } else {
                  extensions.startBlock = [ext.start];
                }
              } else if (ext.level === "inline") {
                if (extensions.startInline) {
                  extensions.startInline.push(ext.start);
                } else {
                  extensions.startInline = [ext.start];
                }
              }
            }
          }
          if (ext.childTokens) {
            extensions.childTokens[ext.name] = ext.childTokens;
          }
        });
        opts.extensions = extensions;
      }
      if (pack3.renderer) {
        const renderer = marked.defaults.renderer || new Renderer();
        for (const prop in pack3.renderer) {
          const prevRenderer = renderer[prop];
          renderer[prop] = (...args2) => {
            let ret = pack3.renderer[prop].apply(renderer, args2);
            if (ret === false) {
              ret = prevRenderer.apply(renderer, args2);
            }
            return ret;
          };
        }
        opts.renderer = renderer;
      }
      if (pack3.tokenizer) {
        const tokenizer = marked.defaults.tokenizer || new Tokenizer();
        for (const prop in pack3.tokenizer) {
          const prevTokenizer = tokenizer[prop];
          tokenizer[prop] = (...args2) => {
            let ret = pack3.tokenizer[prop].apply(tokenizer, args2);
            if (ret === false) {
              ret = prevTokenizer.apply(tokenizer, args2);
            }
            return ret;
          };
        }
        opts.tokenizer = tokenizer;
      }
      if (pack3.hooks) {
        const hooks = marked.defaults.hooks || new Hooks();
        for (const prop in pack3.hooks) {
          const prevHook = hooks[prop];
          if (Hooks.passThroughHooks.has(prop)) {
            hooks[prop] = (arg) => {
              if (marked.defaults.async) {
                return Promise.resolve(pack3.hooks[prop].call(hooks, arg)).then((ret2) => {
                  return prevHook.call(hooks, ret2);
                });
              }
              const ret = pack3.hooks[prop].call(hooks, arg);
              return prevHook.call(hooks, ret);
            };
          } else {
            hooks[prop] = (...args2) => {
              let ret = pack3.hooks[prop].apply(hooks, args2);
              if (ret === false) {
                ret = prevHook.apply(hooks, args2);
              }
              return ret;
            };
          }
        }
        opts.hooks = hooks;
      }
      if (pack3.walkTokens) {
        const walkTokens2 = marked.defaults.walkTokens;
        opts.walkTokens = function(token) {
          let values = [];
          values.push(pack3.walkTokens.call(this, token));
          if (walkTokens2) {
            values = values.concat(walkTokens2.call(this, token));
          }
          return values;
        };
      }
      marked.setOptions(opts);
    });
  };
  marked.walkTokens = function(tokens, callback) {
    let values = [];
    for (const token of tokens) {
      values = values.concat(callback.call(marked, token));
      switch (token.type) {
        case "table": {
          for (const cell of token.header) {
            values = values.concat(marked.walkTokens(cell.tokens, callback));
          }
          for (const row of token.rows) {
            for (const cell of row) {
              values = values.concat(marked.walkTokens(cell.tokens, callback));
            }
          }
          break;
        }
        case "list": {
          values = values.concat(marked.walkTokens(token.items, callback));
          break;
        }
        default: {
          if (marked.defaults.extensions && marked.defaults.extensions.childTokens && marked.defaults.extensions.childTokens[token.type]) {
            marked.defaults.extensions.childTokens[token.type].forEach(function(childTokens) {
              values = values.concat(marked.walkTokens(token[childTokens], callback));
            });
          } else if (token.tokens) {
            values = values.concat(marked.walkTokens(token.tokens, callback));
          }
        }
      }
    }
    return values;
  };
  marked.parseInline = parseMarkdown(Lexer.lexInline, Parser.parseInline);
  marked.Parser = Parser;
  marked.parser = Parser.parse;
  marked.Renderer = Renderer;
  marked.TextRenderer = TextRenderer;
  marked.Lexer = Lexer;
  marked.lexer = Lexer.lex;
  marked.Tokenizer = Tokenizer;
  marked.Slugger = Slugger;
  marked.Hooks = Hooks;
  marked.parse = marked;
  var options = marked.options;
  var setOptions = marked.setOptions;
  var use = marked.use;
  var walkTokens = marked.walkTokens;
  var parseInline = marked.parseInline;
  var parser = Parser.parse;
  var lexer = Lexer.lex;

  // src/components/Content.tsx
  var import_classnames6 = __toESM(require_classnames());
  function Content() {
    const device = applicationStore_default((s7) => s7.device);
    const keys2 = applicationStore_default((s7) => s7.deviceKeys);
    const meta = JSON.parse(device.device_token_metadata);
    const chainId = applicationStore_default((s7) => s7.walletChainId);
    const explorer = getChainData(chainId).explorer;
    const isVideo = device.content_type.indexOf("video") > -1;
    const [status, setStatus] = (0, import_react16.useState)(0);
    const buttonClick = () => {
      setStatus(1);
      setTimeout(() => {
        setStatus(2);
      }, 1e3);
    };
    return /* @__PURE__ */ import_react16.default.createElement(Card, null, isVideo ? /* @__PURE__ */ import_react16.default.createElement("video", { className: "card-video", autoPlay: true, loop: true, playsInline: true, muted: true }, /* @__PURE__ */ import_react16.default.createElement("source", { src: `${ARWEAVE_NODE}/${device.node_id}` })) : /* @__PURE__ */ import_react16.default.createElement("img", { src: `${ARWEAVE_NODE}/${device.node_id}` }), /* @__PURE__ */ import_react16.default.createElement(CardPadding, null, /* @__PURE__ */ import_react16.default.createElement("h1", { className: "content-heading" }, meta.name), /* @__PURE__ */ import_react16.default.createElement("p", { className: "content-meta" }, "Created by", " ", /* @__PURE__ */ import_react16.default.createElement("a", { target: "_blank", href: `${explorer}/${device.device_minter}` }, truncateAddress(device.device_minter))), /* @__PURE__ */ import_react16.default.createElement("div", { className: "content-description", dangerouslySetInnerHTML: { __html: marked(meta.description) } }), /* @__PURE__ */ import_react16.default.createElement(
      "button",
      {
        onClick: buttonClick,
        disabled: status > 0,
        className: (0, import_classnames6.default)("content-special-button", {
          "content-special-button--pending": status === 1,
          "content-special-button--claimed": status === 2
        })
      },
      /* @__PURE__ */ import_react16.default.createElement("div", { className: "content-special-button__claimed" }, /* @__PURE__ */ import_react16.default.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 -960 960 960", width: "17" }, /* @__PURE__ */ import_react16.default.createElement("path", { d: "M382-240 154-468l57-57 171 171 367-367 57 57-424 424Z" }))),
      /* @__PURE__ */ import_react16.default.createElement("svg", { className: "content-special-button__spinner", viewBox: "0 0 20 20" }, /* @__PURE__ */ import_react16.default.createElement(
        "path",
        {
          d: "M7.229 1.173a9.25 9.25 0 1011.655 11.412 1.25 1.25 0 10-2.4-.698 6.75 6.75 0 11-8.506-8.329 1.25 1.25 0 10-.75-2.385z",
          fill: "currentColor"
        }
      )),
      /* @__PURE__ */ import_react16.default.createElement("span", { className: "content-special-button__text" }, status === 0 && /* @__PURE__ */ import_react16.default.createElement(import_react16.default.Fragment, null, "Claim"), status === 1 && /* @__PURE__ */ import_react16.default.createElement(import_react16.default.Fragment, null, "Pending"), status === 2 && /* @__PURE__ */ import_react16.default.createElement(import_react16.default.Fragment, null, "Claimed"))
    ), /* @__PURE__ */ import_react16.default.createElement(Divider, null), /* @__PURE__ */ import_react16.default.createElement(ContentDetail, { title: "Device ID" }, keys2.primaryPublicKeyHash)));
  }

  // src/pages/Viewer.tsx
  function Viewer() {
    return /* @__PURE__ */ import_react17.default.createElement(Wrapper, null, /* @__PURE__ */ import_react17.default.createElement(Header, null), /* @__PURE__ */ import_react17.default.createElement(Content, null), /* @__PURE__ */ import_react17.default.createElement(Footer, null));
  }

  // src/pages/Scan.tsx
  var import_react19 = __toESM(require_react());

  // src/components/NotFoundContent.tsx
  var import_react18 = __toESM(require_react());
  function NotFoundContent() {
    const triggerScan = applicationStore_default((s7) => s7.deviceTriggerScan);
    return /* @__PURE__ */ import_react18.default.createElement(Card, null, /* @__PURE__ */ import_react18.default.createElement(CardPadding, null, /* @__PURE__ */ import_react18.default.createElement("h1", { className: "not-found-content-heading" }, "No Halo"), /* @__PURE__ */ import_react18.default.createElement("p", { className: "not-found-content-body" }, "Scan chip by tapping the button below and holding the chip to your smartphone NFC antenna"), /* @__PURE__ */ import_react18.default.createElement("button", { onClick: triggerScan, className: "not-found-content-scan" }, "SCAN")));
  }

  // src/pages/Scan.tsx
  function scan() {
    return /* @__PURE__ */ import_react19.default.createElement(Wrapper, null, /* @__PURE__ */ import_react19.default.createElement(Header, null), /* @__PURE__ */ import_react19.default.createElement(NotFoundContent, null), /* @__PURE__ */ import_react19.default.createElement(Footer, null));
  }

  // src/components/Loading.tsx
  var import_react20 = __toESM(require_react());
  function Loading() {
    return /* @__PURE__ */ import_react20.default.createElement("div", { className: "loading-wrap" }, /* @__PURE__ */ import_react20.default.createElement("div", { className: "loading" }));
  }

  // src/components/Settings.tsx
  var import_react21 = __toESM(require_react());
  function Settings() {
    const s7 = window.HALO_SETTINGS;
    return /* @__PURE__ */ import_react21.default.createElement("style", null, `
    :root {
      --logoSize: ${s7.logoSize}px;
      --backgroundColor: ${s7.backgroundColor};
      --headerButtonColor: ${s7.headerButtonColor};
      --cardColor: ${s7.cardColor};
      --cardTextColor: ${s7.cardTextColor};
      --cardLinkColor: ${s7.cardLinkColor};
      --cardSubheadingColor: ${s7.cardSubheadingColor};
      --cardBorderColor: ${s7.cardBorderColor};
      --footerColor: ${s7.footerColor};
      --dropdownOverlayColor: ${s7.dropdownOverlayColor};
      --dropdownColor: ${s7.dropdownColor};
      --dropdownTextColor: ${s7.dropdownTextColor};
      --dropdownBorderColor: ${s7.dropdownBorderColor};
      --dropdownIndicatorColor: ${s7.dropdownIndicatorColor};
      --dropdownDisconnectColor: ${s7.dropdownDisconnectColor};
      --borderRadius: ${s7.borderRadius}px;
      --headerButtonBorderRadius: ${s7.headerButtonBorderRadius}px;
      --sidePadding: ${s7.sidePadding}px;
      --headerPadding: ${s7.headerPadding}px;
      --claimColor: ${s7.claimColor};
      --claimColorDisabled: ${s7.claimColorDisabled};
      --claimTextColor: ${s7.claimTextColor};
      --claimTextColorDisabled: ${s7.claimTextColorDisabled};
      --claimButtonColor: ${s7.claimButtonColor};
      --claimButtonTextColor: ${s7.claimButtonTextColor};
      --claimButtonColorHover: ${s7.claimButtonColorHover};
      --claimButtonTextColorHover: ${s7.claimButtonTextColorHover};
      --claimButtonColorDisabled: ${s7.claimButtonColorDisabled};
      --claimButtonTextColorDisabled: ${s7.claimButtonTextColorDisabled};
      --textScale: ${s7.textScale};
      --scanBackgroundColor: ${s7.scanBackgroundColor};
      --scanTextColor: ${s7.scanTextColor};
    }
    @font-face {
      font-family: 'body';
      src: url("${s7.bodyFont}");
      font-weight: normal;
      font-style: normal;
    }
    @font-face {
      font-family: 'headings';
      src: url("${s7.headingFont}");
      font-weight: bold;
      font-style: normal;
    }
  `);
  }

  // src/components/Router.tsx
  function Router() {
    const { address, isConnected, isDisconnected } = useAccount();
    const { chain } = useNetwork();
    const s7 = applicationStore_default();
    (0, import_react22.useEffect)(() => {
      s7.deviceInit();
    }, []);
    (0, import_react22.useEffect)(() => {
      if (isConnected && address) {
        s7.walletConnect(address, chain?.id || 1);
      }
      if (isDisconnected) {
        s7.walletDisconnect();
      }
      s7.walletSetReady();
    }, [address, isConnected, isDisconnected]);
    return /* @__PURE__ */ import_react22.default.createElement(import_react22.default.Fragment, null, /* @__PURE__ */ import_react22.default.createElement(Settings, null), s7.loading && /* @__PURE__ */ import_react22.default.createElement(Loading, null), !s7.loading && s7.device.node_id && /* @__PURE__ */ import_react22.default.createElement(Viewer, null), !s7.loading && !s7.device.node_id && /* @__PURE__ */ import_react22.default.createElement(scan, null));
  }

  // src/index.tsx
  var chains = [mainnet2];
  var projectId = WC_PROJECT;
  var { publicClient } = configureChains(chains, [W6({ projectId })]);
  var wagmiConfig = createConfig2({
    autoConnect: true,
    // @ts-ignore
    connectors: B7({ projectId, version: 2, chains }),
    publicClient
  });
  var ethereumClient = new j5(wagmiConfig, chains);
  var root = import_client.default.createRoot(document.querySelector("#application"));
  root.render(
    /* @__PURE__ */ import_react23.default.createElement(import_react23.default.Fragment, null, /* @__PURE__ */ import_react23.default.createElement(WagmiConfig, { config: wagmiConfig }, /* @__PURE__ */ import_react23.default.createElement(Router, null)), /* @__PURE__ */ import_react23.default.createElement(
      te8,
      {
        explorerExcludedWalletIds: ["fd20dc426fb37566d803205b19bbc1d4096b248ac04548e3cfb6b3a38bd033aa"],
        projectId,
        ethereumClient
      }
    ))
  );
})();
/*! Bundled license information:

react/cjs/react.development.js:
  (**
   * @license React
   * react.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

scheduler/cjs/scheduler.development.js:
  (**
   * @license React
   * scheduler.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.development.js:
  (**
   * @license React
   * react-dom.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
  (**
   * Checks if an event is supported in the current execution environment.
   *
   * NOTE: This will not work correctly for non-generic events such as `change`,
   * `reset`, `load`, `error`, and `select`.
   *
   * Borrows from Modernizr.
   *
   * @param {string} eventNameSuffix Event name, e.g. "click".
   * @return {boolean} True if the event is supported.
   * @internal
   * @license Modernizr 3.0.0pre (Custom Build) | MIT
   *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

@walletconnect/universal-provider/dist/index.es.js:
  (**
  * @license
  * Lodash <https://lodash.com/>
  * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
  * Released under MIT license <https://lodash.com/license>
  * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
  * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  *)

@lit/reactive-element/css-tag.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/reactive-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/lit-html.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-element/lit-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/is-server.js:
  (**
   * @license
   * Copyright 2022 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/custom-element.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/property.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/state.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/base.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/event-options.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-all.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-async.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-assigned-elements.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit/reactive-element/decorators/query-assigned-nodes.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directive.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/class-map.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

lit-html/directives/if-defined.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

use-sync-external-store/cjs/use-sync-external-store-shim.development.js:
  (**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js:
  (**
   * @license React
   * use-sync-external-store-shim/with-selector.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

js-sha3/src/sha3.js:
  (**
   * [js-sha3]{@link https://github.com/emn178/js-sha3}
   *
   * @version 0.8.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2015-2018
   * @license MIT
   *)

classnames/index.js:
  (*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  *)
*/
//# sourceMappingURL=index.js.map
